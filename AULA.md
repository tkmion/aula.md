# README.md

# Trilha de Python

Repositório com o material de Python para a Trilha 4 - Desenvolvimento Python.

## 2 - Programação Python

Curso com duração de 256 horas, totalizando 39 aulas. Previsão de término em ***10/10/2024***.

[avaliação](2.programacao-python/avaliacao.md)

| Aula | Dia | Arquivo |
| :----: | :----: | :----: |
| 33 | 02/10/2024 | [função lambda](2.programacao-python/funcoes.md#lambda)<br>tkinter - parte 2<br>[callback](2.programacao-python/tkinter.md#callback) [tkinter e `lambda`](2.programacao-python/tkinter.md#tkinter-e-lambda) |
| 32 | 01/10/2024 | [tkinter](2.programacao-python/tkinter.md) |
| 31 | 30/09/2024 | [expressões regulares](2.programacao-python/expressoes-regulares.md) |
| 30 | 26/09/2024 | atividade remota<br>[agenda eletrônica](2.programacao-python/atividade-agenda-eletronica.md) |
| 29 | 25/09/2024 | [métodos mágicos de operadores de comparação](2.programacao-python/programacao-orientada-objetos.md#métodos-mágicos-de-operadores-de-comparação)<br>[métodos estáticos](2.programacao-python/programacao-orientada-objetos.md#métodos-estáticos)<br>[métodos de classe](2.programacao-python/programacao-orientada-objetos.md#métodos-de-classe) |
| 28 | 24/09/2024 | [acompanhamento da avaliação](2.programacao-python/avaliacao.md) |
| 27 | 23/09/2024 | [objetos de primeira classe](2.programacao-python/funcoes.md#objetos-de-primeira-classe)<br>[funções internas](2.programacao-python/funcoes.md#funções-internas)<br>[funções retornando funções](2.programacao-python/funcoes.md#funções-retornando-funções)<br>[decoradores](2.programacao-python/funcoes.md#decoradores) |
| 26 | 19/09/2024 | [módulo `datetime`](2.programacao-python/modulos.md#datetime)<br>[herança](2.programacao-python/programacao-orientada-objetos.md#herança)<br>[avaliação - parte 6](2.programacao-python/avaliacao.md#classes) |
| 25 | 18/09/2024 | [cópia profunda](2.programacao-python/copias-rasa-e-profunda.md#cópia-profunda)<br>comandos[`else`](2.programacao-python/tratamento-erros.md#else) e [`finally`](2.programacao-python/tratamento-erros.md#finally)<br>[mensagens de erro](2.programacao-python/tratamento-erros.md#capturando-mensagens-de-erro) |
| 24 | 17/09/2024 | [anotações](2.programacao-python/anotacoes.md)<br>[métodos mágicos aritméticos](2.programacao-python/programacao-orientada-objetos.md#métodos-mágicos-de-operadores-aritméticos) |
| 23 | 16/09/2024 | [comando `yield`](2.programacao-python/comandos-built-in.md#yield)<br>[métodos mágicos](2.programacao-python/programacao-orientada-objetos.md#métodos-mágicos)<br>[métodos `__str__()`](2.programacao-python/programacao-orientada-objetos.md#método-__str__) e [`__repr()__`](2.programacao-python/programacao-orientada-objetos.md#método-__repr__) |
| 22 | 13/09/2024 | [`except` genérico](2.programacao-python/tratamento-erros.md#except-genérico)<br>[notação `json`](2.programacao-python/javascript-object-notation.md)<br>[classes](2.programacao-python/programacao-orientada-objetos.md)<br>[avaliação - parte 5](2.programacao-python/avaliacao.md) |
| 21 | 12/09/2024 | [`encoding`](2.programacao-python/arquivos.md#encoding)<br>[comandos `try` e `except`](2.programacao-python/tratamento-erros.md#blocos-try-e-except) |
| 20 | 11/09/2024 | [função `dir()`](2.programacao-python/funcoes-built-in.md#dir)<br>[variável `__name__`](2.programacao-python/modulos.md#variável-__name__-)<br>[wildcards](2.programacao-python/modulos.md#wildcards)<br>[operador `walrus`](2.programacao-python/operador-walrus.md) |
| 19 | 10/09/2024 | [módulo `string`](2.programacao-python/modulos.md#módulo-string) [módulo `math`](2.programacao-python/modulos.md#módulo-math) [módulo `json`](2.programacao-python/modulos.md#módulo-json)<br>[comando `with`](2.programacao-python/arquivos.md#with) [comando `assert`](2.programacao-python/comandos-built-in.md#assert) |
| 18 | 09/09/2024 | [arquivos](2.programacao-python/arquivos.md)<br>[módulo `os`](2.programacao-python/modulos.md#módulo-os) [módulo `time`](2.programacao-python/modulos.md#módulo-time) |
| 17 | 06/09/2024 | [recursão](2.programacao-python/funcoes.md#recursão)<br>[módulo `sys`](2.programacao-python/modulos.md#módulo-sys) [módulo `random`](2.programacao-python/modulos.md#módulo-random) |
| 16 | 05/09/2024 | acompanhamento da [avaliação](2.programacao-python/avaliacao.md) |
| 15 | 04/09/2024 | [empacotamento e desempacotamento](2.programacao-python/empacotamento-desempacotamento.md)<br>[`*args`](2.programacao-python/funcoes.md#args) [`**kwargs`](2.programacao-python/funcoes.md#kwargs) |
| 14 | 03/09/2024 | comandos<br>[`import`](2.programacao-python/comandos-from-import-as.md#comando-import) [`from` e `as`](2.programacao-python/comandos-from-import-as.md#comandos-from-e-as)<br>[`namespaces`](2.programacao-python/namespaces.md)<br>[avaliação - parte 4](2.programacao-python/avaliacao.md#módulos) |
| 13 | 02/09/2024 | [argumentos com valor padrão](2.programacao-python/funcoes.md#argumentos-com-valor-padrão)<br>[argumentos nomeados](2.programacao-python/funcoes.md#argumentos-nomeados)<br>[tipo `frozenset`](2.programacao-python/tipo-frozenset.md)<br>[`set.copy()`](2.programacao-python/tipo-set.md#setcopy) [`set.issubset()`](2.programacao-python/tipo-set.md#setissubset)<br>[`set.issuperset()`](2.programacao-python/tipo-set.md#setissuperset) [`set.isdisjoint()`](2.programacao-python/tipo-set.md#setisdisjoint) |
| 12 | 29/08/2024 | [`set.symmetric_difference()`](2.programacao-python/tipo-set.md#setsymmetric_difference)<br>[operadores do `set`](2.programacao-python/tipo-set.md#operadores-do-set)<br>[funções](2.programacao-python/funcoes.md)<br>[tipo `None`](2.programacao-python/tipo-none.md)<br>[avaliação - parte 3](2.programacao-python/avaliacao.md#otimização) |
| 11 | 28/08/2024 | [comando `in`](2.programacao-python/comandos-built-in.md#in) e [comando `del`](2.programacao-python/comandos-built-in.md#del)<br>[cópia rasa](2.programacao-python/copias-rasa-e-profunda.md#cópia-rasa)<br>[tipos imutáveis](2.programacao-python/tipos-mutaveis-imutaveis.md#tipos-imutáveis)<br>[tipos mutáveis](2.programacao-python/tipos-mutaveis-imutaveis.md#tipos-mutáveis) |
| 10 | 27/08/2024 | [operação de atribuição composta](2.programacao-python/tipos-int-float.md#operação-de-atribuição-composta)<br>[`else` em loops](2.programacao-python/estruturas-repeticao.md#else-em-loops)<br>[tipo dicionário](2.programacao-python/tipo-dicionario.md)<br>[características](2.programacao-python/tipo-dicionario.md#características)<br>[criando dicionários](2.programacao-python/tipo-dicionario.md#criando-dicionários)<br>[adicionando itens ao dicionário](2.programacao-python/tipo-dicionario.md#adicionando-itens-ao-dicionário)<br>[métodos](2.programacao-python/tipo-dicionario.md#métodos)<br>[`dict.keys()`](2.programacao-python/tipo-dicionario.md#dictkeys) [`dict.values()`](2.programacao-python/tipo-dicionario.md#dictvalues) [`dict.items()`](2.programacao-python/tipo-dicionario.md#dictitems)<br>[avaliação - parte 2](2.programacao-python/avaliacao.md#cpfs-inválidos)<br>[desafios](2.programacao-python/desafios.md) |
| 09 | 26/08/2024 | [loops aninhados](2.programacao-python/estruturas-repeticao.md#loops-aninhados)<br>[`for` vs `while`](2.programacao-python/estruturas-repeticao.md#for-vs-while)<br>[tipo conjunto](2.programacao-python/tipo-set.md)<br>[criando um `set`](2.programacao-python/tipo-set.md#criando-um-set)<br>[métodos do `set`](2.programacao-python/tipo-set.md#métodos-do-set)<br>[`set.union()`](2.programacao-python/tipo-set.md#setunion) [`set.intersection()`](2.programacao-python/tipo-set.md#setintersection)<br>[`set.difference()`](2.programacao-python/tipo-set.md#setdifference) [`set.add()`](2.programacao-python/tipo-set.md#setadd)<br>[`set.remove()`](2.programacao-python/tipo-set.md#setremove) [`set.discard()`](2.programacao-python/tipo-set.md#setdiscard)<br>[`cast` do `set`](2.programacao-python/tipo-set.md#cast) |
| 08 | 23/08/2024 | [operador ternário](2.programacao-python/operador-ternario.md)<br>[compreensão de listas](2.programacao-python/compreensao-listas.md) |
| 07 | 22/08/2024 | [revisão - parte 2](2.programacao-python/revisao-parte-2.md) |
| 06 | 21/08/2024 | [tipo tupla](2.programacao-python/tipo-tupla.md)<br>[avaliação - parte 1](2.programacao-python/avaliacao.md) |
| 05 | 20/08/2024 | [`pass`](2.programacao-python/comandos-built-in.md#pass)<br>[`break`](2.programacao-python/comandos-built-in.md#break)<br>[`continue`](2.programacao-python/comandos-built-in.md#continue)<br>[`break` e `continue`](2.programacao-python/comandos-built-in.md#break-e-continue) |
| 04 | 19/08/2024 | [comando `for`](2.programacao-python/estruturas-repeticao.md#for)<br>[função `range()`](2.programacao-python/funcoes-built-in.md#range)<br>[função `enumerate()`](2.programacao-python/funcoes-built-in.md#enumerate)<br>[função `zip()`](2.programacao-python/funcoes-built-in.md#zip)
| 03 | 16/08/2024 | [métodos das strings](2.programacao-python/tipo-string.md)<br>[`str.upper()`](2.programacao-python/tipo-string.md#strupper) [`str.lower()`](2.programacao-python/tipo-string.md#strlower)<br>[`str.capitalize()`](2.programacao-python/tipo-string.md#strcapitalize) [`str.title()`](2.programacao-python/tipo-string.md#strtitle)<br>[`str.strip()`](2.programacao-python/tipo-string.md#strstrip) [`str.lstrip()`](2.programacao-python/tipo-string.md#strlstrip) [`str.rstrip()`](2.programacao-python/tipo-string.md#strrstrip)<br>[`str.replace()`](2.programacao-python/tipo-string.md#strreplace) [`str.split()`](2.programacao-python/tipo-string.md#strsplit) [`str.join()`](2.programacao-python/tipo-string.md#strjoin)<br>[`str.find()`](2.programacao-python/tipo-string.md#strfind) [`str.rfind()`](2.programacao-python/tipo-string.md#strrfind)<br>[`str.startswith()`](2.programacao-python/tipo-string.md#strstartswith) [`str.endswith()`](2.programacao-python/tipo-string.md#strendswith)<br>[`str.isalpha()`](2.programacao-python/tipo-string.md#strisalpha) [`str.isdigit()`](2.programacao-python/tipo-string.md#strisdigit)<br>[`str.isalnum()`](2.programacao-python/tipo-string.md#strisalnum) [`str.isspace()`](2.programacao-python/tipo-string.md#strisspace)<br>[`str.isupper()`](2.programacao-python/tipo-string.md#strisupper) [`str.islower()`](2.programacao-python/tipo-string.md#strislower) [`str.zfill()`](2.programacao-python/tipo-string.md#strzfill)<br>[`str.center()`](2.programacao-python/tipo-string.md#strcenter) [`str.ljust()`](2.programacao-python/tipo-string.md#strljust) [`str.rjust()`](2.programacao-python/tipo-string.md#strrjust)<br>[`str.partition()`](2.programacao-python/tipo-string.md#strpartition) [`str.rpartition()`](2.programacao-python/tipo-string.md#strrpartition) |
| 02 | 15/08/2024 | [função `print()`](2.programacao-python/funcoes-built-in.md#print)<br>[intercalando e formatando `strings`](2.programacao-python/intercalando-formatando-strings.md)
| 01 | 14/08/2024 | [resolução dos desafios](1.logica-programacao/avaliacao/desafio.md) |

## 1 - Lógica de Programação

Curso com duração de 60 horas, totalizando 15 aulas.

| Aula | Dia | Arquivo |
| :----: | :----: | :----: |
| 15 | 13/08/2024 | [avaliação](1.logica-programacao/avaliacao/desafio.md) |
| 14 | 12/08/2024 | [funções built-in](2.programacao-python/funcoes-built-in.md)<br>[print()](2.programacao-python/funcoes-built-in.md#print) [input()](2.programacao-python/funcoes-built-in.md#input)<br>[len()](1.logica-programacao/comandos-built-in.md#len) [sum()](2.programacao-python/funcoes-built-in.md#sum) [pow()](2.programacao-python/funcoes-built-in.md#pow)<br>[max() e min()](2.programacao-python/funcoes-built-in.md#max-e-min) [abs()](2.programacao-python/funcoes-built-in.md#abs)<br>[round()](2.programacao-python/funcoes-built-in.md#round) [type()](2.programacao-python/funcoes-built-in.md#type)<br>[isinstance()](2.programacao-python/funcoes-built-in.md#isinstance) [ord() e chr()](2.programacao-python/funcoes-built-in.md#ord-e-chr)<br>[help()](2.programacao-python/funcoes-built-in.md#help)<br>[cast de listas](2.programacao-python/tipo-lista.md#cast-de-listas) |
| 13 | 08/08/2024 | [lista](2.programacao-python/tipo-lista.md)<br>[manipulando a lista](2.programacao-python/tipo-lista.md#manipulando-a-lista)<br>[list.append()](2.programacao-python/tipo-lista.md#listappend) [list.insert()](2.programacao-python/tipo-lista.md#listinsert) [list.remove()](2.programacao-python/tipo-lista.md#listpop)<br>[str e list](2.programacao-python/tipo-lista.md#str-e-list)<br>[função len()](2.programacao-python/comandos-built-in.md#len)<br>[comando in](2.programacao-python/comandos-built-in.md#in)<br>[juntando e multiplicando listas](2.programacao-python/tipo-lista.md#juntando-e-multiplicando-listas)<br>[fatiamento](2.programacao-python/tipo-lista.md#fatiamento)<br>[while](2.programacao-python/estruturas-repeticao.md#while)<br>[contador](2.programacao-python/estruturas-repeticao.md#contador) e [acumulador](2.programacao-python/estruturas-repeticao.md#acumulador) |
| 12 | 07/08/2024 | [input](1.logica-programacao/input.md) |
| 11 | 06/08/2024 | [cast](1.logica-programacao/cast.md)<br>[exercícios](1.logica-programacao/revisao-parte-1#exercícios.md) |
| 10 | 05/08/2024 | [revisão - parte 1](1.logica-programacao/revisao-parte-1.md) |
| 09 | 02/08/2024 | [if aninhado](1.logica-programacao/condicionais-if-elif-else.md#if-aninhado)<br>[comparando if simples e if aninhado](1.logica-programacao/condicionais-if-elif-else.md#comparando-if-simples-e-if-aninhado) |
| 08 | 01/08/2024 | [estrutura sequencial](1.logica-programacao/condicionais-if-elif-else.md#estrutura-sequencial)<br>[if](1.logica-programacao/condicionais-if-elif-else.md#if)<br>[else](1.logica-programacao/condicionais-if-elif-else.md#else)<br>[elif](1.logica-programacao/condicionais-if-elif-else.md#elif) |
| 07 | 31/07/2024 | [concatenando strings](2.programacao-python/tipo-string.md#concatenando-strings)<br>[multiplicando strings](2.programacao-python/tipo-string.md#multiplicando-strings)<br>[indexando strings](2.programacao-python/tipo-string.md#indexando-strings)<br>[dividindo strings](2.programacao-python/tipo-string.md#dividindo-strings)<br>[tipo lógico](1.logica-programacao/tipos-python.md#tipo-lógico) |
| 06 | 30/07/2024 | [tipo strings](2.programacao-python/tipo-string.md)<br>[caracteres especiais](2.programacao-python/tipo-string.md#caracteres-especiais)<br>[string-crua](2.programacao-python/tipo-string.md#string-crua)<br>[string-literal](2.programacao-python/tipo-string.md#string-literal) |
| 05 | 29/07/2024 | [instalando o vs code](1.logica-programacao/instalando-vscode.md)<br>[tipos do python](1.logica-programacao/tipos-python.md)<br>[tipos int e float](1.logica-programacao/tipos-python.md#tipos-int-e-float)<br>[variáveis](1.logica-programacao/tipos-python.md#variáveis) |
| 04 | 25/07/2024 | [instalando o python](1.logica-programacao/instalando-python.md)<br>[usando o python](1.logica-programacao/usando-python.md)<br>[interpretdor do python](1.logica-programacao/usando-python.md#interpretador-python)<br>[módulo python](1.logica-programacao/usando-python.md#módulo-python)<br>[explicando exemplos](1.logica-programacao/usando-python.md#explicando-exemplos)<br>[saída de dados](1.logica-programacao/usando-python.md#saída-de-dados)<br>[comentários](1.logica-programacao/usando-python.md#comentários) |
| 03 | 24/07/2024 | [tipos primitivos - parte 2](1.logica-programacao/tipos-primitivos.md)<br>[parênteses](1.logica-programacao/tipos-primitivos.md#parênteses)<br>[prioridades](1.logica-programacao/tipos-primitivos.md#prioridades)<br>[expressões lógicas](1.logica-programacao/tipos-primitivos.md#expressões-lógicas) <br>[comandos de atribuição](1.logica-programacao/tipos-primitivos.md#comandos-de-atribuição) |
| 02 | 23/07/2024 | [tipos primitivos](1.logica-programacao/tipos-primitivos.md)<br>[constantes](1.logica-programacao/tipos-primitivos.md#constantes)<br>[variáveis](1.logica-programacao/tipos-primitivos.md#variáveis)<br>[declarando variáveis](1.logica-programacao/tipos-primitivos.md#declarando-variáveis)<br>[expressões aritméticas](1.logica-programacao/tipos-primitivos.md#expressões-aritméticas) |
| 01 | 22/07/2024 | [o que é lógica](1.logica-programacao/o-que-eh-logica.md) |

## Como Usar Este Repositório

1. **Clone o repositório** : `git clone https://github.com/gutohertzog/trilha-python.git`
2. **Navegue para o diretório desejado** : `cd trilha-python/1-logica-programacao` ou `cd trilha-python/2-programacao-python`
3. **Siga as instruções nos arquivos de cada aula**

## Contribuições

Contribuições são bem-vindas! Se você deseja adicionar novos exemplos, corrigir erros ou melhorar o material existente, sinta-se à vontade para abrir uma pull request.

## Contato

Se você tiver alguma dúvida ou sugestão, entre em contato através das issues do repositório.

Esperamos que este repositório seja útil para seu aprendizado de Python. Boa sorte e bons estudos!


# anotacoes.md

# anotações

Anotações em Python referem-se a uma funcionalidade introduzida na versão 3.0 da linguagem, mas que ganhou maior destaque com a introdução das *type hints* (dicas de tipo) no PEP 484, formalizada a partir do Python 3.5. Elas permitem associar metadados a variáveis, funções e métodos, mas não alteram o comportamento real do código, uma vez que o Python continua sendo uma linguagem de tipagem dinâmica. Em essência, anotações fornecem dicas ou informações adicionais sobre o código, sem impor restrições rígidas.

As anotações por si só não têm impacto na execução do programa; elas são armazenadas em uma estrutura interna (um dicionário chamado `__annotations__`) que pode ser usada por desenvolvedores ou ferramentas para realizar verificações ou introspecção. Elas se integram a frameworks de verificação de tipos, como o `mypy`, e a IDEs que fornecem autocompletar e verificações estáticas de código.

## anotações dos tipos

- **`int`** : para números inteiros;
- **`float`** : para números de ponto flutuante;
- **`bool`** : para valores booleanos (`True` ou `False`);
- **`str`** : para strings (sequências de caracteres);
- **`list`** : para listas, podendo especificar o tipo dos elementos;
- **`tuple`** : para tuplas, onde podemos especificar a quantidade e o tipo de elementos;
- **`dict`** : para dicionários, especificando o tipo das chaves e valores;
- **`set`** : para conjuntos de elementos únicos;
- **`frozenset`** : para conjuntos imutáveis;

## anotações de variáveis

As anotações de variáveis foram formalmente introduzidas no Python 3.6, e permitem que os desenvolvedores especifiquem o tipo de uma variável no momento de sua declaração. Contudo, essas anotações não limitam o valor que pode ser atribuído à variável; elas simplesmente fornecem uma *dica* de qual seria o tipo esperado. O Python, portanto, não rejeitará valores de tipos diferentes do anotado, mantendo sua característica de tipagem dinâmica.

A sintaxe básica para anotar uma variável é:

```python
variavel: Tipo = valor_inicial
```

- `variavel` : é o nome da variável que está sendo anotada;
- `Tipo` : é o tipo que está sendo sugerido para a variável (por exemplo, `int`, `str`, `float`, etc.);
- `valor_inicial` : o valor atribuído à variável, que pode ou não seguir o tipo anotado;

### detalhes

1. **As anotações são opcionais** : as anotações não são obrigatórias, e o Python continuará funcionando normalmente sem elas. Elas são usadas principalmente para fins de documentação e para melhorar a legibilidade do código.

1. **As anotações não são verificadas em tempo de execução** : o Python não realiza nenhuma verificação sobre o tipo anotado em tempo de execução. Isso significa que uma variável anotada como `int` ainda pode receber um valor do tipo `str`, e o Python não lançará erros.

1. **Ferramentas externas podem realizar verificação de tipos** : embora o Python não faça a verificação, ferramentas como o `mypy` podem ser usadas para analisar estaticamente o código e emitir alertas caso haja incompatibilidade de tipos em relação às anotações.

1. **Anotações sem valor inicial** : é possível anotar uma variável sem atribuir um valor a ela no momento da declaração. Isso é útil quando se deseja documentar o tipo de uma variável que será inicializada posteriormente.

### exemplos com cada tipo

#### `int`

O tipo `int` representa números inteiros, sem parte fracionária.

```python
idade: int = 25

print(__annotations__)  # saída : {'idade': <class 'int'>}
```

Aqui, a variável `idade` é anotada como um número inteiro (`int`).

---

#### `float`

O tipo `float` representa números com parte fracionária.

```python
altura: float = 1.75

print(__annotations__)  # saída : {'altura': <class 'float'>}
```

Aqui, a variável `altura` é anotada como um número de ponto flutuante (`float`).

---

#### `bool`

O tipo `bool` é usado para representar valores booleanos: `True` ou `False`.

```python
is_ativo: bool = True

print(__annotations__)  # saída : {'is_ativo': <class 'bool'>}
```

Aqui, a variável `is_ativo` é anotada como um valor booleano (`bool`).

---

#### `str`

O tipo `str` representa uma sequência de caracteres (texto).

```python
nome: str = "João"

print(__annotations__)  # saída : {'nome': <class 'str'>}
```

Aqui, a variável `nome` é anotada como uma string (`str`).

---

#### `list`

O tipo `list` representa uma lista de elementos que pode conter múltiplos valores, de qualquer tipo, mas podemos especificar o tipo dos elementos da lista com anotações de tipo.

```python
notas: list[float] = [7.5, 8.0, 9.2]

print(__annotations__)  # saída : {'notas': <class 'list'>}
```

Aqui, a variável `notas` é anotada como uma lista de números de ponto flutuante (`list[float]`).

---

#### `tuple`

O tipo `tuple` representa uma sequência imutável de elementos. Podemos especificar a quantidade e o tipo dos elementos.

```python
coordenadas: tuple[float, float] = (19.5, 23.0)

print(__annotations__)  # saída : {'coordenadas': <class 'tuple'>}{'coordenadas': <class 'tuple'>}
```

Aqui, a variável `coordenadas` é anotada como uma tupla que contém dois valores do tipo `float`.

---

#### `dict`

O tipo `dict` representa uma coleção de pares chave-valor, onde podemos especificar o tipo das chaves e valores.

```python
notas_por_disciplina: dict[str, float] = {"Matemática": 8.5, "Português": 9.0}

print(__annotations__)  # saída : {'notas_por_disciplina': <class 'dict'>}
```

Aqui, a variável `notas_por_disciplina` é anotada como um dicionário que tem chaves do tipo `str` e valores do tipo `float`.

---

#### `set`

O tipo `set` representa uma coleção não ordenada de elementos únicos.

```python
frutas: set[str] = {"maçã", "banana", "laranja"}

print(__annotations__)  # saída : {'frutas': <class 'set'>}
```

Aqui, a variável `frutas` é anotada como um conjunto (`set`) de strings (`str`).

---

#### `frozenset`

O tipo `frozenset` é como um `set`, mas imutável. Os elementos de um `frozenset` não podem ser alterados após sua criação.

```python
vogais: frozenset[str] = frozenset("aeiou")

print(__annotations__)  # saída : {'vogais': <class 'frozenset'>}
```

Aqui, a variável `vogais` é anotada como um conjunto imutável (`frozenset`) de strings (`str`).

## anotações de funções

As anotações de tipo em funções no Python são usadas para documentar os tipos esperados dos parâmetros e do valor de retorno.

### `int`

Exemplo de parâmetro e retorno com `int` :

```python
def somar(a: int, b: int) -> int:
    return a + b
```

Neste exemplo:
- o tipo dos parâmetros `a` e `b` é `int`, indicando que a função espera receber números inteiros;
- o retorno é anotado como `int`, ou seja, a função retornará um número inteiro;

### `float`

Exemplo de parâmetro e retorno com `float` :

```python
def dividir(a: float, b: float) -> float:
    return a / b
```

Neste exemplo:
- os parâmetros `a` e `b` são do tipo `float`, ou seja, a função espera receber números de ponto flutuante;
- o retorno é `float`, pois a divisão resulta em um número de ponto flutuante;

### `bool`

Exemplo de parâmetro e retorno com `bool` :

```python
def eh_maior(a: int, b: int) -> bool:
    return a > b
```

Neste exemplo:
- os parâmetros `a` e `b` são inteiros (`int`);
- o retorno é `bool`, indicando que a função retorna `True` ou `False`, dependendo do resultado da comparação;

### `str`

Exemplo de parâmetro e retorno com `str` :

```python
def cumprimentar(nome: str) -> str:
    return f"Olá, {nome}!"
```

Neste exemplo:
- o parâmetro `nome` é do tipo `str`, indicando que a função espera uma string (um nome);
- o retorno é uma `str`, que é uma frase de cumprimento;

### `list`

Exemplo de parâmetro com `list` e retorno com `list` :

```python
def dobrar_numeros(numeros: list[int]) -> list[int]:
    return [numero * 2 for numero in numeros]
```

Neste exemplo:
- o parâmetro `numeros` é uma `list[int]`, ou seja, a função espera receber uma lista de números inteiros;
- o retorno também é uma `list[int]`, pois a função retorna uma nova lista com os números inteiros dobrados;

### `tuple`

Exemplo de parâmetro com `tuple` e retorno com `tuple` :

```python
def inverter_coordenadas(coord: tuple[float, float]) -> tuple[float, float]:
    return coord[::-1]
```

Neste exemplo:
- o parâmetro `coord` é uma `tuple[float, float]`, ou seja, a função espera uma tupla com dois números de ponto flutuante;
- o retorno também é uma `tuple[float, float]`, que será a tupla original invertida;

### `dict`

Exemplo de parâmetro com `dict` e retorno com `dict` :

```python
def contar_caracteres(texto: str) -> dict[str, int]:
    return {char: texto.count(char) for char in set(texto)}
```

Neste exemplo:
- o parâmetro `texto` é uma `str`, e a função conta quantas vezes cada caractere aparece no texto;
- o retorno é um `dict[str, int]`, ou seja, um dicionário onde as chaves são caracteres (`str`) e os valores são a quantidade de vezes que aparecem (`int`);

### `set`

Exemplo de parâmetro com `set` e retorno com `set` :

```python
def intersecao_conjuntos(conjunto1: set[int], conjunto2: set[int]) -> set[int]:
    return conjunto1 & conjunto2
```

Neste exemplo:
- os parâmetros `conjunto1` e `conjunto2` são `set[int]`, ou seja, a função espera dois conjuntos de inteiros;
- o retorno é um `set[int]`, representando a interseção dos dois conjuntos (elementos que estão em ambos);

### `frozenset`

Exemplo de parâmetro com `frozenset` e retorno com `frozenset` :

```python
def criar_frozenset(numeros: list[int]) -> frozenset[int]:
    return frozenset(numeros)
```

Neste exemplo:
- o parâmetro `numeros` é uma `list[int]`, ou seja, a função espera uma lista de inteiros;
- o retorno é um `frozenset[int]`, ou seja, um conjunto imutável criado a partir dos números da lista;

---

### `None`

O tipo `None` é usado quando uma função **não retorna nenhum valor**.

Exemplo de função com retorno `None`:

```python
def imprimir_mensagem(mensagem: str) -> None:
    print(mensagem)
```

Neste exemplo:
- o parâmetro `mensagem` é uma `str`, ou seja, a função recebe uma string;
- o retorno é `None`, indicando que a função não retorna nenhum valor; ela apenas imprime a mensagem;

Exemplo de parâmetro `None`:

```python
def processar_valor(valor: int | None) -> int:
    if valor is None:
        return 0
    return valor
```

Neste exemplo:
- O parâmetro `valor` pode ser um número inteiro (`int`) ou `None`, indicando que a função pode receber um valor indefinido.
- O retorno é um `int`, que será o próprio `valor` ou `0` se o parâmetro for `None`.

## exercícios

<details>
<summary>Lista de Exercícios</summary>

1. **Exercícios com `int`**
    1. **Soma de Números**: Escreva uma função que receba dois números inteiros e retorne a soma deles.
    1. **Dobrar um Número**: Crie uma função que receba um número inteiro e retorne o dobro desse número.
    1. **Número Par ou Ímpar**: Escreva uma função que receba um número inteiro e retorne se ele é par ou ímpar.
    1. **Fatorial**: Crie uma função que receba um número inteiro e retorne o seu fatorial.
    1. **Quadrado de um Número**: Faça uma função que receba um número inteiro e retorne o quadrado dele.
1. **Exercícios com `float`**
    1. **Multiplicação de Números**: Escreva uma função que receba dois números de ponto flutuante e retorne o produto deles.
    1. **Conversão de Celsius para Fahrenheit**: Crie uma função que receba uma temperatura em Celsius e retorne em Fahrenheit.
    1. **Divisão de Números**: Escreva uma função que receba dois números de ponto flutuante e retorne o resultado da divisão.
    1. **Área de um Círculo**: Crie uma função que calcule a área de um círculo dado o seu raio (float).
    1. **Média Aritmética**: Faça uma função que receba três números de ponto flutuante e retorne a média aritmética.
1. **Exercícios com `bool`**
    1. **Maior que 10**: Escreva uma função que receba um número inteiro e retorne `True` se ele for maior que 10, caso contrário `False`.
    1. **É Positivo?**: Crie uma função que receba um número de ponto flutuante e retorne `True` se o número for positivo.
    1. **Verificação de Paridade**: Escreva uma função que receba um número inteiro e retorne `True` se o número for par.
    1. **Comparar Números**: Faça uma função que receba dois números e retorne `True` se o primeiro for maior que o segundo.
    1. **Verificação de Feriado**: Crie uma função que receba uma string com o nome do dia da semana e retorne `True` se for "Sábado" ou "Domingo".
1. **Exercícios com `str`**
    1. **Contar Caracteres**: Escreva uma função que receba uma string e retorne o número de caracteres.
    1. **Concatenar Strings**: Crie uma função que receba duas strings e retorne a concatenação delas.
    1. **Inverter String**: Faça uma função que receba uma string e retorne a string invertida.
    1. **Contar Vogais**: Crie uma função que conte o número de vogais em uma string.
    1. **Substituir Espaços por Hífen**: Escreva uma função que substitua todos os espaços de uma string por hífens.
1. **Exercícios com `list`**
    1. **Somar Elementos**: Escreva uma função que receba uma lista de inteiros e retorne a soma dos elementos.
    1. **Maior Elemento**: Crie uma função que receba uma lista de inteiros e retorne o maior valor.
    1. **Duplicar Valores**: Faça uma função que receba uma lista de inteiros e retorne uma nova lista com os valores duplicados.
    1. **Contar Ocorrências**: Escreva uma função que receba uma lista de strings e conte quantas vezes um determinado valor aparece.
    1. **Remover Duplicatas**: Crie uma função que receba uma lista e remova os elementos duplicados.
1. **Exercícios com `tuple`**
    1. **Criar Tupla**: Escreva uma função que receba três valores e retorne uma tupla com esses valores.
    1. **Primeiro e Último Elemento**: Crie uma função que receba uma tupla e retorne o primeiro e o último elemento.
    1. **Tamanho da Tupla**: Faça uma função que receba uma tupla e retorne o tamanho dela.
    1. **Concatenar Tuplas**: Escreva uma função que receba duas tuplas e retorne a concatenação delas.
    1. **Multiplicar Elementos**: Crie uma função que receba uma tupla de números e retorne uma nova tupla com cada elemento multiplicado por 2.
1. **Exercícios com `dict`**
    1. **Criar Dicionário**: Escreva uma função que receba duas listas (chaves e valores) e retorne um dicionário associando-as.
    1. **Valor Máximo**: Crie uma função que receba um dicionário e retorne o valor máximo.
    1. **Contar Itens**: Faça uma função que receba um dicionário e retorne o número de pares chave-valor.
    1. **Atualizar Dicionário**: Escreva uma função que receba um dicionário e uma nova chave e valor, e atualize o dicionário.
    1. **Filtrar Chaves**: Crie uma função que receba um dicionário e uma lista de chaves, e retorne um novo dicionário contendo apenas as chaves especificadas.
1. **Exercícios com `set`**
    1. **Unir Conjuntos**: Escreva uma função que receba dois conjuntos e retorne a união deles.
    1. **Diferença de Conjuntos**: Crie uma função que receba dois conjuntos e retorne a diferença entre eles (itens que estão no primeiro conjunto mas não no segundo).
    1. **Verificar Elemento**: Faça uma função que receba um conjunto e um elemento, e retorne `True` se o elemento estiver no conjunto, caso contrário `False`.
    1. **Interseção de Conjuntos**: Escreva uma função que receba dois conjuntos e retorne a interseção deles (itens que estão em ambos).
    1. **Remover Elementos**: Crie uma função que receba um conjunto e um elemento, e remova o elemento do conjunto se ele estiver presente.
1. **Exercícios com `frozenset`**
    1. **Criar Frozenset**: Escreva uma função que receba uma lista de números e retorne um `frozenset` com esses números.
    1. **Verificar Presença**: Crie uma função que receba um `frozenset` e um número, e retorne `True` se o número estiver no `frozenset`.
    1. **Diferença de Frozensets**: Faça uma função que receba dois `frozensets` e retorne a diferença entre eles (itens que estão no primeiro mas não no segundo).
    1. **Unir Frozensets**: Escreva uma função que receba dois `frozensets` e retorne a união deles.
    1. **Interseção de Frozensets**: Crie uma função que receba dois `frozensets` e retorne a interseção deles (itens que estão em ambos).
1. **Exercícios com `None`**
    1. **Verificar Valor None**: Escreva uma função que receba um valor e retorne `True` se o valor for `None`, caso contrário `False`.
    1. **Retornar None se Vazio**: Crie uma função que receba uma lista e retorne `None` se a lista estiver vazia, caso contrário retorne a lista.
    1. **Ajustar Valor**: Faça uma função que receba um número inteiro e um valor opcional. Se o valor opcional for `None`, defina-o como o número inteiro. Caso contrário, mantenha o valor opcional.
    1. **Função Sem Retorno**: Escreva uma função que não retorna nenhum valor explicitamente, apenas imprime uma mensagem.
    1. **Configuração Opcional**: Crie uma função que receba uma configuração opcional (com valor padrão `None`). Se a configuração for `None`, use um valor padrão interno.

</details>


# arquivos.md

Índice

1. [pontos importantes](#pontos-importantes)
1. [`open()`](#open)
1. [modos do `open()`](#modos-do-open)
1. [métodos do arquivo](#métodos-do-arquivo)
    1. [`read()`](#read)
    1. [`readline()`](#readline)
    1. [`readlines()`](#readlines)
    1. [`readline()` vs `readlines()`](#readline-vs-readlines)
    1. [`write()`](#write)
    1. [`writelines()`](#writelines)
1. [`close()`](#close)
1. [exercícios de arquivos](#exercícios-de-arquivos)
1. [`with`](#with)
    1. [funcionamento](#funcionamento)
    1. [vantagens](#vantagens)
    1. [exemplos de `with` com `open()`](#exemplos-de-with-com-open)
    1. [múltiplos arquivos com `with`](#múltiplos-arquivos-com-with)
1. [exercícios com `with`](#exercícios-com-with)

# arquivos

O processo de leitura de arquivos no Python envolve abrir um arquivo, ler seu conteúdo e, em seguida, fechá-lo. Python oferece diferentes modos de leitura, como `r` para leitura, `w` para escrita, e `a` para adicionar conteúdo. O processo é realizado por meio da função `open()`, que retorna um objeto de arquivo, usado para manipular o conteúdo.

Exemplo básico :

```python
with open('arquivo.txt', 'r') as arquivo:
    conteudo = arquivo.read()
    print(conteudo)
```

Neste exemplo, o comando `with` garante que o arquivo seja fechado corretamente após sua utilização, mesmo em caso de erro. Mais adiante isso será visto com detalhes.

## pontos importantes

### finalidades :
- **processamento de dados** : utilizado para ler dados de arquivos de texto, csvs, logs, etc., e manipulá-los no código;
- **entrada e saída de dados** : permite salvar e carregar informações persistentes, facilitando o armazenamento de resultados ou configurações;

### vantagens :
- **simplicidade** : a leitura de arquivos é direta e fácil de implementar;
- **flexibilidade** : python pode manipular diversos tipos de arquivos (texto, binários, csv, json, etc.);
- **automação**: pode ser usada para automatizar tarefas que envolvem manipulação de dados em massa;

### desvantagens :
- **limitação de memória** : carregar arquivos grandes pode consumir muita memória, afetando o desempenho;
- **erro de codificação** : arquivos podem ter diferentes codificações (ex.: utf-8, ascii), e erros podem ocorrer ao ler arquivos com codificação incorreta;

### cuidados :
- **fechar o arquivo** : sempre garantir que o arquivo seja fechado após a leitura para evitar corrupção de dados ou consumo desnecessário de recursos;
- **exceções** : tratar exceções, como erros de arquivo não encontrado (`FileNotFoundError`) ou de permissões de leitura;
- **codificação** : verificar e definir corretamente a codificação ao abrir o arquivo;

Esses são os pontos essenciais para uma leitura segura e eficiente de arquivos em Python.

## `open()`

A função `open()` no Python é usada para abrir arquivos e manipular dados dentro deles. Essa função cria um objeto que permite que se leia, escreva ou adicione informações a um arquivo de texto ou binário. O uso de `open()` envolve a especificação de um caminho de arquivo e, opcionalmente, um modo de operação (como leitura ou escrita).

Veja sua sinxtaxe básica :

```python
arquivo = open('caminho_do_arquivo', 'modo')
```

A função `open()` retorna um objeto de arquivo que pode ser manipulado para realizar operações como leitura (`read`), escrita (`write`) ou adição de conteúdo (`append`), dependendo do modo escolhido.

### modos mais comuns:

1. **`'r'`** (leitura) : abre um arquivo para leitura. este é o modo padrão. o arquivo deve existir; caso contrário, um erro será gerado;
1. **`'w'`** (escrita) : abre um arquivo para escrita; se o arquivo não existir, ele será criado; se o arquivo já existir, o conteúdo será sobrescrito;
1. **`'a'`** (anexar) : abre o arquivo para anexar dados no final do arquivo. se o arquivo não existir, ele será criado;

### modos do `open()`

O Python possui diversas formas de abrir um arquivo. Abaixo há as formas mais comuns.

| Modo | Uso                                  | Comportamento                                          |
|------|--------------------------------------|--------------------------------------------------------|
| `r`  | leitura                              | abre o arquivo para leitura; gera erro se não existir; |
| `w`  | escrita (sobrescreve)                | abre o arquivo para escrita; cria ou sobrescreve.      |
| `a`  | anexar                               | abre o arquivo para anexar dados; cria se não existir; |

#### 1. modo de leitura `r`

O modo `r` é usado para **abrir um arquivo para leitura**. Quando um arquivo é aberto nesse modo, ele deve **existir previamente**, caso contrário, um erro será gerado (`FileNotFoundError`). O ponteiro do arquivo (a posição de leitura) começa no início do arquivo.

Veja sua sintaxe :

```python
arquivo = open('exemplo.txt', 'r')
conteudo = arquivo.read()  # lê todo o conteúdo do arquivo
arquivo.close()  # fecha o arquivo após a leitura
```

##### exemplo

Suponha que exista um arquivo `dados.txt` com o seguinte conteúdo :

```
Python é uma linguagem de programação.
Ela é poderosa e fácil de aprender.
```

Agora, vamos abrir esse arquivo e ler seu conteúdo :

```python
# abrindo o arquivo para leitura
arquivo = open('dados.txt', 'r')

conteudo = arquivo.read()  # lendo o conteúdo do arquivo

print(f'{conteudo = }')  # exibe o conteúdo no terminal
arquivo.close()  # fecha o arquivo
```

Se o arquivo `dados.txt` não existir, o Python levantará uma exceção :

```python
FileNotFoundError: [Errno 2] No such file or directory: 'dados.txt'
```

#### 2. modo de escrita `w`

O modo `w` é usado para **abrir um arquivo para escrita**. Esse modo **sobrescreve** o conteúdo do arquivo caso ele já exista. Se o arquivo **não existir**, ele será criado automaticamente. O ponteiro de escrita começa no início do arquivo.

Veja sua sintaxe :
```python
arquivo = open('exemplo.txt', 'w')
arquivo.write("Escrevendo algo no arquivo.")  # escreve no arquivo
arquivo.close()  # fecha o arquivo após a escrita
```

##### exemplo

Se deseja criar ou sobrescrever o arquivo `saida.txt` com o texto `"Aprendendo a escrever em arquivos!"`, pode usar o seguinte código :

```python
# abrindo o arquivo para escrita
arquivo = open('saida.txt', 'w')
arquivo.write("Aprendendo a escrever em arquivos!")  # escreve no arquivo
arquivo.close()  # fecha o arquivo
```

Se o arquivo `saida.txt` já existia e tinha algum conteúdo, todo o conteúdo anterior será apagado e substituído pela nova string.

#### 3. modo de anexar `a`

O modo `a` é usado para **abrir um arquivo e anexar dados ao final** do arquivo. Esse modo é útil quando se quer adicionar dados a um arquivo sem sobrescrever o conteúdo existente. Se o arquivo **não existir**, ele será criado. O ponteiro de escrita começa no **final** do arquivo, ou seja, novos dados são sempre adicionados após o conteúdo existente.

Veja sua sintaxe básica :

```python
arquivo = open('exemplo.txt', 'a')
arquivo.write("Adicionando uma nova linha.")  # anexa dados ao arquivo
arquivo.close()  # fecha o arquivo
```

##### exemplo

Se deseja adicionar novas entradas a um arquivo `log.txt`, sem apagar as entradas anteriores, pode usar o modo `a`:

```python
# abrindo o arquivo para anexar dados
arquivo = open('log.txt', 'a')
arquivo.write("Nova entrada de log.\n")  # anexa ao arquivo
arquivo.close()  # Fecha o arquivo
```

Isso adicionará a frase `"Nova entrada de log."` ao final do arquivo. Se executar o programa várias vezes, ele continuará adicionando essa frase ao final do arquivo, sem remover os dados anteriores.


## métodos do arquivo

A função `open()` em Python retorna um objeto de arquivo, que possui vários métodos para manipular seu conteúdo. Dentre os mais importantes, há os métodos `read()`, `readline()`, `readlines()`, `write()` e `writelines()`.

### `read()`

O método `read()` lê o conteúdo de um arquivo inteiro (ou parte dele, dependendo dos parâmetros passados).

Veja sua sintaxe :

```python
conteudo = arquivo.read(tamanho)
```

- **tamanho** (opcional): é o número de caracteres ou bytes a serem lidos; se omitido, `read()` lê o arquivo inteiro;

#### exemplo

```python
arquivo = open('exemplo.txt', 'r')

# lendo todo o conteúdo do arquivo
conteudo = arquivo.read()
print(conteudo)

arquivo.close()
```

Se o arquivo `exemplo.txt` contiver :
```
Primeira linha
Segunda linha
Terceira linha
```

A saída será :
```
Primeira linha
Segunda linha
Terceira linha
```

#### lendo parte do arquivo :

É possível especificar quantos caracteres ler com o argumento `tamanho`. Por exemplo:

```python
arquivo = open('exemplo.txt', 'r')

# lendo apenas os primeiros 10 caracteres
conteudo = arquivo.read(10)
print(conteudo)

arquivo.close()
```

Se o conteúdo do arquivo for o mesmo, a saída será :
```
Primeira
```

Aqui, foram lidos os primeiros 10 caracteres do arquivo.

### `readline()`

O método `readline()` lê **uma linha** do arquivo por vez. Ele é útil quando se deseja processar o arquivo linha por linha.

Veja sua sintaxe :

```python
linha = arquivo.readline(tamanho)
```

- **tamanho** (opcional) : limita o número máximo de caracteres a serem lidos da linha;

#### exemplo

```python
arquivo = open('exemplo.txt', 'r')

# lendo a primeira linha do arquivo
linha = arquivo.readline()
print(linha)

arquivo.close()
```

Se o arquivo contiver :
```
Primeira linha
Segunda linha
Terceira linha
```

A saída será :
```
Primeira linha
```

#### lendo todas as linhas com `readline()`

Se quiser ler todas as linhas do arquivo, pode usar um loop :

```python
arquivo = open('exemplo.txt', 'r')

linha = arquivo.readline()
while linha:
    print(linha, end='')  # end='' evita uma linha extra ao final
    linha = arquivo.readline()

arquivo.close()
```

A saída será:
```
Primeira linha
Segunda linha
Terceira linha
```

#### limitando o número de caracteres por linha

É possível limitar o número de caracteres que serão lidos por linha :

```python
arquivo = open('exemplo.txt', 'r')

# lendo apenas os primeiros 8 caracteres da primeira linha
linha = arquivo.readline(8)
print(linha)

arquivo.close()
```

Isso resultará em:
```
Primeira
```

### `readlines()`

O método `readlines()` lê **todas as linhas do arquivo de uma só vez** e as armazena em uma **lista**, onde cada linha é um elemento.

Veja sua sintaxe :

```python
linhas = arquivo.readlines()
```

#### exemplo
```python
arquivo = open('exemplo.txt', 'r')

# lendo todas as linhas do arquivo
linhas = arquivo.readlines()

# imprimindo a lista de linhas
print(linhas)

arquivo.close()
```

Se o arquivo contiver :

```
Primeira linha
Segunda linha
Terceira linha
```

A saída será :

```python
['Primeira linha\n', 'Segunda linha\n', 'Terceira linha\n']
```

Aqui, cada linha do arquivo se torna um item da lista. Note que os caracteres de nova linha (`\n`) são preservados.

Logo, é possível iterar sobre essa lista para processar cada linha individualmente :

```python
arquivo = open('exemplo.txt', 'r')

# lendo todas as linhas do arquivo
linhas = arquivo.readlines()

# iterando sobre as linhas e imprimindo uma a uma
for linha in linhas:
    print(linha, end='')

arquivo.close()
```

Isso exibirá :

```
Primeira linha
Segunda linha
Terceira linha
```

### `readline()` vs `readlines()`

Em suma :

- `readline()` lê **uma linha** por vez;
- `readlines()` lê **todas as linhas** de uma vez e as retorna como uma lista;

### `write()`

O método `write()` é usado para **escrever dados em um arquivo**. Pode ser utilizado em modos de escrita (`'w'`, `'a'`, `'w+'`, `'a+'`, etc.). Lembre-se de que o método **não adiciona automaticamente uma nova linha**, então precisará incluir `\n` manualmente se quiser pular linhas.

Veja a sintaxe :

```python
arquivo.write(texto)
```

- **texto**: é o conteúdo que você deseja escrever no arquivo. deve ser uma string;

#### exemplo

```python
arquivo = open('exemplo.txt', 'w')

# escrevendo texto no arquivo
arquivo.write("Primeira linha\n")
arquivo.write("Segunda linha\n")

arquivo.close()
```

Aqui :
- o arquivo `exemplo.txt` será sobrescrito (ou criado se não existir);
- o método `write()` insere as linhas fornecidas no arquivo;
- o `\n` é necessário para garantir que cada linha seja escrita em uma nova linha no arquivo;

#### exemplo

Se quiser **anexar** (adicionar) novas informações ao final de um arquivo, pode abrir o arquivo no modo de anexar (`'a'`) :

```python
arquivo = open('exemplo.txt', 'a')

# adicionando uma nova linha ao final do arquivo
arquivo.write("Terceira linha adicionada\n")

arquivo.close()
```

Isso não sobrescreverá o conteúdo existente, mas adicionará a nova linha ao final do arquivo.

#### importante :

- o método `write()` **não adiciona quebras de linha automaticamente**; portanto, se quiser que o texto vá para a próxima linha, adicione `\n` no final da string que está escrevendo;
- se usar o modo `'w'`, o arquivo será **sobrescrito**; todo o conteúdo anterior será apagado;

### `writelines()`

O método `writelines()` em Python é usado para **escrever uma sequência de strings** em um arquivo de uma só vez. A sequência pode ser uma lista, tupla ou qualquer objeto iterável que contenha strings.

Diferentemente do método `write()`, que escreve uma única string de cada vez, o `writelines()` permite escrever várias linhas de uma só vez, **sem adicionar automaticamente quebras de linha** (`\n`). Se quiser que cada linha seja escrita em uma nova linha no arquivo, precisará incluir manualmente o caractere de nova linha (`\n`) ao final de cada string da sequência.

Veja a sintaxe :

```python
arquivo.writelines(iteravel)
```

- **iterável**: um objeto que contém múltiplas strings, como uma lista ou tupla;

#### exemplo :

Aqui está um exemplo de como usar `writelines()` para escrever várias linhas em um arquivo :

```python
# abrindo o arquivo no modo de escrita
arquivo = open('exemplo.txt', 'w')

# lista de linhas para serem escritas
linhas = ["Primeira linha\n", "Segunda linha\n", "Terceira linha\n"]

# escrevendo todas as linhas no arquivo de uma vez
arquivo.writelines(linhas)

# fechando o arquivo
arquivo.close()
```

Neste exemplo :
- o arquivo `exemplo.txt` será criado ou sobrescrito;
- as três linhas da lista `linhas` são escritas de uma só vez no arquivo;
- note que cada string na lista termina com `\n` para garantir que as linhas sejam separadas no arquivo;

#### importante

O método `writelines()` **não adiciona automaticamente quebras de linha** (`\n`). Se as strings no iterável não tiverem `\n`, elas serão escritas consecutivamente, sem separação.

```python
arquivo = open('exemplo.txt', 'w')

# lista de linhas sem \n
linhas = ["Primeira linha", "Segunda linha", "Terceira linha"]

# escrevendo todas as linhas no arquivo
arquivo.writelines(linhas)

arquivo.close()
```

Neste caso, o conteúdo do arquivo será :

```
Primeira linhaSegunda linhaTerceira linha
```

#### iteráveis além de listas

É também possível usar qualquer objeto iterável que contenha strings, como uma tupla ou até um gerador.

#### exemplo com uma tupla

```python
arquivo = open('exemplo.txt', 'w')

# tupla de strings
linhas = ("Linha 1\n", "Linha 2\n", "Linha 3\n")

arquivo.writelines(linhas)

arquivo.close()
```

#### exemplo com um gerador

```python
arquivo = open('exemplo.txt', 'w')

# gerador de strings
linhas = (f"Linha {i}\n" for i in range(1, 4))

arquivo.writelines(linhas)

arquivo.close()
```

## `close()`

O método **`close()`** em Python é utilizado para **fechar um arquivo** que foi previamente aberto. Quando um arquivo é aberto com a função `open()`, ele ocupa recursos do sistema, como memória e descritores de arquivo, e precisa ser fechado para liberar esses recursos corretamente. Além disso, ao fechar um arquivo, todas as operações de leitura e escrita pendentes são finalizadas e os dados são garantidamente gravados no disco.

### detalhes

- **liberação de recursos**: fechar o arquivo libera os recursos do sistema operacional associados a ele. Se um arquivo permanecer aberto por muito tempo, especialmente em grandes aplicações, isso pode resultar em esgotamento de descritores de arquivo, levando a erros;

- **garantia de gravação completa**: para arquivos abertos para escrita, o método `close()` assegura que qualquer dado pendente seja gravado corretamente no disco. Se o arquivo não for fechado após a escrita, algumas mudanças podem não ser aplicadas (especialmente se os dados estiverem armazenados em buffers temporários);

- **após fechar o arquivo**: uma vez que o arquivo é fechado, não é possível realizar mais operações de leitura ou escrita até que ele seja reaberto;

### exemplo

```python
# abrindo um arquivo para escrita
arquivo = open('exemplo.txt', 'w')

# escrevendo dados no arquivo
arquivo.write("Este é um exemplo de uso do método close.\n")

# fechando o arquivo após a escrita
arquivo.close()
```

Aqui :
- o arquivo `exemplo.txt` foi aberto no modo de escrita (`'w'`);
- foi escrita uma linha de texto no arquivo;
- foi usado o método `arquivo.close()` para fechar o arquivo e garantir que os dados sejam salvos corretamente;

### efeitos de não fechar o arquivo

Se o método `close()` não for usado, pode causar problemas em certos cenários :

1. **dados não gravados** : no caso de operações de escrita, se o arquivo não for fechado, o python pode não gravar os dados imediatamente no arquivo físico; isso ocorre porque os sistemas operacionais frequentemente armazenam dados temporariamente em um buffer para otimizar o desempenho. o `close()` força a gravação final desses dados no disco.

Exemplo :

```python
arquivo = open('exemplo.txt', 'w')
arquivo.write("Texto sem fechar o arquivo.")
# Sem o close(), o texto pode não ser gravado completamente no arquivo.
```

2. **vazamento de recursos** : não fechar um arquivo pode levar a um vazamento de descritores de arquivo, especialmente em sistemas que têm um limite sobre o número de arquivos que podem ser abertos simultaneamente; isso pode resultar em erros ao tentar abrir novos arquivos.

3. **erros ao tentar acessar um arquivo já fechado** : se tentar ler ou escrever em um arquivo após tê-lo fechado, o python gerará um erro.

Exemplo :

```python
arquivo = open('exemplo.txt', 'r')
arquivo.close()
conteudo = arquivo.read()  # Tentativa de ler após fechar o arquivo
```

O Python levantará um erro `ValueError` :

```
ValueError: I/O operation on closed file.
```

### importância de `close()` com grandes volumes de dados

Quando trabalha com arquivos grandes ou abre muitos arquivos em sequência, o fechamento adequado dos arquivos torna-se ainda mais crítico. Manter arquivos abertos sem fechá-los pode resultar em erros como:

- **`OSError: Too many open files`** : se muitos arquivos forem abertos ao mesmo tempo sem serem fechados, o sistema pode esgotar seu limite de descritores de arquivo, o que gera este erro; fechar os arquivos conforme eles são usados ajuda a evitar esse problema.


## exercícios

<details>
<summary>Lista de Exercícios</summary>

1. exercícios sobre o método `read()`
    1. Abra um arquivo de texto chamado `dados.txt` e use o método `read()` para ler todo o conteúdo. Exiba o conteúdo no terminal.
    1. Crie um arquivo chamado `historico.txt`, escreva nele cinco frases e leia todo o conteúdo usando `read()`. Exiba as frases lidas.
    1. Abra o arquivo `historico.txt` e leia os primeiros 20 caracteres do arquivo usando `read()`. Exiba os caracteres no terminal.
    1. Crie um arquivo `poema.txt` com três estrofes de um poema. Use `read()` para ler todo o poema e exibi-lo no terminal.
    1. Crie um programa que abre o arquivo `numeros.txt` e usa `read()` para ler todo o conteúdo. Depois, converta o texto em uma lista de inteiros.
    1. Abra o arquivo `paragrafo.txt` contendo um parágrafo de texto e leia os primeiros 50 caracteres com `read()`.
    1. Crie um arquivo `livro.txt` contendo três capítulos de um livro. Leia o primeiro capítulo (considerando 1000 caracteres) com o método `read()`.
    1. Escreva um programa que lê o conteúdo completo de um arquivo `mensagem.txt` e conta o número de palavras usando `read()`.
    1. Crie um arquivo `diario.txt` e escreva 5 entradas de diário. Depois, leia e exiba as duas primeiras entradas (aproximadamente 100 caracteres) usando `read()`.
    1. Crie um arquivo `contos.txt` e escreva dois contos curtos. Use o método `read()` para ler o primeiro conto (aproximadamente 500 caracteres).
1. exercícios sobre o método `readline()`
    1. Crie um arquivo `compras.txt` com uma lista de compras (uma por linha). Leia e exiba a primeira linha usando o método `readline()`.
    1. Abra o arquivo `compras.txt` e use `readline()` para ler e exibir as três primeiras linhas.
    1. Crie um programa que abra o arquivo `agenda.txt` e use `readline()` para ler cada linha individualmente, mostrando o conteúdo no terminal.
    1. Abra o arquivo `alunos.txt`, que contém o nome de 10 alunos, e leia o nome do primeiro aluno usando `readline()`.
    1. Crie um programa que abra o arquivo `mensagens.txt` e leia cada linha usando um loop `while` até o final do arquivo, exibindo cada mensagem no terminal.
    1. Abra o arquivo `livros.txt` contendo uma lista de livros. Use `readline()` para ler e exibir o título do segundo livro.
    1. Crie um arquivo `tarefas.txt` com 5 tarefas diárias. Use `readline()` para ler e exibir todas as tarefas uma a uma em um loop.
    1. Crie um programa que leia as primeiras três linhas de um arquivo `nomes.txt` e exiba os nomes no terminal.
    1. Abra um arquivo `frases.txt` e leia frases usando `readline()`. Exiba apenas as frases que contêm mais de 50 caracteres.
    1. Crie um programa que leia um arquivo `receitas.txt` e use `readline()` para exibir uma receita de cada vez.
1. exercícios sobre o método `readlines()`
    1. Abra um arquivo `notas.txt` contendo as notas de 10 alunos, uma por linha. Use `readlines()` para ler todas as linhas de uma vez e exiba-as como uma lista.
    1. Crie um arquivo `filmes.txt` com 5 títulos de filmes, um por linha. Use `readlines()` para ler e exibir todos os títulos no terminal.
    1. Abra o arquivo `tarefas.txt`, use `readlines()` para ler todas as tarefas de uma vez e exiba a terceira tarefa da lista.
    1. Crie um arquivo `produtos.txt` com uma lista de produtos. Use `readlines()` para ler todos os produtos e depois exiba-os em ordem reversa.
    1. Escreva um programa que abre um arquivo `frases.txt`, leia todas as frases com `readlines()` e exiba apenas as frases que têm mais de 20 caracteres.
    1. Crie um arquivo `contatos.txt` com nomes e números de telefone, um por linha. Use `readlines()` para armazenar os contatos em uma lista.
    1. Abra o arquivo `livros.txt`, leia todas as linhas com `readlines()` e exiba o número total de linhas lidas.
    1. Crie um arquivo `dicionario.txt` com palavras e seus significados, uma por linha. Use `readlines()` para ler todas as palavras e exibi-las em formato de lista.
    1. Abra um arquivo `amigos.txt` e use `readlines()` para ler todos os nomes. Em seguida, exiba o primeiro e o último nome da lista.
    1. Crie um programa que leia todas as linhas de um arquivo `dados.txt` com `readlines()` e armazene-as em uma lista. Em seguida, itere sobre a lista e exiba cada linha com seu número de linha correspondente.
1. exercícios sobre o método `write()`
    1. Crie um arquivo `saida.txt` e escreva a frase "Python é incrível!" usando o método `write()`.
    1. Crie um programa que abre ou cria um arquivo `registro.txt` e usa o método `write()` para adicionar a frase "Registro de atividades".
    1. Escreva um programa que crie um arquivo `numeros.txt` e adicione os números de 1 a 10, cada número em uma linha, usando o método `write()`.
    1. Crie um arquivo `diario.txt` e use `write()` para adicionar uma entrada de diário contendo a data e um texto qualquer.
    1. Abra ou crie um arquivo `notas.txt` e escreva as notas de três matérias usando o método `write()`.
    1. Crie um arquivo `tarefa.txt` e use `write()` para adicionar três tarefas diárias. Certifique-se de usar `\n` para separar as tarefas em linhas diferentes.
    1. Abra o arquivo `mensagem.txt` e use `write()` para sobrescrever seu conteúdo com a frase "Novo conteúdo escrito com write()".
    1. Crie um arquivo `historico.txt` e use `write()` para registrar o histórico de eventos, escrevendo uma nova linha a cada execução.
    1. Escreva um programa que abra um arquivo `log.txt` e use `write()` para registrar a hora atual do sistema a cada execução do programa.
    1. Crie um arquivo `lista_de_compras.txt` e use o método `write()` para adicionar 5 itens de compras. Cada item deve estar em uma linha separada.
1. Exercícios sobre o Método `writelines()`
    1. Crie um arquivo `nomes.txt` e use o método `writelines()` para escrever uma lista de nomes (cada nome em uma linha).
    1. Crie um arquivo `numeros.txt` e use `writelines()` para escrever os números de 1 a 10, cada um em uma linha separada.
    1. Crie um programa que abre ou cria um arquivo `agenda.txt` e usa `writelines()` para adicionar três compromissos, cada um em uma linha.
    1. Crie um arquivo `tarefas.txt` e use `writelines()` para adicionar cinco tarefas de uma lista, cada tarefa em uma linha separada.
    1. Escreva um programa que cria ou abre um arquivo `cidades.txt` e usa `writelines()` para adicionar o nome de três cidades, cada uma em uma linha.
    1. Crie um arquivo `frutas.txt` e use `writelines()` para adicionar o nome de cinco frutas em uma lista, cada nome em uma linha.
    1. Abra ou crie um arquivo `enderecos.txt` e use `writelines()` para adicionar três endereços, cada um em uma linha.
    1. Escreva um programa que cria um arquivo `historico.txt` e usa `writelines()` para adicionar três eventos, cada evento em uma linha separada.
    1. Crie um programa que abre o arquivo `receitas.txt` e usa `writelines()` para adicionar três receitas, cada receita em uma linha separada.
    1. Crie um arquivo `projetos.txt` e use `writelines()` para adicionar os títulos de três projetos de uma lista, cada título em uma linha.

</details>

## `with`

O comando `with` em Python é uma forma conveniente e segura de gerenciar recursos que precisam ser abertos e fechados, como arquivos, conexões de rede ou bloqueios em threads. Quando usado com a função `open()`, ele simplifica a manipulação de arquivos, garantindo que o arquivo seja fechado automaticamente, mesmo que ocorra uma exceção durante a execução do código.

### funcionamento

O comando `with` funciona usando o **gerenciamento de contexto**, que envolve a invocação de dois métodos especiais de um objeto: `__enter__()` e `__exit__()`. O método `__enter__()` é chamado quando o bloco `with` é iniciado, e o método `__exit__()` é chamado quando o bloco `with` é encerrado, seja de forma normal ou por uma exceção. No caso de arquivos, o método `__exit__()` fecha o arquivo automaticamente.

Veja sua sintaxe :

```python
with open('arquivo.txt', 'modo') as variavel_arquivo:
    # operações de leitura ou escrita
    variavel_arquivo.write("Escrevendo algo no arquivo.")
```

- **`open('arquivo.txt', 'modo')`** : abre o arquivo `arquivo.txt` no modo especificado (por exemplo, leitura `'r'`, escrita `'w'`, etc.);
- **`as variavel_arquivo`** : atribui o objeto de arquivo a uma variável (neste caso, `variavel_arquivo`) para que se possa manipulá-lo dentro do bloco `with`;
- **bloco de código** : o código dentro do bloco `with` pode realizar operações com o arquivo; após o final do bloco, o arquivo é fechado automaticamente;

### vantagens

O camando `with` tem algumas vantagens quando se trabalha com arquivos :

1. **gerenciamento automático de recursos** : o `with` garante que o arquivo seja fechado corretamente, mesmo que haja um erro ou exceção dentro do bloco de código;
2. **código mais conciso e legível** : não é necessário chamar `arquivo.close()`, pois isso é tratado automaticamente;

- **exemplos de `with` com `open()`**

#### leitura de um arquivo

```python
with open('exemplo.txt', 'r') as arquivo:
    conteudo = arquivo.read()
    print(conteudo)
```

Aqui :
- o arquivo `exemplo.txt` é aberto no modo de leitura (`'r'`);
- o conteúdo do arquivo é lido com `arquivo.read()`;
- ao sair do bloco `with`, o arquivo é fechado automaticamente, mesmo que ocorra um erro ao ler o conteúdo;

#### escrita em um arquivo

```python
with open('exemplo.txt', 'w') as arquivo:
    arquivo.write("Escrevendo no arquivo usando 'with'.\n")
    arquivo.write("Outra linha de exemplo.\n")
```

Neste exemplo :
- o arquivo é aberto no modo de escrita (`'w'`), e duas linhas são escritas nele;
- o arquivo será fechado automaticamente ao sair do bloco, garantindo que os dados sejam gravados corretamente;

#### leitura linha por linha:

```python
with open('exemplo.txt', 'r') as arquivo:
    for linha in arquivo:
        print(linha, end='')
```

Aqui :
- o arquivo é aberto para leitura;
- um laço `for` percorre cada linha do arquivo e a imprime;
- como o arquivo é um iterável, é possível ler linha por linha sem carregar todo o conteúdo na memória ao mesmo tempo;

<!--
### tratamento de exceções

O uso do `with` com arquivos também garante o fechamento correto mesmo que haja exceções durante a manipulação do arquivo.

Por exemplo :
```python
try:
    with open('exemplo.txt', 'r') as arquivo:
        conteudo = arquivo.read()
        # Suponha que ocorra um erro aqui
        raise ValueError("Um erro ocorreu!")
except ValueError as e:
    print(f"Erro: {e}")
```

Neste código :
- o arquivo será fechado automaticamente, mesmo que o erro ocorra durante a leitura;
- o `try-except` captura o erro, mas o recurso de fechar o arquivo continua garantido;
-->

### múltiplos arquivos com `with`

É também possível abrir múltiplos arquivos ao mesmo tempo usando um único comando `with` :

```python
with open('arquivo1.txt', 'r') as origem, open('arquivo2.txt', 'w') as destino:
    # lendo do primeiro arquivo, origem
    conteudo = origem.read()
    # alterando o conteúdo original
    conteudo += 'novo texto'
    # escrevendo no segundo arquivo, destino
    destino.write(conteudo)
```

Aqui :
- o arquivo `arquivo1.txt` é aberto no modo de leitura, e `arquivo2.txt` no modo de escrita;
- o conteúdo do primeiro arquivo é lido e escrito no segundo arquivo;
- ambos os arquivos são fechados automaticamente ao final do bloco `with`;

## exercícios com `with`

<details>
<summary>Lista de Exercícios</summary>

1. Crie um arquivo chamado `saudacao.txt` e use o comando `with` para abrir o arquivo e escrever a frase "Olá, bem-vindo ao Python!" nele. Após isso, exiba o conteúdo do arquivo no terminal.
1. Crie um arquivo `poema.txt` e use o comando `with` para escrever três estrofes de um poema. Depois, use o `with` novamente para abrir e ler o conteúdo do arquivo e exibir no terminal.
1. Escreva um programa que abra um arquivo chamado `dados.txt` usando o comando `with` e leia as primeiras 30 letras do arquivo, exibindo-as no terminal.
1. Crie um arquivo `compras.txt` com uma lista de compras. Use o comando `with` para adicionar dois novos itens no final do arquivo e depois leia todo o conteúdo, exibindo-o no terminal.
1. Crie um arquivo `log.txt` e, em um loop, registre a hora atual do sistema cinco vezes (uma vez por linha), usando o comando `with`.
1. Crie um arquivo `tarefas.txt` e adicione cinco tarefas diárias usando o comando `with`. Em seguida, leia e exiba todo o conteúdo do arquivo no terminal.
1. Escreva um programa que crie ou abra um arquivo `notas.txt` e adicione as notas de três matérias usando o comando `with`. Depois, use o `with` para abrir e ler o arquivo, exibindo as notas.
1. Crie um arquivo `frutas.txt` e use o comando `with` para escrever o nome de cinco frutas. Em seguida, leia e exiba todo o conteúdo do arquivo no terminal.
1. Escreva um programa que usa o comando `with` para criar um arquivo `mensagem.txt` e adicionar uma mensagem de boas-vindas. Depois, leia o conteúdo do arquivo e conte quantos caracteres a mensagem possui.
1. Crie um arquivo `historico.txt` e, com o uso do comando `with`, adicione três eventos históricos. Depois, leia todo o conteúdo e exiba apenas o primeiro evento.
1. Crie um arquivo `nomes.txt` com nomes de pessoas, cada um em uma linha. Use o comando `with` para ler os nomes e armazená-los em uma lista, depois exiba a lista no terminal.
1. Escreva um programa que crie um arquivo `diario.txt` e adicione uma entrada de diário com a data e um texto. Depois, use o comando `with` para exibir o conteúdo da última linha do arquivo.
1. Crie um arquivo `receitas.txt` e escreva três receitas curtas usando o comando `with`. Em seguida, use `with` novamente para ler e exibir todas as receitas.
1. Crie um arquivo `contatos.txt` e adicione três contatos (nome e telefone). Depois, use o comando `with` para ler o conteúdo e exibir apenas os números de telefone.
1. Crie um arquivo `projetos.txt` e use o comando `with` para escrever os títulos de três projetos. Depois, leia o arquivo e exiba o título do segundo projeto.
1. Crie um arquivo `endereco.txt` e escreva seu endereço completo usando o comando `with`. Em seguida, leia o arquivo e exiba o número da casa.
1. Crie um arquivo `planos.txt` e adicione três planos para o futuro. Em seguida, use o comando `with` para ler e exibir os planos, um por um.
1. Crie um arquivo `musicas.txt` e adicione o nome de cinco músicas favoritas. Depois, use o comando `with` para ler o arquivo e exibir a quantidade de músicas armazenadas.
1. Crie um arquivo `alunos.txt` e adicione o nome de cinco alunos. Em seguida, use o comando `with` para ler o arquivo e exibir todos os nomes em maiúsculas.
1. Crie um arquivo `historico_vendas.txt` e use o comando `with` para adicionar os valores de vendas de uma semana. Depois, leia o arquivo e exiba o valor total somando todas as vendas.

</details>

## encoding

O **encoding** (ou codificação) é a forma como os caracteres são convertidos em bytes para serem armazenados em arquivos ou transmitidos em redes. Quando se com arquivos de texto no Python, o **encoding** determina como o conteúdo textual será interpretado e convertido entre **strings** (internamente manipuladas como Unicode no Python) e **bytes** (armazenados em disco).

### conceito

Um **encoding** é um mapeamento entre caracteres (como letras, números e símbolos) e uma representação binária (bytes). Alguns encodings comuns incluem:

- **UTF-8** : um encoding muito usado para a web e arquivos de texto em geral. Ele usa entre 1 e 4 bytes para representar um caractere. É compatível com o ASCII (que usa 1 byte por caractere);
- **ASCII** : um encoding básico que utiliza 1 byte para representar 128 caracteres, mas não é adequado para caracteres não-ingleses ou símbolos especiais;
- **UTF-16** e **UTF-32** : usam 2 e 4 bytes, respectivamente, para representar caracteres. Esses encodings são mais compactos em representações de alguns caracteres Unicode, mas são menos comuns para arquivos de texto gerais;
- **ISO-8859-1** (ou Latin-1) : um encoding de 1 byte que representa caracteres da Europa Ocidental. Pode ser útil ao lidar com arquivos mais antigos;

### encoding ao abrir arquivos

Quando se trabalha com **arquivos de texto**, deve-se especificar o encoding correto ao abrir o arquivo para garantir que o Python leia e escreva os dados corretamente. Se o encoding não for especificado corretamente, pode resultar em erros como `UnicodeDecodeError` ou a leitura incorreta de caracteres.

### como especificar o encoding

Ao abrir arquivos de texto usando a função `open()` no Python, pode-se (e deve) especificar o encoding correto através do parâmetro `encoding`.

```python
# abrindo um arquivo com encoding específico
with open('arquivo.txt', 'r', encoding='utf-8') as arquivo:
    conteudo = arquivo.read()
    print(conteudo)
```

### principais encodings usados no Python

#### UTF-8 (padrão recomendado)

O **UTF-8** é o encoding padrão para arquivos de texto no Python moderno, especialmente se o arquivo contiver caracteres de várias línguas e scripts.

- **Exemplo** : Abrindo e escrevendo um arquivo em UTF-8.

```python
# Escrevendo em um arquivo com UTF-8
with open('arquivo_utf8.txt', 'w', encoding='utf-8') as arquivo:
    arquivo.write('Olá, Mundo!!')

# Lendo um arquivo em UTF-8
with open('arquivo_utf8.txt', 'r', encoding='utf-8') as arquivo:
    conteudo = arquivo.read()
    print(conteudo)
```

#### ISO-8859-1 (Latin-1)

O **ISO-8859-1** (também conhecido como **Latin-1**) é um encoding de 1 byte usado para representar caracteres da Europa Ocidental. Embora não suporte todos os caracteres Unicode, ele pode ser útil para arquivos mais antigos ou sistemas que não precisam de suporte para outros idiomas.

- **Exemplo** : Usando Latin-1 para abrir um arquivo.

```python
# Lendo um arquivo com encoding Latin-1
with open('arquivo_latin1.txt', 'r', encoding='iso-8859-1') as arquivo:
    conteudo = arquivo.read()
    print(conteudo)
```

#### ASCII

O **ASCII** é um encoding mais limitado, que só suporta caracteres básicos do inglês (números, letras e símbolos simples). Como só usa 1 byte por caractere, ele é útil para arquivos simples, mas inadequado para textos em outros idiomas.

- **Exemplo** : Usando o encoding ASCII.

```python
# Escrevendo e lendo um arquivo com encoding ASCII
with open('arquivo_ascii.txt', 'w', encoding='ascii') as arquivo:
    arquivo.write('Hello, World!')

with open('arquivo_ascii.txt', 'r', encoding='ascii') as arquivo:
    conteudo = arquivo.read()
    print(conteudo)
```

### problemas comuns com encoding

#### UnicodeDecodeError

Esse erro ocorre quando se tenta ler um arquivo com um encoding errado ou sem especificar o encoding corretamente.

```python
with open('arquivo_utf8.txt', 'r', encoding='ascii') as arquivo:
    conteudo = arquivo.read()  # Isso gerará um UnicodeDecodeError
```

Neste exemplo, o arquivo foi escrito usando **UTF-8**, mas estamos tentando lê-lo usando **ASCII**, que não suporta a maioria dos caracteres Unicode, resultando no erro.

#### codificação de caracteres especiais

Quando o arquivo contém caracteres que não estão no conjunto básico do encoding que se está usando, esses caracteres podem aparecer corrompidos ou resultar em erro.

```python
# Usando o encoding errado
with open('arquivo_latin1.txt', 'r', encoding='utf-8') as arquivo:
    conteudo = arquivo.read()  # Pode exibir caracteres incorretos
```

Neste caso, um arquivo em **Latin-1** está sendo lido com **UTF-8**, o que pode causar problemas na interpretação de alguns caracteres.

### definindo o encoding correto ao criar ou ler arquivos

1. **verifique o encoding do arquivo original** : se estiver lidando com arquivos que não foram criados por você, tente identificar o encoding correto. Ferramentas como editores de texto avançados ou bibliotecas externas podem ajudar a determinar isso;

2. **use sempre utf-8 para novos arquivos** : se estiver criando arquivos de texto, é recomendável sempre usar **utf-8**, pois ele é amplamente suportado e lida bem com a maioria dos caracteres;

3. **mantenha o encoding consistente** : ao escrever e ler o mesmo arquivo, use o mesmo encoding em ambas as operações; isso evita problemas de conversão incorreta de caracteres;

### exemplos

#### especificando o encoding ao escrever e ler arquivos

```python
# Escrevendo um arquivo com UTF-8
with open('mensagem.txt', 'w', encoding='utf-8') as arquivo:
    arquivo.write('Este é um texto com acentuação e caracteres especiais: ç, ã, ê.')

# Lendo o arquivo com o mesmo encoding
with open('mensagem.txt', 'r', encoding='utf-8') as arquivo:
    conteudo = arquivo.read()
    print(conteudo)
```

#### lendo um arquivo com encoding incorreto

```python
# Tentando abrir um arquivo UTF-8 com Latin-1 (resultado incorreto)
with open('mensagem.txt', 'r', encoding='iso-8859-1') as arquivo:
    conteudo = arquivo.read()  # Isso pode exibir caracteres corrompidos
    print(conteudo)
```

## exercícios encoding

<details>
<summary>Lista de Exercícios</summary>

1. Exercícios de Arquivos de Texto com Encoding
    1. Escreva um arquivo de texto `mensagem_utf8.txt` usando o encoding **UTF-8** e armazene a frase "Olá, Mundo!". Em seguida, leia o arquivo e exiba o conteúdo no terminal.
    1. Crie um arquivo de texto `mensagem_ascii.txt` usando o encoding **ASCII** e armazene a frase "Hello, World!". Depois, tente ler esse arquivo com o encoding **UTF-8** e observe o que acontece.
    1. Escreva um arquivo `caracteres_especiais.txt` em **ISO-8859-1** e armazene uma frase com caracteres especiais, como "Ação, Café, São Paulo". Em seguida, leia o arquivo com o encoding correto e exiba a frase.
    1. Escreva um arquivo `frase_latin1.txt` usando **ISO-8859-1** e armazene uma frase em português com acentuação. Leia o arquivo com **UTF-8** e veja o resultado. Depois, corrija o encoding e leia novamente.
    1. Crie um arquivo `nomes_utf16.txt` usando o encoding **UTF-16** e armazene os nomes "Alice", "Bob" e "Carlos". Leia o arquivo com o encoding **UTF-16** e exiba os nomes no terminal.
    1. Abra o arquivo `nomes_utf16.txt` com o encoding **UTF-8** e veja o que acontece. Em seguida, corrija o código para usar o encoding correto e leia os nomes novamente.
    1. Escreva um arquivo de texto `alfabeto.txt` em **ASCII** e armazene o alfabeto de A a Z. Leia o arquivo e exiba o conteúdo no terminal.
    1. Crie um arquivo `numeros.txt` com o encoding **UTF-8** e armazene os números de 1 a 10, cada número em uma linha. Em seguida, leia o arquivo e exiba os números.
    1. Crie um arquivo `frase_utf32.txt` com o encoding **UTF-32** e armazene a frase "Python é divertido!". Leia o arquivo com o encoding correto e exiba o conteúdo.
    1. Escreva um arquivo `mistura.txt` com o encoding **UTF-8** e armazene uma combinação de caracteres de diferentes idiomas (por exemplo, "Olá", "你好", "Hello"). Leia o arquivo e exiba o conteúdo.
1. Exercícios de Arquivos JSON com Encoding
    1. Crie um dicionário Python com informações sobre uma pessoa (nome, idade, cidade). Salve-o em um arquivo JSON `pessoa.json` com o encoding **UTF-8**.
    1. Leia o arquivo `pessoa.json` criado no exercício anterior, decodificando-o com **UTF-8**, e exiba as informações da pessoa.
    1. Crie um dicionário contendo uma lista de frutas e seus preços. Salve o dicionário em um arquivo JSON `frutas.json` com o encoding **ISO-8859-1**.
    1. Abra o arquivo `frutas.json` com o encoding **ISO-8859-1** e leia o conteúdo, exibindo a lista de frutas e preços no terminal.
    1. Crie um arquivo JSON `dados_usuarios.json` com uma lista de dicionários, onde cada dicionário representa um usuário com as chaves: "nome", "idade", "email". Escreva o arquivo usando **UTF-8**.
    1. Leia o arquivo `dados_usuarios.json` criado no exercício anterior, e exiba a lista de usuários no terminal.
    1. Crie um dicionário Python com uma lista de frases em diferentes idiomas (português, inglês, chinês). Salve o dicionário em um arquivo JSON `frases.json` com o encoding **UTF-16**.
    1. Leia o arquivo JSON `frases.json` criado no exercício anterior com o encoding **UTF-16** e exiba as frases no terminal.
    1. Crie um arquivo JSON `configuracoes.json` com configurações de sistema (por exemplo, tema, idioma, notificações). Salve o arquivo com o encoding **UTF-8**.
    1. Leia o arquivo `configuracoes.json` e atualize uma das configurações. Em seguida, salve novamente o arquivo com o mesmo encoding.

</details>


# atividade-agenda-eletronica.md

# atividade aula

Abaixo há a atividade que deverá ser realizada e entregue no começo de aula do dia 30/10, na próxima segunda-feira.
Ela servirá como aula não presencial do dia 26/10/2024. A não entrega da atividade implicará em falta no dia.

O código deverá ser desenvolvido em apenas um módulo.

Sua complexidade foi pensada para ser desenvolvida em uma aula de 4h.

## agenda eletrônica

Agendas eletrônicas eram dispositivos portáteis que armazenavam digitalmente informações como contatos, compromissos, tarefas e anotações, substituindo as agendas de papel tradicionais. Elas ofereciam recursos como calendário, calculadora, jogos e, em alguns casos, até mesmo conexão com outros dispositivos. Eram populares antes da era dos smartphones, que acabaram incorporando suas funções e tornando-as obsoletas.

## tarefa

Desenvolva uma agenda eletrônica pagar guardar apenas os contatos.
Use apenas os conhecimentos adquiridos em aula.

## estrutura

A Agenda Eletrônica deverá ser criada segundo os critérios abaixo :
- uma classe `Agenda` que vai ter as seguintes funcionalidades :
    - adicionar contato;
    - editar contato;
    - apagar contato;
    - listar todos os contatos;
    - listar contatos semelhantes ao nome que for buscado :
        - exemplo : buscar por *carlos* irá retornar *Carlos Alberto*, *Carlos Silva* e *José Carlos da Silva*;
    - ao inicializar, ela deve mostrar o nome de todos os aniversariantes do dia;
- uma classe `Contato`, que vai ser composta por :
    - nome completo;
    - telefone;
    - endereço;
    - data de aniversário (exibida sempre como dd/mm/yyyy);
    - correio eletrônico;
    - também deve mostrar :
        - a idade a partir da data de nascimento;
        - a quantidade de dias até o próximo aniversário;
- uma classe `Arquivo`, que :
    - vai salvar os dados em disco;
    - carregar os dados do disco sempre que for inicializada;
    - salvar os dados em disco sempre que algo for alterado;
    - escolha o formato de arquivo que achar melhor de trabalhar:
        - texto, json ou binário (única exceção de uso de material ainda não visto, MUITO DESAFIADOR!!!);

Considerações :
- opções incorretas devem ser mostradas na tela;
- use o módulo `os` para limpar a tela sempre que a agenda for inicalizada ou alguma opção escolhida;
- use menus numéricos para navegar pelas opções;
- use exceções específicas;


# aula.md

# Trilha de Python

Repositório com o material de Python para a Trilha 4 - Desenvolvimento Python.

## 2 - Programação Python

Curso com duração de 256 horas, totalizando 39 aulas. Previsão de término em ***10/10/2024***.

[avaliação](2.programacao-python/avaliacao.md)

| Aula | Dia | Arquivo |
| :----: | :----: | :----: |
| 18 | 09/09/2024 | [arquivos](2.programacao-python/arquivos.md)<br>[módulo `os`](2.programacao-python/modulos.md#módulo-os) [módulo `time`](2.programacao-python/modulos.md#módulo-time) |
| 17 | 06/09/2024 | [recursão](2.programacao-python/recursao.md)<br>[módulo `sys`](2.programacao-python/modulos.md#módulo-sys) [módulo `random`](2.programacao-python/modulos.md#módulo-random) |
| 16 | 05/09/2024 | acompanhamento da [avaliação](2.programacao-python/avaliacao.md) |
| 15 | 04/09/2024 | [empacotamento e desempacotamento](2.programacao-python/empacotamento-desempacotamento.md)<br>[`*args`](2.programacao-python/funcoes.md#args) [`**kwargs`](2.programacao-python/funcoes.md#kwargs) |
| 14 | 03/09/2024 | comandos<br>[`import`](2.programacao-python/comandos-from-import-as.md#comando-import) [`from` e `as`](2.programacao-python/comandos-from-import-as.md#comandos-from-e-as)<br>[`namespaces`](2.programacao-python/comando-global-namespaces.md)<br>[avaliação](2.programacao-python/avaliacao.md#módulos) |
| 13 | 02/09/2024 | [argumentos com valor padrão](2.programacao-python/funcoes.md#argumentos-com-valor-padrão)<br>[argumentos nomeados](2.programacao-python/funcoes.md#argumentos-nomeados)<br>[tipo `frozenset`](2.programacao-python/tipo-frozenset.md)<br>[`set.copy()`](2.programacao-python/tipo-set.md#setcopy) [`set.issubset()`](2.programacao-python/tipo-set.md#setissubset)<br>[`set.issuperset()`](2.programacao-python/tipo-set.md#setissuperset) [`set.isdisjoint()`](2.programacao-python/tipo-set.md#setisdisjoint) |
| 12 | 29/08/2024 | [`set.symmetric_difference()`](2.programacao-python/tipo-set.md#setsymmetric_difference)<br>[operadores do `set`](2.programacao-python/tipo-set.md#operadores-do-set)<br>[funções](2.programacao-python/funcoes.md)<br>[tipo `None`](2.programacao-python/tipo-none.md)<br>[avaliação](2.programacao-python/avaliacao.md#otimização) |
| 11 | 28/08/2024 | [comando `in`](2.programacao-python/comandos-built-in.md#in) e [comando `del`](2.programacao-python/comandos-built-in.md#del)<br>[cópia rasa](2.programacao-python/copias-rasa-e-profunda.md#cópia-rasa)<br>[tipos imutáveis](2.programacao-python/tipos-mutaveis-imutaveis.md#tipos-imutáveis)<br>[tipos mutáveis](2.programacao-python/tipos-mutaveis-imutaveis.md#tipos-mutáveis) |
| 10 | 27/08/2024 | [operação de atribuição composta](2.programacao-python/tipos-int-float.md#operação-de-atribuição-composta)<br>[`else` em loops](2.programacao-python/estruturas-repeticao.md#else-em-loops)<br>[tipo dicionário](2.programacao-python/tipo-dicionario.md)<br>[características](2.programacao-python/tipo-dicionario.md#características)<br>[criando dicionários](2.programacao-python/tipo-dicionario.md#criando-dicionários)<br>[adicionando itens ao dicionário](2.programacao-python/tipo-dicionario.md#adicionando-itens-ao-dicionário)<br>[métodos](2.programacao-python/tipo-dicionario.md#métodos)<br>[`dict.keys()`](2.programacao-python/tipo-dicionario.md#dictkeys) [`dict.values()`](2.programacao-python/tipo-dicionario.md#dictvalues) [`dict.items()`](2.programacao-python/tipo-dicionario.md#dictitems)<br>[avaliação](2.programacao-python/avaliacao.md#cpfs-inválidos)<br>[desafios](2.programacao-python/desafios.md) |
| 09 | 26/08/2024 | [loops aninhados](2.programacao-python/estruturas-repeticao.md#loops-aninhados)<br>[`for` vs `while`](2.programacao-python/estruturas-repeticao.md#for-vs-while)<br>[tipo conjunto](2.programacao-python/tipo-set.md)<br>[criando um `set`](2.programacao-python/tipo-set.md#criando-um-set)<br>[métodos do `set`](2.programacao-python/tipo-set.md#métodos-do-set)<br>[`set.union()`](2.programacao-python/tipo-set.md#setunion) [`set.intersection()`](2.programacao-python/tipo-set.md#setintersection)<br>[`set.difference()`](2.programacao-python/tipo-set.md#setdifference) [`set.add()`](2.programacao-python/tipo-set.md#setadd)<br>[`set.remove()`](2.programacao-python/tipo-set.md#setremove) [`set.discard()`](2.programacao-python/tipo-set.md#setdiscard)<br>[`cast` do `set`](2.programacao-python/tipo-set.md#cast) |
| 08 | 23/08/2024 | [operador ternário](2.programacao-python/opererador-ternario.md)<br>[compreensão de listas](2.programacao-python/compreensao-listas.md) |
| 07 | 22/08/2024 | [revisão - parte 2](2.programacao-python/revisao-parte-2.md) |
| 06 | 21/08/2024 | [tipo tupla](2.programacao-python/tipo-tupla.md)<br>[avaliação](2.programacao-python/avaliacao.md) |
| 05 | 20/08/2024 | [`pass`](2.programacao-python/comandos-built-in.md#pass)<br>[`break`](2.programacao-python/comandos-built-in.md#break)<br>[`continue`](2.programacao-python/comandos-built-in.md#continue)<br>[`break` e `continue`](2.programacao-python/comandos-built-in.md#break-e-continue) |
| 04 | 19/08/2024 | [comando `for`](2.programacao-python/estruturas-repeticao.md#for)<br>[função `range()`](2.programacao-python/funcoes-built-in.md#range)<br>[função `enumerate()`](2.programacao-python/funcoes-built-in.md#enumerate)<br>[função `zip()`](2.programacao-python/funcoes-built-in.md#zip)
| 03 | 16/08/2024 | [métodos das strings](2.programacao-python/tipo-string.md)<br>[`str.upper()`](2.programacao-python/tipo-string.md#strupper) [`str.lower()`](2.programacao-python/tipo-string.md#strlower)<br>[`str.capitalize()`](2.programacao-python/tipo-string.md#strcapitalize) [`str.title()`](2.programacao-python/tipo-string.md#strtitle)<br>[`str.strip()`](2.programacao-python/tipo-string.md#strstrip) [`str.lstrip()`](2.programacao-python/tipo-string.md#strlstrip) [`str.rstrip()`](2.programacao-python/tipo-string.md#strrstrip)<br>[`str.replace()`](2.programacao-python/tipo-string.md#strreplace) [`str.split()`](2.programacao-python/tipo-string.md#strsplit) [`str.join()`](2.programacao-python/tipo-string.md#strjoin)<br>[`str.find()`](2.programacao-python/tipo-string.md#strfind) [`str.rfind()`](2.programacao-python/tipo-string.md#strrfind)<br>[`str.startswith()`](2.programacao-python/tipo-string.md#strstartswith) [`str.endswith()`](2.programacao-python/tipo-string.md#strendswith)<br>[`str.isalpha()`](2.programacao-python/tipo-string.md#strisalpha) [`str.isdigit()`](2.programacao-python/tipo-string.md#strisdigit)<br>[`str.isalnum()`](2.programacao-python/tipo-string.md#strisalnum) [`str.isspace()`](2.programacao-python/tipo-string.md#strisspace)<br>[`str.isupper()`](2.programacao-python/tipo-string.md#strisupper) [`str.islower()`](2.programacao-python/tipo-string.md#strislower) [`str.zfill()`](2.programacao-python/tipo-string.md#strzfill)<br>[`str.center()`](2.programacao-python/tipo-string.md#strcenter) [`str.ljust()`](2.programacao-python/tipo-string.md#strljust) [`str.rjust()`](2.programacao-python/tipo-string.md#strrjust)<br>[`str.partition()`](2.programacao-python/tipo-string.md#strpartition) [`str.rpartition()`](2.programacao-python/tipo-string.md#strrpartition) |
| 02 | 15/08/2024 | [função `print()`](2.programacao-python/funcoes-built-in.md#print)<br>[intercalando e formatando `strings`](2.programacao-python/intercalando-formatando-strings.md)
| 01 | 14/08/2024 | [resolução dos desafios](1.logica-programacao/avaliacao/desafio.md) |

## 1 - Lógica de Programação

Curso com duração de 60 horas, totalizando 15 aulas.

| Aula | Dia | Arquivo |
| :----: | :----: | :----: |
| 15 | 13/08/2024 | [avaliação](1.logica-programacao/avaliacao/desafio.md) |
| 14 | 12/08/2024 | [funções built-in](2.programacao-python/funcoes-built-in.md)<br>[print()](2.programacao-python/funcoes-built-in.md#print) [input()](2.programacao-python/funcoes-built-in.md#input)<br>[len()](1.logica-programacao/comandos-built-in.md#len) [sum()](2.programacao-python/funcoes-built-in.md#sum) [pow()](2.programacao-python/funcoes-built-in.md#pow)<br>[max() e min()](2.programacao-python/funcoes-built-in.md#max-e-min) [abs()](2.programacao-python/funcoes-built-in.md#abs)<br>[round()](2.programacao-python/funcoes-built-in.md#round) [type()](2.programacao-python/funcoes-built-in.md#type)<br>[isinstance()](2.programacao-python/funcoes-built-in.md#isinstance) [ord() e chr()](2.programacao-python/funcoes-built-in.md#ord-e-chr)<br>[help()](2.programacao-python/funcoes-built-in.md#help)<br>[cast de listas](2.programacao-python/tipo-lista.md#cast-de-listas) |
| 13 | 08/08/2024 | [lista](2.programacao-python/tipo-lista.md)<br>[manipulando a lista](2.programacao-python/tipo-lista.md#manipulando-a-lista)<br>[list.append()](2.programacao-python/tipo-lista.md#listappend) [list.insert()](2.programacao-python/tipo-lista.md#listinsert) [list.remove()](2.programacao-python/tipo-lista.md#listpop)<br>[str e list](2.programacao-python/tipo-lista.md#str-e-list)<br>[função len()](2.programacao-python/comandos-built-in.md#len)<br>[comando in](2.programacao-python/comandos-built-in.md#in)<br>[juntando e multiplicando listas](2.programacao-python/tipo-lista.md#juntando-e-multiplicando-listas)<br>[fatiamento](2.programacao-python/tipo-lista.md#fatiamento)<br>[while](2.programacao-python/estruturas-repeticao.md#while)<br>[contador](2.programacao-python/estruturas-repeticao.md#contador) e [acumulador](2.programacao-python/estruturas-repeticao.md#acumulador) |
| 12 | 07/08/2024 | [input](1.logica-programacao/input.md) |
| 11 | 06/08/2024 | [cast](1.logica-programacao/cast.md)<br>[exercícios](1.logica-programacao/revisao-parte-1#exercícios.md) |
| 10 | 05/08/2024 | [revisão - parte 1](1.logica-programacao/revisao-parte-1.md) |
| 09 | 02/08/2024 | [if aninhado](1.logica-programacao/condicionais-if-elif-else.md#if-aninhado)<br>[comparando if simples e if aninhado](1.logica-programacao/condicionais-if-elif-else.md#comparando-if-simples-e-if-aninhado) |
| 08 | 01/08/2024 | [estrutura sequencial](1.logica-programacao/condicionais-if-elif-else.md#estrutura-sequencial)<br>[if](1.logica-programacao/condicionais-if-elif-else.md#if)<br>[else](1.logica-programacao/condicionais-if-elif-else.md#else)<br>[elif](1.logica-programacao/condicionais-if-elif-else.md#elif) |
| 07 | 31/07/2024 | [concatenando strings](2.programacao-python/tipo-string.md#concatenando-strings)<br>[multiplicando strings](2.programacao-python/tipo-string.md#multiplicando-strings)<br>[indexando strings](2.programacao-python/tipo-string.md#indexando-strings)<br>[dividindo strings](2.programacao-python/tipo-string.md#dividindo-strings)<br>[tipo lógico](1.logica-programacao/tipos-python.md#tipo-lógico) |
| 06 | 30/07/2024 | [tipo strings](2.programacao-python/tipo-string.md)<br>[caracteres especiais](2.programacao-python/tipo-string.md#caracteres-especiais)<br>[string-crua](2.programacao-python/tipo-string.md#string-crua)<br>[string-literal](2.programacao-python/tipo-string.md#string-literal) |
| 05 | 29/07/2024 | [instalando o vs code](1.logica-programacao/instalando-vscode.md)<br>[tipos do python](1.logica-programacao/tipos-python.md)<br>[tipos int e float](1.logica-programacao/tipos-python.md#tipos-int-e-float)<br>[variáveis](1.logica-programacao/tipos-python.md#variáveis) |
| 04 | 25/07/2024 | [instalando o python](1.logica-programacao/instalando-python.md)<br>[usando o python](1.logica-programacao/usando-python.md)<br>[interpretdor do python](1.logica-programacao/usando-python.md#interpretador-python)<br>[módulo python](1.logica-programacao/usando-python.md#módulo-python)<br>[explicando exemplos](1.logica-programacao/usando-python.md#explicando-exemplos)<br>[saída de dados](1.logica-programacao/usando-python.md#saída-de-dados)<br>[comentários](1.logica-programacao/usando-python.md#comentários) |
| 03 | 24/07/2024 | [tipos primitivos - parte 2](1.logica-programacao/tipos-primitivos.md)<br>[parênteses](1.logica-programacao/tipos-primitivos.md#parênteses)<br>[prioridades](1.logica-programacao/tipos-primitivos.md#prioridades)<br>[expressões lógicas](1.logica-programacao/tipos-primitivos.md#expressões-lógicas) <br>[comandos de atribuição](1.logica-programacao/tipos-primitivos.md#comandos-de-atribuição) |
| 02 | 23/07/2024 | [tipos primitivos](1.logica-programacao/tipos-primitivos.md)<br>[constantes](1.logica-programacao/tipos-primitivos.md#constantes)<br>[variáveis](1.logica-programacao/tipos-primitivos.md#variáveis)<br>[declarando variáveis](1.logica-programacao/tipos-primitivos.md#declarando-variáveis)<br>[expressões aritméticas](1.logica-programacao/tipos-primitivos.md#expressões-aritméticas) |
| 01 | 22/07/2024 | [o que é lógica](1.logica-programacao/o-que-eh-logica.md) |
 

## Acesso Computadores
Para acessar os computadores nos laboratórios da escola, é necessário entrar com o `usuário` e `senha`.

- Login : número da matrícula
- Senha : `tech@2024`

Ao realizar o primeiro acesso, será pedido para alterar a senha de acesso. A nova senha deverá atender os requisitos de complexidade :

- não conter :
    - nome do usuário
    - matrícula
    - data de nascimento
- conter ao menos 3 das regras abaixo :
    - caracteres maiúsculos (A - Z)
    - caracteres minúsculos (a - z)
    - números (0 - 9)
    - caracteres especiais, não alfanuméricos (!,@,#,&,% etc)
# Livros

Abaixo há diversos links de livros que podem ser usados para consultar.

* [Python 4 Everybody](https://www.py4e.com/book) (en-us / pt-br)
* [Python Notes for Professionals](https://books.goalkicker.com/PythonBook) (en-us)
* [Think Python](https://greenteapress.com/wp/think-python-3rd-edition) (en-us)
* [Learning Python Language eBook](https://riptutorial.com/ebook/python) (en-us)
* [Learn Python, Break Python](https://learnpythonbreakpython.com) (en-us)
* [Learn Python the Hard Way](https://learnpythonthehardway.org/python3) (en-us)


## Outros
Abaixo, há links relacionados a outros tópicos que também são interessantes.

* Git :
    * [Git Notes for Professionals](https://books.goalkicker.com/GitBook) (en-us)
* VS Code
    * [Boost Your Coding Fu](https://www.barbarianmeetscoding.com/boost-your-coding-fu-with-vscode-and-vim/dedication) (en-us)
# VS Code

## Atalhos

Abaixo há uma tabela de atalhos usados no VS Code.

### Comandos Básicos

| atalho | ação |
| :----: | :----: |
| <kbd>ctrl</kbd> + <kbd>s</kbd> | salva o arquivo |
| <kbd>ctrl</kbd> + <kbd>f</kbd> | busca no arquivo |

### Comandos de Edição

| atalho | ação |
| :----: | :----: |
| <kbd>ctrl</kbd> + <kbd>;</kbd> | comenta/descomenta linha |
| <kbd>ctrl</kbd> + <kbd>z</kbd> | desfazer alteração no arquivo |
| <kbd>alt</kbd> + <kbd>seta baixo</kbd> | move a linha para baixo |
| <kbd>alt</kbd> + <kbd>seta cima</kbd> | move a linha para cima |
| <kbd>alt</kbd> + <kbd>shift</kbd> + <kbd>seta baixo</kbd> | duplica a linha para baixo |
| <kbd>alt</kbd> + <kbd>shift</kbd> + <kbd>seta cima</kbd> | duplica a linha para cima |

### Comandos de Seleção

| atalho | ação |
| :----: | :----: |
| <kbd>ctrl</kbd> + <kbd>d</kbd> | seleciona as mesmas palavras |

## Extensões

Abaixo há uma sugestão de extensões para serem usadas no programa.

| extensão | tipo | uso |
| :----: | :----: | :----: |
| python | obrigatório | melhora o suporte do vs code para o python |
| vscode-icons | opcional | altera os ícones quando abre uma pasta |
| indent-rainbow | opcional | adiciona uma cor diferente a cada indentação |
Índice Cast

1. [o que é cast](#o-que-é-cast)
1. [funções de conversão](#funções-de-conversões)
1. [detalhes importantes](#detalhes-importantes)
1. [lista de exercícios](#lista-de-exercícios)

# cast

## o que é cast

Em programação, **cast** ou **casting** refere-se à conversão de uma variável de um tipo de dado para outro. No Python, isso é feito utlizando funções de conversão de tipo. Por exemplo, pode-se converter um número em uma string, uma string em um número.

## funções de conversões

Abaixo, há uma lista de conversão de algum dos tipo do Python :

* `int()` : converte para um número inteiro;
* `float()` : converte para um número de ponto flutuante;
* `str()` : converte para uma string;
* `bool()` : converte para um valor booleano;

Veja alguns exemplos :

```python
# convertendo string para inteiro
numero = int('123')
print(numero)  # saída : 123

# convertendo float para inteiro
numero = int(3.14159265)
print(numero)  # saida : 3

# convertendo boolean para inteiro
numero = int(True)
print(numero)  # saida : 1

# convertendo string para float
numero = float('3.1415')
print(numero)  # saída : 3.1415

# convertendo inteiro para float
numero = float(42)
print(numero)  # saida : 42.0

# convertendo boolean para float
numero = float(True)
print(numero)  # saida : 1.0

# convertendo inteiro para string
texto = str(42)
print(texto)  # saída : "42"

# convertendo float para string
texto = str(3.1415)
print(texto)  # saida : "3.1415"

# convertendo boolean para string
texto = str(True)
print(texto)  # saida : "True"

# convertendo inteiro para boolean
texto = bool(42)
print(texto)  # saída : True

# convertendo float para boolean
texto = bool(0.0)
print(texto)  # saida : False

# convertendo string para boolean
texto = bool('Arnold')
print(texto)  # saida : True

# convertendo string para boolean
texto = bool('')
print(texto)  # saida : False
```

## detalhes importantes

Alguns detalhes importantes sobre a conversão de um tipo de variável em outra :

1. `ìnt()` : converte uma string ou float para um inteiro, mas se a string não representar um número inteiro válido, irá levantar um erro;
1. `float()` : converte uma string ou um inteiro para um float e, assim como o inteiro, se a string não representar um número válido, irá levantar um erro;
1. `str()` : converte qualquer tipo de dado para uma string;
1. `bool()` : converte qualquer tipo de dado para booleano. Valores como `0`, `0.0`,`''` (uma string vazia), `[]` (uma lista vazia), `()` (uma tupla vazia), `{}` (um dicionário vazio) são convertidos para `False`, enquanto que qualquer outro valor é convertido para `True`.

## lista de exercícios

<details>
<summary>Lista de Exercícios</summary>

1. Converting to Integer (int())
    1. Converta a string "1234" para um inteiro.
    1. Converta a string "56" para um inteiro.
    1. Converta o float 98.76 para um inteiro.
    1. Converta a string "0" para um inteiro.
    1. Converta o float 0.0 para um inteiro.
    1. Converta a string "200" para um inteiro.
    1. Converta o float 150.99 para um inteiro.
    1. Converta a string "-123" para um inteiro.
    1. Converta a string "999" para um inteiro.
    1. Converta o float -45.67 para um inteiro.
1. Converting to Float (float())
    1. Converta a string "123.45" para um float.
    1. Converta a string "56.78" para um float.
    1. Converta o inteiro 100 para um float.
    1. Converta a string "0" para um float.
    1. Converta o inteiro 0 para um float.
    1. Converta a string "250.75" para um float.
    1. Converta o inteiro 45 para um float.
    1. Converta a string "-987.65" para um float.
    1. Converta a string "3.14159" para um float.
    1. Converta o inteiro -200 para um float.
1. Converting to String (str())
    1. Converta o inteiro 1234 para uma string.
    1. Converta o float 56.78 para uma string.
    1. Converta o inteiro 0 para uma string.
    1. Converta o float 0.0 para uma string.
    1. Converta o inteiro 789 para uma string.
    1. Converta o float 12.34 para uma string.
    1. Converta o inteiro -123 para uma string.
    1. Converta o float -56.78 para uma string.
    1. Converta o booleano True para uma string.
    1. Converta o booleano False para uma string.
1. Converting to Boolean (bool())
    1. Converta a string "True" para um booleano.
    1. Converta a string "False" para um booleano.
    1. Converta a string "" (string vazia) para um booleano.
    1. Converta o inteiro 0 para um booleano.
    1. Converta o inteiro 1 para um booleano.
    1. Converta o float 0.0 para um booleano.
    1. Converta o float 3.14 para um booleano.
    1. Converta a string "Hello" para um booleano.
    1. Converta a string "0" para um booleano.
    1. Converta a string " " (espaço) para um booleano.

</details>

Índice Estruturas Condicionais

1. [estutura sequencial](#estrutura-sequencial)
1. [if](#if)
1. [else](#else)
1. [elif](#elif)
1. [if aninhado](#if-aninhado)
1. [comparando if simples e if aninhado](#comparando-if-simples-e-if-aninhado)

# estruturas condicionais em python

## estrutura sequencial

A estrutura sequencial de um algoritmo corresponde ao fato de que um conjunto de ações será executado em uma sequência linear de cima para baixo e da esquerda para a direita.

Veja um exemplo :

```python
# como calcular o valor de x de uma função quadrática usando a fórmula de
# Bhaskara
# considere a equação quadrática : x^2 + 2x - 3 = 0, encontre os dois valores
# possíveis para o X
a = 1
b = 2
c = -3

delta = b ** 2 - 4 * a * c

x1 = (-b + (delta ** (1/2))) / (2 * a)
x2 = (-b - (delta ** (1/2))) / (2 * a)

print('Os valores de X são',x1,'e',x2,'.')
```

Nesse exemplo, pode-se ver que o algoritmo inicia na primeira linha, executa sucessivamente cada uma e termina quando chega na última linha. Nenhuma linha foi ignorada.

Há algumas estruturas das linguagens de programação que permitem alterar esse fluxo.

Provavelmente a estrutura condicional mais conhecida seja a `if-else`.

## if

Em Python, o `if` é usado para fazer uma decisão baseada em uma condição. A palavra `if` significa **se** em inglês. Quando usamos `if` em Python, estamos dizendo ao computador para fazer algo **se** uma determinada condição for verdadeira.

Veja sua estrutura básica :

```python
if <condição>:
    # código a ser executado se a condição for verdadeira
```

- **condição**: uma expressão que o Python avalia como verdadeira (True) ou falsa (False);
- **código a ser executado**: um bloco de código que será executado apenas se a condição for verdadeira;

Agora veja alguns exemplos simples :

```python
idade = 18

if idade >= 18:
    print('Você já pode dirigir.')
```

Neste exemplo, a condição `idade >= 18` é verdadeira, pois a variável `idade` é igual a 18. Portanto, o Python executa o código dentro do bloco `if` e imprime "Você já pode dirigir."

```python
idade = 15

if idade >= 18:
    print('Você já pode dirigir.')
```

Neste outro exemplo, a condição `idade >= 18` é falsa, pois a variável `idade` é igual a 15. Portanto, o Python não irá executar o código dentro do bloco `if`.

## else

O `else` é usado em conjunto com o `if` para definir o que deve ser feito quando a condição do `if` não é verdadeira. A palavra `else` significa **senão** em inglês. Portanto, estamos dizendo ao computador para fazer algo se a condição do `if` for falsa. Seu uso é opcional.

Veja sua estrutura básica :

```python
if condição:
    # código a ser executado se a condição for verdadeira
else:
    # código a ser executado se a condição for falsa
```

- **código a ser executado se a condição for falsa**: um bloco de código que será executado apenas se a condição do `if` for falsa;

Veja agora alguns exemplos :

```python
idade = 15

if idade >= 18:
    print("Você já pode dirigir.")
else:
    print("Você está proibido de dirigir.")
```

Neste exemplo, a condição `idade >= 18` é falsa, pois a variável `idade` é igual a 15. Portanto, o Python não executa o código dentro do bloco `if`, mas sim o código dentro do bloco `else`, imprimindo "Você está proibido de dirigir."

## elif

Em Python, o `elif` é uma combinação de `else` e `if`, que significa `senão se` em inglês. Ele permite verificar múltiplas condições em uma estrutura condicional, adicionando alternativas ao `if` inicial. Se a condição do `if` for falsa, o Python verifica a condição do `elif`. Você pode usar quantos `elif` precisar para cobrir todas as possibilidades. Assim como o `else`, o uso do `elif` também é opcional.

Veja sua estrutura básica :

```python
if condição1:
    # código a ser executado se condição1 for verdadeira
elif condição2:
    # código a ser executado se condição1 for falsa e condição2 for verdadeira
elif condição3:
    # código a ser executado se condição1 e condição2 forem falsas e condição3 for verdadeira
else:
    # código a ser executado se todas as condições anteriores forem falsas
```

- **condição1, condição2, condição3, ...**: expressões que o Python avalia como verdadeiras (True) ou falsas (False);
- **código a ser executado**: blocos de código que serão executados se a condição correspondente for verdadeira;

Veja um exemplo simples :

```python
nota = 75

if nota >= 90:
    print("Você tirou um A.")
elif nota >= 80:
    print("Você tirou um B.")
elif nota >= 70:
    print("Você tirou um C.")
else:
    print("Você está de recuperação.")
```

Neste exemplo, o Python verifica a condição `nota >= 90`. Como ela é falsa, ele passa para a próxima condição `nota >= 80`, que também é falsa. Em seguida, ele verifica `nota >= 70`, que é verdadeira. Portanto, ele executa o código dentro desse bloco "elif" e imprime "Você tirou um C.".

É possível usar quantos "elif" precisar para cobrir todas as possíveis condições. Veja um exemplo mais detalhado:

```python
dia_da_semana = "quarta-feira"

if dia_da_semana == "segunda-feira":
    print("Hoje é segunda-feira.")
elif dia_da_semana == "terça-feira":
    print("Hoje é terça-feira.")
elif dia_da_semana == "quarta-feira":
    print("Hoje é quarta-feira.")
elif dia_da_semana == "quinta-feira":
    print("Hoje é quinta-feira.")
elif dia_da_semana == "sexta-feira":
    print("Hoje é sexta-feira.")
else:
    print("Hoje é fim de semana.")
```

Neste exemplo, o Python verifica cada condição `elif` na ordem em que aparecem. Quando ele encontra a condição verdadeira (`dia_da_semana == "quarta-feira"`), ele executa o bloco de código correspondente e ignora os demais.

<details>
    <summary>Lista de Exercícios</summary>

1. Exercícios Simples
    1. Verifique se um número é positivo. Caso seja, exiba "Positivo".
    1. Verifique se um número é negativo. Caso seja, exiba "Negativo".
    1. Verifique se um número é igual a zero. Caso seja, exiba "Zero".
    1. Verifique se um número é maior que 10. Caso seja, exiba "Maior que 10".
    1. Verifique se um número é menor que 5. Caso seja, exiba "Menor que 5".
    1. Verifique se um número é par. Caso seja, exiba "Par".
    1. Verifique se um número é ímpar. Caso seja, exiba "Ímpar".
    1. Verifique se uma pessoa é maior de idade (idade >= 18). Caso seja, exiba "Maior de idade".
    1. Verifique se uma pessoa é menor de idade (idade < 18). Caso seja, exiba "Menor de idade".
    1. Verifique se um número é positivo, negativo ou zero. Exiba a mensagem correspondente.
1. Exercícios Intermediários
    1. Verifique se um número é maior que outro. Caso seja, exiba "Maior".
    1. Verifique se um número é menor que outro. Caso seja, exiba "Menor".
    1. Verifique se dois números são iguais. Caso sejam, exiba "Iguais".
    1. Verifique se um número é maior ou igual a outro. Caso seja, exiba "Maior ou igual".
    1. Verifique se um número é menor ou igual a outro. Caso seja, exiba "Menor ou igual".
    1. Verifique se um número está entre 1 e 10. Exiba "Entre 1 e 10" ou "Fora do intervalo".
    1. Verifique se uma pessoa pode votar (idade >= 16). Exiba "Pode votar" ou "Não pode votar".
    1. Verifique se um número é divisível por 3. Exiba "Divisível por 3" ou "Não é divisível por 3".
    1. Verifique se um ano é bissexto (divisível por 4, mas não por 100, exceto se for divisível por 400). Exiba "Bissexto" ou "Não bissexto".
        ```python
        ano = 2095

        if ano % 400 == 0:
            eh_div_400 = True
        else:
            eh_div_400 = False

        if ano % 100 == 0:
            eh_div_100 = True
        else:
            eh_div_100 = False

        if ano % 4 == 0:
            eh_div_4 = True
        else:
            eh_div_4 = False

        print('o ano', ano)
        if eh_div_400 or (not eh_div_100 and eh_div_4):
            print('é bissexto')
        else:
            print('não é bissexto')
        ```
    1. Verifique se um número é positivo, negativo ou zero e exiba a mensagem correspondente.
1. Exercícios Avançados
    1. Verifique se a média das notas de um aluno é maior ou igual a 7. Caso seja, exiba "Aprovado". Caso contrário, exiba "Reprovado".
    1. Verifique se a temperatura está abaixo de 0. Caso esteja, exiba "Congelante". Se estiver entre 0 e 20, exiba "Frio". Se estiver acima de 20, exiba "Quente".
    1. Verifique se um número é par ou ímpar, e se é maior ou menor que 10. Exiba as mensagens correspondentes.
    1. Verifique se um aluno passou de ano. As notas finais de três matérias devem ser todas maiores ou iguais a 6. Caso seja, exiba "Passou". Caso contrário, exiba "Não passou".
    1. Verifique se um número está entre 1 e 100. Se estiver entre 1 e 50, exiba "Entre 1 e 50". Se estiver entre 51 e 100, exiba "Entre 51 e 100". Caso contrário, exiba "Fora do intervalo".
    1. Verifique se uma pessoa é maior de idade (idade >= 18) e se é aposentada (idade >= 65). Exiba "Maior de idade" ou "Aposentado" ou "Menor de idade".
        ```python
        idade = 78

        if idade >= 65:
            print('é aposentado')
        elif idade >= 18:
            print('é maior de idade')
        else:
            print('menor de idade')

        if idade >= 18 and idade < 65:
            print('é maior de idade')
        elif idade >= 65:
            print('é aposentado')
        else:
            print('menor de idade')
        ```
    1. Verifique se um número é múltiplo de 5 ou de 10. Exiba "Múltiplo de 5", "Múltiplo de 10" ou "Não é múltiplo de 5 nem de 10".
    1. Verifique se a nota final de um aluno é maior ou igual a 7. Se for, exiba "Aprovado". Se for menor que 5, exiba "Reprovado". Se estiver entre 5 e 7, exiba "Recuperação".
    1. Verifique se a temperatura está abaixo de 0. Caso esteja, exiba "Congelante". Se estiver entre 0 e 15, exiba "Frio". Se estiver entre 16 e 30, exiba "Agradável". Se estiver acima de 30, exiba "Quente".
    1. Verifique se uma pessoa pode votar (idade >= 16) e se é obrigada a votar (idade >= 18 e < 70). Exiba "Não pode votar", "Pode votar" ou "Obrigada a votar".
1. Exercícios Complexos
    1. Verifique se um triângulo é equilátero, isósceles ou escaleno com base nos comprimentos de seus lados.
    1. Verifique se uma pessoa pode se aposentar. Ela deve ter pelo menos 65 anos ou ter trabalhado por pelo menos 30 anos. Exiba "Pode se aposentar" ou "Não pode se aposentar".
        ```python
        idade = 45
        tempo_trab = 31

        if idade >= 65 or tempo_trab > 30:
            print('pode ser aposentar')
        else:
            print('ainda não pode se aposentar')
        ```
    1. Verifique se uma nota está entre 0 e 10. Se estiver fora, exiba "Nota inválida". Caso contrário, verifique se é maior ou igual a 7 (Aprovado), entre 5 e 6.9 (Recuperação) ou menor que 5 (Reprovado).
    1. Verifique se um ponto (x, y) está dentro, fora ou sobre a borda de um círculo de raio 5 centrado na origem.
    1. Verifique se um número é positivo, negativo ou zero. Além disso, verifique se é par ou ímpar e exiba as mensagens correspondentes.
    1. Verifique se uma data (dia, mês, ano) é válida. Considere anos bissextos e meses com diferentes números de dias. Exiba "Data válida" ou "Data inválida".
    1. Verifique se um ano é bissexto. Se for, exiba "Bissexto". Caso contrário, verifique se é par ou ímpar e exiba a mensagem correspondente.
    1. Verifique se três valores podem formar um triângulo. Caso possam, verifique se é equilátero, isósceles ou escaleno.
    1. Verifique se um número é par ou ímpar. Além disso, verifique se está entre 1 e 100 e exiba as mensagens correspondentes.
1. Exercícios Muito Complexos
    1. Verifique se uma data (dia, mês, ano) é válida. Caso seja, verifique se é uma data futura, passada ou presente em relação à data atual.
        ```python

        hoje_dia = 2
        hoje_mes = 8
        hoje_ano = 2024

        teste_dia = 2
        teste_mes = 8
        teste_ano = 2024

        #1   3   5   7   8  10  12
        #jan_mar_mai_jul_ago_out_dez = 31
        #4   6   9  11
        #abr_jun_set_nov = 30
        #2
        #fev = 28 # ou 29

        if (teste_mes == 1 or teste_mes == 3 or teste_mes == 5 or teste_mes == 7 or teste_mes == 8 or teste_mes == 10 or teste_mes == 12) and teste_dia <= 31:
            dia_mes_valido = True
        elif (teste_mes == 4 or teste_mes == 6 or teste_mes == 9 or teste_mes == 11) and teste_dia <= 30:
            dia_mes_valido = True
        elif teste_mes == 2 and teste_dia < 28:
            dia_mes_valido = True
        else:
            dia_mes_valido = False

        mesmo_ano = False
        if teste_ano < hoje_ano:
            print('data ano passada')
        elif teste_ano > hoje_ano:
            print('data ano futura')
        else:
            print('mesmo ano')
            mesmo_ano = True

        mesmo_mes = False
        if mesmo_ano and teste_mes < hoje_mes:
            print('data mes passada')
        elif mesmo_ano and teste_mes > hoje_mes:
            print('data mes futura')
        elif mesmo_ano and teste_mes == hoje_mes:
            mesmo_mes = True
            print('mesmo mes')

        if mesmo_ano and mesmo_mes and (teste_dia < hoje_dia):
            print('data dia passada')
        elif mesmo_ano and mesmo_mes and (teste_dia > hoje_dia):
            print('data dia futuro')
        elif mesmo_ano and mesmo_mes and (teste_dia == hoje_dia):
            print('mesmo dia, mesmo mes, mesmo ano')
        ```
    1. Verifique se uma pessoa pode dirigir. Ela deve ter pelo menos 18 anos e ter passado no exame de direção. Exiba "Pode dirigir" ou "Não pode dirigir".
    1. Verifique se um aluno está aprovado, em recuperação ou reprovado com base em suas notas em três provas e uma prova final. As regras de aprovação são: média >= 7 (Aprovado), média entre 5 e 6.9 (Recuperação), média < 5 (Reprovado).
    1. Verifique se um ano é bissexto. Caso seja, verifique se a data 29/02/ano é válida. Exiba "Data válida" ou "Data inválida".

</details>

## if aninhado

Um `if` aninhado é uma estrutura condicional que está dentro de outro `if`, `elif` ou `else`. Em outras palavras, é um `if` dentro de um `if`. Isso permite criar decisões mais complexas, verificando condições dentro de outras condições.

Veja um exemplo básico :

```python
if condição1:
    # código a ser executado se condição1 for verdadeira
    if condição2:
        # código a ser executado se condição2 também for verdadeira
    else:
        # código a ser executado se condição2 for falsa
else:
    # código a ser executado se condição1 for falsa
```

### if aninhado em dois níveis

Veja um exemplo onde é verificado a idade e, dentro disso, é verificafo a cidadania para determinar se uma pessoa pode votar :

```python
idade = 20
cidadania = "brasileira"

if idade >= 18:
    if cidadania == "brasileira":
        print("Você pode votar.")
    else:
        print("Você não pode votar porque não é cidadão brasileiro.")
else:
    print("Você não pode votar porque é menor de idade.")
```

Neste exemplo, temos duas condições a serem verificadas:
1. A idade deve ser maior ou igual a 18;
1. A cidadania deve ser "brasileira";

Se a idade é maior ou igual a 18, o Python verifica a cidadania. Se ambas as condições forem verdadeiras, ele imprime "Você pode votar". Se a idade for menor que 18, ele imprime "Você não pode votar porque é menor de idade".

### if aninhado em três níveis

Veja ver um exemplo mais complexo com três níveis de "if" aninhado :

```python
idade = 25
cidadania = "brasileira"
residencia = "São Paulo"

if idade >= 18:
    if cidadania == "brasileira":
        if residencia == "São Paulo":
            print("Você pode votar em São Paulo.")
        else:
            print("Você pode votar, mas não em São Paulo.")
    else:
        print("Você não pode votar porque não é cidadão brasileiro.")
else:
    print("Você não pode votar porque é menor de idade.")
```

Neste exemplo, verificamos três condições:
1. A idade deve ser maior ou igual a 18;
1. A cidadania deve ser "brasileira";
1. A residência deve ser "São Paulo";

Se todas as condições forem verdadeiras, ele imprime "Você pode votar em São Paulo". Se a cidadania for "brasileira" mas a residência não for "São Paulo", ele imprime "Você pode votar, mas não em São Paulo". Se a cidadania não for "brasileira", ele imprime "Você não pode votar porque não é cidadão brasileiro". Se a idade for menor que 18, ele imprime "Você não pode votar porque é menor de idade".

### mais exemplos

1. **verificando múltiplas condições aninhadas em uma compra**

```python
saldo = 1000
preco_item = 500
quantidade_em_estoque = 10

if saldo >= preco_item:
    if quantidade_em_estoque > 0:
        print("Compra realizada com sucesso!")
    else:
        print("Item fora de estoque.")
else:
    print("Saldo insuficiente.")
```

Neste exemplo, a compra só será realizada se houver saldo suficiente e o item estiver em estoque.

2. **verificando aninhamentos para determinar a faixa etária e o período do dia**

```python
idade = 16
periodo_do_dia = "tarde"

if idade < 18:
    if periodo_do_dia == "manhã":
        print("Você é menor de idade e está na escola de manhã.")
    elif periodo_do_dia == "tarde":
        print("Você é menor de idade e está na escola à tarde.")
    else:
        print("Você é menor de idade e está em casa à noite.")
else:
    if periodo_do_dia == "manhã":
        print("Você é adulto e está trabalhando de manhã.")
    elif periodo_do_dia == "tarde":
        print("Você é adulto e está trabalhando à tarde.")
    else:
        print("Você é adulto e está descansando à noite.")
```

Este exemplo determina a mensagem a ser exibida com base na idade e no período do dia.

## comparando if simples e if aninhado

### exemplo 1: verificação de senha e nome de usuário

**com `if` aninhado**

```python
usuario = "admin"
senha = "1234"

if usuario == "admin":
    if senha == "1234":
        print("Acesso permitido.")
    else:
        print("Senha incorreta.")
else:
    print("Usuário não encontrado.")
```

**sem `if` aninhado**

```python
usuario = "admin"
senha = "1234"

if usuario == "admin" and senha == "1234":
    print("Acesso permitido.")
elif usuario == "admin":
    print("Senha incorreta.")
else:
    print("Usuário não encontrado.")
```

### exemplo 2: verificação de temperatura e umidade

**com `if` aninhado**

```python
temperatura = 30
umidade = 70

if temperatura > 25:
    if umidade > 60:
        print("Está quente e úmido.")
    else:
        print("Está quente e seco.")
else:
    if umidade > 60:
        print("Está frio e úmido.")
    else:
        print("Está frio e seco.")
```

**sem `if` aninhado**

```python
temperatura = 30
umidade = 70

if temperatura > 25 and umidade > 60:
    print("Está quente e úmido.")
elif temperatura > 25 and umidade <= 60:
    print("Está quente e seco.")
elif temperatura <= 25 and umidade > 60:
    print("Está frio e úmido.")
else:
    print("Está frio e seco.")
```

### exemplo 3: verificação de estoque e saldo para compra

**com `if` aninhado**

```python
saldo = 200
preco_item = 150
estoque = 5

if estoque > 0:
    if saldo >= preco_item:
        print("Compra realizada com sucesso!")
    else:
        print("Saldo insuficiente.")
else:
    print("Item fora de estoque.")
```

**sem `if` aninhado**

```python
saldo = 200
preco_item = 150
estoque = 5

if estoque > 0 and saldo >= preco_item:
    print("Compra realizada com sucesso!")
elif estoque > 0:
    print("Saldo insuficiente.")
else:
    print("Item fora de estoque.")
```

### resumo das comparações

- **if simples**:
  - Útil para verificar condições diretamente relacionadas.
  - Pode se tornar complicado com múltiplos níveis de verificação.
- **if aninhado**:
  - Clarifica a estrutura das decisões.
  - Facilita a leitura e a manutenção do código.
  - Melhora a organização do código para decisões complexas.

Os exemplos mostraram que o uso de `if` aninhado pode tornar o código mais claro e fácil de entender quando múltiplas condições devem ser verificadas, enquanto o `if` simples pode ser mais direto para condições simples e independentes.

<details>
    <summary>Lista de Exercícios</summary>

Para os exercícios abaixo, use a estrutura de `if` que achar mais conveniente.

1. Exercícios Simples
    1. Verifique se um número é positivo. Caso seja, verifique se é maior que 10.
    1. Verifique se um número é negativo. Caso seja, verifique se é menor que -10.
    1. Verifique se um número é zero. Caso não seja, verifique se é positivo ou negativo.
    1. Verifique se um número é par. Caso seja, verifique se é maior que 20.
    1. Verifique se uma pessoa é maior de idade (idade >= 18). Se for, verifique se tem 65 anos ou mais.
1. Exercícios Intermediários
    1. Verifique se um número é maior que 10. Caso seja, verifique se é menor que 20.
    1. Verifique se um número é positivo. Caso seja, verifique se é ímpar.
    1. Verifique se uma pessoa pode votar (idade >= 16). Se puder, verifique se é obrigatória a votação (idade >= 18 e < 70).
    1. Verifique se uma string não está vazia. Caso não esteja, verifique se o primeiro caracter é uma vogal.
    1. Verifique se um número é divisível por 3. Caso seja, verifique se também é divisível por 5.
1. Exercícios Avançados
    1. Verifique se a média das notas de um aluno é maior ou igual a 7. Caso seja, verifique se a nota em matemática é maior que 5.
    1. Verifique se a temperatura está abaixo de 0. Caso esteja, exiba "Congelante". Se não, verifique se está entre 0 e 20, exiba "Frio".
    1. Verifique se um número é par ou ímpar. Se for par, verifique se é maior que 10. Se for ímpar, verifique se é menor que 5.
    1. Verifique se um número está entre 1 e 100. Se estiver, verifique se é múltiplo de 10.
    1. Verifique se a média das notas de um aluno é maior ou igual a 7. Caso seja, exiba "Aprovado". Caso contrário, verifique se está entre 5 e 6.9 e exiba "Recuperação".
1. Exercícios Complexos
    1. Verifique se três valores podem formar um triângulo. Caso possam, verifique se é equilátero, isósceles ou escaleno.
    1. Verifique se uma pessoa pode se aposentar. Ela deve ter pelo menos 65 anos. Se não tiver, verifique se trabalhou por pelo menos 30 anos.
    1. Verifique se uma data (dia, mês, ano) é válida. Considere anos bissextos. Se o ano for bissexto, verifique se o mês é fevereiro e o dia é 29.
    1. Verifique se um número é positivo, negativo ou zero. Se for positivo, verifique se é maior que 100. Se for negativo, verifique se é menor que -100.
    1. Verifique se um aluno passou de ano. As notas finais de três matérias devem ser todas maiores ou iguais a 6. Caso seja, verifique se a média é maior ou igual a 7.
1. Exercícios Muito Complexos
    1. Verifique se uma pessoa pode dirigir. Ela deve ter pelo menos 18 anos e ter passado no exame de direção. Caso não tenha 18 anos, verifique se está perto de completar 18 (falta menos de um mês).
    1. Verifique se um aluno está aprovado, em recuperação ou reprovado com base em suas notas em três provas e uma prova final. A média das três provas deve ser maior ou igual a 7. Caso contrário, verifique se a média com a prova final é maior ou igual a 5.
    1. Verifique se uma pessoa é elegível para uma promoção. Ela deve ter pelo menos 5 anos de experiência na empresa. Caso não tenha, verifique se tem uma avaliação de desempenho excelente. Se não tiver, verifique se completará 5 anos de experiência em menos de 6 meses.
        ```python
        anos_experiencia = 6
        meses_experiencia = 4
        aval_desempenho = 'regular'


        if anos_experiencia >= 5:
            print('já pode ser promovido')
        else:
            if aval_desempenho == 'excelente':
                print('tem bom comportamento, pode ser promovido')
            else:
                if anos_experiencia >= 4 and anos_experiencia < 5 and meses_experiencia > 6:
                    print('pode ser promovido')
                else:
                    print('vosmecê ainda não pode ser promovido')
        ```

</details>

Índice Input

* [input](#input)
* [exercícios input](#exercícios-input)

# input

A função `input` do Python é uma ferramenta fundamental para receber dados do usuário durante a execução de um programa. Ela é usada para ler uma linha de texto digitada pelo usuário e pode ser armazenada em uma variável para uso posterior no código.

Quando usada, a função `input` exibe uma mensagem (prompt) ao usuário e pausa a execução do programa até que o usuário digite algo e pressione a tecla Enter, finalizando assim a entrada de dados. **TUDO** o que o usuário digitar é retornado como uma `string`.

Veja um uso básico

```python
msg = input("Mensagem para o usuário: ")
```

O que acontece é o seguinte :
1. O Python exibe a "Mensagem para o usuário: ";
1. O usuário digita uma resposta e pressiona Enter;
1. A resposta do usuário é armazenada na variável `msg`;

Veja alguns exemplos de uso :

```python
# recebendo o nome do usuário
nome = input("Digite seu nome: ")
print("Olá, " + nome + "!")
```

No algoritmo anterior :
1. O programa pede que o usuário digite seu nome;
1. O usuário digita o nome e pressiona Enter;
1. O programa armazena o nome na variável `nome`;
1. O programa imprime uma mensagem de saudação usando o nome fornecido pelo usuário;

```python
# recebendo dois números
numero1 = input("Digite o primeiro número: ")
numero2 = input("Digite o segundo número: ")

# convertendo as entradas para inteiros
numero1 = int(numero1)
numero2 = int(numero2)

soma = numero1 + numero2
print("A soma dos números é :", soma)
```

No algoritmo acima :
1. O programa pede que o usuário digite dois números;
1. As entradas são inicialmente strings, então precisamos convertê-las para inteiros usando a função `int`;
1. Depois de converter, somamos os números e exibimos o resultado;

### dados recebidos

Por padrão, a função `input` ***SEMPRE*** retorna uma string. Se o valor esperado for um número, é necessário converter a string para o tipo de dado adequado (por exemplo, `int` ou `float`).

Aqui estão alguns exemplos :

```python
# recebendo um valor decimal
altura = input("Digite sua altura (em metros): ")
altura = float(altura)
print("Sua altura é :", altura, "metros")

# recebendo um valor inteiro
idade = int(input("Digite sua idade: "))
print("Sua idade é:", idade)
```

É necessário ter cuidado quando se está convertendo um tipo string para inteiro ou float. Pois se o conteúdo não puder ser convertido apropriadamente, irá levantar um erro. Por hora, não será visto como tratar isso.

## exercícios input

<details>
<summary>Lista de Exercícios</summary>

1. String
    1. Peça ao usuário para digitar seu nome e exiba uma saudação personalizada.
    1. Peça ao usuário para digitar uma palavra e exiba o primeiro e o último caractere.
    1. Peça ao usuário para digitar uma frase e exiba a quantidade de caracteres na frase.
    1. Peça ao usuário para digitar duas palavras e exiba-as concatenadas.
    1. Peça ao usuário para digitar uma frase e exiba a frase invertida.
1. String com if-elif-else
    1. Peça ao usuário para digitar uma palavra e verifique se a palavra contém a letra "a". Exiba uma mensagem apropriada.
    1. Peça ao usuário para digitar uma frase e verifique se a frase tem mais de 20 caracteres. Exiba uma mensagem apropriada.
    1. Peça ao usuário para digitar seu nome. Se o nome começar com a letra "A", exiba "Seu nome começa com A". Caso contrário, exiba "Seu nome não começa com A".
    1. Peça ao usuário para digitar uma palavra. Se a palavra for "Python", exiba "Linguagem de programação". Caso contrário, exiba "Palavra comum".
    1. Peça ao usuário para digitar uma frase. Se a frase terminar com um ponto (.), exiba "Frase completa". Caso contrário, exiba "Frase incompleta".
1. Int
    1. Peça ao usuário para digitar sua idade e exiba uma mensagem dizendo quantos anos ele terá em 10 anos.
    1. Peça ao usuário para digitar dois números inteiros e exiba a soma deles.
    1. Peça ao usuário para digitar um número inteiro e exiba o quadrado desse número.
    1. Peça ao usuário para digitar um número inteiro e exiba a metade desse número.
    1. Peça ao usuário para digitar dois números inteiros e exiba o produto deles.
1. Int com if-elif-else
    1. Peça ao usuário para digitar um número inteiro. Se o número for positivo, exiba "Positivo". Se for negativo, exiba "Negativo". Se for zero, exiba "Zero".
    1. Peça ao usuário para digitar dois números inteiros e exiba o maior deles.
    1. Peça ao usuário para digitar um número inteiro. Se o número for par, exiba "Par". Caso contrário, exiba "Ímpar".
    1. Peça ao usuário para digitar sua idade. Se a idade for maior ou igual a 18, exiba "Maior de idade". Caso contrário, exiba "Menor de idade".
    1. Peça ao usuário para digitar um número inteiro. Se o número for múltiplo de 3, exiba "Múltiplo de 3". Se for múltiplo de 5, exiba "Múltiplo de 5". Se for múltiplo de ambos, exiba "Múltiplo de 3 e 5".
1. Float
    1. Peça ao usuário para digitar um número decimal e exiba o dobro desse número.
    1. Peça ao usuário para digitar dois números decimais e exiba a média deles.
    1. Peça ao usuário para digitar um número decimal e exiba a raiz quadrada desse número.
    1. Peça ao usuário para digitar um número decimal e exiba o cubo desse número.
    1. Peça ao usuário para digitar dois números decimais e exiba a divisão do primeiro pelo segundo.
1. Float com if-elif-else
    1. Peça ao usuário para digitar um número decimal. Se o número for maior que 100, exiba "Maior que 100". Caso contrário, exiba "Menor ou igual a 100".
    1. Peça ao usuário para digitar dois números decimais e exiba o maior deles.
    1. Peça ao usuário para digitar um número decimal. Se o número for positivo, exiba "Positivo". Se for negativo, exiba "Negativo".
    1. Peça ao usuário para digitar um número decimal. Se o número for maior que 50 e menor que 100, exiba "Entre 50 e 100". Caso contrário, exiba "Fora do intervalo".
    1. Peça ao usuário para digitar um número decimal. Se o número for maior que 0,5, exiba "Maior que meio". Caso contrário, exiba "Menor ou igual a meio".
1. Bool
    1. Peça ao usuário para digitar "True" ou "False" e exiba o valor booleano correspondente.
    1. Peça ao usuário para digitar uma resposta "sim" ou "não" e exiba o valor booleano correspondente.
    1. Peça ao usuário para digitar se ele gosta de programação (sim ou não) e exiba a resposta como booleano.
    1. Peça ao usuário para digitar se ele é maior de idade (sim ou não) e exiba a resposta como booleano.
    1. Peça ao usuário para digitar se ele tem um pet (sim ou não) e exiba a resposta como booleano.
1. Bool com if-elif-else
    1. Peça ao usuário para digitar "True" ou "False". Se for "True", exiba "Verdadeiro". Se for "False", exiba "Falso".
    1. Peça ao usuário para digitar se ele está estudando (sim ou não). Se for "sim", exiba "Estudando". Caso contrário, exiba "Não estudando".
    1. Peça ao usuário para digitar se ele está trabalhando (sim ou não). Se for "sim", exiba "Trabalhando". Caso contrário, exiba "Não trabalhando".
    1. Peça ao usuário para digitar se ele gosta de esportes (sim ou não). Se for "sim", exiba "Gosta de esportes". Caso contrário, exiba "Não gosta de esportes".
    1. Peça ao usuário para digitar se ele usa óculos (sim ou não). Se for "sim", exiba "Usa óculos". Caso contrário, exiba "Não usa óculos".
1. Exercícios Mistos
    1. Peça ao usuário para digitar seu nome e idade. Exiba uma mensagem dizendo quantos anos ele terá em 5 anos.
    1. Peça ao usuário para digitar dois números inteiros e um número decimal. Exiba a soma dos três números.
    1. Peça ao usuário para digitar uma frase e um número inteiro. Exiba a frase repetida o número de vezes digitado.
    1. Peça ao usuário para digitar uma palavra e um número decimal. Exiba a palavra concatenada com o número decimal convertido para string.
    1. Peça ao usuário para digitar uma frase e um valor booleano (sim ou não). Exiba a frase concatenada com a string "Verdadeiro" ou "Falso", dependendo do valor booleano.
1. Exercícios Mistos com if-elif-else
    1. Peça ao usuário para digitar um número inteiro e um número decimal. Se a soma for maior que 100, exiba "Soma maior que 100". Caso contrário, exiba "Soma menor ou igual a 100".
    1. Peça ao usuário para digitar seu nome e idade. Se a idade for maior ou igual a 18, exiba "Maior de idade". Caso contrário, exiba "Menor de idade".
    1. Peça ao usuário para digitar uma palavra e um valor booleano (sim ou não). Se o valor booleano for "sim", exiba a palavra em maiúsculas. Caso contrário, exiba a palavra em minúsculas.
    1. Peça ao usuário para digitar dois números decimais. Se o primeiro for maior que o segundo, exiba "Primeiro maior". Caso contrário, exiba "Segundo maior ou igual".
    1. Peça ao usuário para digitar uma frase e um número inteiro. Se o número for positivo, exiba a frase com a quantidade de caracteres igual ao número. Se for negativo, exiba a frase invertida.

</details>

Índice Instalando o Python

1. [o que é o python](#o-que-é-o-python)
1. [como instalar](#como-instalar)

# instalando o python

## o que é o python

Python é uma linguagem de programação de alto nível, interpretada e de propósito geral, conhecida por sua simplicidade e legibilidade. Criada pelo matemático holandês Guido van Rossum e lançada pela primeira vez em 1991, Python foi projetada para enfatizar a facilidade de leitura do código, utilizando uma sintaxe que permite aos programadores expressar conceitos de maneira clara e concisa.

Algumas características principais de Python incluem:

1. **Sintaxe Clara e Intuitiva**: A sintaxe de Python é semelhante ao inglês, o que torna o código mais legível e mais fácil de entender e escrever;
2. **Multiplataforma**: Python é compatível com a maioria dos sistemas operacionais, incluindo Windows, macOS e Linux;
3. **Bibliotecas e Frameworks Ricos**: Python possui uma vasta coleção de bibliotecas e frameworks, como NumPy, Pandas, Matplotlib, Django e Flask, que facilitam o desenvolvimento em diversas áreas, como ciência de dados, aprendizado de máquina, desenvolvimento web, automação e muito mais;
4. **Interpretada**: Python é uma linguagem interpretada, o que significa que o código é executado linha por linha, facilitando a depuração e tornando o desenvolvimento mais ágil;
5. **Paradigmas de Programação**: Suporta múltiplos paradigmas de programação, incluindo programação procedural, orientada a objetos e funcional;

Devido a essas características, Python é amplamente utilizada tanto por iniciantes quanto por desenvolvedores experientes e em várias áreas de desenvolvimento, desde scripts simples até aplicações complexas de inteligência artificial e análise de dados.

## como instalar

Há diversar formas de instalar o Python. Para cada sistema operacional há uma ou mais formas específicas:

- Windows : https://python.org.br/instalacao-windows/
- Linux : https://python.org.br/instalacao-linux/
- macOS : https://python.org.br/instalacao-mac/

### windows
O Python pode ser baixado do seu site em [www.python.org](https://www.python.org/downloads/), no botão em destaque. O nome do arquivo será algo como `python-3.xx-amd64.exe`, sendo o `x` substituído pela versão atual do programa. Quando ele for executado, ele poderá ser instalado de duas formas, com e sem direitos de administrador. Se for instalado com direitos de administrador, então o Python ficará disponível para todos os usuários da máquina. Se for instalado para o usuário local, então apenas ele terá o programa instalado.

Uma vez executado, é apresentada a tela de `Install Python 3.xx (64-bit)`. Nela há duas opções apresentadas:
- **Install Now** (instalar agora) : essa opção irá pedir a senha do administrador;
- **Customize installation** (customizar a instalação) : essa opção permite escolher instalar para o usuário local ou instalar para todos os usuários;

As opções abaixo podem ser deixadas inalteradas.
- [x] Use admin privileges when installing py.exe;
- [ ] Add python.exe to PATH;

Após selecionar a opção **Customize installation**, será mostrada a tela de `Optional Features` (Funções Opcionais).

- [x] Documentation
- [x] pip
- [x] tcl/tk and IDLE
- [x] Python test suite
- [x] py launcher
- [ ] for all users (requires admin privileges)

Marque as opções assim como consta acima. A **Documentation**, como o nome indica, vai instalar a documentação do Python, que também pode ser encontrada em [Python Docs](https://docs.python.org/3/). O **pip** é o gerenciador de pacotes do Python (Package Installer for Python). O **tcl/tk** é uma biblioteca usada para gerar aplicações gráficas e o IDLE é o ambiente integrado de desenvolvimento padrão que vem com o instalador do Python (integrated development environment for Python). O **py launcher** é um atalho para todas as versões do Python instaladas no sistema. O **for all users** é usado quando se quer que o Python seja instalado para todos os usuários da máquina, isto é, ele será instalado no *AppData* de cada usuário existente na máquina.

A próxima tema é a de `Advanced Options` (Opções Avançadas).

- [ ] Install Python 3.xx for all users
- [x] Associate files with Python
- [x] Create shortcuts for installed applications
- [x] Add Python to environment variables
- [x] Precompile standard library
- [x] Download debugging symbols
- [x] Download debug binaries

Se a opção **Install Python for all users** for marcada, ele será instalado na pasta Arquivo de Programas do Windows e dessa forma estará disponível para todos os usuários. Com exceção da primeira opção, todas as demais podem ser marcadas. No campo abaixo irá mostrar o caminho onde o Python será instalado.

Uma vez que a instalação for finalizada, é possível verficar se está instalado abrindo o *Prompt de Comando* e digitando `python --version`. Se a versão for mostrada, então tudo foi instalado corretamente.
```cmd
C:\> python --version
Python 3.xx

C:\> |
```

#### variáveis de ambiente
Adicionar um programa às variáveis de ambiente do Windows envolve a atualização da variável de ambiente `PATH` para incluir o diretório do programa.

Veja os passos :

1. Abrir as Propriedades do Sistema :
    - Pressione `Win + R`, digite `sysdm.cpl` e pressione `Enter`.
1. Acessar as Variáveis de Ambiente :
    - Na janela "Propriedades do Sistema", vá para a guia `Avançado` e clique em `Variáveis de Ambiente...`.
1. Editar a Variável PATH :
    - Na seção "Variáveis do sistema", encontre a variável `Path` e selecione-a.
    - Clique em `Editar...`.
1. Adicionar o Caminho do Programa :
    - Na janela "Editar Variável de Ambiente", clique em `Novo` e adicione o caminho completo do diretório do programa que deseja adicionar.
    - Por exemplo, se for adicionar o Python instalado para o usuário, vai estar em
        - `C:\Users\<seu_usuário>\AppData\Programs\Python\Python312`
    - Uma vez localizado, adicione esse caminho.
1. Salvar as Alterações :
    - Clique em `OK` para fechar todas as janelas abertas.

#### verificando
Para garantir que o programa foi adicionado ao `PATH`, abra o `Prompt de Comando` (CMD) e digite o comando relacionado ao programa para verificar se ele é reconhecido pelo sistema. Por exemplo, como foi adicionado o Python, digite `python --version` para verificar se o comando é executado corretamente.

Isso deve permitir que o programa seja executado a partir de qualquer diretório no Prompt de Comando.

### linux

Se você é usuário de Linux, provavelmente você já sabe instalar o Python ;)

<details>
  <summary>Lista de Exercícios</summary>

1. Instale o Python 3.6:
    1. Baixe e instale o Python 3.6 na sua máquina.
    1. Verifique a instalação rodando `python --version`.
1. Instale o Python 3.7:
    1. Baixe e instale o Python 3.7 na sua máquina.
    1. Verifique a instalação rodando `python --version`.
1. Remova o Python 3.6:
    1. Desinstale o Python 3.6 do seu sistema.
    1. Verifique a remoção rodando `python --version` e confirmando que a versão não está mais disponível.
1. Instale o Python 3.8:
    1. Baixe e instale o Python 3.8 na sua máquina.
    1. Verifique a instalação rodando `python --version`.
1. Remova o Python 3.7:
    1. Desinstale o Python 3.7 do seu sistema.
    1. Verifique a remoção rodando `python --version` e confirmando que a versão não está mais disponível.
1. Instale o Python 3.9:
    1. Baixe e instale o Python 3.9 na sua máquina.
    1. Verifique a instalação rodando `python --version`.
1. Remova o Python 3.8:
    1. Desinstale o Python 3.8 do seu sistema.
    1. Verifique a remoção rodando `python --version` e confirmando que a versão não está mais disponível.
1. Instale o Python 3.10:
    1. Baixe e instale o Python 3.10 na sua máquina.
    1. Verifique a instalação rodando `python --version`.
1. Instale o Python 3.11:
    1. Baixe e instale o Python 3.11 na sua máquina.
    1. Verifique a instalação rodando `python --version`.
1. Remova o Python 3.9:
    1. Desinstale o Python 3.9 do seu sistema.
    1. Verifique a remoção rodando `python --version` e confirmando que a versão não está mais disponível.
1. Instale o Python 3.6 e o Python 3.10 simultaneamente:
    1. Baixe e instale o Python 3.6 e o Python 3.10 na sua máquina.
    1. Verifique a instalação rodando `python --version`;
    1. Troque a ordem de precedência para o Python 3.6 no PATH.
    1. Verifique a instalação rodando `python --version`;
1. Remova o Python 3.6:
    1. Desinstale o Python 3.6 do seu sistema.
    1. Verifique a remoção rodando `python --version` e confirmando que a versão não está mais disponível.
1. Instale o Python 3.7 e o Python 3.11 simultaneamente:
    1. Baixe e instale o Python 3.7 e o Python 3.11 na sua máquina.
    1. Verifique a instalação rodando `python --version`.
    1. Troque a ordem de precedência para o Python 3.7 no PATH.
    1. Verifique a instalação rodando `python --version`;
1. Remova o Python 3.10:
    1. Desinstale o Python 3.10 do seu sistema.
    1. Verifique a remoção rodando `python --version` e confirmando que a versão não está mais disponível.
1. Instale o Python 3.8 e o Python 3.7 simultaneamente:
    1. Baixe e instale o Python 3.8 e o Python 3.7 na sua máquina.
    1. Verifique a instalação rodando `python --version`.
    1. Troque a ordem de precedência para o Python 3.8 no PATH.
    1. Verifique a instalação rodando `python --version`.
1. Remova o Python 3.11:
    1. Desinstale o Python 3.11 do seu sistema.
    1. Verifique a remoção rodando `python --version` e confirmando que a versão não está mais disponível.
1. Instale o Python 3.9 e o Python 3.8 simultaneamente:
    1. Baixe e instale o Python 3.9 e o Python 3.8 na sua máquina.
    1. Verifique a instalação rodando `python --version`;
    1. Troque a ordem de precedência para o Python 3.9 no PATH.
    1. Verifique a instalação rodando `python --version`.
1. Remova o Python 3.7:
    1. Desinstale o Python 3.7 do seu sistema.
    1. Verifique a remoção rodando `python --version` e confirmando que a versão não está mais disponível.
1. Remova o Python 3.8:
    1. Desinstale o Python 3.8 do seu sistema.
    1. Verifique a remoção rodando `python --version` e confirmando que a versão não está mais disponível.
1. Instale a última versão do Python (atual):
    1. Baixe e instale a última versão do Python 3 disponível.
    1. Verifique a instalação rodando `python --version`.
    1. Confirme que é a única versão instalada no sistema.

</details>
Índice Instalando o VS Code

1. [baixando o vs code](#baixando-o-vs-code)
1. [instalar o vs code](#instalar-o-vs-code)
1. [extensão do vs code](#extensão-do-vs-code)

# como baixar e instalar o vs code

A seguir há um passo a passo de como baixar e instalar o VS Code.

## baixando o vs code

1. **Abrir o Navegador de Internet:**
    - Clique no ícone do navegador de internet (por exemplo, Google Chrome, Firefox, Edge) na barra de tarefas ou na área de trabalho.

2. **Acessar o Site de Download:**
    - Na barra de endereços do navegador, digite [https://code.visualstudio.com/download](https://code.visualstudio.com/download) e pressione Enter.

3. **Selecionar a Versão para Download:**
    - Na página serão apresentadas 3 versões para o download.
    - Selecione a versão apropriada para o seu sistema operacional (Windows, macOS ou Linux).
        - Para as aulas, selecione a versão **User Installer** do Windows.
        - Em sua casa, escolha a versão principal.

## instalar o vs code

### windows

A versão **User Installer** é usada para realizar uma instalação onde o usuário não possui as permissões de administrador na máquina. Ela terá um nome como `VSCodeUserSetup-x64-1.xx.exe`, onde `xx` representa a versão baixada.

1. **Executar o Instalador:**
    - Após o download, localize o arquivo baixado (geralmente na pasta "Downloads").
    - Clique duas vezes no arquivo `VSCodeSetup.exe` para iniciar o instalador.
1. **Iniciar a Instalação:**
    - Clique em "Sim" se o Windows solicitar permissão para fazer alterações no dispositivo.
    - Na tela de boas-vindas do instalador do VS Code, clique em "Next" (Avançar).
1. **Aceitar o Contrato de Licença:**
    - Marque a caixa "I accept the agreement" (Eu aceito o contrato) e clique em "Next" (Avançar).
1. **Escolher a Pasta de Instalação:**
    - Deixe a pasta de instalação padrão ou selecione outra pasta de sua escolha e clique em "Next" (Avançar).
1. **Criar Atalho no Menu Iniciar**
    - Deixe a opção padrão e clique em "Next" (Avançar).
1. **Selecionar Componentes Adicionais:**
    - Marque todas as opções faltantes, criar ícone na área de trabalho e adicionar o Code ao menu do Explorer.
    - Clique em "Next" (Avançar).
1. **Revisar e Instalar:**
    - Revise as opções de instalação de modo que fique parecido com o modelo abaixo :
    ```
    Local de destino:
        C:\Users\<seu_usuario>\AppData\Local\Programs\Microsoft VS Code

    Pasta do Menu Iniciar:
        Visual Studio Code

    Tarefas adicionais:
        Atalhos adicionais:
            Criar um atalho na área de trabalho
        Outros:
            Adicione a ação "Abrir com Code" ao menu de contexto de arquivo do Windows Explorer
            Adicione a ação "Abrir com Code" ao menu de contexto de diretório do Windows Explorer
            Registre Code como um editor para tipos de arquivos suportados
            Adicione em PATH (disponível após reiniciar)
    ```
   - Clique em "Install" (Instalar). Aguarde a instalação ser concluída.
1. **Finalizar a Instalação:**
   - Marque a opção "Launch Visual Studio Code" (Lançar Visual Studio Code) e clique em "Finish" (Concluir).

### macos

1. **Abrir o Arquivo de Download:**
   - Após o download, localize o arquivo baixado (geralmente na pasta "Downloads").
   - Clique duas vezes no arquivo `.dmg`.
2. **Mover o VS Code para a Pasta Aplicativos:**
   - Arraste o ícone do Visual Studio Code para a pasta "Applications" (Aplicativos).
3. **Abrir o VS Code:**
   - Vá até a pasta "Applications" (Aplicativos) e clique duas vezes no ícone do Visual Studio Code para abrir o aplicativo.

### linux

1. **Dependendo da Distribuição, Utilize o Método Apropriado:**

    **Ubuntu/Debian:**
    - Abra o terminal.
    - Digite o comando:
    ```
    sudo apt update
    sudo apt install code
    ```
    - Pressione Enter e siga as instruções para instalar.<br><br>

    **Fedora/RHEL:**
    - Abra o terminal.
    - Digite o comando:
    ```
    sudo rpm --import https://packages.microsoft.com/keys/microsoft.asc
    sudo sh -c 'echo -e "[code]\nname=Visual Studio Code\nbaseurl=https://packages.microsoft.com/yumrepos/vscode\nenabled=1\ngpgcheck=1\ngpgkey=https://packages.microsoft.com/keys/microsoft.asc" > /etc/yum.repos.d/vscode.repo'
    sudo dnf check-update
    sudo dnf install code
    ```
    - Pressione Enter e siga as instruções para instalar.<br><br>

2. **Abrir o VS Code:**
   - Após a instalação, abra o Visual Studio Code pelo menu de aplicativos ou digitando `code` no terminal.

### dicas finais

- **Tradução para Português:**
  - Abra o VS Code.
  - Vá até "View" (Exibir) > "Command Palette" (Paleta de Comandos).
  - Digite `Configure Display Language` e selecione `Portuguese (Brazil)`.

----

## extensão do vs code

O VS Code, por si só, é uma ferramente muito poderosa, mas ele pode melhorar.

O programa tem uma funcionalidade chamada de extensões, onde é possível adicionar extensões ao programa de modo que ele funcione melhor para determinados trabalhos.

Há uma extensão perfeita para trabalhar com Python no VS Code. Para instalá-la, siga os passos abaixo.

### instalando a extensão

1. **Abrir o VS Code:**
   - Clique no ícone do Visual Studio Code na área de trabalho ou na lista de aplicativos.
1. **Abrir o Gerenciador de Extensões:**
   - No lado esquerdo da janela do VS Code, clique no ícone de quadrados empilhados (Extensões). Alternativamente, você pode usar o atalho de teclado `Ctrl+Shift+X` no Windows/Linux ou `Cmd+Shift+X` no macOS.
1. **Procurar por "Python":**
   - Na barra de pesquisa do gerenciador de extensões, digite `Python`.
   - A extensão oficial do Python, desenvolvida pela Microsoft, deve aparecer como o primeiro resultado. Ela é identificada com o nome "Python" e o ícone de uma cobra amarela.
1. **Instalar a Extensão:**
   - Clique no botão "Install" (Instalar) ao lado da extensão "Python". A instalação pode levar alguns momentos.
1. **Selecionar o Interpretador Python:**
   - Após a instalação, o VS Code pode solicitar que você selecione um interpretador Python.
   - Se a solicitação aparecer, clique em "Select Python Interpreter" (Selecionar Interpretador Python).
   - Escolha o interpretador Python instalado no seu sistema. Se você tiver mais de uma versão do Python instalada, selecione a versão que deseja usar.

### verificando a instalação

1. **Criar um Novo Arquivo Python:**
   - Clique em "File" (Arquivo) > "New File" (Novo Arquivo).
   - Salve o arquivo com a extensão `.py` (por exemplo, `teste.py`).
2. **Escrever um Código Simples:**
   - Digite o seguinte código no arquivo:
     ```python
     print("Olá, mundo!")
     ```
   - Salve o arquivo.
3. **Executar o Código:**
   - Clique com o botão direito no arquivo e selecione "Run Python File in Terminal" (Executar Arquivo Python no Terminal).
   - O terminal deve abrir na parte inferior do VS Code e exibir a saída `Olá, mundo!`.

Agora, você está pronto para começar a programar em Python no VS Code com a extensão instalada.
Índice Introdução à Lógica de Programação

1. [o que é lógica](#o-que-é-lógica)
1. [lógica no dia a dia](#lógica-no-dia-a-dia)
1. [e a lógica de programação](#e-a-lógica-de-programação)
1. [o que é um algoritmo](#o-que-é-um-algoritmo)
1. [algoritmizando a lógica](#algoritmizando-a-lógica)
1. [resumo](#resumo)
1. [atividades](#atividades)

# introdução à lógica de programação

## o que é lógica

O uso corriqueiro da palavra lógica está normalmente relacionado à coerência e à racionalidade. Frequentemente se associa lógica apenas à matemática, não se percebendo sua aplicabilidade e sua relação com as demais ciências, bem como seu emprego cotidiano nas ações do dia a dia, quando alguma decisão é tomada de forma racional.

A lógica pode ser relacionada com a *correção do pensamento*, pois uma de suas preocupações é determinar quais operações são válidas e quais não são. Como filosifia, ela procura saber porque pensamos assim e não de outro jeito. Com arte ou técnica, ela nos ensina a usar corretamente as leis do pensamento.

Pode-se dizer que a lógica é a *arte de bem pensar*, que é a *ciência das formas do pensamento*. Como a forma mais complexa de pensamento é o raciocínio, a lógica estuda a *correção do raciocínio*. Pode-se dizer ainda que a lógica tem em vista a *ordem da razão*. Isso dá a entender que a nossa razão pode funcionar desordenadamente. Por isso, a lógica estuda e ensina a colocar `ordem no pensamento`.

Exemplos :
- Todo mamífero é um animal. Todo cavalo é um mamífero. Portanto, todo cavalo é um animal;
- Kaiton é um país do planeta Stix. Todos os Xinpins são de Kaiton. Logo, todos os Xinpins são Stixianos;

Esses exemplos ilustram silogismos, que no estudo da Lógica Proposicional representam um argumento composto de duas premissas e uma conclusão; e está estabelecendo uma relação, que pode ser válida ou não. Esse é um dos objetivos da lógica, o estudo de técnicas de formalização, dedução e análise que permitam verificar a validade de argumentos. No caso dos exemplos, ambos são válidos.

Vale a pena ressaltar que, apesar da aparente coerência de um encadeamento lógico, ele pode ser válido ou nãp em sua estrutura. Nesse sentido, a lógica também objetiva a criação de uma representação mais formal, contrapondo-se à linguagem natural, que é suscetível a argumentações informais e problemas de interpretação.

Exemplos :
- Todo escorpião é um invertebrado. Algumas pessoas são de escorpião. Logo, algumas pessoas são invertebradas;

## lógica no dia a dia

Sempre que há um pensamento, a lógica ou a ilógica necessariamente acompanha. Quando se escreve ou fala, um pensamento está sendo expressado, logo é necessário usar lógica nessas atividades. Pode-se perceber a importância da lógica na vida, não só na teoria, como na prática. Quando se quer falar, pensar ou agir corretamente, é preciso colocar *ordem no pensamento*, isto é, usar a lógica.

Exemplos :
- A gaveta está fechada. A caneta está dentro da gaveta. É preciso primeiro abrir a gaveta para depois pegar a caneta;
- Anastácia é mais velha que Gioconda. Gioconda é mais velha que Lucineide. Portanto, Anastácia é mais velha que Lucineide;

## e a lógica de programação

Significa o uso correto s leis do pensamento, da *ordem da razão* e de processos de raciocínio e simbolização formais na programação de computadores, objetivando a racionalidade e o desenvolvimento de técnicas que cooperem para a produção de soluções logicamente válidas e coerentes, que resolvam os problemas que se deseja programar.

O raciocínio é algo abstrato. Os seres humanos têm a capacidade de expressá-lo através da palavra falada ou escrita, que por vez, se baseia em um determinado idioma, que segue uma série de padrões. Um mesmo racioncínio pode ser expresso em qualquer um dos idiomas existentes, mas continuará representando o mesmo raciocínio, usando apenas outra convenção.

Algo similar acontece com a Lógica de Programação, que pode ser criada pela mente treinada e pode ser representada em qualquer uma das inúmeras linguagens de programação existentes. Essas, por sua vez, são atreladas a uma grande diversidade de detalhes computacionais, que pouco têm a ver com o raciocínio original. Para escapar desse problema e, ao mesmo tempo, representar mais fielmente o racioncínio da Lógica de Programação, é utilizado os Algoritmos.

## o que é um algoritmo

Um algoritmo pode ser definido como uma sequência finita de passos que visam atingir um objetivo bem definido.

Na medida em que é preciso especificar uma sequência de passos, é necessário *pensar com ordem*, portanto precisa-se utilizar a lógica.

Apesar do nome pouco usual, algoritmos são comuns no cotidiano. Uma receita de bolo, por exemplo. Nela está descrita uma série de ingredientes necessários e uma sequência de passos (ações) que devem ser seguidos para que se consiga fazer o bolo pretendido.

Quando se faz um algoritmo, é ncessário especificar as ações clara e precisamente. A partir de um estado iniciale após um preríodo de tempo finito, será produzido um estado final previsível e bem definido. O algoritmo fixa um padrão de comportamento a ser seguido.

## algoritmizando a lógica

Uma importância da construção dos Algoritmos é que uma vez concebida uma solução algorítmica para um problema, esta pode ser traduzida para qualquer linguagem de programação.

### a lâmpada

Um primeiro algoritmo pode ser escrito utlizando o portuquês coloquial. Ele vai descrever o comportamento na resolução de uma determinada atividade, como trocar uma lâmpada. Mesmo sendo uma atividade óbvia, ela é realizada de maneira inconscientemente, sem se atentar aos detalhes, que são as ações que levam a alcançar o objetivo.

Vamos ao algoritmo.

Algoritmo Troca de Lâmpada v1.0 :
- pegar uma escada;
- colocar a escada embaixo da lâmpada;
- buscar uma lâmpada reserva;
- subir na escada;
- retirar a lâmpada velha;
- colocar a lâmpada reserva;
- jogar fora a lâmpada velha;
- guardar a escada;

Esses são os passos gerais para trocar uma lâmpada. Seguimos esses passos involuntariamente e pode ser usado por qualquer pessoa. Mas, e se a lâmpada não estivesse queimada? A execução dos passos levaria a uma troca, mesmo ela estando ou não queimada, já que essa possibilidade não foi prevista nos passos.

Então, para corrigir isso, será feito um teste para verificar se a lâmpada está ou não queimada. Veja como fica o novo algoritmo.

Algoritmo Troca de Lâmpada v1.1 :
- pegar uma escada;
- colocar a escada embaixo da lâmpada;
- buscar uma lâmpada reserva;
- ligar o interruptor;
- se a lâmpada não ligar, então :
    - subir na escada;
    - retirar a lâmpada velha;
    - colocar a lâmpada reserva;
    - jogar fora a lâmpada velha;
- guardar a escada;

Agora há ações relacionadas à condição da `lâmpada não ligar`, ou seja, se essa condição for verdadeira (a lâmpada estiver queimada) será feita a troca dela seguindo as ações :
- subir na escada;
- retirar a lâmpada velha;
- colocar a lâmpada reserva;
- jogar fora a lâmpada velha;

Se a condição `lâmpada não ligar` for falsa (se a lâmpada estiver funcionando), as ações relativas à troca dela não serão executadas e não será trocada.

Note, também, que a condição de *guardar da escada* só irá acontecer com ou sem a troca da lâmpada. Mas isso também tem um problema, o algoritmo não prevê guardar a lâmpada nova, caso a velha ainda funcione.

O que aconteceu em v1.1 foi a inclusão de um teste seletivo, usando uma condição que determina qual ou quais ações serão executadas se a condição resultar em verdadeiro. Diferente da v1.0, onde tudo era executado.

Apesar do algoritmo funcionar corretamente, ele pode ser melhorado. Qual é o objetivo de pegar a escada e uma nova lâmpada *antes* de verificar se a lâmpada em questão está queimada? Podemos executar as ações de pegar uma escada e lâmpada apenas se a lâmpada não ligar.

Algoritmo Troca de Lâmpada v1.2
- ligar o interruptor;
- se a lâmpada não ligar, então :
    - pegar uma escada;
    - colocar a escada embaixo da lâmpada;
    - buscar uma lâmpada reserva;
    - subir na escada;
    - retirar a lâmpada velha;
    - colocar a lâmpada reserva;
    - jogar fora a lâmpada velha;
    - guardar a escada;

Observer que, agora, a opção de `ligar o interruptor` é a primeira ação do algoritmo. Em seguida, a condição `lâmpada não ligar` já é testada. Agora, as opções de pegar uma lâmpada e a escada dependem da lâmpada estar queimada.

### repetição

Embora a solução de v1.2 seja adequada, ela não considera que a nova lâmpada também esteja queimada e, portanto, não atingir o objetivo do algoritmo. É possível fazer uma melhoria no algoritmo para que se troque a lâmpada diversas vezes, se necessário, até que funcione.

Algoritmo Troca de Lâmpada v1.3
- ligar o interruptor;
- se a lâmpada não ligar, então :
    - pegar uma escada;
    - colocar a escada embaixo da lâmpada;
    - buscar uma lâmpada reserva;
    - subir na escada;
    - retirar a lâmpada velha;
    - colocar a lâmpada reserva;
    - jogar fora a lâmpada velha;
    - se a lâmpada não ligar, então :
        - retirar a lâmpada velha;
        - colocar a lâmpada reserva;
        - jogar fora a lâmpada velha;
        - se a lâmpada não ligar, então :
            - retirar a lâmpada velha;
            - colocar a lâmpada reserva;
            - jogar fora a lâmpada velha;
            - se a lâmpada não ligar, então :
                - retirar a lâmpada velha;
                - colocar a lâmpada reserva;
                - .
                - .
                - ao infinito e além!
    - guardar a escada;

Pode-se ver que o algoritmo não tem fim. Não há como especificar até quando será feito o teste da lâmpada, quando termina. As ações são executadas até a lâmpada ligar, caso contrário ela será testada até o fim dos tempos. Embora essa solução eventualmente atinja o objetivo (colocar uma lâmpada que funcione), há o problema do número exato de testes da lâmpada.

Veja que o teste da lâmpada reserva é efetuado pelo mesmo conjunto de ações :
- se a lâmpada não ligar, então :
    - retirar a lâmpada velha;
    - colocar a lâmpada reserva;

Também, veja que a condição `guardar a escada` só acontecerá após todos os testes das lâmpada funcionar corretamente.

A condição da `lâmpada não ligar` permaneceu e é estabelecido um fluxo repetitivo que só é finalizado quando a condição de parada for falsa (a lâmpada não ligar). Pode-se ver que o número de repetições é *indefinido*, mas é *finito* e que depende apenas da condição estabelecida. Dessa forma, ocorre uma repetição de ações até alcançar o objetivo: trocar a lâmpada queimada por uma que funcione.d

Veja como fica o novo algoritmo :

Algoritmo Troca de Lâmpada v1.4
- ligar o interruptor;
- se a lâmpada não ligar, então :
    - pegar uma escada;
    - colocar a escada embaixo da lâmpada;
    - buscar uma lâmpada reserva;
    - subir na escada;
    - retirar a lâmpada velha;
    - colocar a lâmpada reserva;
    - jogar fora a lâmpada velha;
    - enquanto a lâmpada não ligar, faça :
        - retirar a lâmpada velha;
        - colocar a lâmpada reserva;
        - jogar fora a lâmpada velha;
    - guardar a escada;

Na versão v1.4, é feito um teste de troca de lâmpada e que, enquanto a condição não for verdadeira, ele será repetido indefinidamente.

Até o momento, está sendo testado apenas um ponto de luz, um soquete. E se fosse necessário trocar 10 pontos de luz?

Algoritmo Troca de Lâmpada v1.5
- ligar o `primeiro` interruptor;
- se a lâmpada não ligar, então :
    - pegar uma escada;
    - colocar a escada embaixo da lâmpada;
    - buscar uma lâmpada reserva;
    - subir na escada;
    - retirar a lâmpada velha;
    - colocar a lâmpada reserva;
    - jogar fora a lâmpada velha;
    - enquanto a lâmpada não ligar, faça :
        - retirar a lâmpada velha;
        - colocar a lâmpada reserva;
        - jogar fora a lâmpada velha;
    - guardar a escada;
- ligar o `segundo` interruptor;
- se a lâmpada não ligar, então :
    - pegar uma escada;
    - colocar a escada embaixo da lâmpada;
    - .
    - .
    - .
- ligar o `terceiro` interruptor;
- se a lâmpada não ligar, então :
    - .
    - .
    - .
- ligar o `quarto` interruptor;
    - .
    - .
    - .
- ligar o `quinto` interruptor;
- se a lâmpada não ligar, então :
    - .
    - .
    - .

Repare que o algoritmo v1.5 é apenas um conjunto de 10 repetições da versão v1.4. Como o conjunto de ações repetidas é igual, pode-se alterar o fluxo de sequencial de execução de modo a fazer com que ele voltasse a executar o conjunto de ações relativas a um único ponto de luz (v1.4) o tanto quanto for necessário.

Veja como ficará :

Algoritmo Troca de Lâmpada v1.6
- ir até o interruptor do `primeiro` soquete;
- enquanto a quantidade de soquetes testados for menor que dezesseis, faça :
    - ligar o interruptor;
    - se a lâmpada não ligar, então :
        - pegar uma escada;
        - colocar a escada embaixo da lâmpada;
        - buscar uma lâmpada reserva;
        - subir na escada;
        - retirar a lâmpada velha;
        - colocar a lâmpada reserva;
        - jogar fora a lâmpada velha;
        - enquanto a lâmpada não ligar, faça :
            - retirar a lâmpada velha;
            - colocar a lâmpada reserva;
            - jogar fora a lâmpada velha;
        - guardar a escada;

Quando a condição `quantidade de soquetes testados for menor que dez` for verdadeira, as ações responsáveis pela troca ou não de um único soquete são exexutadas. Caso a condição de parada seja falsa, ou seja, todos os 10 soquetes já tiverem sido testados, nada mais será executado.

## resumo

Todo o exemplo foi desenvolvido a partir do problema de descrever os passos necessários para efetuar a troca de uma lâmpada, ou seja, construir um *algoritmo* para esse fim. Inicialmente, havia um pequeno conjunto de ações que deveriam ser executadas, todas passo a passo, compondo uma ordem sequencial de execução.

Pode-se ver que nem todas as ações previstas deveriam ser executadas. Isso mostrou que um determinado conjunto de ações fosse evitado, selecionado conforme o resultado de uma determinada condição. Dessa forma, era necessário uma *estrutura condicional* através de um *teste condicional* que permitisse ou não que o fluxo de execução passasse por um deterinado conjunto de ações.

Depois, surgiu uma necessidade repetir diversos trechos de código do algoritmo. Para resolver isso, foi alterado o fluxo de execução para que ele passasse diversas vezes pelo mesmo trecho diversas vezes, enquanto a condição não fosse satisfeita. Resolução semelhante que foi usado quando foi necessário realizar a troca de dez pontos de luz. Para ambos os casos, foi usado uma *estrutrua de repetição*.

Vale a pena ressaltar que praticamente qualquer pessoa seria capaz de resolver o problema de trocar uma lâmpada, incluindo se adaptar a qualquer circunstância pitoresca que pudesse surgir. Mas um programa de computador tradicional não tem conhecimento prévio e nem tem a capacidade de raciocínio para encontrar soluções diante de uma situação imprevista. Isso implica que todos os detalhes devem ser determinados em todas as situações que ele deve executar, prevendo os obstáculos e a forma que superá-los, isto é, descrever uma sequência finitas de passos que garantam a solução do problema. Essa atividade é realizada pelos **programadores**.

## atividades

1. Três senhoras, dona Branca, dona Rosa e dona Violeta, passeavam pelo parque quando dona Rosa disse :
    - Não é curioso que estejamos usando vestidos de cores branca, rosa e violeta, embora nenhuma de nós esteja usando um vestido de cor igual ao seu próprio nome?
    - Uma simples coincidência, respondeu a senhora com o vestido violeta. Qual a cor do vestido de cada senhora?

    <details>
    <summary>Resposta</summary>

    Para resolver o problema, precisamos seguir as pistas fornecidas e usar um pouco de lógica dedutiva. Identificando as senhoras e suas cores de vestido. São 3 senhoras, a dona Branca, a dona Rosa e a dona Violeta. Identificando as cores dos vestidos disponíveis: branco, rosa e violeta. Entendendo as pistas, nenhuma das senhoras está usando um vestido da cor que corresponde ao seu nome, a dona Rosa não está usando um vestido rosa, a dona Branca não está usando um vestido branco e dona Violeta não está usando um vestido violeta. Deduções a partir da conversa, quando dona Rosa comenta sobre a coincidência, a senhora com o vestido violeta responde. Logo, a dona Rosa não pode estar usando o vestido rosa, a dona Branca não pode estar usando o vestido branco e a dona Violeta não pode estar usando o vestido violeta. Como a dona Branca é quem fez a primeira afirmação, as únicas que podem ter respondido eram a dona Violeta e a dona Rosa. Como a resposta veio da dona usando o vestido violeta, sabemos que a dona Violeta não pode ter respondido (nenhuma delas está usando o vestido da cor de seu nome). Logo, a resposta só pode ter vindo da dona Rosa usando o vestido violeta. Com isso, ainda falta descobrir quais vestidos a dona Branca e a dona Violeta estão usando entre os vestidos restantes, rosa e branco. Como a dona Branca não pode estar usando o vestido branco, então ela só pode usar o vestido rosa. Logo, a dona Violeta está usando o vestido branco, sendo a única combinação faltante.

    </details>

1. Um homem precisa atravessar um rio com um barco que possui capacidade para carregar apenas ele mesmo e mais uma de suas três cargas, que são : um lobo, um bode e um maço de alfafa. O que o homem deve fazer para conseguir atravessar o rio sem perder suas cargas? As regras são :
    - O bode não pode ficar sozinho com a alfafa;
    - O homem pode viajar sozinho;
    - O lobo não pode ficar sozinho com o bode;

    <details>
    <summary>Resposta</summary>

    Para resolver o problema de atravessar o rio com o lobo, o bode e a alfafa, sem deixar o bode sozinho com a alfafa ou o lobo sozinho com o bode, é preciso planejar cuidadosamente cada travessia. Vamos resolver isso passo a passo. Na primeira viagem, o homem leva o bode para o outro lado do rio e o deixa lá enquanto que o lobo e a alfafa ficam do lado inicial. Na segunda viagem o homem retorna sozinho ao lado inicial e o lobo e a alfafa ainda estão do lado inicial. Na terceira viagem o homem leva o lobo para o outro lado do rio e agora, o bode e o lobo estão juntos do outro lado, mas o homem não pode deixá-los juntos, então, o homem pega o bode e retorna com ele ao lado inicial. Na quarta viagem o homem deixa o bode no lado inicial e leva a alfafa para o outro lado do rio e agora, o lobo e a alfafa estão juntos do outro lado, e o bode está sozinho do lado inicial. Na quinta viagem o homem retorna sozinho ao lado inicial. Na sexta viagem o homem leva o bode para o outro lado do rio.

    </details>

1. Três jesuítas e três canibais precisam atravessar um rio. Para isso, eles têm um barco com capacidade para duas pessoas. Por medida de segurança, não se deve permitir que em alguma margem a quantidade de jesuítas seja inferior à de canibais. Qual a solução para efetuar a travessia com segurança?

    <details>
    <summary>Resposta</summary>

    Para resolver o problema dos três jesuítas e três canibais precisando atravessar o rio sem nunca permitir que os canibais sejam mais numerosos que os jesuítas em qualquer margem, precisamos planejar cuidadosamente cada travessia. Vamos representar os jesuítas como J e os canibais como C. Vamos usar o formato (J, C) para representar a quantidade de jesuítas e canibais em cada margem do rio. Inicialmente, todos estão na margem esquerda (3J, 3C) e (0J, 0C) na margem direita. Na primeira viagem vamos atravessar 2 canibais para a margem direita, ficando (3J, 1C) | (0J, 2C). Na segunda viagem vamos retornar 1 canibal para a margem esquerda, ficando (3J, 2C) | (0J, 1C). Na terceira viagem vamos atravessar 2 canibais para a margem direita novamente, ficando (3J, 0C) | (0J, 3C). Na quarta viagem vamos retornar 1 canibal para a margem esquerda, ficando (3J, 1C) | (0J, 2C). Na quinta viagem vamos atravessar 2 jesuítas para a margem direita, ficando (1J, 1C) | (2J, 2C). Na sexta viagem vamos retornar 1 jesuíta e 1 canibal para a margem esquerda, ficando (2J, 2C) | (1J, 1C). Na sétima viagem atravessam 2 jesuítas para a margem direita novamente, ficando (0J, 2C) | (3J, 1C). Na oitava viagem vamos retornar 1 canibal para a margem esquerda, ficando (0J, 3C) | (3J, 0C). Na nona viagem vamos atravessar 2 canibais para a margem direita, ficando (0J, 1C) | (3J, 2C). Na décima viagem retorna 1 canibal para a margem esquerda, ficando (0J, 2C) | (3J, 1C). Na décima primeira viagem atravessam 2 canibais para a margem direita, ficando (0J, 0C) | (3J, 3C).

    </details>

1. No torneio de atletismo, Carlos, José e Sérgio participaram das provas de 100 metros rasos, salto em distância e arremesso de dardo. Cada um deles conseguiu um primeiro lugar, um segundo e um terceiro. Descubra o que cada um conquistou, sabendo que :
    - José venceu Carlos no salto em distância;
    - Sérgio chegou atrás de José no arremesso de dardo;
    - Carlos não chegou em primeiro nos 100 metros rasos;

1. João tem três barris. No barril A, que está vazio, cabem 8 litros. No barril B cabem 5 litros. No varril C cabem 3 litros. O que deve fazer João para deixar os barris A e B com 4 litros cada e o C vazio?

    <details>
    <summary>Resposta</summary>

    Para resover esse problema, é necessário ficar atento ao portuguës também. O problema diz que o barril A está vazio, mas não diz o mesmo dos barris B e C, então pode-se implicar que estão cheios. Também, como não há outras medidas no barris, não há como dividir o conteúdo de qualquer barril parcialmente, como passar 1 litro do barril C para o barril A, por exemplo. Partindo desse princípio, temos que deixar os barris A e B com 4 litros cada. No começo, estamos com (A, 0L), (B, 5L) e (C, 3L). No primeiro passo, vamos transferir todo o conteúdo do barril C para o barril A, ficando (A, 3L), (B, 5L) e (C, 0L). No segundo passo, vamos passar o conteúdo do barril B para o C, ficando (A, 3L), (B, 2L) e (C, 3L). Agora, no terceiro passo, vamos passar o conteúdo do barril C para o barril A, ficando (A, 6L), (B, 2L) e (C, 0L). No quarto passo, vamos passar o conteúdo do barril B para o barril C, ficando (A, 6L), (B, 0L) e (C, 2L). No quinto passo, vamos passar o conteúdo do barril A para o barril B, ficando (A, 1L), (B, 5L) e (C, 2L). No sexto passo, vamos passar o conteúdo do barril B para o C, ficando (A, 1L), (B, 4L) e (C, 3L). Por fim, no sétimo passo, vamos colocar o líquido do barril C no A, ficando (A, 4L), (B, 4L) e (C, 0L).

    </details>
Índice Revisao - Parte 1

1. [tipos primitivos](#tipos-primitvos)
1. [variáveis](#variáveis)
1. [int](#int)
1. [float](#float)
1. [combinando int e float](#combinando-int-e-float)
1. [str](#str)
1. [bool](#bool)
1. [condicional if-elif-else](#condicional-if-elif-else)
1. [exercícios](#exercícios)

# revisão

## tipos primitivos

O Python possui 4 tipos primitivos básicos, são eles :
* **int** : representa os números inteiros negativos, zero e positivos;
* **float** : representa os números de ponto flutuante negativos, zero e positivos;
* **string** : representa tudo que é texto entre as simples e duplas;
* **boolean** : representa o verdadeiro e falso, das comparações;

## variáveis

Variáveis são usadas para armazenar valores dos tipos de Python. É uma boa prática usar nomes de variáveis que façam sentido com seu uso.

Por exemplo :
```python
# números inteiros (int)
idade = 25
anos_de_experiencia = 3
quantidade_de_alunos = 30
numero_de_livros = 10
pontuacao = 85
dias_no_ano = 365
numero_de_irmaos = 2
quantidade_de_copos = 6
anos_de_estudo = 15
numero_do_andar = 4

# números de ponto flutuante (float)
preco = 19.99
altura = 1.75
peso = 68.5
distancia = 12.34
nota_final = 8.7
temperatura = 22.0
salario = 3500.75
media_dos_alunos = 7.4
taxa_de_crescimento = 1.03
velocidade_media = 60.5

# strings (str)
nome = ´João´
cidade = "São Paulo"
pais = "Brasil"
curso = ´Engenharia´
profissao = "médico"
nome_da_empresa = "Oscorp"
modelo_do_carro = "Civic"
marca_do_celular = "Samsung"
cor_favorita = "azul"
time_do_coracao = "Grêmio"

# booleanos (bool)
esta_chovendo = True
tem_aula_hoje = False
janela_aberta = True
luz_acesa = False
internet_funcionando = True
tarefa_completa = False
estudando_python = True
ferias_chegando = False
fim_de_semana = True
trabalho_entregue = False

# constantes
NUMERO_MAXIMO_DE_TENTATIVAS = 5  # int
NOME_DO_PROJETO = "Desenvolvimento de Software"  # str
VELOCIDADE_DA_LUZ = 299792458  # int
NOME_DA_EMPRESA = "Senac Tech"  # str
PI = 3.14159  # float
NUMERO_JOGADORES_CAMPO = 11  # int
COR_DO_INTERNACIONAL = 'vermelho'  # str
HA_VIDA_TERRA = True  # bool
```

Repare que as variáveis acima não possuem qualquer acentuação nos seus nomes (diferente dos textos que possuem), as palavras diferentes são ligadas por um sublinhado e seus nomes fazem referência ao seu conteúdo, para facilitar a leitura e identificação no código.

As variáveis são reconhecidas por terem todas as letras minúsculas (caixa baixa) enquanto que as constantes são reconhecidas por terem seus nomes em letras maiúsculas (caixa alta).

As variáveis tem por característica terem seus valores **ALTERADOS** (podem ou não) durante a execução do programa, enquanto que as constantes tem por característica terem valores **NÃO ALTERÁVEIS** (que não deveriam) durante a execução do programa.

## precedência dos operadores

Há uma precedência fixa entre todos os operadores usados.

Veja a tabela abaixo :

| prioridade | operador símbolo | operador nome | tipo operador |
| :----: | :----: | :----: | :----: |
| 1 | `()` | parênteses | operadores aritméticos |
| 2 | `**` | potência | operadores aritméticos |
| 3 | `*`<br>`/`<br>`//`<br>`%` | multiplicaçao<br>divisão<br>divisão inteira<br>módulo | operadores aritméticos |
| 4 | `+`<br>`-` | soma<br>subtração | operadores aritméticos |
| 5 | `==`<br>`>`<br>`<`<br>`>=`<br>`<=`<br>`!=` | igual a<br>maior que<br>menor que<br>maior ou igual a<br>menor ou igual a<br>diferente de | operadores relacionais |
| 6 | `not` | negação | operadores lógicos |
| 7 | `and` | conjunção | operadores lógicos |
| 8 | `or` | disjunção | operadores lógicos |

## int

O tipo inteiro, com abreviação de `int`, são usados para representar os números negativos (-10, -42, -1), o zero (0) e lembrando que não é usado a representação de -0 e os números positivos (1, 30, 42).

Veja abaixo as operações realizadas com os números inteiros :

```python
# adição de dois inteiros:
a = 5
b = 3
resultado = a + b
print(resultado)  # saída : 8

# subtração de dois inteiros:
x = 10
y = 4
diferenca = x - y
print(diferenca)  # saída : 6

# multiplicação de dois inteiros:
largura = 7
altura = 5
area = largura * altura
print(area)  # saída : 35

# divisão de dois inteiros (divisão inteira):
total = 20
partes = 4
divisao = total // partes
print(divisao)  # saída : 5

# resto da divisão de dois inteiros (módulo):
numero = 17
divisor = 3
resto = numero % divisor
print(resto)  # saída : 2

# potenciação:
base = 2
expoente = 3
potencia = base ** expoente
print(potencia)  # saída : 8

# uso de parênteses para alterar a precedência:
resultado = (5 + 3) * 2
print(resultado)  # saída : 16

# comparação de igualdade:
idade_joao = 18
idade_maria = 18
mesma_idade = idade_joao == idade_maria
print(mesma_idade)  # saída : True

# comparação de diferença:
nota1 = 7
nota2 = 8
notas_diferentes = nota1 != nota2
print(notas_diferentes)  # saída : True

# comparação maior que:
saldo_banco = 1500
saldo_minimo = 1000
acima_do_minimo = saldo_banco > saldo_minimo
print(acima_do_minimo)  # saída : True

# comparação menor que:
velocidade_carro = 80
velocidade_limite = 90
abaixo_limite = velocidade_carro < velocidade_limite
print(abaixo_limite)  # saída : True

# comparação maior ou igual a:
temperatura = 30
temperatura_minima = 30
dentro_do_padrao = temperatura >= temperatura_minima
print(dentro_do_padrao)  # saída : True

# comparação menor ou igual a:
pessoas_na_fila = 10
capacidade_maxima = 15
pode_entrar = pessoas_na_fila <= capacidade_maxima
print(pode_entrar)  # saída : True

# uso de constante:
PI = 3.14
raio = 5
circunferencia = 2 * PI * raio
print(circunferencia)  # saída : 31.400000000000002

# soma com variável e constante:
INCREMENTO = 10
valor = 25
novo_valor = valor + INCREMENTO
print(novo_valor)  # saída : 35

# subtração com variável e constante:
DESCONTO = 5
preco_original = 50
preco_com_desconto = preco_original - DESCONTO
print(preco_com_desconto)  # saída : 45

# expressão complexa com várias operações:
resultado = (4 + 5) * 2 - (3 ** 2) // 2
print(resultado)  # saída : 11

# divisão com resultado decimal:
a = 10
b = 4
divisao_decimal = a / b
print(divisao_decimal)  # saída : 2.5

# uso de variável para armazenar resultado de uma expressão:
numero1 = 15
numero2 = 5
resultado_expressao = (numero1 * 2 + numero2) / 3
print(resultado_expressao)  # saída : 11.666666666666666
```

## float

O tipo ponto flutuante, com abreviação de `float`, são usados para representar os números negativos (-10.9, -42.0, -1.000001), o zero (0.0) e lembrando que não é usado a representação de -0.0 e os números positivos (1.00000000002, 30.123, 42.0).

Veja abaixo as operações realizadas com os números de ponto flutuante :

```python
# adição de dois floats:
a = 5.2
b = 3.1
resultado = a + b
print(resultado)  # saída : 8.3

# subtração de dois floats:
x = 10.5
y = 4.2
diferenca = x - y
print(diferenca)  # saída : 6.3

# multiplicação de dois floats:
largura = 7.5
altura = 5.2
area = largura * altura
print(area)  # saída : 39.0

# divisão de dois floats:
total = 20.0
partes = 4.0
divisao = total / partes
print(divisao)  # saída : 5.0

# resto da divisão de dois floats (módulo):
numero = 17.5
divisor = 3.2
resto = numero % divisor
print(resto)  # saída : 1.8999999999999986

# potenciação:
base = 2.0
expoente = 3.0
potencia = base ** expoente
print(potencia)  # saída : 8.0

# uso de parênteses para alterar a precedência:
resultado = (5.5 + 3.3) * 2.0
print(resultado)  # saída : 17.6

# comparação de igualdade:
preco_produto1 = 18.50
preco_produto2 = 18.50
mesmo_preco = preco_produto1 == preco_produto2
print(mesmo_preco)  # saída : True

# comparação de diferença:
nota1 = 7.5
nota2 = 8.0
notas_diferentes = nota1 != nota2
print(notas_diferentes)  # saída : True

# comparação maior que:
saldo_banco = 1500.75
saldo_minimo = 1000.00
acima_do_minimo = saldo_banco > saldo_minimo
print(acima_do_minimo)  # saída : True

# comparação menor que:
velocidade_carro = 80.5
velocidade_limite = 90.0
abaixo_limite = velocidade_carro < velocidade_limite
print(abaixo_limite)  # saída : True

# comparação maior ou igual a:
temperatura = 30.0
temperatura_minima = 30.0
dentro_do_padrao = temperatura >= temperatura_minima
print(dentro_do_padrao)  # saída : True

# comparação menor ou igual a:
pessoas_na_fila = 10.5
capacidade_maxima = 15.0
pode_entrar = pessoas_na_fila <= capacidade_maxima
print(pode_entrar)  # saída : True

# uso de constante:
PI = 3.14
raio = 5.0
circunferencia = 2 * PI * raio
print(circunferencia)  # saída : 31.400000000000002

# soma com variável e constante:
INCREMENTO = 10.0
valor = 25.5
novo_valor = valor + INCREMENTO
print(novo_valor)  # saída : 35.5

# subtração com variável e constante:
DESCONTO = 5.0
preco_original = 50.0
preco_com_desconto = preco_original - DESCONTO
print(preco_com_desconto)  # saída : 45.0

# expressão complexa com várias operações:
resultado = (4.5 + 5.2) * 2.0 - (3.0 ** 2) // 2.0
print(resultado)  # saída : 11.4

# divisão com resultado decimal:
a = 10.0
b = 4.0
divisao_decimal = a / b
print(divisao_decimal)  # saída : 2.5

# uso de variável para armazenar resultado de uma expressão:
numero1 = 15.5
numero2 = 5.2
resultado_expressao = (numero1 * 2.0 + numero2) / 3.0
print(resultado_expressao)  # saída : 12.066666666666668
```

## combinando int e float

Tanto o tipo inteiro `int` quanto o tipo ponto flutuante `float` são tipos numéricos, então eles podem ser usados juntos para as operações acima.

Veja exemplos :

```python
# adição de um inteiro e um float:
a = 5
b = 3.2
resultado = a + b
print(resultado)  # saída : 8.2

# subtração de um float por um inteiro:
x = 10.5
y = 4
diferenca = x - y
print(diferenca)  # saída : 6.5

# multiplicação de um inteiro por um float:
largura = 7
altura = 5.2
area = largura * altura
print(area)  # saída : 36.4

# divisão de um inteiro por um float:
total = 20
partes = 4.0
divisao = total / partes
print(divisao)  # saída : 5.0

# divisão de um float e um inteiro (divisão inteira):
total = 23.4
partes = 4
divisao = total // partes
print(divisao)  # saída : 5.0

# resto da divisão de um inteiro por um float (módulo):
numero = 17
divisor = 3.2
resto = numero % divisor
print(resto)  # saída : 1.3999999999999986

# potenciação com base float e expoente inteiro:
base = 2.5
expoente = 3
potencia = base ** expoente
print(potencia)  # saída : 15.625

# uso de parênteses para alterar a precedência com inteiro e float:
resultado = (5 + 3.3) * 2
print(resultado)  # saída : 16.6

# comparação de igualdade entre inteiro e float:
idade_joao = 18
idade_maria = 18.0
mesma_idade = idade_joao == idade_maria
print(mesma_idade)  # saída : True

# soma de uma constante inteira com uma variável float:
INCREMENTO = 10
valor = 25.5
novo_valor = valor + INCREMENTO
print(novo_valor)  # saída : 35.5

# expressão complexa com inteiros e floats:
resultado = (4 + 5.5) * 2 - (3 ** 2) // 2.0
print(resultado)  # saída : 10.0
```

## str

O tipo texto, chamado de String `str`, é o tipo usado para representar tudo que é texto e que está entre aspas simples `'...'`, aspas duplas `"..."` e aspas triplas `'''...'''` e `"""..."""`, essa última conhecida como strings literais.

A indexação de strings em Python é uma maneira de acessar caracteres individuais dentro de uma string.

A indexação de strings começa do 0. Isso significa que o primeiro caractere da string está no índice 0, o segundo caractere está no índice 1, e assim por diante.
Por exemplo, para a string "Python", o caractere 'P' está no índice 0, 'y' está no índice 1, 't' está no índice 2, etc.

```python
texto = "Python"
print(texto[0])  # saída : P
print(texto[1])  # saída : y
```

Índices negativos são usados para acessar caracteres a partir do final da string. O índice -1 refere-se ao último caractere, -2 ao penúltimo, e assim por diante.
Por exemplo, para a string "Python", o caractere 'n' está no índice -1 e 'o' está no índice -2.

```python
texto = "Python"
print(texto[-1])  # saída : n
print(texto[-2])  # saída : o
```

O fatiamento permite extrair uma parte da string. A sintaxe é texto[início:fim:passo], onde:
- `início` é o índice onde o fatiamento começa (inclusivo),
- `fim` é o índice onde o fatiamento termina (exclusivo),
- `passo` é o intervalo entre os caracteres que serão incluídos (opcional).

Se o início ou fim não forem fornecidos, o fatiamento usará o início ou o final da string, respectivamente.

```python
texto = "Python"
print(texto[:3])    # saída : Pyt (do início até o índice 2)
print(texto[3:])    # saída : hon (do índice 3 até o final)
print(texto[::2])   # saída : Pto (passo 2, pegando cada segundo caractere)
print(texto[::-1])   # saída : nohtyP (passo -1, inverte a string)
```

Veja alguns exemplos :

```python
# concatenando duas strings:
saudacao = "Olá"
nome = "Mundo"
mensagem = saudacao + " " + nome
print(mensagem)  # saída : Olá Mundo

# concatenando strings com números:
parte1 = "Número"
parte2 = " 42"
resultado = parte1 + parte2
print(resultado)  # saída : Número 42

# multiplicação de uma string:
repeticao = "Ha" * 3
print(repeticao)  # saída : HaHaHa

# uso do caractere de nova linha \n:
mensagem = "Primeira linha\nSegunda linha"
print(mensagem)
# saída :
# Primeira linha
# Segunda linha

# uso do caractere de tabulação \t:
mensagem = "Nome:\tJoão"
print(mensagem)
# saída :
# Nome:    João

# uso da barra invertida \ para escapar caracteres:
caminho = "C:\\Users\\Nome"
print(caminho)  # saída : C:\Users\Nome

# concatenando com \n:
linha1 = "Esta é a primeira linha"
linha2 = "Esta é a segunda linha"
mensagem = linha1 + "\n" + linha2
print(mensagem)
# saída :
# Esta é a primeira linha
# Esta é a segunda linha

# concatenando com \t:
chave = "Chave:"
valor = "12345"
mensagem = chave + "\t" + valor
print(mensagem)
# saída :
# Chave:  12345

# uso de aspas simples dentro de uma string com aspas duplas:
mensagem = "Ela disse: 'Olá!'"
print(mensagem)  # saída : Ela disse: 'Olá!'

# uso de aspas duplas dentro de uma string com aspas simples:
mensagem = 'Ele respondeu: "Bom dia!"'
print(mensagem)  # saída : Ele respondeu: "Bom dia!"

# concatenando com variáveis:
nome = "Ana"
saudacao = "Bom dia, " + nome + "!"
print(saudacao)  # saída : Bom dia, Ana!

# multiplicação de strings com espaços:
ponto = ". "
linha = ponto * 10
print(linha)  # saída : . . . . . . . . . .

# uso do caractere de nova linha para formatação:
lista_compras = "Itens:\n- Maçã\n- Banana\n- Laranja"
print(lista_compras)
# saída :
# Itens:
# - Maçã
# - Banana
# - Laranja

# uso do caractere de tabulação para formatação:
tabela = "Produto\tPreço\nMaçã\t1.50\nBanana\t0.75"
print(tabela)
# saída :
# Produto    Preço
# Maçã       1.50
# Banana     0.75

# uso da barra invertida para incluir aspas duplas:
mensagem = "Ele disse: \"Bom trabalho!\""
print(mensagem)  # saída : Ele disse: "Bom trabalho!"

# uso da barra invertida para incluir aspas simples:
mensagem = 'Ela disse: \'Até logo!\''
print(mensagem)  # saída : Ela disse: 'Até logo!'

# concatenando strings literais:
mensagem = "Python " + "é " + "divertido!"
print(mensagem)  # saída : Python é divertido!

# uso de caracteres especiais em uma string:
texto = "Linha1\nLinha2\tTabbed\nCaminho: C:\\Usuários\\Nome"
print(texto)
# saída :
# Linha1
# Linha2  Tabbed
# Caminho: C:\Usuários\Nome

# concatenando strings com múltiplas linhas:
mensagem = "Olá,\n" + "Este é um exemplo de mensagem\n" + "com múltiplas linhas."
print(mensagem)
# saída :
# Olá,
# Este é um exemplo de mensagem
# com múltiplas linhas.

# multiplicação de strings para criar um padrão:
padrao = "AB" * 5
print(padrao)  # saída : ABABABABAB

# uso de aspas duplas dentro de aspas duplas com escape:
frase = "Ele disse: \"Isso é incrível!\""
print(frase)  # saída : Ele disse: "Isso é incrível!"

# uso de aspas simples dentro de aspas simples com escape:
frase = 'Ela respondeu: \'Sim, estou de acordo.\''
print(frase)  # saída : Ela respondeu: 'Sim, estou de acordo.'

# uso de caracteres de nova linha \n em uma string longa:
mensagem = "Linha 1\nLinha 2\nLinha 3"
print(mensagem)
# saída :
# Linha 1
# Linha 2
# Linha 3

# uso de tabulação \t para alinhar texto:
tabela = "Nome\tIdade\tCidade\nAna\t30\tSão Paulo\nCarlos\t25\tRio de Janeiro"
print(tabela)
# saída :
# Nome    Idade    Cidade
# Ana     30       São Paulo
# Carlos  25       Rio de Janeiro

# uso de barra invertida para escapar uma barra invertida:
caminho = "C:\\Usuários\\Publico"
print(caminho)  # saída : C:\Usuários\Publico

# uso de aspas simples dentro de uma string com aspas duplas sem escape:
mensagem = "O livro se chama 'Python para Iniciantes'"
print(mensagem)  # saída : O livro se chama 'Python para Iniciantes'

# uso de aspas duplas dentro de uma string com aspas simples sem escape:
mensagem = 'Ele disse: "Boa sorte!"'
print(mensagem)  # saída : Ele disse: "Boa sorte!"

# string literal com múltiplas linhas usando aspas triplas:
mensagem = '''Esta é uma string
que ocupa múltiplas linhas,
sem a necessidade de caracteres de nova linha.'''
print(mensagem)
# saída :
# Esta é uma string
# que ocupa múltiplas linhas,
# sem a necessidade de caracteres de nova linha.

# uso de aspas triplas dentro de aspas triplas:
texto = """Ela disse: "Isso é 'fantástico'!"
E ele respondeu: "Concordo completamente."""
print(texto)
# saída :
# Ela disse: "Isso é 'fantástico'!"
# E ele respondeu: "Concordo completamente."

# acessando o primeiro caractere
texto = "Python"
print(texto[0])  # saída : P

# acessando o terceiro caractere
texto = "Python"
print(texto[2])  # saída : t

# acessando o último caractere
texto = "Python"
print(texto[-1])  # saída : n

# acessando o penúltimo caractere
texto = "Python"
print(texto[-2])  # saída : o

# fatiando os primeiros três caracteres
texto = "Python"
print(texto[:3])  # saída : Pyt

# fatiando os caracteres do índice 2 ao 5
texto = "Python"
print(texto[2:6])  # saída : thon

# fatiando a partir do índice 4 até o final
texto = "Python"
print(texto[4:])  # saída : hon

# fatiando até o índice 4
texto = "Python"
print(texto[:4])  # saída : Pyt

# fatiando com passo de 2 caracteres
texto = "Python"
print(texto[::2])  # saída : Pto

# fatiando com passo negativo
texto = "Python"
print(texto[::-1])  # saída : nohtyP

# fatiando com passo de 3 caracteres
texto = "Python"
print(texto[::3])  # saída : Phn

# fatiando com início e fim específicos
texto = "Python"
print(texto[1:5:2])  # saída : ytn

# fatiando uma string com tamanho variável
texto = "Indexação"
print(texto[3:7])  # saída : exaç

# fatiando uma string com caracteres especiais
texto = "Hello, World!"
print(texto[7:])  # saída : World!

# acessando um caractere em uma string de números
texto = "123456"
print(texto[4])  # saída : 5

# fatiando uma string para pegar caracteres de um espaço em branco
texto = "Python Programming"
print(texto[7:11])  # saída : Prog

# fatiando uma string para pegar caracteres de uma palavra específica
texto = "A quick brown fox"
print(texto[2:9])  # saída : quick b

# fatiando uma string para pegar a última palavra
texto = "A quick brown fox"
print(texto[11:])  # saída : brown fox

# fatiando uma string para pegar caracteres com diferentes passos
texto = "abcdefghijk"
print(texto[::4])  # saída : ae
```

## bool

O tipo lógico, chamado de boolean `bool` no Python, é usado quando se quer representar um valor lógico de verdadeiro ou falso. Ele é muito usado nas estruturas de decisões como `if-elif-else` e `while`, por exemplo.

Veja alguns exemplos :

```python
# comparação de igualdade entre inteiros:
a = 5
b = 5
resultado = a == b
print(resultado)  # saída : True

# comparação de diferença entre inteiros:
a = 5
b = 3
resultado = a != b
print(resultado)  # saída : True

# comparação maior que entre inteiros:
a = 10
b = 5
resultado = a > b
print(resultado)  # saída : True

# comparação menor que entre inteiros:
a = 5
b = 10
resultado = a < b
print(resultado)  # saída : True

# comparação maior ou igual entre inteiros:
a = 10
b = 10
resultado = a >= b
print(resultado)  # saída : True

# comparação menor ou igual entre inteiros:
a = 5
b = 10
resultado = a <= b
print(resultado)  # saída : True

# comparação de igualdade entre strings:
palavra1 = "python"
palavra2 = "python"
resultado = palavra1 == palavra2
print(resultado)  # saída : True

# comparação de diferença entre strings:
palavra1 = "python"
palavra2 = "Python"
resultado = palavra1 != palavra2
print(resultado)  # saída : True

# uso do operador and (e lógico):
a = True
b = False
resultado = a and b
print(resultado)  # saída : False

# uso do operador or (ou lógico):
a = True
b = False
resultado = a or b
print(resultado)  # saída : True

# uso do operador not (não lógico):
a = True
resultado = not a
print(resultado)  # saída : False

# combinação de operadores relacionais e lógicos:
a = 10
b = 5
c = 7
resultado = (a > b) and (c < a)
print(resultado)  # saída : True

# comparação entre float e inteiro:
a = 10.0
b = 10
resultado = a == b
print(resultado)  # saída : True

# comparação de strings com diferentes casos:
palavra1 = "pythoN"
palavra2 = "python"
resultado = palavra1 == palavra2
print(resultado)  # saída : False

# verificação se um número é par:
numero = 4
resultado = numero % 2 == 0
print(resultado)  # saída : True

# verificação se um número é ímpar:
numero = 5
resultado = numero % 2 != 0
print(resultado)  # saída : True

# outra forma de verificar se um número é par ou ímpar
numero = 5
valor = numero // 2
valor = valor * 2
resultado = valor == numero
print(resultado)

# combinação de operadores and, or e not:
a = True
b = False
c = True
resultado = (a and b) or (not c)
print(resultado)  # saída : False

# comparação entre variáveis booleanas:
a = True
b = False
resultado = a == b
print(resultado)  # saída : False
```

## condicional if-elif-else

Condicionais são usados para tomar decisões no seu código. Com base em condições (que são expressões que retornam `True` ou `False`), você pode executar diferentes blocos de código.

### condicionais simples

* **`if`** : verifica uma condição. Se a condição for verdadeira (`True`), o bloco de código dentro do if será executado.
    ```python
    if teste_condicional:
        # Código a ser executado se a condição for verdadeira
    ```
* **`elif`** : é uma abreviação de `else if` e verifica uma condição alternativa se a condição anterior (`if`) não for verdadeira. Pode haver múltiplos `elif`.
    ```python
    if teste_condicional1:
        # Código se teste_condicional1 for verdadeira
    elif teste_condicional2:
        # Código se teste_condicional1 for falsa e teste_condicional2 for verdadeira
    ```
* **`else`** :executa um bloco de código se todas as condições anteriores (`if` e `elif`) forem falsas.
    ```python
    if teste_condicional1:
        # Código se teste_condicional1 for verdadeira
    elif teste_condicional2:
        # Código se teste_condicional1 for falsa e teste_condicional2 for verdadeira
    else:
        # Código se todas as condições anteriores forem falsas
    ```

### condicinais aninhadas

Permite decisões mais complexas ao verificar condições adicionais dentro de blocos `if`, `elif` ou `else`.

```python
if teste_condicional1:
    # Código executado se teste_condicional1 for verdadeira
    if teste_condicional2:
        # Código executado se teste_condicional2 for verdadeira e teste_condicional1 for verdadeira
    elif teste_condicional3:
        # Código executado se teste_condicional3 for verdadeira e teste_condicional1 for verdadeira
    else:
        # Código executado se nenhuma teste_condicional2 ou teste_condicional3 for verdadeira, mas condição1 for verdadeira
elif teste_condicional4:
    # Código executado se teste_condicional4 for verdadeira e teste_condicional1 for falsa
else:
    # Código executado se nenhuma das condições anteriores for verdadeira
```

### exemplos

Veja exemplos da condição `if`-`elif`-`else` :

```python
# verificação simples com if:
idade = 18
if idade >= 18:
    print("Você é maior de idade.")

# usando if e else:
idade = 16
if idade >= 18:
    print("Você é maior de idade.")
else:
    print("Você é menor de idade.")

# usando if, elif e else:
nota = 85
if nota >= 90:
    print("Aprovado com Distinção")
elif nota >= 70:
    print("Aprovado")
else:
    print("Reprovado")

# verificação de idade para categoria de ingresso:
idade = 22
if idade < 12:
    print("Ingresso infantil")
elif idade < 18:
    print("Ingresso juvenil")
else:
    print("Ingresso adulto")

# verificação de temperatura:
temperatura = 30
if temperatura < 15:
    print("Está frio.")
elif temperatura < 25:
    print("Está agradável.")
else:
    print("Está quente.")

# verificação de número par ou ímpar:
numero = 7
if numero % 2 == 0:
    print("O número é par.")
else:
    print("O número é ímpar.")

# checando se um número está entre dois valores:
numero = 15
if 10 <= numero <= 20:
    print("O número está entre 10 e 20.")
else:
    print("O número não está entre 10 e 20.")

# verificação de idade para habilitação de dirigir:
idade = 17
if idade >= 18:
    print("Pode obter a carteira de motorista.")
else:
    print("Não pode obter a carteira de motorista.")

# checando se uma variável é igual a um valor específico:
fruta = "maçã"
if fruta == "maçã":
    print("Você escolheu uma maçã.")
elif fruta == "banana":
    print("Você escolheu uma banana.")
else:
    print("Fruta não reconhecida.")

# checando o saldo da conta bancária:
saldo = 100
if saldo >= 0:
    print("Saldo positivo.")
else:
    print("Saldo negativo.")

# verificação de status de login:
usuario_logado = True
if usuario_logado:
    print("Bem-vindo de volta!")
else:
    print("Por favor, faça o login.")

# verificação de idade para desconto em ingresso:
idade = 65
if idade >= 65:
    print("Desconto para idosos.")
else:
    print("Sem desconto.")

# verificação de validade de senha:
senha = "12345"
if len(senha) >= 6:
    print("Senha válida.")
else:
    print("Senha muito curta.")

# determinação do tipo de triângulo:
a = 3
b = 4
c = 5
if a == b == c:
    print("Triângulo equilátero.")
elif a == b or b == c or a == c:
    print("Triângulo isósceles.")
else:
    print("Triângulo escaleno.")

# checando se um valor está fora de um intervalo:
valor = 25
if valor < 10 or valor > 20:
    print("Valor fora do intervalo.")
else:
    print("Valor dentro do intervalo.")

# verificação de número positivo, negativo ou zero:
numero = 0
if numero > 0:
    print("Número positivo.")
elif numero < 0:
    print("Número negativo.")
else:
    print("Número é zero.")

# checando se um número é múltiplo de 3 e 5:
numero = 15
if numero % 3 == 0 and numero % 5 == 0:
    print("O número é múltiplo de 3 e 5.")
elif numero % 3 == 0:
    print("O número é múltiplo de 3.")
elif numero % 5 == 0:
    print("O número é múltiplo de 5.")
else:
    print("O número não é múltiplo de 3 nem de 5.")

# condicionais aninhadas

# verificação de idade e se a pessoa é estudante:
idade = 20
estudante = True
if idade >= 18:
    if estudante:
        print("Você é um estudante adulto.")
    else:
        print("Você é um adulto não estudante.")
else:
    print("Você é menor de idade.")

# verificação de temperatura e umidade:
temperatura = 30
umidade = 70
if temperatura > 25:
    if umidade > 60:
        print("Clima quente e úmido.")
    else:
        print("Clima quente e seco.")
else:
    print("Clima fresco.")

# checagem de aprovação em um curso:
nota = 85
presença = 90
if nota >= 70:
    if presença >= 75:
        print("Aprovado no curso.")
    else:
        print("Reprovado por falta de presença.")
else:
    print("Reprovado por nota.")

# verificação de acesso com senha e nível de usuário:
senha = "admin123"
nivel_usuario = "admin"
if senha == "admin123":
    if nivel_usuario == "admin":
        print("Acesso total concedido.")
    else:
        print("Acesso limitado concedido.")
else:
    print("Senha incorreta.")

# verificação de idade para entrada em evento e se possui convite:
idade = 25
convite = True
if idade >= 18:
    if convite:
        print("Entrada permitida ao evento.")
    else:
        print("Você precisa de um convite para entrar.")
else:
    print("Você não tem idade suficiente para entrar.")

# checagem de valor de desconto e valor total da compra:
valor_total = 150
desconto = 10  # em porcentagem
if valor_total > 100:
    if desconto > 5:
        print("Desconto aplicado.")
    else:
        print("Desconto não suficiente para aplicar.")
else:
    print("Compra abaixo do valor mínimo para desconto.")

# verificação de saldo bancário e status da conta:
saldo = 2000
conta_ativa = True
if conta_ativa:
    if saldo >= 1000:
        print("Conta com saldo suficiente.")
    else:
        print("Saldo insuficiente.")
else:
    print("Conta não está ativa.")

# verificação de idade para compra de bebida alcoólica e estado de residência:
idade = 22
estado = "SP"
if idade >= 21:
    if estado == "SP" or estado == "RJ":
        print("Você pode comprar bebida alcoólica.")
    else:
        print("Restrições de compra no seu estado.")
else:
    print("Você não pode comprar bebida alcoólica.")

# verificação de validade de voucher e valor da compra:
valor_compra = 50
voucher_valido = True
if voucher_valido:
    if valor_compra >= 40:
        print("Voucher aplicado com sucesso.")
    else:
        print("Valor da compra não atende aos requisitos do voucher.")
else:
    print("Voucher inválido.")

# checagem de disponibilidade de produto e status de entrega:
produto_em_estoque = True
status_entrega = "em trânsito"
if produto_em_estoque:
    if status_entrega == "em trânsito":
        print("Produto disponível e em entrega.")
    else:
        print("Produto disponível, mas entrega não iniciada.")
else:
    print("Produto fora de estoque.")
```

## exercícios

<details>
<summary>Lista de Exercícios</summary>

## int e float

1. Exercícios Iniciais
    1. Crie uma variável x com o valor 10 e uma variável y com o valor 5. Imprima a soma de x e y.
    1. Crie uma variável a com o valor 8 e uma variável b com o valor 4. Imprima o resultado da subtração de a por b.
    1. Crie uma variável x com o valor 7 e uma variável y com o valor 3. Imprima o resultado da multiplicação de x por y.
    1. Crie uma variável x com o valor 20 e uma variável y com o valor 4. Imprima o resultado da divisão de x por y.
    1. Crie uma variável x com o valor 10 e outra variável y com o valor 4. Imprima o resto da divisão de x por y.
    1. Crie uma variável a com o valor 15. Imprima o valor de a elevado ao quadrado.
    1. Crie uma variável a com o valor 9 e outra variável b com o valor 2. Imprima a divisão inteira de a por b.
    1. Crie uma variável x com o valor 5.5 e uma variável y com o valor 2.2. Imprima a soma de x e y.
    1. Crie uma variável x com o valor 3.7 e uma variável y com o valor 1.2. Imprima o resultado da subtração de x por y.
    1. Crie uma variável x com o valor 4.5 e uma variável y com o valor 2. Imprima o resultado da multiplicação de x por y.
1. Exercícios Intermediários
    1. Crie uma variável a com o valor 25 e outra variável b com o valor 7. Imprima o resultado da divisão de a por b, com 2 casas decimais.
    1. Crie uma variável x com o valor 6.7 e uma variável y com o valor 3.1. Imprima a soma de x e y, com 1 casa decimal.
    1. Crie uma variável a com o valor 16 e outra variável b com o valor 4. Crie uma terceira variável resultado que armazene a raiz quadrada de a dividida por b. Imprima resultado.
    1. Crie uma variável x com o valor 12.5 e uma variável y com o valor 2.5. Imprima a diferença entre x e y e verifique se é maior que 8.
    1. Crie uma variável a com o valor 3.14 e outra variável b com o valor 2. Crie uma variável resultado que armazene a multiplicação de a por b, e imprima o resultado com 3 casas decimais.
    1. Crie uma variável x com o valor 45.9 e outra variável y com o valor 15.1. Imprima o resultado da divisão de x por y, com 4 casas decimais.
        ```python
        x = 45.9
        y = 15.1

        print('x / y', x / y)
        print('(x/y) * 10000', (x/y)*10000)
        print('((x/y) * 10000) // 1', ((x/y) * 10000) // 1)

        print('(((x/y)*10000)//1)/10000',(((x/y)*10000)//1)/10000)

        print('x/y * 10000 // 1 / 10000', x/y * 10000 // 1 / 10000)
        ```
    1. Crie uma variável a com o valor 0.5 e outra variável b com o valor 0.25. Imprima a soma de a e b, multiplicada por 100.
    1. Crie uma variável x com o valor 8.2 e uma variável y com o valor 3.4. Imprima o resultado da multiplicação de x por y e verifique se é menor que 30.
    1. Crie uma variável a com o valor 17 e outra variável b com o valor 3. Crie uma variável resultado que armazene a soma de a com o resto da divisão de a por b. Imprima resultado.
    1. Crie uma variável x com o valor 5.6 e outra variável y com o valor 2.3. Imprima o resultado da subtração de x por y, arredondado para o inteiro mais próximo.
1. Exercícios Avançados
    1. Crie uma variável x com o valor 9 e uma variável y com o valor 4. Imprima o resultado da expressão (x ** 2 + y ** 2) / (x - y).
    1. Crie uma variável x com o valor 10.5 e uma variável y com o valor 2.7. Imprima o resultado da expressão (x * y) - (x / y).
    1. Crie uma variável a com o valor 12 e uma variável b com o valor 5. Crie uma variável resultado que armazene a soma de a e b, elevada ao quadrado. Imprima resultado.
    1. Crie uma variável x com o valor 6.8 e uma variável y com o valor 2.4. Imprima a soma de x com y, multiplicada pelo resto da divisão de x por y.
    1. Crie uma variável a com o valor 20 e outra variável b com o valor 7. Crie uma variável resultado que armazene a média de a e b. Imprima resultado com 2 casas decimais.
    1. Crie uma variável x com o valor 15.75 e uma variável y com o valor 3.5. Imprima o resultado da expressão x / y somado ao quadrado de y.
    1. Crie uma variável a com o valor 8 e uma variável b com o valor 3. Crie uma variável resultado que armazene a diferença entre a e b, e verifique se o quadrado do resultado é maior que 20. Imprima resultado.
    1. Crie uma variável x com o valor 7.5 e uma variável y com o valor 3.2. Imprima o resultado da expressão (x + y) / (x - y) com 2 casas decimais.
    1. Crie uma variável a com o valor 25 e uma variável b com o valor 5. Crie uma variável resultado que armazene o valor absoluto da diferença entre o quadrado de a e o cubo de b. Imprima resultado.
    1. Crie uma variável x com o valor 10.4 e uma variável y com o valor 3.6. Imprima a expressão (x ** 2 + y ** 2) / (x * y) e verifique se é maior que 5.
    1. Crie uma variável a com o valor 8 e outra variável b com o valor 3. Crie uma variável resultado que armazene a soma de a e b, e imprima o resultado dividido pela raiz quadrada de a.
    1. Crie uma variável x com o valor 11.2 e uma variável y com o valor 5.7. Imprima o resultado da expressão (x - y) * (x + y), com 2 casas decimais.
    1. Crie uma variável a com o valor 30 e outra variável b com o valor 4. Crie uma variável resultado que armazene a diferença entre a e b, elevada ao cubo. Imprima resultado.
    1. Crie uma variável x com o valor 8.5 e uma variável y com o valor 2.3. Imprima a expressão (x * y) + (x / y) e verifique se é menor que 20.
    1. Crie uma variável a com o valor 18 e uma variável b com o valor 7. Crie uma variável resultado que armazene o valor absoluto da diferença entre a e o produto de b por 2. Imprima resultado.
    1. Crie uma variável x com o valor 14.7 e uma variável y com o valor 6.3. Imprima o resultado da expressão (x + y) / (x - y) e verifique se é maior que 2.
    1. Crie uma variável a com o valor 12 e uma variável b com o valor 5. Crie uma variável resultado que armazene a soma de a e b, multiplicada pela raiz quadrada de a. Imprima resultado.
    1. Crie uma variável x com o valor 9.8 e uma variável y com o valor 4.2. Imprima a expressão ((x + y) * 2) / (x - y), com 2 casas decimais.
    1. Crie uma variável a com o valor 7 e outra variável b com o valor 2. Crie uma variável resultado que armazene o valor absoluto do quadrado de a subtraído do cubo de b. Imprima resultado.
    1. Crie uma variável x com o valor 5.5 e uma variável y com o valor 2.2. Crie uma variável resultado que armazene a soma de x e y, e imprima o resultado elevado ao quadrado.
    1. Crie uma variável a com o valor 21 e uma variável b com o valor 3. Crie uma variável resultado que armazene a diferença entre o quadrado de a e o cubo de b, dividido por b. Imprima resultado.
    1. Crie uma variável x com o valor 20.5 e uma variável y com o valor 3.2. Imprima o resultado da expressão (x - y) * (x + y), com 1 casa decimal.
    1. Crie uma variável a com o valor 18 e uma variável b com o valor 7. Crie uma variável resultado que armazene a soma de a com o produto de b e 2. Imprima resultado dividido pela raiz quadrada de a.
    1. Crie uma variável x com o valor 12.4 e uma variável y com o valor 2.5. Imprima a expressão ((x * y) + (x / y)) - (y ** 2), com 2 casas decimais.
    1. Crie uma variável a com o valor 14 e uma variável b com o valor 5. Crie uma variável resultado que armazene o quadrado da soma de a e b, dividido pelo cubo de b. Imprima resultado.
    1. Crie uma variável x com o valor 25.7 e uma variável y com o valor 8.3. Imprima o resultado da expressão (x / y) * ((x + y) / (x - y)), com 2 casas decimais.
    1. Crie uma variável a com o valor 30 e uma variável b com o valor 7. Crie uma variável resultado que armazene o produto de a por b, dividido pela diferença entre a e b. Imprima resultado.
    1. Crie uma variável x com o valor 10.5 e uma variável y com o valor 3.7. Imprima a expressão ((x * y) + (x / y)) - (x ** 2), com 2 casas decimais.
    1. Crie uma variável a com o valor 15 e uma variável b com o valor 4. Crie uma variável resultado que armazene a soma de a e b, elevada ao cubo, e depois subtraia 100. Imprima resultado.
    1. Crie uma variável x com o valor 9.9 e uma variável y com o valor 2.2. Imprima a expressão ((x ** 2) + (y ** 2)) / ((x * y) - y), com 2 casas decimais.

## str

1. Exercícios Simples
    1. Crie duas variáveis str1 e str2 com os valores "Hello" e "World". Imprima a soma das duas strings.
    1. Crie uma variável texto com o valor "Python". Imprima a string "PythonPython" usando a multiplicação de strings.
    1. Crie uma variável frase com o valor "Python Programming". Imprima os primeiros 6 caracteres da string.
    1. Crie uma variável texto com o valor "Hello, World!". Imprima os caracteres da posição 7 até o final da string.
    1. Crie uma variável mensagem com o valor "Python". Imprima os primeiros 3 caracteres.
    1. Crie uma variável palavra com o valor "Data". Imprima a string "DataDataData" usando a multiplicação de strings.
    1. Crie uma variável texto com o valor "Python". Imprima os caracteres do índice 1 ao 4.
    1. Crie duas variáveis prefixo e sufixo com os valores "Hello" e "World". Imprima a soma das duas strings com um espaço entre elas.
    1. Crie uma variável nome com o valor "Alice". Imprima a string "AliceAlice" usando a multiplicação de strings.
    1. Crie uma variável mensagem com o valor "Data Science". Imprima os caracteres do índice 5 até o final da string.
1. Exercícios Intermediários
    1. Crie uma variável texto com o valor "Learn Python". Imprima os caracteres do índice 6 ao 11.
    1. Crie uma variável frase com o valor "Hello World". Imprima a string "HelloHello" usando a multiplicação de strings.
    1. Crie uma variável texto com o valor "Programming". Imprima os primeiros 4 caracteres.
    1. Crie uma variável mensagem com o valor "String Manipulation". Imprima os caracteres do índice 8 ao 15.
    1. Crie duas variáveis part1 e part2 com os valores "Python" e "Rocks". Imprima a soma das duas strings com um espaço entre elas.
    1. Crie uma variável palavra com o valor "Machine Learning". Imprima a string "Machine LearningMachine Learning" usando a multiplicação de strings.
    1. Crie uma variável texto com o valor "Artificial Intelligence". Imprima os caracteres do índice 3 ao 8.
    1. Crie uma variável mensagem com o valor "Data Analysis". Imprima os caracteres do índice 5 ao 10.
    1. Crie uma variável frase com o valor "Learn to Code". Imprima a string "Learn to CodeLearn to Code" usando a multiplicação de strings.
    1. Crie uma variável texto com o valor "Statistics". Imprima os caracteres do índice 4 até o final da string.
1. Exercícios Avançados
    1. Crie uma variável frase com o valor "Welcome to the World of Python". Imprima os caracteres do índice 11 ao 20.
    1. Crie uma variável texto com o valor "Programming is Fun". Imprima a string "ProgrammingProgramming" usando a multiplicação de strings.
    1. Crie uma variável mensagem com o valor "Learn Python Basics". Imprima os caracteres do índice 0 ao 4.
    1. Crie uma variável frase com o valor "Data Science and Machine Learning". Imprima os caracteres do índice 17 ao 30.
    1. Crie duas variáveis str1 e str2 com os valores "Data" e "Science". Imprima a soma das duas strings com um espaço entre elas.
    1. Crie uma variável texto com o valor "Advanced Python Techniques". Imprima a string "Advanced Python TechniquesAdvanced Python Techniques" usando a multiplicação de strings.
    1. Crie uma variável mensagem com o valor "Artificial Intelligence Overview". Imprima os caracteres do índice 14 até o final da string.
    1. Crie uma variável texto com o valor "Introduction to Programming". Imprima os caracteres do índice 5 ao 25.
    1. Crie uma variável frase com o valor "Exploring Data Science" e imprima a string "Exploring Data ScienceExploring Data Science" usando a multiplicação de strings.
    1. Crie uma variável texto com o valor "Big Data Analytics". Imprima os caracteres do índice 3 ao 12.
    1. Crie uma variável mensagem com o valor "Data Visualization Techniques". Imprima os caracteres do índice 10 ao 25.
    1. Crie duas variáveis prefixo e sufixo com os valores "Machine Learning" e " in Python". Imprima a soma das duas strings com um espaço entre elas.
    1. Crie uma variável texto com o valor "Deep Learning Models". Imprima a string "Deep Learning ModelsDeep Learning Models" usando a multiplicação de strings.
    1. Crie uma variável frase com o valor "Data Driven Insights". Imprima os caracteres do índice 4 ao 12.
    1. Crie uma variável texto com o valor "Programming for Data Science". Imprima os caracteres do índice 12 até o final da string.
    1. Crie uma variável mensagem com o valor "Exploring Machine Learning Algorithms". Imprima a string "Exploring Machine Learning AlgorithmsExploring Machine Learning Algorithms" usando a multiplicação de strings.
    1. Crie uma variável texto com o valor "Advanced Data Analytics Techniques". Imprima os caracteres do índice 8 ao 28.
    1. Crie uma variável frase com o valor "Understanding Data Science Principles". Imprima os caracteres do índice 18 ao 35.
    1. Crie duas variáveis parte1 e parte2 com os valores "Introduction" e " to Python". Imprima a soma das duas strings com um espaço entre elas.
    1. Crie uma variável texto com o valor "Machine Learning Fundamentals". Imprima a string "Machine Learning FundamentalsMachine Learning Fundamentals" usando a multiplicação de strings.
    1. Crie uma variável mensagem com o valor "Data Science Applications". Imprima os caracteres do índice 5 ao 20.
    1. Crie uma variável texto com o valor "Artificial Intelligence Applications". Imprima os caracteres do índice 22 até o final da string.
    1. Crie uma variável frase com o valor "Deep Learning for AI". Imprima a string "Deep Learning for AIDeep Learning for AI" usando a multiplicação de strings.
    1. Crie uma variável texto com o valor "Introduction to Machine Learning". Imprima os caracteres do índice 0 ao 15.
    1. Crie uma variável mensagem com o valor "Python for Data Science and Analytics". Imprima os caracteres do índice 10 ao 35.
    1. Crie duas variáveis str1 e str2 com os valores "Deep Learning" e " in Python". Imprima a soma das duas strings com um espaço entre elas.
    1. Crie uma variável texto com o valor "Understanding Data Science Techniques". Imprima a string "Understanding Data Science TechniquesUnderstanding Data Science Techniques" usando a multiplicação de strings.
    1. Crie uma variável frase com o valor "Introduction to Data Visualization". Imprima os caracteres do índice 11 ao 30.
    1. Crie uma variável texto com o valor "Advanced Machine Learning Techniques". Imprima os caracteres do índice 10 ao 35.
    1. Crie uma variável mensagem com o valor "Data Science Fundamentals Overview". Imprima a string "Data Science Fundamentals OverviewData Science Fundamentals Overview" usando a multiplicação de strings.

## if-elif-else

1. Exercícios Simples
    1. Crie uma variável idade com o valor 18. Imprima "Maior de idade" se a idade for maior ou igual a 18. Caso contrário, imprima "Menor de idade".
    1. Crie uma variável preco com o valor 150. Imprima "Carro caro" se o preço for maior que 100, e "Carro barato" caso contrário.
    1. Crie uma variável nota com o valor 7.5. Imprima "Aprovado" se a nota for maior ou igual a 7.0. Caso contrário, imprima "Reprovado".
    1. Crie uma variável temperatura com o valor 22.5. Imprima "Quente" se a temperatura for maior que 25. Caso contrário, imprima "Frio".
    1. Crie uma variável nome com o valor "Ana". Imprima "Olá Ana" se o nome for "Ana", e "Olá desconhecido" caso contrário.
    1. Crie uma variável altura com o valor 1.75. Imprima "Altura adequada" se a altura for maior ou igual a 1.70. Caso contrário, imprima "Altura inadequada".
    1. Crie uma variável produto com o valor "livro". Imprima "Produto disponível" se o produto for "livro", e "Produto não disponível" caso contrário.
    1. Crie uma variável idade com o valor 65. Imprima "Aposentado" se a idade for maior ou igual a 65. Caso contrário, imprima "Não aposentado".
    1. Crie uma variável x com o valor 10. Imprima "Positivo" se x for maior que 0, e "Não positivo" caso contrário.
    1. Crie uma variável n com o valor 4. Imprima "Par" se n for divisível por 2, e "Ímpar" caso contrário.
1. Exercícios Intermediários
    1. Crie uma variável nota com o valor 5. Crie um bloco if-elif-else para imprimir "Aprovado" se a nota for maior ou igual a 7, "Recuperação" se a nota for entre 5 e 6, e "Reprovado" caso contrário.
    1. Crie uma variável idade com o valor 20. Crie um bloco if-elif-else para imprimir "Adulto" se a idade for entre 18 e 60, "Idoso" se a idade for maior que 60, e "Jovem" se a idade for menor que 18.
    1. Crie uma variável salario com o valor 3000. Imprima "Imposto alto" se o salário for maior que 2500, e "Imposto baixo" caso contrário.
    1. Crie uma variável nota com o valor 8.5. Imprima "Excelente" se a nota for maior ou igual a 9, "Bom" se a nota estiver entre 7 e 8.9, e "Suficiente" caso contrário.
    1. Crie uma variável numero com o valor 15. Imprima "Divisível por 3" se numero for divisível por 3, e "Não divisível por 3" caso contrário.
    1. Crie uma variável tempo com o valor 30. Crie um bloco if-elif-else para imprimir "Tempo curto" se o tempo for menor que 20, "Tempo médio" se estiver entre 20 e 40, e "Tempo longo" caso contrário.
    1. Crie uma variável nome com o valor "Carlos". Crie um bloco if-elif-else para imprimir "Nome é Carlos" se o nome for "Carlos", "Nome começa com C" se começar com "C", e "Nome diferente" caso contrário.
    1. Crie uma variável ano com o valor 2024. Imprima "Ano bissexto" se o ano for divisível por 4, mas não por 100, ou se for divisível por 400. Caso contrário, imprima "Ano não bissexto".
    1. Crie uma variável altura com o valor 1.65. Crie um bloco if-elif-else para imprimir "Baixa" se a altura for menor que 1.60, "Média" se estiver entre 1.60 e 1.80, e "Alta" caso contrário.
    1. Crie uma variável idade com o valor 30. Imprima "Jovem adulto" se a idade for entre 20 e 30, "Adulto" se estiver entre 31 e 50, e "Meia-idade" caso contrário.
1. Exercícios Avançados
    1. Crie uma variável dia com o valor "Sábado". Imprima "Fim de semana" se o dia for "Sábado" ou "Domingo", e "Dia de semana" caso contrário.
    1. Crie uma variável idade com o valor 16. Crie um bloco if-elif-else para imprimir "Infantil" se a idade for menor que 12, "Juvenil" se estiver entre 12 e 18, e "Adulto" caso contrário.
    1. Crie uma variável mes com o valor "Julho". Imprima "Verão" se o mês for "Junho", "Julho", ou "Agosto", e "Não é verão" caso contrário.
    1. Crie uma variável temperatura com o valor 10. Imprima "Frio" se a temperatura for menor que 15, "Agradável" se estiver entre 15 e 25, e "Quente" caso contrário.
    1. Crie uma variável nota com o valor 9.5. Crie um bloco if-elif-else para imprimir "Excelente" se a nota for maior ou igual a 9, "Muito bom" se estiver entre 7 e 8.9, e "Suficiente" caso contrário.
    1. Crie uma variável preco com o valor 90. Crie um bloco if-elif-else para imprimir "Desconto alto" se o preço for maior que 100, "Desconto médio" se estiver entre 50 e 100, e "Sem desconto" caso contrário.
    1. Crie uma variável idade com o valor 70. Crie um bloco if-elif-else para imprimir "Idoso" se a idade for maior ou igual a 65, "Adulto" se estiver entre 18 e 64, e "Jovem" caso contrário.
    1. Crie uma variável salario com o valor 4000. Crie um bloco if-elif-else para imprimir "Classe alta" se o salário for maior que 3000, "Classe média" se estiver entre 1500 e 3000, e "Classe baixa" caso contrário.
    1. Crie uma variável x com o valor 8. Crie um bloco if-elif-else para imprimir "Múltiplo de 2" se x for divisível por 2, "Múltiplo de 4" se x for divisível por 4, e "Não é múltiplo" caso contrário.
    1. Crie uma variável nome com o valor "Pedro". Imprima "Bem-vindo Pedro" se o nome for "Pedro", "Nome começando com P" se começar com "P", e "Nome diferente" caso contrário.
    1. Crie uma variável dia com o valor 10. Crie um bloco if-elif-else para imprimir "Início do mês" se o dia for menor ou igual a 10, "Meio do mês" se estiver entre 11 e 20, e "Fim do mês" caso contrário.
    1. Crie uma variável idade com o valor 45. Crie um bloco if-elif-else para imprimir "Meia-idade" se a idade for entre 40 e 60, "Adulto" se estiver entre 20 e 39, e "Jovem" caso contrário.
    1. Crie uma variável velocidade com o valor 90. Crie um bloco if-elif-else para imprimir "Velocidade alta" se a velocidade for maior que 80, "Velocidade média" se estiver entre 50 e 80, e "Velocidade baixa" caso contrário.
    1. Crie uma variável ponto com o valor 10. Crie um bloco if-elif-else para imprimir "Nota máxima" se o ponto for igual a 10, "Nota alta" se estiver entre 7 e 9, e "Nota baixa" caso contrário.
    1. Crie uma variável altura com o valor 1.90. Crie um bloco if-elif-else para imprimir "Muito alto" se a altura for maior que 1.85, "Médio" se estiver entre 1.60 e 1.85, e "Baixo" caso contrário.
    1. Crie uma variável preco com o valor 200. Crie um bloco if-elif-else para imprimir "Caro" se o preço for maior que 150, "Médio" se estiver entre 100 e 150, e "Barato" caso contrário.
    1. Crie uma variável tempo com o valor 60. Crie um bloco if-elif-else para imprimir "Tempo curto" se o tempo for menor que 30, "Tempo médio" se estiver entre 30 e 60, e "Tempo longo" caso contrário.
    1. Crie uma variável senha com o valor "12345". Crie um bloco if-elif-else para imprimir "Senha correta" se a senha for "12345", "Senha curta" se tiver menos de 6 caracteres, e "Senha incorreta" caso contrário.
    1. Crie uma variável percentual com o valor 85. Crie um bloco if-elif-else para imprimir "Excelente" se o percentual for maior ou igual a 90, "Bom" se estiver entre 70 e 89, e "Regular" caso contrário.
    1. Crie uma variável x com o valor 2. Crie um bloco if-elif-else para imprimir "Número primo" se x for 2 ou 3, "Número par" se for divisível por 2, e "Número ímpar" caso contrário.
    1. Crie uma variável dia com o valor "Quarta-feira". Imprima "Dia útil" se o dia for "Segunda-feira", "Terça-feira", "Quarta-feira", "Quinta-feira", ou "Sexta-feira", e "Fim de semana" caso contrário.
    1. Crie uma variável peso com o valor 65. Crie um bloco if-elif-else para imprimir "Peso normal" se o peso estiver entre 50 e 70, "Abaixo do peso" se for menor que 50, e "Acima do peso" caso contrário.
    1. Crie uma variável sabor com o valor "Chocolate". Imprima "Sabor favorito" se o sabor for "Chocolate", "Sabor agradável" se for "Baunilha", e "Sabor não listado" caso contrário.
    1. Crie uma variável ponto com o valor 45. Crie um bloco if-elif-else para imprimir "Nota alta" se o ponto for maior que 40, "Nota média" se estiver entre 20 e 40, e "Nota baixa" caso contrário.
    1. Crie uma variável status com o valor "ativo". Crie um bloco if-elif-else para imprimir "Ativo" se o status for "ativo", "Inativo" se for "inativo", e "Status desconhecido" caso contrário.
    1. Crie uma variável altura com o valor 1.55. Crie um bloco if-elif-else para imprimir "Baixa" se a altura for menor que 1.60, "Média" se estiver entre 1.60 e 1.75, e "Alta" caso contrário.
    1. Crie uma variável distancia com o valor 15. Crie um bloco if-elif-else para imprimir "Curta" se a distância for menor que 10, "Média" se estiver entre 10 e 20, e "Longa" caso contrário.
    1. Crie uma variável idade com o valor 25. Crie um bloco if-elif-else para imprimir "Adulto jovem" se a idade for entre 20 e 30, "Adulto" se estiver entre 31 e 50, e "Meia-idade" caso contrário.
    1. Crie uma variável quantidade com o valor 12. Crie um bloco if-elif-else para imprimir "Quantidade alta" se a quantidade for maior que 15, "Quantidade média" se estiver entre 5 e 15, e "Quantidade baixa" caso contrário.
    1. Crie uma variável temp com o valor 5. Crie um bloco if-elif-else para imprimir "Muito frio" se a temperatura for menor que 10, "Agradável" se estiver entre 10 e 25, e "Quente" caso contrário.
</details>
Índice Tipos Primitivos

1. [informação](#informação)
1. [constantes](#constantes)
1. [variáveis](#variáveis)
1. [declarando variáveis](#declarando-variáveis)
1. [expressões aritméticas](#expressões-aritméticas)
1. [parênteses](#parênteses)
1. [prioridades](#prioridades)
1. [expressões lógicas](#expressões-lógicas)
1. [comandos de atribuição](#comandos-de-atribuição)

# tipos primitivos

## informação

Para entender os tipos primitivos, tem que estar atentos para um conceito muito importante, *a informação*.

Existe uma diferença sutil entre dado e informação. Ao citar uma data, por exemplo, 20 de setembro. Essa data sozinha, representa apenas um dado, mas ao dizer que é a data de início da Revolução Farroupilha, está sendo agregado um valor ao dado da data, apresentando uma informação.

Aproximando a maneira que o computador manipula as informações, pode-se dividir em quatro tipos primitivos, que são os tipos básicos que serão usados na construção de algoritmos.

- `inteiro` : é toda e qualquer informação numérica que pertença ao conjunto dos números inteiros (positivos, negativos e nulo). Exemplos :
    - ele tem 3 gatos;
    - eu tenho 10 dedos;
    - eu tinha 2 pulmões;
- `real` : é toda e qualquer informação numérica que pertença ao conjunto dos números reais (positivos, negativos e nulo). Exemplos :
    - o PI valor 3.1415926535;
    - o número de Euler vale 2.71828;
    - peguei 0.853 gramas de guisado;
- `caracter` : é toda e qualquer informação composta de um conjunto de caracteres numéricos  (0...9), alfabéticos (A...Z, a...z) e especiais (!@#$%,.). Esse tipo de dado está sempre entre aspas simples ou duplas. Exemplos :
    - minha senha é "s)Lf]\?[G8A$aQM:Fnr'/Orw;%qg$<*9";
    - o nome é "Arnold Schwarzenegger";
    - ela disse que "a resposta é 42";
- `lógico` : é toda e qualquer informação que pode assumir apenas duas situações. Exemplos :
    - a porta está **aberta** ou **fechada**;
    - a pessoa está **viva** ou **morta**;
    - a lâmpada está **ligada** ou **desligada**;

<details>
    <summary>Lista de Exercícios</summary>

Determine o tipo primitivo de cada uma das sentenças abaixo :

1. Eu vi 12 pássaros no parque.
    ```
    inteiro
    ```
1. A temperatura média do corpo humano é 36.5 graus Celsius.
    ```
    real
    ```
1. O nome do meu cachorro é "Buddy".
    ```
    caracter
    ```
1. A janela está aberta ou fechada?
    ```
    lógico
    ```
1. A altura da Torre Eiffel é 324 metros.
    ```
    inteiro
    ```
1. Minha senha é "A1b2C3d4!".
    ```
    caracter
    ```
1. Ele tem 4 filhos.
    ```
    inteiro
    ```
1. O número de Euler vale 2.71828.
    ```
    real
    ```
1. A porta está trancada ou destrancada?
    ```
    lógico
    ```
1. Eu tenho 5 irmãos.
    ```
    inteiro
    ```
1. A profundidade do oceano é 10.994 metros.
    ```
    real
    ```
1. O nome da cidade é "São Paulo".
    ```
    caracter
    ```
1. O computador está ligado ou desligado?
    ```
    lógico
    ```
1. O preço do litro de gasolina é 5.49 reais.
    ```
    real
    ```
1. Meu endereço de e-mail é "meuemail@exemplo.com".
    ```
    caracter
    ```
1. Quantos dedos há nas suas duas mãos?
    ```
    inteiro
    ```
1. O número de telefone é "123-456-7890".
    ```
    caracter
    ```
1. Você está feliz ou triste?
    ```
    lógico
    ```
1. A distância entre as duas cidades é 300 quilômetros.
    ```
    inteiro
    ```
1. Meu filme favorito é "O Senhor dos Anéis".
    ```
    caracter
    ```
1. O sinal está verde ou vermelho?
    ```
    lógico
    ```
1. A raiz quadrada de 64 é 8.
    ```
    inteiro
    ```
1. O nome da sua escola é "Escola Primária ABC".
    ```
    caracter
    ```
1. A lâmpada está ligada ou desligada?
    ```
    lógico
    ```
1. Eu bebi 1.5 litros de água hoje.
    ```
    real
    ```
1. A frase "Carpe Diem" é do latim.
    ```
    caracter
    ```
1. O céu está limpo ou nublado?
    ```
    lógico
    ```
1. Ele ganhou 15 pontos no jogo.
    ```
    inteiro
    ```
1. A área do círculo é 78.5 centímetros quadrados.
    ```
    real
    ```
1. A senha é "P@ssw0rd!".
    ```
    caracter
    ```
1. A música está tocando ou parada?
    ```
    lógico
    ```
1. Eu tenho 3 cachorros.
    ```
    inteiro
    ```
1. O valor de Pi é 3.1415926535.
    ```
    real
    ```
1. A janela está aberta ou fechada?
    ```
    lógico
    ```
1. O nome do autor é "J.K. Rowling".
    ```
    caracter
    ```
1. O carro está em movimento ou parado?
    ```
    lógico
    ```
1. A massa do objeto é 4.5 quilogramas.
    ```
    real
    ```
1. O número da sua conta bancária é "12345678".
    ```
    caracter
    ```
1. A comida está pronta ou crua?
    ```
    lógico
    ```
1. O dia está ensolarado ou chuvoso?
    ```
    lógico
    ```
1. O livro tem 350 páginas.
    ```
    inteiro
    ```
1. O peso do bebê é 3.2 quilogramas.
    ```
    real
    ```
1. O título do livro é "O Alquimista".
    ```
    caracter
    ```
1. O telefone está silencioso ou tocando?
    ```
    lógico
    ```
1. O preço do pão é 2.75 reais.
    ```
    real
    ```
1. A frase "Olá, mundo!" é comum na programação.
    ```
    caracter
    ```
1. A luz está acesa ou apagada?
    ```
    lógico
    ```
1. A soma de 5 e 3 é 8.
    ```
    inteiro
    ```
1. O nome do filme é "Matrix".
    ```
    caracter
    ```
1. Você está acordado ou dormindo?
    ```
    lógico
    ```
1. O comprimento do rio é 6.650 quilômetros.
    ```
    real
    ```
1. O endereço é "Rua das Flores, 123".
    ```
    caracter
    ```
1. O computador está ligado ou desligado?
    ```
    lógico
    ```
1. A profundidade do lago é 15 metros.
    ```
    inteiro
    ```
1. O valor da resistência é 10 ohms.
    ```
    inteiro
    ```
1. O nome do seu animal de estimação é "Fido".
    ```
    caracter
    ```
1. A janela está aberta ou fechada?
    ```
    lógico
    ```
1. O saldo da conta é 1023.75 reais.
    ```
    real
    ```
1. A frase "A prática leva à perfeição" é um provérbio.
    ```
    caracter
    ```
1. O céu está limpo ou nublado?
    ```
    lógico
    ```
1. O prédio tem 20 andares.
    ```
    inteiro
    ```
1. O peso do pacote é 2.3 quilogramas.
    ```
    real
    ```
1. O nome do jogo é "Minecraft".
    ```
    caracter
    ```
1. A luz está acesa ou apagada?
    ```
    lógico
    ```
1. A área da sala é 45 metros quadrados.
    ```
    inteiro
    ```
1. A sequência de caracteres é "!@#$%^&*()".
    ```
    caracter
    ```
1. O telefone está tocando ou silencioso?
    ```
    lógico
    ```
1. O número de páginas lidas é 200.
    ```
    inteiro
    ```
1. A densidade do material é 7.85 g/cm³.
    ```
    real
    ```
1. O nome da rua é "Avenida Paulista".
    ```
    caracter
    ```
1. A porta está aberta ou fechada?
    ```
    lógico
    ```
1. O valor da pressão é 101.3 kPa.
    ```
    real
    ```
1. O título da música é "Bohemian Rhapsody".
    ```
    caracter
    ```
1. A comida está quente ou fria?
    ```
    lógico
    ```
1. O comprimento do campo é 100 metros.
    ```
    inteiro
    ```
1. A palavra "Python" é uma linguagem de programação.
    ```
    caracter
    ```
1. O carro está em movimento ou parado?
    ```
    lógico
    ```
1. O valor da nota é 9.5.
    ```
    real
    ```
1. O nome da banda é "The Beatles".
    ```
    caracter
    ```
1. A janela está aberta ou fechada?
    ```
    lógico
    ```
1. A quantidade de açúcar é 250 gramas.
    ```
    inteiro
    ```
1. O número do apartamento é "302".
    ```
    caracter
    ```
1. A luz está acesa ou apagada?
    ```
    lógico
    ```
1. O tempo de corrida foi 2.5 horas.
    ```
    real
    ```
1. O nome do software é "Microsoft Word".
    ```
    caracter
    ```
1. O carro está ligado ou desligado?
    ```
    lógico
    ```
1. A distância até a lua é 384400 quilômetros.
    ```
    inteiro
    ```
1. O nome do livro é "1984".
    ```
    caracter
    ```
1. A temperatura da água é 25 graus Celsius.
    ```
    inteiro
    ```
1. O peso do peixe é 1.7 quilogramas.
    ```
    real
    ```
1. A frase "A resposta é 42" é do livro "Guia do Mochileiro das Galáxias".
    ```
    caracter
    ```
1. O computador está ligado ou desligado?
    ```
    lógico
    ```
1. O número de folhas é 100.
    ```
    inteiro
    ```
1. A massa do planeta é 5.97 x 10^24 quilogramas.
    ```
    real
    ```
1. O nome da cor é "Azul".
    ```
    caracter
    ```
1. A porta está trancada ou destrancada?
    ```
    lógico
    ```
1. O valor da corrente é 0.5 amperes.
    ```
    real
    ```
1. O título do artigo é "Impacto das Mudanças Climáticas".
    ```
    caracter
    ```
1. A lâmpada está ligada ou desligada?
    ```
    lógico
    ```
1. O número de série é "SN12345678".
    ```
    caracter
    ```

</details>

## constantes

Entende-se um dado como constante quando seu valor não sofre qualquer variação no decorrer do tempo, ou seja, o valor é constante do início ao fim da execução do algoritmo. Ele pode ser usado para representar um valor conhecidamente imutável, como o valor 3.14159265 do PI, ou quando não se quer que ele seja alterado durante a execução do algoritmo, como especificar o nome de um autor (J. R. R. Tolkien) de um livro (O Hobbit).

## variáveis

Um dado é classificado como variável quando tem a possibilidade de ser alterado a qualquer momento durante a execução do algoritmo. Por exemplo, calcular a média de uma turma somando todas as notas e depois dividindo pela quantidade de alunos, ou usar um contador para contar quantas vezes é realizada uma repetição de alguma coisa, como o quicar de uma bola no chão.

Um exemplo prático de ambos os casos (variáveis e constantes) seria o uso de uma fórmula matemática. O cálculo da área do círculo é dado por pi vezes o raio ao quadrado. O pi é o valor constante da fórmula, ele jamais vai mudar. Enquanto que o raio é a variável, onde a cada execução ele poderá ter um valor diferente.

## declarando variáveis

No ambiente computacional, as informações variáveis são guardadas em dispositivos eletrônicos chamados de **memória**. Pode-se imaginar que essa memória é como um armário repleto de gavetas, que são usadas para armazenar objetos.

Esse armário tem diversas gavetas, então é necessário diferenciar uma da outra. Isso é feito com indentificadores, etiquetas, rótulos. Cada gaveta (variável) pode guardar apenas um dado, um objeto de cada vez.

> [!NOTE]
> o Python, diferente de outras linguagens como C, C++, Java, não possui variáveis restritas a um tipo primitivo; uma variável pode ser hora inteiro, hora uma lista, hora uma string;

Portanto, é preciso definir nomes para determinadas gavetas especificando qual o material dos objetos que lá estão armazenados. Declarar variáveis é usado para identificar dados.

Por exemplo :
- nome = "Arnold"
- idade = 76
- altura = 1.88

### nomes

Para declarar uma variável, é necessário seguir algumas regras :
- elas devem começar por um caractere alfabético;
- podem ser seguidos por mais caracteres alfanuméricos e sublinhado;
- não podem ser usados caracteres especias;
- não pode haver espaço entre as palavras de identificação das variáveis;
- exemplo :
    - nomes válidos : nome, idade, id4d3, nome_completo, imc;
    - nomes inválidos : 1nome, 4_altura, !passagem, nome completo;

Também há algumas boas práticas para serem seguidas :
- não usar acentuação nos nomes de variáveis;
- usar o padrão de nomenclatura [*snake_case*](https://www.alura.com.br/artigos/convencoes-nomenclatura-camel-pascal-kebab-snake-case#snake-case) para as variáveis, constantes, funções;
- usar o padrão SCREAMING_SNAKE_CASE para constantes;

O Python usa essas convenções de boas práticas para facilitar a legibilidade dos códigos e padronizar. Também é necessário que se faça um nome para as variáveis que faça sentido com o dado que ela armazenará.

- usar `x = "Schwarzenegger` não é claro quanto a que a variável armazena;
- usar `sobrenome = "Schwarzenegger` torna muito mais claro que tipo de dado aquela variável guarda;

<details>
    <summary>Lista de Exercícios</summary>

Identifique quais são e o porquê dos nomes de variáveis serem válidos ou inválidos :

1. variavel1
1. 2variavel
1. var_iavel
1. var-iavel
1. variavel nome
1. #variavel
1. variavel_
1. var@iavel
1. variavel!
1. variavel#
1. variavel
1. variável
1. vari_avel
1. var*
1. var&
1. variavel.
1. variavel,
1. variavel;
1. variavel:
1. variavel?
1. variavel<
1. variavel>
1. variavel=
1. variavel+
1. variavel-
1. variavel/
1. variavel\\
1. variavel|
1. variavel~
1. variavel$
1. variavel%
1. variavel^
1. variavel(
1. variavel)
1. variavel[
1. variavel]
1. variavel{
1. variavel}
1. variavel"1
1. variavel'1
1. variavel1'
1. variavel 1
1. variavel
1. variavel
1. var__iavel
1. (variavel)
1. -var_iavel
1. variavel___
1. variavel__
1. variavel_1_

</details>

## expressões aritméticas

É denominado expressão aritmética aquela cujos operadores são aritméticos e cujos operandos são constantes ou variáveis do tipo inteiro ou real.

Os operadores, por sua vez, são o conjunto de símbolos que representa as operações básicas da matemática.

| Operador | Função | Exemplo |
| ---- | ---- | ---- |
| `+` | Adição | `30 + 12`, `X + 12` |
| `-` | Subtração | `2 - 3`, `Y - 12` |
| `*` | Multiplicação | `7 * 3`, `A * Z` |
| `/` | Divisão | `10 / 5`, `n1 / n2` |
| `**` | Potenciação | `2 / 10`, `n2 ** n2` |

> [!TIP]
> Lembre que, uma operação de radiciação (tirar a raiz), nada mais é do que uma operação de potência.
>
> Exemplo : a raiz quadrada de 5 pode ser escreta como `5 ** (1/2)`;

<details>
  <summary>Lista de Exercícios</summary>

Para os exercícios abaixo, use variáveis e constantes quando achar necessário.

1. Exercícios Simples
    1. Calcule a soma de 5 e 3.
        ```
        5 + 3
        ```
    1. Subtraia 8 de 15.
        ```
        15 - 8
        ```
    1. Multiplique 4 por 6.
        ```
        4 * 6
        ```
    1. Divida 20 por 4.
        ```
        20 / 4
        ```
    1. Calcule 2 elevado à potência de 3.
        ```
        2 ** 3
        2 ^ 3
        ```
    1. Calcule a soma de 7, 3 e 2.
        ```
        7 + 3 + 2
        ```
    1. Subtraia 5 de 10 e depois subtraia 3.
        ```
        (10 - 5) - 3
        ```
    1. Multiplique 3, 2 e 4.
        ```
        3 * 2 * 4
        ```
    1. Divida 25 por 5 e depois por 2.
        ```
        (25 / 5) / 2
        ```
    1. Calcule 5 elevado à potência de 2 e subtraia 3.
        ```
        (5 ** 2) - 3
        ```
1. Exercícios de Nível Intermediário
    1. Calcule a soma de 4, 5 e 6 e depois multiplique o resultado por 2.
        ```
        (4 + 5 + 6) * 2
        ```
    1. Subtraia 10 de 25, depois divida o resultado por 3.
        ```
        (25 - 10) / 3
        ```
    1. Calcule 3 elevado à potência de 2 e depois adicione 7.
        ```
        (3 ** 2) + 7
        ```
    1. Multiplique 8 por 3, depois subtraia 10.
        ```
        (8 * 3) - 10
        ```
    1. Divida 36 por 6, depois adicione 2 e multiplique por 3.
        ```
        ((36 / 6) + 2) * 3
        ```
    1. Calcule 2 elevado à potência de 4 e depois subtraia 5.
        ```
        (2 ** 4) - 5
        ```
    1. Calcule a soma de 6 e 7, depois divida o resultado por 2.
        ```
        (6 + 7) / 2
        ```
    1. Subtraia 14 de 28, depois multiplique o resultado por 3.
        ```
        (28 - 14) * 3
        ```
    1. Calcule 4 elevado à potência de 3 e depois adicione 5.
        ```
        (4 ** 3) + 5
        ```
    1. Multiplique 9 por 4, depois subtraia 15 e divida o resultado por 3.
        ```
        ((9 * 4) - 15) / 3
        ```
1. Exercícios Avançados
    1. Calcule a soma de 5, 8 e 12, depois multiplique o resultado por 2 e subtraia 10.
        ```
        ((5 + 8 + 12) * 2) - 10
        ```
    1. Subtraia 15 de 45, depois divida o resultado por 5 e adicione 7.
        ```
        ((45 - 12) / 5) + 7
        ```
    1. Calcule 2 elevado à potência de 5 e depois subtraia 9 e multiplique por 2.
        ```
        ((2 ** 5) - 9) * 2
        ```
    1. Multiplique 7 por 6, depois adicione 10 e divida por 4.
        ```
        ((7 * 6) + 10) / 4
        ```
    1. Divida 72 por 8, depois adicione 5 e multiplique por 3.
        ```
        ((72 / 8) + 5) * 3
        ```
    1. Calcule 3 elevado à potência de 3 e depois subtraia 8 e divida por 2.
        ```
        ((3 ** 3) - 8) / 2
        ```
    1. Calcule a soma de 9 e 14, depois multiplique por 3 e subtraia 5.
        ```
        ((9 + 14) * 3) - 5
        ```
    1. Subtraia 20 de 60, depois divida por 4 e adicione 7.
        ```
        ((60 - 20) / 4) + 7
        ```
    1. Calcule 4 elevado à potência de 4 e depois subtraia 20 e multiplique por 2.
        ```
        ((4 ** 4) - 20) * 2
        ```
    1. Multiplique 10 por 5, depois adicione 8 e divida por 6.
        ```
        ((10 * 5) + 8) / 6
        ```
1. Exercícios Complexos
    1. Calcule a soma de 12, 8 e 5, depois multiplique o resultado por 3, subtraia 15 e divida por 2.
        ```
        (((12 + 8 + 5) * 3) - 15) / 2
        ```
    1. Subtraia 18 de 50, depois divida por 4, adicione 7 e multiplique por 3.
        ```
        (((50 - 18) / 4) + 7) * 3
        ```
    1. Calcule 5 elevado à potência de 3, depois subtraia 10, multiplique por 2 e adicione 8.
        ```
        (((5 ** 3) - 10) * 2) + 8
        ```
    1. Multiplique 6 por 7, depois adicione 12, divida por 3 e subtraia 4.
        ```
        (((6 * 7) + 12) / 3) - 4
        ```
    1. Divida 81 por 9, depois adicione 5, multiplique por 4 e subtraia 10.
        ```
        (((81 / 9) + 5) * 4) - 10
        ```
    1. Calcule 2 elevado à potência de 6, depois subtraia 20, divida por 2 e multiplique por 3.
        ```
        (((2 ** 6) - 20) / 2) * 3
        ```
    1. Calcule a soma de 7, 13 e 18, depois multiplique por 4, subtraia 25 e divida por 5.
        ```
        (((7 + 13 + 18) * 4) - 25) / 5
        ```
    1. Subtraia 30 de 90, depois divida por 5, adicione 9 e multiplique por 2.
        ```
        (((90 - 30) / 5) + 9) * 2
        ```
    1. Calcule 3 elevado à potência de 4, depois subtraia 50, multiplique por 3 e adicione 20.
        ```
        (((3 ** 4) - 50) * 3) + 20
        ```
    1. Multiplique 8 por 9, depois adicione 20, divida por 7 e subtraia 3.
        ```
        (((8 * 9) + 20) / 7) - 3
        ```
1. Exercícios Muito Complexos
    1. Calcule a soma de 15, 9 e 7, depois multiplique por 2, subtraia 10, divida por 3 e adicione 5.
        ```
        ((((15 + 9 + 7) * 2) - 10) / 3) + 5
        ```
    1. Subtraia 25 de 100, depois divida por 5, adicione 8, multiplique por 3 e subtraia 7.
        ```
        ((((100 - 25) / 5) + 8) * 3) - 7
        ```
    1. Calcule 4 elevado à potência de 3, depois subtraia 15, multiplique por 2, adicione 10 e divida por 5.
        ```
        ((((4 ** 3) - 15) * 2) + 10) / 5
        ```
    1. Multiplique 11 por 6, depois adicione 30, divida por 4, subtraia 8 e multiplique por 2.
        ```
        ((((11 * 6) + 30) / 4) - 8) * 2
        ```
    1. Divida 144 por 12, depois adicione 7, multiplique por 3, subtraia 20 e divida por 2.
        ```
        ((((144 / 12) + 7) * 3) - 20) / 3
        ```
    1. Calcule 5 elevado à potência de 4, depois subtraia 30, divida por 2, multiplique por 3 e adicione 10.
        ```
        ((((5 ** 4) - 30) / 2) * 3) + 10
        ```
    1. Calcule a soma de 8, 14 e 22, depois multiplique por 5, subtraia 40, divida por 4 e adicione 6.
        ```
        ((((8 + 14 + 22) * 5) - 40) / 4) + 6
        ```
    1. Subtraia 50 de 200, depois divida por 10, adicione 15, multiplique por 2 e subtraia 5.
        ```
        ((((200 - 50) / 10)/ + 15) * 2) - 5
        ```
    1. Calcule 6 elevado à potência de 3, depois subtraia 40, multiplique por 4, adicione 25 e divida por 3.
        ```
        ((((6 ** 3) - 40) * 4) + 25) / 3
        ```
    1. Multiplique 9 por 7, depois adicione 50, divida por 5, subtraia 10, multiplique por 3 e adicione 15.
        ```
        (((((9 * 7) + 50) / 5) - 10) * 3) + 15
        ```

</details>

Ainda há alguns operadores aritméticos não usuais, mas que são muito úteis na construção de algoritmos. São eles o `resto` da divisão inteira e o `quociente` da divisão inteira. Cada um traz como resultado o que é especificado.

| Operador | Função | Exemplo |
| ---- | ---- | ---- |
| `%` | Resto | `12 % 3`, `X % 11` |
| `//` | Quociente | `10 // 3`, `X // 20` |

Por exemplo :
- `11 % 3` irá retornar o resto da divisão, que será `2`;
- `11 // 3` irá retornar o quociente da divisão, que será `3`;

Os operadores de resto e quociente inteiros são úteis em diversos cenários, entre os quais categorizar números ou separar seus algarismos.

Por exemplo, para verificar se um número é par ou ímpar, basta verificar o resto da divisão por 2. Os restos possíveis para essa divisão são apenas 2, `1` ou `0`. Números pares sempre irão gerar resto igual a zero, enquanto que números ímpares sempre irão gerar um resto igual a um.

- `12 % 2` terá como resto 0;
- `11 % 2` terá como resto 1;

Ele também pode ser usado para separar um número inteiro. Para isso, basta realizar divisões sucessivas por 10 para obter seus algarismos.

Por exemplo :
- `1947 % 10` terá como resto 7 (unidade);
- `194 % 10` terá como resto 4 (dezena);
- `19 % 10` terá como resto 9 (centena);
- `1 % 10` terá como resto 1 (milhas);

## parênteses

Diferente da matemática, onde se usam parênteses `()`, colchetes `[]` e chaves `{}` para representar diferentes níveis de uma equação, na programação usa-se apenas parênteses `()`, em todos os níveis. Veja uma comparação abaixo :
- na `matemática` : 7 * {4 - [2 / (1 + 2)] * 10}
- na `programação` : 7 * (4 - (2 / (1 + 2)) * 10)

Isso permite criar níveis muito profundos de uso de parênteses :
- 7 + (4 * 1 + (3 / (2 - (9 * 4) - (1 * 1) / 3) + (2 * 21)) + 10)

## prioridades

Na resolução das expressões aritméticas, as operações guardam uma hierarquia entre si

| prioridade | operadores |
| :----: | :----: |
| 1 | parênteses mais internos |
| 2 | ** |
| 3 | * / % // |
| 4 | + - |

Em caso de empate (operadores de mesma prioridade), deve-se resolver da esquerda para a direita, conforme a sequência da própria expressão. Se for necessário alterar essa prioridade, usa-se parênteses. Veja alguns exemplos :
```
5 + 9 + 3 / 2
5 + 9 + 1.5
14 + 1.5
15.5
```

```
5 + (9 + 3) / 2
5 + 12 / 2
5 + 6
11
```

<details>
  <summary>Mais Exercícios</summary>

1. Exercícios Simples
    1. Calcule o resto da divisão de 15 por 4.
        ```
        15 % 4 = 3
        ```
    1. Encontre o quociente da divisão inteira de 20 por 3.
        ```
        20 // 3 = 6
        ```
    1. Calcule 25 % 6 + 8.
        ```
        25 % 6 + 8
        1 + 8 = 9
        ```
    1. Encontre o quociente da divisão de 45 por 7 e adicione 3.
        ```
        45 // 7 + 3
        6 + 3 = 9
        ```
    1. Calcule o resto da divisão de 30 por 5 e multiplique por 4.
        ```
        30 % 5 * 4
        0 * 4 = 0
        ```
1. Exercícios de Nível Intermediário
    1. Encontre o quociente da divisão de 50 por 8 e subtraia 2.
        ```
        (50 // 8) - 2
        6 - 2 = 4
        ```
    1. Calcule 18 % 5 + 3 * 2.
        ```
        (18 % 5) + (3 * 2)
        3 + 6 = 9
        ```
    1. Encontre o quociente da divisão de 35 por 4 e multiplique por 2.
        ```
        35 // 4 * 2
        8 * 2 = 16
        ```
    1. Calcule o resto da divisão de 40 por 9 e adicione 7.
        ```
        40 % 9 + 7
        4 + 7 = 11
        ```
    1. Encontre o quociente da divisão de 60 por 11 e adicione o resto da divisão de 27 por 4.
        ```
        60 // 11 + 27 % 4
        5 + 3 = 8
        ```
1. Exercícios Avançados
    1. Calcule 48 % 10 + 6 // 3.
        ```
        48 % 10 + 6 // 3
        8 + 2 = 10
        ```
    1. Encontre o quociente da divisão de 81 por 9 e subtraia 5 % 2.
        ```
        81 // 9 - 5 % 2
        9 - 1 = 8
        ```
    1. Calcule 9 ** 2 % 7 + 4.
        ```
        81 % 7 + 4
        4 + 4 = 8
        ```
    1. Encontre o quociente da divisão de 100 por 15 e multiplique por 3 % 4.
        ```
        100 // 15 * 3 % 4
        6 * 3 % 4
        18 % 4 = 2
        ```
    1. Calcule o resto da divisão de 64 por 8 e adicione 36 // 6.
        ```
        64 % 8 + 36 // 6
        0 + 6 = 6
        ```
1. Exercícios Complexos
    1. Encontre o quociente da divisão de 49 por 6 e subtraia 14 % 5.
        ```
        49 // 6 - 14 % 5
        8 - 4 = 4
        ```
    1. Calcule 72 % 10 + 7 // 2 * 3.
        ```
        2 + 3 * 3
        2 + 9 = 11
        ```
    1. Encontre o quociente da divisão de 95 por 8 e adicione 25 % 6.
        ```
        95 // 8 + 25 % 6
        11 + 1 = 12
        ```
    1. Calcule 3 ** 3 % 4 + 20 // 3.
        ```
        27 % 4 + 6
        3 + 6 = 9
        ```
    1. Encontre o quociente da divisão de 120 por 11 e subtraia 44 % 7.
        ```
        120 // 11 - 44 % 7
        10 - 2 = 8
        ```
1. Exercícios Muito Complexos
    1. Calcule 150 % 11 + 18 // 4 * 2.
        ```
        7 + 4 * 2
        7 + 8 = 15
        ```
    1. Calcule 6 ** 2 % 5 + 88 // 9.
        ```
        36 % 5 + 9
        1 + 9 = 10
        ```
    1. Calcule o resto da divisão de 220 por 15 e adicione 100 // 7.
        ```
        220 % 15 + 100 // 7
        10 + 14 = 24
        ```
    1. Encontre o quociente da divisão de 140 por 12 e multiplique por 50 % 8.
        ```
        140 // 12 * 50 % 8
        11 * 50 % 8
        550 % 8 = 6
        ```
    1. Encontre o quociente da divisão de 200 por 17 e adicione 60 % 9.
        ```
        200 // 17 + 60 % 9
        11 + 6 = 17
        ```

</details>

## expressões lógicas

É entendido como expressão lógica aquela cujos operadores são lógicos ou relacionais e cujos operadores são relações ou variáveis ou constantes do tipo lógico.

### operadores relacionais

Usa-se `operadores relacionais` para realizar comparações entre dois valores de mesmo tipo primitivo, que podem ser representados como constantes, ou variáveis ou expressões aritméticas. Eles são usados para construir equações.

| Operador | Função | Exemplo |
| :----: | :----: | :----: |
| `==` | igual a | `3 == 2`, `"a" == "a"` |
| `>` | maior que | `5 > 4`, `X > Y` |
| `<` | menor que | `5 < 4`, `A < Z` |
| `>=` | maior ou igual a | `12 >= 5`, `C >= A` |
| `<=` | menor ou igual a | `12 <= 5`, `C <= A` |
| `!=` | diferente de | `2 != 10`, `n2 != n2` |

O resultado obetido de uma relação é sempre um valor **lógico**. Por exemplo, analisando a relação numérica `X + Y == Z`, o resultado será verdade ou falso à medida que o valor da expressão aritmética `X + Y` seja igual ou diferente do conteúdo da variável `C`.

### operadores lógicos

Existem três `operadores lógicos` básicos que são usados para a formação de novas proposições lógicas compostas a partir de outras proposições lógicas simples.

| Operador | Função |
| :----: | :----: |
| `not` | negação |
| `and` | conjunção |
| `or` | disjunção |

### tabelas-verdade

Tabela-verdade é o conjunto de todas as possibilidades combinatórias entre os valores de diversas variáveis lógicas, as quais se encontram em apenas duas situações (True para verdadeiro ou False para falso), e um conjunto de operadores lógicos.

Veja as tabelas verdades :

- Operação de negação

| A | not A |
| :----: | :----: |
| `True` | `False` |
| `False` | `True` |

- Operação de conjunção

| A | B | A and B |
| :----: | :----: | :----: |
| `True` | `True` | `True` |
| `True` | `False` | `False` |
| `False` | `True` | `False` |
| `False` | `False` | `False` |

- Operação de disjunção

| A | B | A or B |
| :----: | :----: | :----: |
| `True` | `True` | `True` |
| `True` | `False` | `True` |
| `False` | `True` | `True` |
| `False` | `False` | `False` |

Alguns exemplos práticos :
- Se chover `e` trovejar, eu fico em casa.
    - Como é possível ver, usou-se o conectivo `e` (que no Python é usado como `and`) para verificar se a proposição *ficar em casa* será satisfeita. A pessoa ficará em casa apenas se chover **E** trovejar, se ambas forem verdade ao mesmo tempo.<br><br>
- Se chover `ou` trovejar, eu fico em casa.
    - Agora, usando o operadore `ou` (que no Python é usado como `or`) indica que a pessoa ficará vem casa se chover **OU** se trovejar, aumentando as chaves de não sair de casa.<br><br>
```python
2 < 5 and 15/3 == 6
 True and 5 == 6
 True and False
     False
```
```python
2 < 5 or 15/3 == 6
 True or 5 == 6
 True or False
     True
```
```python
False or 20 // (18 / 3) != (21 / 3) // 2
False or 20 // 6 != 7 // 2
False or 3 != 3
False or False
    False
```
```python
not True or (3 ** 2) / 3 < 15 - 35 % 7
not True or 9 / 3 < 15 - 0
not True or 3 < 15
not True or True
   False or True
        True
```

### prioridades

Vaja na tabela abaixo a prioridade entre os operadores lógicos :

| prioridade | operadores |
| :----: | :----: |
| 1 | not |
| 2 | and |
| 3 | or |

E por fim, veja a prioridade entre todos os operadores :

| prioridade | operadores |
| :----: | :----: |
| 1 | parênteses mais internos |
| 2 | operadores aritméticos |
| 3 | operadores relacionais |
| 4 | operadores lógicos |

<details>
  <summary>Lista de Exercícios</summary>

1. Exercícios Simples
    1. Verifique se 5 + 3 é igual a 8.
        ```
        5 + 3 == 8
        True
        ```
    1. Verifique se 10 - 4 é diferente de 5.
        ```
        10 - 4 != 5
        True
        ```
    1. Verifique se 7 * 2 é maior que 13.
        ```
        7 * 2 > 13
        True
        ```
    1. Verifique se 16 / 4 é menor ou igual a 4.
        ```
        16 / 4 <= 4
        True
        ```
    1. Verifique se 3 ** 2 é maior ou igual a 9.
        ```
        3 ** 2 >= 9
             9 >= 9
              True
        ```
1. Exercícios de Nível Intermediário
    1. Verifique se 12 % 5 é igual a 2 e 3 * 4 é maior que 11.
        ```
        12 % 5 == 2 and 3 * 4 > 11
             2 == 2 and 12 > 11
               True and True
                   True
        ```
    1. Verifique se 15 // 2 é diferente de 7 ou 8 + 2 é menor que 11.
        ```
        15 // 2 != 7 or 8 + 2 < 11
        True
        ```
    1. Verifique se 18 % 4 é igual a 2 e 9 / 3 é igual a 3.
        ```
        18 % 4 == 2 and 9 / 3 == 3
        True
        ```
    1. Verifique se 5 ** 2 é menor que 30 ou 6 - 1 é maior que 4.
        ```
        5 ** 2 < 30 or 6 - 1 > 4
        True
        ```
    1. Verifique se 20 // 3 é maior ou igual a 6 e 7 + 8 é igual a 15.
        ```
        20 // 3 >= 6 and 7 + 8 == 15
        True
        ```
1. Exercícios Avançados
    1. Verifique se 25 % 7 é menor que 4 e 3 ** 2 é igual a 9.
        ```
        25 % 7 < 4 and 3 ** 2 == 9
             4 < 4 and 9 == 9
             False and True
                  False
        ```
    1. Verifique se 14 // 5 é maior que 2 ou 10 / 2 é diferente de 5.
        ```
        14 // 5 > 2 or 10 / 2 != 5
        False
        ```
    1. Verifique se 30 % 8 é igual a 6 e 5 * 2 é menor ou igual a 10.
        ```
        30 % 8 == 6 and 5 * 2 <= 10
        True
        ```
    1. Verifique se 27 // 4 é menor que 7 ou 4 ** 2 é igual a 16.
        ```
        27 // 4 < 7 or 4 ** 2 == 16
        True
        ```
    1. Verifique se 21 % 6 é diferente de 3 e 12 / 4 é maior ou igual a 3.
        ```
        21 % 6 != 3 and 12 / 4 >= 3
        False
        ```
1. Exercícios Complexos
    1. Verifique se 35 % 9 é menor que 8 e 6 // 2 é igual a 3.
        ```
        35 % 9 < 8 and 6 // 2 == 3
        False
        ```
    1. Verifique se 40 // 7 é maior que 5 ou 9 ** 2 é diferente de 81.
        ```
        40 // 7 > 5 or 9 ** 2 != 81
        True
        ```
    1. Verifique se 48 % 11 é igual a 4 e 10 * 2 é maior que 19.
        ```
        48 % 11 ==F 4 and 10 * 2 > 19
              4 == 4 and 20 > 19
                True and True
                    True
        ```
    1. Verifique se 50 // 6 é menor ou igual a 8 ou 12 / 3 é igual a 4.
        ```
        50 // 6 <= 8 or 12 / 3 == 4
        True
        ```
    1. Verifique se 33 % 7 é maior que 3 e 14 - 6 é menor ou igual a 8.
        ```
        33 % 7 > 3 and 14 - 6 <= 8
        True
        ```
1. Exercícios Muito Complexos
    1. Verifique se 100 % 12 é diferente de 4 e 11 * 3 é menor que 34.
    1. Verifique se 12 * 5 é maior que 59 and 20 // 5 é igual a 4.
    1. Verifique se 15 % 4 é igual a 3 and 9 ** 2 é maior que 80.
    1. Verifique se 18 % 7 é igual a 4 or 32 / 4 é maior que 8.
    1. Verifique se 18 / 3 é diferente de 6 and 12 * 2 é maior que 22.
    1. Verifique se 20 + 10 é igual a 30 or 15 // 3 é menor ou igual a 5.
    1. Verifique se 24 / 4 é maior que 5 and 11 - 6 é diferente de 5.
    1. Verifique se 25 - 5 é igual a 20 or 14 + 6 é menor que 21.
    1. Verifique se 27 % 4 é igual a 3 or 7 ** 2 é menor ou igual a 49.
    1. Verifique se 28 + 7 é diferente de 35 or 21 // 7 é menor que 4.
    1. Verifique se 30 + 15 é maior que 44 or 27 // 9 é igual a 3.
    1. Verifique se 30 // 5 é maior que 5 and 9 + 6 é igual a 15.
    1. Verifique se 33 // 5 é maior ou igual a 6 and 18 - 9 é igual a 9.
    1. Verifique se 35 - 7 é diferente de 28 or 16 / 4 é igual a 4.
    1. Verifique se 36 / 6 é igual a 6 and 7 ** 2 é diferente de 50.
    1. Verifique se 40 % 7 é menor que 6 or 12 * 2 é igual a 24.
    1. Verifique se 40 // 5 é maior que 7 and 8 ** 2 é igual a 64.
        ```
        40 // 5 > 7 and 8 ** 2 == 64
              8 > 7 and 64 == 64
               True and True
                   True
        ```
    1. Verifique se 45 % 8 é menor que 6 and 14 * 2 é igual a 28.
    1. Verifique se 50 - 20 é maior que 29 or 25 + 6 é igual a 31.
    1. Verifique se 55 // 6 é maior que 9 and 22 + 8 é igual a 30.
    1. Verifique se 60 % 13 é igual a 8 e 15 // 4 é diferente de 3.
    1. Verifique se 60 - 25 é diferente de 34 or 10 ** 2 é igual a 100.
    1. Verifique se 70 // 8 é menor que 9 ou 8 ** 2 é igual a 64.
    1. Verifique se 75 + 25 é igual a 100 or 45 % 6 é menor que 4.
    1. Verifique se 8 ** 2 é maior que 63 and 14 % 3 é igual a 2.
    1. Verifique se 80 - 30 é maior ou igual a 50 and 6 ** 3 é diferente de 216.
    1. Verifique se 81 % 10 é menor ou igual a 1 e 18 / 2 é maior que 8.
    1. Verifique se 9 + 3 é maior que 11 and 15 - 7 é igual a 8.
    1. Verifique se 90 // 11 é maior que 8 ou 20 - 5 é igual a 15.
    1. Verifique se 99 - 11 é diferente de 88 or 18 / 3 é igual a 6.

</details>

## comando de atribuição

Um comando de atribuição permite armazenar um valor em uma variável (ainda usando a analogia do armário, equivalente a guardar na gaveta). Para o comando de atribuição funcionar, é usado o sinal de igual `=`.

Veja exemplos :
- `numero = 10`
- `nome_completo = 'Arnold Schwarzenegger'`

A ordem de atribuição será sempre da direita para a esquerda, isto é, a variável `nome` está recebendo a string `'Arnold Schwarzenegger'` para ser armazenada dentro dela. Tenha em mente que, se outro nome for atribuído à variáve, o valor antigo será perdido para todo sempre.

Sempre use nome de variáveis que sejam compatíveis com o que ela vai armazenar, isso facilita a ligibilidade do código.
Índice Tipos Python

1. [tipos int e float](#tipos-int-e-float)
1. [variáveis](#variáveis)
1. [tipo strings](#tipo-strings)
1. [manipulando strings](#manipulando-strings)
1. [indexando strings](#indexando-strings)
1. [dividindo strings](#dividindo-strings)
1. [tipo lógico](#tipo-lógico)

# tipos do python

Veja agora alguns dos tipos do Python.

## int e float

O interpretador funciona como uma calculadora simples. A expressão que for digitada será executada e a resposta será apresentada. Os operadores usados são os mesmos da matemática.
- `+` para adição;
- `-` para subtração;
- `*` para multiplicação;
- `/` para divisão;

Veja alguns exemplos :
```python
>>> 1 + 1
2
>>> 50 - 8
42
>>> 3 * 5
15
>>> 4 / 2
2.0
>>> |
```

Assim como na matemática, os parênteses podem ser usados para mudar a ordem de execução dos operadores. Se for necessário, mais parênteses internos podem ser adicionados.

```python
>>> 10 * 4 + 2
42
>>> 10 * (4 + 2)
60
>>>
>>> # o IMC é calculado usando o peso divido pelo quadrado da altura
>>> 90 / (1.8 * 1.8)
27.777777777777775
>>>
>>> 10 / 3 + 2 - 5 * -2 * 1
15.333333333333334
>>> (10 / (3 + 2) - 5 * (-2 * 1))
12.0
>>> |
```

Repare que o resultado da divisão foi o que apresentou maior diferença em todas as respostas. Surgiu um `.0` junto ao dois, no primeiro exemplo. Isso acontece por haver distinção entre os tipos numéricos.

Os **números inteiros** são aqueles que não apresentação valor fracionário (2, 3, 5, 7, 12, 42). São representados pela sigla `int`.

Os números que possuem a parte fracionária, são chamados de **números de ponto flutuante** (3.14, 1.81, 2.0). São representados pela sigla `float`. Os números do tipo float são especificados com um ponto `.` em vez da vírgula `,` como é usado no Brasil. Isso acontece porque a vírgula é usada para separar itens. Se fizer `3,14`, o Python irá interpretar como sendo dois números de uma tupla (veremos o que é mais adiante), o número 3 seguido do número 14.

Uma divisão **SEMPRE** irá retornar um valor do tipo float, mesmo se o resultado tiver uma parte fracionária zerada (3.000000000000). Para realizar uma divisão e captar apenas a parte inteira (o quociente), usa-se o operador `//`. Para recuperar apenas o resto da divisão, usa-se o operador `%`. Em termos de precedência dos operadores, eles são equivalentes da multiplicação e divisão.

Veja abaixo alguns exemplos :
```python
>>> 76 / 5  # divisão tradicional sempre retorna um float, dividendo / divisor
15.2000
>>> 76 // 5  # o operador // retorna a parte inteira da divisão, o quociente
15
>>> 76 % 5  # o operador % retorna o resto da divisão
1
>>> 15 * 5 + 1  # quociente * divisor + resto = dividendo
76
>>> |
```
<img
    src="https://matematicafacil.mat.br/cursos/ensinofundamental/4aserie/blog6741.jpg"
    alt="imagem dos elementos da divisão"
    width="65%">

Com o Python, é possível usar o operador `**` para calcular potências e raízes :
```python
>>> 5 ** 2  # 5 ao quadrado
25
>>> 2 ** 7  # 2 elevado na potência 7
128
>>> 36 ** (1/2)  # raiz quadrada de 36
6.0
>>> |
```

E assim como na matemática, os operadores também tem sua ordem de execução :
1. `()`
1. `**`
1. `*` `/` `//` `%`
1. `+` `-`

Além de `int` e `float`, o Python também suporta outros tipos de números, como `Decimal` e `Fraction` usando pacotes específicos. E, também, há suporte nativo a números complexos, usando os sufixos `j` ou `J` para indicar a parte imaginária.

```python
>>> 3+5j
(3+5j)
>>>
>>> 3+5j - 2-3j
(1+2j)
>>> |
```

## variáveis
Nos exemplos acima, todos os valores usados, uma vez que foram calculados, eram perdidos. O resultado da equação `2 ** 7` vai ser mostrado e descartado. É necessário que toda linguagem de programação seja capaz de aceitar, armazenar e nomear dados.

Um programa deve ser capaz de receber dados do teclado (ou de outra parte do seu programa) e associar a um nome aquele dado. Este dado pode ser um valor simples ou múltiplos valores que são associados a um nome. Dados que são associados a um nome e que guarda dado é chamada de *variável*. Pense na variável como uma caixa com um nome do lado de fora dela e que pode colocar o que quiser dentro.

O Python possui muitas formas diferentes de armazenar listas de dados. É conveniente associar nomes aos dados. O sinal de igual `=` é usado para atribuir um valor a uma variável.
```python
>>> idade = 76
>>> nome = 'Arnold Schwarzenegger'
>>>
>>> idade
61
>>> nome
'Arnold Schwarzenegger'
>>> 2024 - idade
1948
>>> |
```

Caso tente-se usar uma variável não definida, irá levantar um erro :
```python
>>> numero
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'numero' is not defined
>>> |
```

Com o uso de variáveis, é possível armazenar o valor para usar posteriormente.

### pep 8 - variáveis
<details>
  <summary>Detalhes</summary>

Quando você escreve código, é necessário dar nome para muitas coisas: variáveis, funções, classes, pacotes e por aí vai. Escolher nomes corretos irá poupar seu tempo e energia mais tarde.

Por exemplo, é uma péssima prática usar l, O ou I como nome de variáveis. Dependendo da fonte usada, essas letras podem se passar e serem confundidas com 1 e 0.
```python
>>> O = 2  # não é recomendado
>>> O  # isso seria um zero ou a letra o maíuscula?
2
>>> |
```
Fazendo isso, parece que se está tentando salvar o valor 2 no valor zero, o que é impossível.

#### nomes das variáveis
As variáveis devem iniciar com o primeiro caractere sendo uma letra (há outro caractere permitido, mas será visto bem mais tarde). Depois do primeiro, pode-se usar números também. Espaços não são permitidos para os nomes, então é usado o sublinhado `_` para separar as palavras. Variáveis também não podem possuir acentuações ou cedilhas nos nomes.

Lembrando que esse tipo de nomenclatura é conhecida como [*snake_case*](https://www.alura.com.br/artigos/convencoes-nomenclatura-camel-pascal-kebab-snake-case#snake-case).

```python
>>> # variáveis com nomes permitidos
>>> resposta = 42
>>> resposta
42
>>> valor1 = 12
>>> valor1
12
>>> valor_2 = 20
>>> valor_2
20
>>> primeiro_nome = 'Arnold'
>>> primeiro_nome
'Arnold'
>>> # nomes de variáveis que não são recomendados ou que geram erro
>>> ação = 'atacar'
>>> ação
'atacar'
>>> 2_dois = 2
  File "<stdin>", line 1
    2_dois = 2
     ^
SyntaxError: invalid decimal literal
>>> primeiro nome = 'Arnold'
  File "<stdin>", line 1
    primeiro nome = 'Arnold'
             ^^^^
SyntaxError: invalid syntax
>>> |
```

#### nomes proibidos
O Python possui diversas palavras-chave que não podem ser usadas como nomes de variáveis. Se algum valor for tentado associar a ela, irá levantar um erro de sintaxe :

```python
>>> if = 10
  File "<stdin>", line 1
    if = 10
       ^
SyntaxError: invalid syntax
>>> and = 50
  File "<stdin>", line 1
    and = 50
    ^^^
SyntaxError: invalid syntax
>>> while = 1
  File "<stdin>", line 1
    while = 1
          ^
SyntaxError: invalid syntax
>>> for = 10
  File "<stdin>", line 1
    for = 10
        ^
SyntaxError: invalid syntax
>>> return = 20
  File "<stdin>", line 1
    return = 20
           ^
SyntaxError: invalid syntax
>>>
>>> # Mais algumas palavras reservadas :
>>> # pass if elif else while for break continue and or not in is import from
>>> # as try except raise finally with del print def return yield del global
>>> # class exec lambda assert
```

</details>

## exercícios de números

<details>
  <summary>Lista de Exercícios</summary>

Para os exercícios abaixo, use variáveis e comentários quando achar necessário.

Apesar de serem exercícios com muitos cálculos matemáticos, o objetivo deles não é a resposta em si, mas como transformar uma fómula matemática em um algoritmo para ser usado com Python.

Por exemplo, considere a fórmula do círculo.

<img
    src="https://s3.static.brasilescola.uol.com.br/be/2023/06/formula-da-area-do-circulo.jpg"
    alt="imagem dos elementos da divisão"
    width="45%">

Para transformar em algoritmo, pode se fazer de várias formas :

```python
>>> # método 1
>>> print(3.14 * 10 ** 2)
314.0
>>>
>>> # método 2
>>> raio = 10
>>> pi = 3.14
>>> print(pi * raio ** 2)
314.0
>>>
>>> # método 3
>>> raio = 10
>>> pi = 3.14
>>> area = pi * raio * raio
>>> print(area)
314.0
>>>
```

1. Exercícios Simples
    1. Calcule a área de um quadrado de lado 5.
        ```python
        lado = 5
        area = lado * lado  # método 1
        area = lado * 2  # método 2
        print('a área do quadrado é')
        print(area)
        print(lado * lado)
        ```
    1. Calcule a área de um retângulo de base 8 e altura 6.
        ```python
        base = 8
        altura = 6
        area = base * altura
        print('a área do retângulo é')
        print(area)
        ```
    1. Calcule o perímetro de um triângulo equilátero de lado 7.
        ```python
        lado = 7
        perimetro = lado + lado + lado  # método 1
        perimetro = lado * 3  # método 2
        print(perimetro)
        ```
    1. Calcule o volume de um cubo de lado 3.
        ```python
        lado = 3
        volume = lado * lado * lado  # método 1
        volume = lado ** 3  # método 2
        print(volume)
        ```
    1. Calcule a área de um círculo de raio 4 (use π = 3.14).
        ```python
        PI = 3.14
        raio = 4
        area = pi * raio ** 2
        print(area)
        ```
    1. Calcule a hipotenusa de um triângulo retângulo com catetos 3 e 4.
        ```python
        cateto1 = 3
        cateto2 = 4
        cat1_mais_cat2 = (cateto1 ** 1) + (cateto2 ** 2)
        hipotenusa = cat1_mais_cat2 ** (1/2)  # método 1
        hipotenusa = cat1_mais_cat2 ** 0.5  # método 2
        print(hipotenusa)
        ```
    1. Calcule a área de um triângulo de base 10 e altura 5.
        ```python
        base = 10
        altura = 5
        area = (base * altura) / 2
        print(area)
        ```
    1. Calcule o perímetro de um retângulo de base 9 e altura 4.
        ```python
        base = 9
        altura = 4
        perimetro = base * 2 + altura * 2
        print(perimetro)
        ```
    1. Calcule a área de um losango com diagonais 8 e 6.
        ```python
        diagonal1 = 8
        diagonal2 = 6
        area = diagonal1 * diagonal2 / 2
        print(area)
        ```
    1. Calcule o volume de um paralelepípedo de arestas 2, 3 e 5.
        ```python
        aresta1 = 2
        aresta2 = 3
        aresta3 = 5
        volume = aresta1 * aresta2 * aresta3
        print(volume)
        ```
1. Exercícios de Nível Intermediário
    1. Calcule a área de um trapézio com bases 7 e 5 e altura 4.
    1. Calcule o volume de uma esfera de raio 3 (use π = 3.14).
    1. Calcule a área lateral de um cilindro de raio 3 e altura 7 (use π = 3.14).
    1. Calcule o volume de um cone de raio 4 e altura 9 (use π = 3.14).
    1. Calcule a distância entre os pontos (1, 2) e (4, 6).
    1. Resolva a equação quadrática x² - 5x + 6 = 0 usando a fórmula de Bhaskara.
    1. Calcule a área de um hexágono regular de lado 6.
    1. Calcule o perímetro de um pentágono regular de lado 8.
    1. Calcule a área de um setor circular de raio 5 e ângulo 60° (use π = 3.14).
    1. Calcule o volume de um prisma de base triangular com lados 3, 4, 5 e altura 10.
1. Exercícios Avançados
    1. Calcule a área de um octógono regular de lado 7.
    1. Calcule a área total de um cilindro de raio 4 e altura 10 (use π = 3.14).
    1. Calcule o volume de uma pirâmide quadrangular de base 6 e altura 9.
    1. Calcule o comprimento da diagonal de um retângulo de lados 6 e 8.
    1. Calcule a área de um triângulo equilátero de lado 12.
    1. Calcule o volume de um tetraedro regular de aresta 5.
    1. Resolva a equação quadrática 2x² - 4x - 6 = 0 usando a fórmula de Bhaskara.
    1. Calcule a área de um polígono regular de 10 lados com lado 4.
    1. Calcule o volume de um cilindro de raio 5 e altura 12 (use π = 3.14).
    1. Calcule a distância entre os pontos (3, 5) e (9, 12).
1. Exercícios Complexos
    1. Calcule a área de um dodecágono regular de lado 8.
    1. Calcule o volume de uma esfera de raio 7 (use π = 3.14).
    1. Calcule a área de um triângulo isósceles de lados 10, 10 e 12.
    1. Calcule o volume de um tronco de cone com raios 5 e 3 e altura 8 (use π = 3.14).
    1. Resolva a equação quadrática 3x² - 12x + 9 = 0 usando a fórmula de Bhaskara.
    1. Calcule a área de um círculo inscrito em um triângulo de lados 6, 8 e 10 (use π = 3.14).
    1. Calcule o perímetro de um triângulo equilátero inscrito em um círculo de raio 6 (use π = 3.14).
    1. Calcule o volume de um prisma hexagonal de base 4 e altura 15.
    1. Calcule a área de um paralelogramo de base 9 e altura 6.
    1. Calcule a área total de um cone de raio 5 e geratriz 13 (use π = 3.14).
1. Exercícios Muito Complexos
    1. Calcule a área de um decágono regular de lado 10.
    1. Calcule o volume de uma pirâmide hexagonal de base 6 e altura 10.
    1. Calcule a área de um triângulo retângulo inscrito em um semicírculo de raio 8 (use π = 3.14).
        ```python
        # referência : http://www.osfantasticosnumerosprimos.com.br/005-texto-017-triangulos-pitagoricos-inscrito-semicircunferencia.html
        # todo triângulo retângulo inscrito em um semicírculo terá ângulos de 30, 60 e 90 graus.
        # SOHCAHTOA = sen=op/hip cos=ad/hip tan=op/ad
        # sen 30 graus = 1/2
        cat_op = (1/2) * 8
        cat_ad = ((3 ** (1/2)) / 2) * 8
        area = (cat_op * cat_ad) / 2
        print(area)
        ```
    1. Calcule o volume de um cilindro inscrito em um cubo de lado 10 (use π = 3.14).
    1. Resolva a equação quadrática x² - 4x - 12 = 0 usando a fórmula de Bhaskara.
    1. Calcule a área de um círculo circunscrito a um triângulo de lados 7, 24 e 25 (use π = 3.14).
    1. Calcule o volume de um dodecaedro regular de aresta 3.
    1. Calcule a área de um setor circular com raio 10 e ângulo 45° (use π = 3.14).
    1. Calcule a distância entre os pontos (2, -3) e (-4, 5).
    1. Calcule a área total de um cilindro inscrito em um cubo de lado 12 (use π = 3.14).

</details>

## tipo lógico

O tipo lógico, no Python, é conhecido como **Boolean**, que é representado por `bool`. Ele só pode ter dois valores, `True` e `False`, que são usados para representar a verdade ou falsidade de uma condição

| Operadores Lógicos |
| :----: |
| `not` |
| `and` |
| `or` |

| Operadores Relacionais | Função |
| :----: | :----: |
| `==` | igual a |
| `>` | maior que |
| `<` | menor que |
| `>=` | maior ou igual a |
| `<=` | menor ou igual a |
| `!=` | diferente de |

Veja abaixo alguns exemplos :

```python
print('not True = ', not True)
print('not False =', not False)

print('5 == 5 =', 5 == 5)
print('42 < 16 =', 42 < 16)
print('42 > 16 =', 42 > 16)
print('42 <= 42 =', 42 <= 42)
print('42 >= 43 =', 42 >= 43)
print('42 != 42 =', 42 != 42)

# usando para calcular média
media = (3 + 7 + 9) / 3
passou_de_ano = media >= 7
print('A aluno passou de ano?', passou_de_ano)
```

Índice Usando o Python

1. [pep 8](#pep-8)
1. [usando o python](#usando-o-python)
1. [interpretador python](#interpretador-python)
1. [módulo python](#módulo-python)
1. [explicando exemplos](#explicando-exemplos)
1. [comandos de saída e entrada de dados](#comando-de-saída-e-entrada-de-dados)
1. [comentários](#comentários)
1. [o que foi visto até agora](#o-que-foi-visto-até-agora)

# pep 8
Antes de iniciar o Python é preciso saber que existe a `PEP 8`.

A PEP 8 existe para melhorar a leitura do código Python. Uma vez o Guido van Rossum (autor do Python) disse que `um código é lido com muito mais frequência do que é escrito`.

Um código pode ser escrito em alguns minutos ou um dia inteiro, mas uma vez escrito, ele nunca mais terá que ser escrito novamente (muito provavelmente alterado em algum ponto). E DEFINITIVAMENTE ele terá que ser lido novamente. Pode ser difícil de relembrar o que um determinado trecho de código feito há alguns dias, semanas, meses ou até mesmo anos está fazendo se ele não estiver bem claro e documentado.

Seguir as orientações da PEP 8 ajuda a manter uma boa legibilidade das variáveis; saber que há espaço em branco suficiente para tornar o código mais fácil de ler; saber que os comentários são precisos e ajudam a lembrar o que ele faz. Além desses aspectos, também facilita para ler o código de outros programadores.

O manual de referência para todas essas boas práticas está documentado na [PEP 8 - Style Guide for Python Code](https://peps.python.org/pep-0008) (em inglês). PEP é uma abreviação de Python Enhancement Proposals (Propostas de Melhoramentos do Python).

Conforme novas funcionalidades do Python são apresentadas, sua respectiva PEP 8 será mostrada.

# usando o python
O Python pode ser utilizado de diversas formas.

As duas mais comuns são:
- [Interpretador Python](#interpretador-python) : ele é acessado pelo Prompt de Comando digitando python e também é conhecido como *Modo Interativo*;
- [Módulo Python](#módulo-python) : arquivo com extensão .py;

> [!TIP]
> Ative a visualização das extensões de arquivos de seu sistema operacional.
>
> [Como ativar no Windows](https://support.microsoft.com/pt-br/windows/extens%C3%B5es-de-nome-de-arquivo-comuns-no-windows-da4a4430-8e76-89c5-59f7-1cdbbc75cb01);
>
> [Como ativar no macOS](https://support.apple.com/pt-br/guide/mac-help/mchlp2304/mac);
>
> Como ativar no Linux : se usa Linux, provavelmente você já sabe como;

## interpretador python
Uma vez que o Python é instalado, é possível iniciar o interpretador através do terminal (Linux e macOS) ou Prompt de Comando (Windows). Para isso, basta realizar a chamada do python no shell.

Chamada do Python no Linux / macOS :
```shell
$ python
Python 3.12.3 (main, Apr 23 2024, 09:16:07) [GCC 13.2.1 20240417] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> |
```

Chamada do Python no Windows :
```powershell
C:\> python
Python 3.12.3 (tags/v3.12.2:6abddd9, Feb 6 2024, 21:26:36) [MSC v.1937 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>> |
```

Pode-se sair do interpretador digitando :
```shell
>>> quit()
```
ou
```shell
>>> exit()
```
ou ainda segurando as teclas `Ctrl + z` no Windows ou `Ctrl + d` no Linux/macOS;

Os recursos de edição de linha do interpretador incluem edição interativa, substituição de histórico e completamento de código.

Quando os comandos são lidos a partir do terminal/console, diz-se que o interpretador está em modo interativo. Nesse modo, ele solicita um próximo comando através do *prompt primário*, representado por três sinais de maior `>>>`; para linhas de continuação do comando atual, o *prompt secundário* padrão é formado por três pontos `...`.

Veja alguns exemplos de uso do interpretador :
```python
$ python
Python 3.12.3 (main, Apr 23 2024, 09:16:07) [GCC 13.2.1 20240417] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> 10
10
>>> 30 + 12
42
>>>
>>> 'um texto'
'um texto'
>>> "outro texto"
'outro texto'
>>>
>>> True is False
False
>>>
>>> 4/1 - 4/3 + 4/5 - 4/7 + 4/9 - 4/11
2.9760461760461765
>>>
>>> a_terra_eh_plana = True
>>> if a_terra_eh_plana:
...     print('Cuidado com o Cthulhu!')
...
Cuidado com o Cthulhu!
>>> |
```
Há também uma forma de executar comandos python diretamente do terminal (fora do interpretador), mas isso será visto mais adiante.

`PS.:` nos sistemas Linux e macOS pode haver uma diferença na versão do interpretador. Muitos pacotes antigos ainda presentes nesses sistemas são dependentes da versão 2 do Python para funcionar corretamente, número esse que diminui a cada ano. Por causa disso, em algumas versões mais antigas do Linux e do macOS ainda é necessário digitar `python3` para que a terceira versão seja executada e não a segunda.

## módulo python
Outra forma de usar o Python é através de arquivos com a extensão `.py`, que são chamados de *módulos* no Python.

Quando se usa um módulo Python, qualquer comando lá colocado é executado apenas quando ele é chamado após o `python` no terminal.

Por exemplo, imagine que há um módulo chamado `resposta.py` que, quando chamado, vai exibir uma pergunta e sua resposta.

Módulo `resposta.py` :
```python
valor = 42

print('Qual é a resposta da vida, do universo e tudo mais?')

if valor != 42:
    print('Resposta errada!')
else:
    print(f'A resposta é : {valor}')
```
Chamando o módulo `resposta.py` usando o interpretador python :
```shell
$ python resposta.py
Qual é a resposta da vida, do universo e tudo mais?
A resposta é : 42
```

## explicando exemplos
A partir de agora muitos exemplos serão mostrados. Qualquer exemplo mostrado em *Modo Interativo* também pode ser usado em um *módulo* Python.

Usando o módulo *main.py* e sua chamada pelo interpretador :
```python
# usando o módulo main.py
n_1 = 10
n_2 = 32

print(f'A expressão {n_1} + {n_2} é igual a {n_1 + n_2}.')
```
```shell
$ python main.py
A expressão 10 + 32 é igual a 42.
```

Usando o mesmo exemplo diretamente no interpretador :
```python
>>> # usando o Interpretador Python
>>> n_1 = 10
>>> n_2 = 32
>>>
>>> print(f'A expressão {n_1} + {n_2} é igual a {n_1 + n_2}.')
A expressão 10 + 32 é igual a 42.
>>>
>>> |
```

## comando de saída e entrada de dados

Os algoritmos precisam ser 'alimentados' com dados proveniente do meio externo para efetuarem as operações e cálculos que são necessários para alcançar algum objetivo. Com essa finalidade, utiliza-se comandos de entrada e saída. Por hora, o foco será na saída de dados.

### saída de dados

Para que um algoritmo em Python possa mostrar os dados que calculou dentro do módulo, usa-se o comando `print()`. Em português, pode ser lido como "imprimir" algo na tela.

Veja como fica :
```python
>>> nome = 'Arnoldão'
>>> print(nome)
Arnoldão
>>> print(10 + 32)
42
```

Esse comando, também permite mostrar mais de um objeto, desde que esteja separado por vírgula.
```python
>>> nome = 'Arnoldão'
>>> valor = 10
>>> print(nome, valor)
Arnoldão 10
>>> print(nome, 3.141592)
Arnoldão 3.141592
>>> print(52 - valor)
42
```

Ele também funciona no modo interativo, mostrando e executando alguns comandos de dentro da string, como a quebra de linha `\n`, por exemplo. Mais adiante isso será visto com mais detalhes.

## comentários
Quando se desenvolve códigos, é muito importante criar o hábito de manter seu código bem documentado. Deixar ele claro para outras pessoas e até para você mesmo do futuro quando precisa voltar e realizar alterações nele meses depois de criado.

Comentários em Python começam com o caractere cerquilha `#` e se estende até o final da linha. Um comentário pode aparecer no início da linha ou após espaço em branco ou código, mas não dentro de uma string literal. Nela, ele será interpretado como apenas mais um caractere da string.

Exemplos :
```python
>>> # este é o primeiro comentário
>>> num = 1 # e este é o segundo comentário
>>>         # ... e agora o terceiro!
>>> texto = '# isto não é um comentário porque está dentro das aspas'
>>> texto
'# isto não é um comentário porque está dentro das aspas'
```

### pep 8 - comentários
<details>
  <summary>Detalhes</summary>

Os comentários possuem 3 regras básicas :
- limite o tamanho da linha dos comentários e das strings de documentação em 79 caracteres;
- use frases completas, iniciando com letra maiúscula;
- tenha certeza de atualizar os comentários se o código for alterado;

Existem diversos tipos de comentários em Python. Conforme os estudos avançam, mais tipos serão vistos.

### comentários de linha
Comentários de linha explicam um único treco de código. São úteis para relembrar, ou explicar para outros desenvolvedores, porque certa linha de código é necessária.

A PEP 8 sugere que :
- use os comentários de linha com moderação;
- escreva o comentário do código na mesma linha a que se referem;
- separe os comentários de linha com dois ou mais espaços;
- inicie o comentário com um `#` e um simples espaço;
- não use para explicar o óbvio;

```python
>>> x = 5  # este é um comentário de linha
```

Às vezes, um nome de variavel pode servir melhor que um comentário :
```python
>>> x = 'Arnold Schwarzenegger'  # nome do ator
>>>
>>> nome_ator = 'Arnold Schwarzenegger'
```

Comentários de linha como o abaixo são uma má prática porque eles são óbvios e poluem o código :
```python
>>> lista_vazia = []  # inicializa uma lista vazia
>>>
>>> x = 5
>>> x = x * 5  # multiplica x por 5
```
</details>

## o que foi visto até agora

Até agora foram vistos os tipos primitivos, como declarar variáveis, constantes, como usar expressões aritméticas e lógicas, parênteses, comandos de atribuição e comentários.

Tudo o que foi visto pode ser usado diretamente no Interpretador do Python.

<details>
  <summary>Lista de Exercícios</summary>

Refaça todos os exercícios do arquivo [tipos-primitivos](tipos-primitivos.md#expressões-aritméticas) a partir das expressões aritméticas, mas agora usando o interpretador do Python.

Use um ou mais módulos Python para salvar a execução de seus códigos.

</details>
# arquivos

O processo de leitura de arquivos no Python envolve abrir um arquivo, ler seu conteúdo e, em seguida, fechá-lo. Python oferece diferentes modos de leitura, como `r` para leitura, `w` para escrita, e `a` para adicionar conteúdo. O processo é realizado por meio da função `open()`, que retorna um objeto de arquivo, usado para manipular o conteúdo.

Exemplo básico :

```python
with open('arquivo.txt', 'r') as arquivo:
    conteudo = arquivo.read()
    print(conteudo)
```

Neste exemplo, o comando `with` garante que o arquivo seja fechado corretamente após sua utilização, mesmo em caso de erro. Mais adiante isso será visto com detalhes.

## pontos importantes

### finalidades :
- **processamento de dados** : utilizado para ler dados de arquivos de texto, csvs, logs, etc., e manipulá-los no código;
- **entrada e saída de dados** : permite salvar e carregar informações persistentes, facilitando o armazenamento de resultados ou configurações;

### vantagens :
- **simplicidade** : a leitura de arquivos é direta e fácil de implementar;
- **flexibilidade** : python pode manipular diversos tipos de arquivos (texto, binários, csv, json, etc.);
- **automação**: pode ser usada para automatizar tarefas que envolvem manipulação de dados em massa;

### desvantagens :
- **limitação de memória** : carregar arquivos grandes pode consumir muita memória, afetando o desempenho;
- **erro de codificação** : arquivos podem ter diferentes codificações (ex.: utf-8, ascii), e erros podem ocorrer ao ler arquivos com codificação incorreta;

### cuidados :
- **fechar o arquivo** : sempre garantir que o arquivo seja fechado após a leitura para evitar corrupção de dados ou consumo desnecessário de recursos;
- **exceções** : tratar exceções, como erros de arquivo não encontrado (`FileNotFoundError`) ou de permissões de leitura;
- **codificação** : verificar e definir corretamente a codificação ao abrir o arquivo;

Esses são os pontos essenciais para uma leitura segura e eficiente de arquivos em Python.

## `open()`

A função `open()` no Python é usada para abrir arquivos e manipular dados dentro deles. Essa função cria um objeto que permite que se leia, escreva ou adicione informações a um arquivo de texto ou binário. O uso de `open()` envolve a especificação de um caminho de arquivo e, opcionalmente, um modo de operação (como leitura ou escrita).

Veja sua sinxtaxe básica :

```python
arquivo = open('caminho_do_arquivo', 'modo')
```

A função `open()` retorna um objeto de arquivo que pode ser manipulado para realizar operações como leitura (`read`), escrita (`write`) ou adição de conteúdo (`append`), dependendo do modo escolhido.

### modos mais comuns:

1. **`'r'`** (leitura) : abre um arquivo para leitura. este é o modo padrão. o arquivo deve existir; caso contrário, um erro será gerado;
1. **`'w'`** (escrita) : abre um arquivo para escrita; se o arquivo não existir, ele será criado; se o arquivo já existir, o conteúdo será sobrescrito;
1. **`'a'`** (anexar) : abre o arquivo para anexar dados no final do arquivo. se o arquivo não existir, ele será criado;

### modos do `open()`

O Python possui diversas formas de abrir um arquivo. Abaixo há as formas mais comuns.

| Modo | Uso                                  | Comportamento                                          |
|------|--------------------------------------|--------------------------------------------------------|
| `r`  | leitura                              | abre o arquivo para leitura; gera erro se não existir; |
| `w`  | escrita (sobrescreve)                | abre o arquivo para escrita; cria ou sobrescreve.      |
| `a`  | anexar                               | abre o arquivo para anexar dados; cria se não existir; |

#### 1. modo de leitura `r`

O modo `r` é usado para **abrir um arquivo para leitura**. Quando um arquivo é aberto nesse modo, ele deve **existir previamente**, caso contrário, um erro será gerado (`FileNotFoundError`). O ponteiro do arquivo (a posição de leitura) começa no início do arquivo.

Veja sua sintaxe :

```python
arquivo = open('exemplo.txt', 'r')
conteudo = arquivo.read()  # lê todo o conteúdo do arquivo
arquivo.close()  # fecha o arquivo após a leitura
```

##### exemplo

Suponha que exista um arquivo `dados.txt` com o seguinte conteúdo :

```
Python é uma linguagem de programação.
Ela é poderosa e fácil de aprender.
```

Agora, vamos abrir esse arquivo e ler seu conteúdo :

```python
# abrindo o arquivo para leitura
arquivo = open('dados.txt', 'r')

conteudo = arquivo.read()  # lendo o conteúdo do arquivo

print(f'{conteudo = }')  # exibe o conteúdo no terminal
arquivo.close()  # fecha o arquivo
```

Se o arquivo `dados.txt` não existir, o Python levantará uma exceção :

```python
FileNotFoundError: [Errno 2] No such file or directory: 'dados.txt'
```

#### 2. modo de escrita `w`

O modo `w` é usado para **abrir um arquivo para escrita**. Esse modo **sobrescreve** o conteúdo do arquivo caso ele já exista. Se o arquivo **não existir**, ele será criado automaticamente. O ponteiro de escrita começa no início do arquivo.

Veja sua sintaxe :
```python
arquivo = open('exemplo.txt', 'w')
arquivo.write("Escrevendo algo no arquivo.")  # escreve no arquivo
arquivo.close()  # fecha o arquivo após a escrita
```

##### exemplo

Se deseja criar ou sobrescrever o arquivo `saida.txt` com o texto `"Aprendendo a escrever em arquivos!"`, pode usar o seguinte código :

```python
# abrindo o arquivo para escrita
arquivo = open('saida.txt', 'w')
arquivo.write("Aprendendo a escrever em arquivos!")  # escreve no arquivo
arquivo.close()  # fecha o arquivo
```

Se o arquivo `saida.txt` já existia e tinha algum conteúdo, todo o conteúdo anterior será apagado e substituído pela nova string.

#### 3. modo de anexar `a`

O modo `a` é usado para **abrir um arquivo e anexar dados ao final** do arquivo. Esse modo é útil quando se quer adicionar dados a um arquivo sem sobrescrever o conteúdo existente. Se o arquivo **não existir**, ele será criado. O ponteiro de escrita começa no **final** do arquivo, ou seja, novos dados são sempre adicionados após o conteúdo existente.

Veja sua sintaxe básica :

```python
arquivo = open('exemplo.txt', 'a')
arquivo.write("Adicionando uma nova linha.")  # anexa dados ao arquivo
arquivo.close()  # fecha o arquivo
```

##### exemplo

Se deseja adicionar novas entradas a um arquivo `log.txt`, sem apagar as entradas anteriores, pode usar o modo `a`:

```python
# abrindo o arquivo para anexar dados
arquivo = open('log.txt', 'a')
arquivo.write("Nova entrada de log.\n")  # anexa ao arquivo
arquivo.close()  # Fecha o arquivo
```

Isso adicionará a frase `"Nova entrada de log."` ao final do arquivo. Se executar o programa várias vezes, ele continuará adicionando essa frase ao final do arquivo, sem remover os dados anteriores.


## métodos do arquivo

A função `open()` em Python retorna um objeto de arquivo, que possui vários métodos para manipular seu conteúdo. Dentre os mais importantes, há os métodos `read()`, `readline()`, `readlines()`, `write()` e `writelines()`.

### `read()`

O método `read()` lê o conteúdo de um arquivo inteiro (ou parte dele, dependendo dos parâmetros passados).

Veja sua sintaxe :

```python
conteudo = arquivo.read(tamanho)
```

- **tamanho** (opcional): é o número de caracteres ou bytes a serem lidos; se omitido, `read()` lê o arquivo inteiro;

#### exemplo

```python
arquivo = open('exemplo.txt', 'r')

# lendo todo o conteúdo do arquivo
conteudo = arquivo.read()
print(conteudo)

arquivo.close()
```

Se o arquivo `exemplo.txt` contiver :
```
Primeira linha
Segunda linha
Terceira linha
```

A saída será :
```
Primeira linha
Segunda linha
Terceira linha
```

#### lendo parte do arquivo :

É possível especificar quantos caracteres ler com o argumento `tamanho`. Por exemplo:

```python
arquivo = open('exemplo.txt', 'r')

# lendo apenas os primeiros 10 caracteres
conteudo = arquivo.read(10)
print(conteudo)

arquivo.close()
```

Se o conteúdo do arquivo for o mesmo, a saída será :
```
Primeira
```

Aqui, foram lidos os primeiros 10 caracteres do arquivo.

### `readline()`

O método `readline()` lê **uma linha** do arquivo por vez. Ele é útil quando se deseja processar o arquivo linha por linha.

Veja sua sintaxe :

```python
linha = arquivo.readline(tamanho)
```

- **tamanho** (opcional) : limita o número máximo de caracteres a serem lidos da linha;

#### exemplo

```python
arquivo = open('exemplo.txt', 'r')

# lendo a primeira linha do arquivo
linha = arquivo.readline()
print(linha)

arquivo.close()
```

Se o arquivo contiver :
```
Primeira linha
Segunda linha
Terceira linha
```

A saída será :
```
Primeira linha
```

#### lendo todas as linhas com `readline()`

Se quiser ler todas as linhas do arquivo, pode usar um loop :

```python
arquivo = open('exemplo.txt', 'r')

linha = arquivo.readline()
while linha:
    print(linha, end='')  # end='' evita uma linha extra ao final
    linha = arquivo.readline()

arquivo.close()
```

A saída será:
```
Primeira linha
Segunda linha
Terceira linha
```

#### limitando o número de caracteres por linha

É possível limitar o número de caracteres que serão lidos por linha :

```python
arquivo = open('exemplo.txt', 'r')

# lendo apenas os primeiros 8 caracteres da primeira linha
linha = arquivo.readline(8)
print(linha)

arquivo.close()
```

Isso resultará em:
```
Primeira
```

### `readlines()`

O método `readlines()` lê **todas as linhas do arquivo de uma só vez** e as armazena em uma **lista**, onde cada linha é um elemento.

Veja sua sintaxe :

```python
linhas = arquivo.readlines()
```

#### exemplo
```python
arquivo = open('exemplo.txt', 'r')

# lendo todas as linhas do arquivo
linhas = arquivo.readlines()

# imprimindo a lista de linhas
print(linhas)

arquivo.close()
```

Se o arquivo contiver :

```
Primeira linha
Segunda linha
Terceira linha
```

A saída será :

```python
['Primeira linha\n', 'Segunda linha\n', 'Terceira linha\n']
```

Aqui, cada linha do arquivo se torna um item da lista. Note que os caracteres de nova linha (`\n`) são preservados.

Logo, é possível iterar sobre essa lista para processar cada linha individualmente :

```python
arquivo = open('exemplo.txt', 'r')

# lendo todas as linhas do arquivo
linhas = arquivo.readlines()

# iterando sobre as linhas e imprimindo uma a uma
for linha in linhas:
    print(linha, end='')

arquivo.close()
```

Isso exibirá :

```
Primeira linha
Segunda linha
Terceira linha
```

### `readline()` vs `readlines()`

Em suma :

- `readline()` lê **uma linha** por vez;
- `readlines()` lê **todas as linhas** de uma vez e as retorna como uma lista;

### `write()`

O método `write()` é usado para **escrever dados em um arquivo**. Pode ser utilizado em modos de escrita (`'w'`, `'a'`, `'w+'`, `'a+'`, etc.). Lembre-se de que o método **não adiciona automaticamente uma nova linha**, então precisará incluir `\n` manualmente se quiser pular linhas.

Veja a sintaxe :

```python
arquivo.write(texto)
```

- **texto**: é o conteúdo que você deseja escrever no arquivo. deve ser uma string;

#### exemplo

```python
arquivo = open('exemplo.txt', 'w')

# escrevendo texto no arquivo
arquivo.write("Primeira linha\n")
arquivo.write("Segunda linha\n")

arquivo.close()
```

Aqui :
- o arquivo `exemplo.txt` será sobrescrito (ou criado se não existir);
- o método `write()` insere as linhas fornecidas no arquivo;
- o `\n` é necessário para garantir que cada linha seja escrita em uma nova linha no arquivo;

#### exemplo

Se quiser **anexar** (adicionar) novas informações ao final de um arquivo, pode abrir o arquivo no modo de anexar (`'a'`) :

```python
arquivo = open('exemplo.txt', 'a')

# adicionando uma nova linha ao final do arquivo
arquivo.write("Terceira linha adicionada\n")

arquivo.close()
```

Isso não sobrescreverá o conteúdo existente, mas adicionará a nova linha ao final do arquivo.

#### importante :

- o método `write()` **não adiciona quebras de linha automaticamente**; portanto, se quiser que o texto vá para a próxima linha, adicione `\n` no final da string que está escrevendo;
- se usar o modo `'w'`, o arquivo será **sobrescrito**; todo o conteúdo anterior será apagado;

### `writelines()`

O método `writelines()` em Python é usado para **escrever uma sequência de strings** em um arquivo de uma só vez. A sequência pode ser uma lista, tupla ou qualquer objeto iterável que contenha strings.

Diferentemente do método `write()`, que escreve uma única string de cada vez, o `writelines()` permite escrever várias linhas de uma só vez, **sem adicionar automaticamente quebras de linha** (`\n`). Se quiser que cada linha seja escrita em uma nova linha no arquivo, precisará incluir manualmente o caractere de nova linha (`\n`) ao final de cada string da sequência.

Veja a sintaxe :

```python
arquivo.writelines(iteravel)
```

- **iterável**: um objeto que contém múltiplas strings, como uma lista ou tupla;

#### exemplo :

Aqui está um exemplo de como usar `writelines()` para escrever várias linhas em um arquivo :

```python
# abrindo o arquivo no modo de escrita
arquivo = open('exemplo.txt', 'w')

# lista de linhas para serem escritas
linhas = ["Primeira linha\n", "Segunda linha\n", "Terceira linha\n"]

# escrevendo todas as linhas no arquivo de uma vez
arquivo.writelines(linhas)

# fechando o arquivo
arquivo.close()
```

Neste exemplo :
- o arquivo `exemplo.txt` será criado ou sobrescrito;
- as três linhas da lista `linhas` são escritas de uma só vez no arquivo;
- note que cada string na lista termina com `\n` para garantir que as linhas sejam separadas no arquivo;

#### importante

O método `writelines()` **não adiciona automaticamente quebras de linha** (`\n`). Se as strings no iterável não tiverem `\n`, elas serão escritas consecutivamente, sem separação.

```python
arquivo = open('exemplo.txt', 'w')

# lista de linhas sem \n
linhas = ["Primeira linha", "Segunda linha", "Terceira linha"]

# escrevendo todas as linhas no arquivo
arquivo.writelines(linhas)

arquivo.close()
```

Neste caso, o conteúdo do arquivo será :

```
Primeira linhaSegunda linhaTerceira linha
```

#### iteráveis além de listas

É também possível usar qualquer objeto iterável que contenha strings, como uma tupla ou até um gerador.

#### exemplo com uma tupla

```python
arquivo = open('exemplo.txt', 'w')

# tupla de strings
linhas = ("Linha 1\n", "Linha 2\n", "Linha 3\n")

arquivo.writelines(linhas)

arquivo.close()
```

#### exemplo com um gerador

```python
arquivo = open('exemplo.txt', 'w')

# gerador de strings
linhas = (f"Linha {i}\n" for i in range(1, 4))

arquivo.writelines(linhas)

arquivo.close()
```

## `close()`

O método **`close()`** em Python é utilizado para **fechar um arquivo** que foi previamente aberto. Quando um arquivo é aberto com a função `open()`, ele ocupa recursos do sistema, como memória e descritores de arquivo, e precisa ser fechado para liberar esses recursos corretamente. Além disso, ao fechar um arquivo, todas as operações de leitura e escrita pendentes são finalizadas e os dados são garantidamente gravados no disco.

### detalhes

- **liberação de recursos**: fechar o arquivo libera os recursos do sistema operacional associados a ele. Se um arquivo permanecer aberto por muito tempo, especialmente em grandes aplicações, isso pode resultar em esgotamento de descritores de arquivo, levando a erros;

- **garantia de gravação completa**: para arquivos abertos para escrita, o método `close()` assegura que qualquer dado pendente seja gravado corretamente no disco. Se o arquivo não for fechado após a escrita, algumas mudanças podem não ser aplicadas (especialmente se os dados estiverem armazenados em buffers temporários);

- **após fechar o arquivo**: uma vez que o arquivo é fechado, não é possível realizar mais operações de leitura ou escrita até que ele seja reaberto;

### exemplo

```python
# abrindo um arquivo para escrita
arquivo = open('exemplo.txt', 'w')

# escrevendo dados no arquivo
arquivo.write("Este é um exemplo de uso do método close.\n")

# fechando o arquivo após a escrita
arquivo.close()
```

Aqui :
- o arquivo `exemplo.txt` foi aberto no modo de escrita (`'w'`);
- foi escrita uma linha de texto no arquivo;
- foi usado o método `arquivo.close()` para fechar o arquivo e garantir que os dados sejam salvos corretamente;

### efeitos de não fechar o arquivo

Se o método `close()` não for usado, pode causar problemas em certos cenários :

1. **dados não gravados** : no caso de operações de escrita, se o arquivo não for fechado, o python pode não gravar os dados imediatamente no arquivo físico; isso ocorre porque os sistemas operacionais frequentemente armazenam dados temporariamente em um buffer para otimizar o desempenho. o `close()` força a gravação final desses dados no disco.

Exemplo :

```python
arquivo = open('exemplo.txt', 'w')
arquivo.write("Texto sem fechar o arquivo.")
# Sem o close(), o texto pode não ser gravado completamente no arquivo.
```

2. **vazamento de recursos** : não fechar um arquivo pode levar a um vazamento de descritores de arquivo, especialmente em sistemas que têm um limite sobre o número de arquivos que podem ser abertos simultaneamente; isso pode resultar em erros ao tentar abrir novos arquivos.

3. **erros ao tentar acessar um arquivo já fechado** : se tentar ler ou escrever em um arquivo após tê-lo fechado, o python gerará um erro.

Exemplo :

```python
arquivo = open('exemplo.txt', 'r')
arquivo.close()
conteudo = arquivo.read()  # Tentativa de ler após fechar o arquivo
```

O Python levantará um erro `ValueError` :

```
ValueError: I/O operation on closed file.
```

### importância de `close()` com grandes volumes de dados

Quando trabalha com arquivos grandes ou abre muitos arquivos em sequência, o fechamento adequado dos arquivos torna-se ainda mais crítico. Manter arquivos abertos sem fechá-los pode resultar em erros como:

- **`OSError: Too many open files`** : se muitos arquivos forem abertos ao mesmo tempo sem serem fechados, o sistema pode esgotar seu limite de descritores de arquivo, o que gera este erro; fechar os arquivos conforme eles são usados ajuda a evitar esse problema.


## exercícios

<details>
<summary>Lista de Exercícios</summary>

1. exercícios sobre o método `read()`
    1. Abra um arquivo de texto chamado `dados.txt` e use o método `read()` para ler todo o conteúdo. Exiba o conteúdo no terminal.
    1. Crie um arquivo chamado `historico.txt`, escreva nele cinco frases e leia todo o conteúdo usando `read()`. Exiba as frases lidas.
    1. Abra o arquivo `historico.txt` e leia os primeiros 20 caracteres do arquivo usando `read()`. Exiba os caracteres no terminal.
    1. Crie um arquivo `poema.txt` com três estrofes de um poema. Use `read()` para ler todo o poema e exibi-lo no terminal.
    1. Crie um programa que abre o arquivo `numeros.txt` e usa `read()` para ler todo o conteúdo. Depois, converta o texto em uma lista de inteiros.
    1. Abra o arquivo `paragrafo.txt` contendo um parágrafo de texto e leia os primeiros 50 caracteres com `read()`.
    1. Crie um arquivo `livro.txt` contendo três capítulos de um livro. Leia o primeiro capítulo (considerando 1000 caracteres) com o método `read()`.
    1. Escreva um programa que lê o conteúdo completo de um arquivo `mensagem.txt` e conta o número de palavras usando `read()`.
    1. Crie um arquivo `diario.txt` e escreva 5 entradas de diário. Depois, leia e exiba as duas primeiras entradas (aproximadamente 100 caracteres) usando `read()`.
    1. Crie um arquivo `contos.txt` e escreva dois contos curtos. Use o método `read()` para ler o primeiro conto (aproximadamente 500 caracteres).
1. exercícios sobre o método `readline()`
    1. Crie um arquivo `compras.txt` com uma lista de compras (uma por linha). Leia e exiba a primeira linha usando o método `readline()`.
    1. Abra o arquivo `compras.txt` e use `readline()` para ler e exibir as três primeiras linhas.
    1. Crie um programa que abra o arquivo `agenda.txt` e use `readline()` para ler cada linha individualmente, mostrando o conteúdo no terminal.
    1. Abra o arquivo `alunos.txt`, que contém o nome de 10 alunos, e leia o nome do primeiro aluno usando `readline()`.
    1. Crie um programa que abra o arquivo `mensagens.txt` e leia cada linha usando um loop `while` até o final do arquivo, exibindo cada mensagem no terminal.
    1. Abra o arquivo `livros.txt` contendo uma lista de livros. Use `readline()` para ler e exibir o título do segundo livro.
    1. Crie um arquivo `tarefas.txt` com 5 tarefas diárias. Use `readline()` para ler e exibir todas as tarefas uma a uma em um loop.
    1. Crie um programa que leia as primeiras três linhas de um arquivo `nomes.txt` e exiba os nomes no terminal.
    1. Abra um arquivo `frases.txt` e leia frases usando `readline()`. Exiba apenas as frases que contêm mais de 50 caracteres.
    1. Crie um programa que leia um arquivo `receitas.txt` e use `readline()` para exibir uma receita de cada vez.
1. exercícios sobre o método `readlines()`
    1. Abra um arquivo `notas.txt` contendo as notas de 10 alunos, uma por linha. Use `readlines()` para ler todas as linhas de uma vez e exiba-as como uma lista.
    1. Crie um arquivo `filmes.txt` com 5 títulos de filmes, um por linha. Use `readlines()` para ler e exibir todos os títulos no terminal.
    1. Abra o arquivo `tarefas.txt`, use `readlines()` para ler todas as tarefas de uma vez e exiba a terceira tarefa da lista.
    1. Crie um arquivo `produtos.txt` com uma lista de produtos. Use `readlines()` para ler todos os produtos e depois exiba-os em ordem reversa.
    1. Escreva um programa que abre um arquivo `frases.txt`, leia todas as frases com `readlines()` e exiba apenas as frases que têm mais de 20 caracteres.
    1. Crie um arquivo `contatos.txt` com nomes e números de telefone, um por linha. Use `readlines()` para armazenar os contatos em uma lista.
    1. Abra o arquivo `livros.txt`, leia todas as linhas com `readlines()` e exiba o número total de linhas lidas.
    1. Crie um arquivo `dicionario.txt` com palavras e seus significados, uma por linha. Use `readlines()` para ler todas as palavras e exibi-las em formato de lista.
    1. Abra um arquivo `amigos.txt` e use `readlines()` para ler todos os nomes. Em seguida, exiba o primeiro e o último nome da lista.
    1. Crie um programa que leia todas as linhas de um arquivo `dados.txt` com `readlines()` e armazene-as em uma lista. Em seguida, itere sobre a lista e exiba cada linha com seu número de linha correspondente.
1. exercícios sobre o método `write()`
    1. Crie um arquivo `saida.txt` e escreva a frase "Python é incrível!" usando o método `write()`.
    1. Crie um programa que abre ou cria um arquivo `registro.txt` e usa o método `write()` para adicionar a frase "Registro de atividades".
    1. Escreva um programa que crie um arquivo `numeros.txt` e adicione os números de 1 a 10, cada número em uma linha, usando o método `write()`.
    1. Crie um arquivo `diario.txt` e use `write()` para adicionar uma entrada de diário contendo a data e um texto qualquer.
    1. Abra ou crie um arquivo `notas.txt` e escreva as notas de três matérias usando o método `write()`.
    1. Crie um arquivo `tarefa.txt` e use `write()` para adicionar três tarefas diárias. Certifique-se de usar `\n` para separar as tarefas em linhas diferentes.
    1. Abra o arquivo `mensagem.txt` e use `write()` para sobrescrever seu conteúdo com a frase "Novo conteúdo escrito com write()".
    1. Crie um arquivo `historico.txt` e use `write()` para registrar o histórico de eventos, escrevendo uma nova linha a cada execução.
    1. Escreva um programa que abra um arquivo `log.txt` e use `write()` para registrar a hora atual do sistema a cada execução do programa.
    1. Crie um arquivo `lista_de_compras.txt` e use o método `write()` para adicionar 5 itens de compras. Cada item deve estar em uma linha separada.
1. Exercícios sobre o Método `writelines()`
    1. Crie um arquivo `nomes.txt` e use o método `writelines()` para escrever uma lista de nomes (cada nome em uma linha).
    1. Crie um arquivo `numeros.txt` e use `writelines()` para escrever os números de 1 a 10, cada um em uma linha separada.
    1. Crie um programa que abre ou cria um arquivo `agenda.txt` e usa `writelines()` para adicionar três compromissos, cada um em uma linha.
    1. Crie um arquivo `tarefas.txt` e use `writelines()` para adicionar cinco tarefas de uma lista, cada tarefa em uma linha separada.
    1. Escreva um programa que cria ou abre um arquivo `cidades.txt` e usa `writelines()` para adicionar o nome de três cidades, cada uma em uma linha.
    1. Crie um arquivo `frutas.txt` e use `writelines()` para adicionar o nome de cinco frutas em uma lista, cada nome em uma linha.
    1. Abra ou crie um arquivo `enderecos.txt` e use `writelines()` para adicionar três endereços, cada um em uma linha.
    1. Escreva um programa que cria um arquivo `historico.txt` e usa `writelines()` para adicionar três eventos, cada evento em uma linha separada.
    1. Crie um programa que abre o arquivo `receitas.txt` e usa `writelines()` para adicionar três receitas, cada receita em uma linha separada.
    1. Crie um arquivo `projetos.txt` e use `writelines()` para adicionar os títulos de três projetos de uma lista, cada título em uma linha.

</details>
# avaliação

## validando cpf

O CPF, ou Cadastro de Pessoas Físicas, é um documento emitido pela Receita Federal do Brasil que serve para identificar os contribuintes brasileiros, tanto residentes no país quanto no exterior. Ele é essencial para diversas atividades, como abrir contas bancárias, declarar imposto de renda, realizar compras a crédito, entre outras.

O CPF é composto por 11 dígitos numéricos, geralmente formatados como `XXX.XXX.XXX-YY`, onde `XXX.XXX.XXX` são os números do CPF propriamente ditos e `YY` são os dígitos verificadores, usados para validar a autenticidade do número.

O algoritmo de validação do CPF calcula o primeiro dígito verificador a partir dos 9 primeiros dígitos do CPF, e em seguida, calcula o segundo dígito verificador a partir dos 9 (nove) primeiros dígitos do CPF, mais o primeiro dígito, obtido na primeira parte.

Para explicar bem o processo de validação, vai ser usado como exemplo o CPF fictício, mas válido : `111.444.777-35`.

## cálculo dos dígitos

### cálculo do primeiro dígito

Para validar um CPF, é preciso começar com o calculo do primeiro dígito verificador. Para isso, é preciso separar os 9 primeiros dígitos do CPF (111444777) e multiplicar cada um dos números, da esquerda para a direita por números decrescentes a partir do 10.

Veja a tabela abaixo :

> | Dígito CPF|| Multiplicador|| Resultado |
> | :----: | :----: | :----: | :----: | :----: |
> ||||||
> | `1` | * | `10` | = | `10` |
> | `1` | * | `9` | = | `9` |
> | `1` | * | `8` | = | `8` |
> | `4` | * | `7` | = | `28` |
> | `4` | * | `6` | = | `24` |
> | `4` | * | `5` | = | `20` |
> | `7` | * | `4` | = | `28` |
> | `7` | * | `3` | = | `21` |
> | `7` | * | `2` | = | `14` |
> ||||||

Cada dígito do CPF é multiplicado pelo respectivo número. Depois todos os resultados são somados :

> `10` + `9` + `8` + `28` + `24` + `20` + `28` + `21` + `14` = `162`

A partir do resultado obtido na soma, é realizada uma divisão por `11`. Esse cálculo irá gerar um quociente e um resto inteiros. Então, dividir `162` por `11` irá gerar um quociente igual a `14` e um resto igual `8`.

A partir desse resultado, é feita a seguinte avaliação :
- se o resto da divisão for `menor que 2`, então o primeiro dígito é igual a `zero`;
- se o resto da divisão for `maior ou igual a 2`, então o dígito verificador é igual a `11 menos o resto da divisão`;

No exemplo, o resto obitido foi oito, logo o primeiro dígito verificador é o onze menor o resto :

> `11 - 8 = 3`

O primeiro dígito verificador é `3`.

### cálculo do segundo dígito

Para calcular o segundo dígito, é necessário já saber qual é o primeiro digito calculado. O mesmo processo de multiplicação e soma terá que ser realizado, mas dessa vez é incluído o recém calculado primeiro dígito verificador ao final. E, em vez de iniciar a multiplicação em 10 e decrescer até o 2, é iniciado em `11` e decrescendo ainda até o 2.

Veja a tabela abaixo :

> | Dígito CPF|| Multiplicador|| Resultado |
> | :----: | :----: | :----: | :----: | :----: |
> ||||||
> | `1` | * | `11` | = | `11` |
> | `1` | * | `10` | = | `10` |
> | `1` | * | `9` | = | `9` |
> | `4` | * | `8` | = | `32` |
> | `4` | * | `7` | = | `28` |
> | `4` | * | `6` | = | `24` |
> | `7` | * | `5` | = | `35` |
> | `7` | * | `4` | = | `28` |
> | `7` | * | `3` | = | `21` |
> | `3` | * | `2` | = | `6` |
> ||||||

Novamente é efetuada a soma dos resultados da multiplicação :

> `11` + `10` + `9` + `32` + `28` + `24` + `35` + `28` + `21` + `6` = `204`

E novamente o total do somatório é dividido por onze para obter o quociente `18` e o resto `6` da divisão.

Uma vez conhecidos o resto e o quociente, o mesmo teste do resto é realizado :
- se o resto da divisão for `menor que 2`, então o primeiro dígito é igual a `zero`;
- se o resto da divisão for `maior ou igual a 2`, então o dígito verificador é igual a `11 menos o resto da divisão`;

No exemplo, subtraindo 11 do resto resultará em :

> `11 - 6 = 5`

Logo, `5` é o segundo dígito verificador.

### testando

Agora que ambos os dígitos são conhecidos (`3` e `5`), é possível validar o CPF.

Para isso, é necessário comparar os dígitos primeiro e segundo com o CPF a ser validado, o `111.444.777-35` deste exemplo. Se o primeiro dígito for igual ao penúltimo número do CPF e o segundo dígito for igual ao último número do CPF, então ele é válido. Se qualquer um deles for diferente, então o CPF é inválido.

Por exemplo :
- 111.444.777-35 é válido;
- 111.444.777-36 é inválido;

## cpfs inválidos

Alguns CPFs podem passar na validação, mas não são considerados inválidos.

São os CPFs com dígitos repetidos, como `111.111.111-11`, `222.222.222-22`, `333.333.333-33`, etc.

Então, seu código deve ignorar os CPFs acima e avisar ao usuário de sua invalidade.

## entrada de dados

Seu programa deverá pedir **vários** CPFs ao usuário.

Os formatos possíveis para um CPF digitado podem ser `XXX.XXX.XXX-YY`, `XXXXXXXXXYY`, `XXX.XXX.XXXYY`, etc. Não podem ser aceitos caracteres alfanuméricos e caracteres especiais, com exceção do ponto `.` e do traço `-`. Para interromper a digitação dos CPFs o usuário precisará digitar `sair` em vez de um CPF.

Após receber o CPF, seu programa deverá mostrar uma das mensagens abaixo :
- *O CPF digitato está em um formato inválido*, caso tenha sido digitado letras;
- *O CPF <cpf_digitado> é inválido!*, se os dígitos verificadores forem diferentes dos dois últimos números do CPF;
- *O CPF <cpf_digitado> é válido!*, se os dígitos verificadores forem iguais dos dois últimos números do CPF;

O campo <cpf_digitado> deverá estar no formato `XXX.XXX.XXX-YY`, independente de como ele foi digitado pelo usuário.

## mensagens

Crie mensagens de boas vindas e de encerramento para seu programa.

## otimização

Use funções para otimizar seu programa.

Embora o código da soma dos dígitos do CPF e da validação dos dígitos verificadores possa ser feito em uma função cada, isso não será obrigatório para seu programa. Crie funções para deixar seu programa organizado e mais eficiente.

Seu programa deverá, **por hora**, possuir ao menos 4 funções.

### módulos

Para melhor organização do software, organize seu programa em ao menos 2 módulos. Um deles conterá as funções e variáveis de seu programa e o outro será o módulo principal, que ficará responsável pela execução do programa, chamado de `main.py`.

## o que usar

> [!CAUTION]
> Apenas os conteúdos vistos em aula (que estão neste repositório) são permitidos para a realização do código.
> Se algum material fora deste repositório for usado, ***`TODO`*** o código será invalidado e o aluno estará sugeito à **recuperação**.

## checklist

Abaixo há uma lista de todos os pontos que devem ser realizados.
Lista essa que irá aumentar quando novos conteúdos forem apresentados em aula.

Lista :

Parte 1
- [ ] receber um CPF do usuário;
- [ ] validar o CPF digitado (só pode possuir números, pontos e traço);
- [ ] mostrar uma mensagem informando se o CPF está em formato inválido;
- [ ] encontrar o primeiro dígito verificador;
- [ ] usar o primeiro dígito encontrado para o cálculo do segundo dígito verificador;
- [ ] encontrar o segundo dígito verificador;
- [ ] comparar os dois dígitos encontrados com os dois últimos números do CPF;
- [ ] mostrar o CPF digitado no formato XXX.XXX.XXX-YY;
- [ ] mostrar uma mensagem informando se o CPF digitado é válido ou inválido;

Parte 2
- [ ] receber diversos CPFs do usuário sem interromper o programa;
- [ ] rejeitar CPFs com dígitos iguais;

Parte 3
- [ ] mensagem de boas vindas;
- [ ] função para receber e validar o CPF;
- [ ] função para calcular a soma dos dígitos verificadores (uma função para ambas as somas);
- [ ] função para realizar os testes dos dígitos verificadores (uma função para ambos os testes);
- [ ] mensagem ao finalizar;

Parte 4
- [ ] organize seu programa em ao menos dois módulos;
- [ ] um módulo será de auxiliar, onde terá as funções e variáveis;
- [ ] o outro será o principal e deverá ser chamado de `main.py`, onde o programa será executado;
Índice

1. [conceito de namespace](#conceito-de-namespace)
1. [tipos de namespaces](#tipos-de-namespaces)
    1. [1. namespace local](#1-namespace-local)
    1. [2. namespace global](#2-namespace-global)
    1. [3. namespace built-in](#3-namespace-built-in)
1. [hierarquia dos namespaces](#hierarquia-dos-namespaces)
1. [modificando variáveis globais dentro de funções](#modificando-variáveis-globais-dentro-de-funções)
1. [namespaces e módulos](#namespaces-e-módulos)
1. [exercícios](#exercícios)

# namespaces

Namespaces em Python são sistemas que garantem que os nomes de variáveis, funções, classes e outros identificadores usados em um programa sejam únicos e não entrem em conflito uns com os outros. Eles funcionam como contêineres que mapeiam nomes para objetos correspondentes, de forma que diferentes partes de um código possam usar os mesmos nomes sem interferir umas nas outras.

## conceito de namespace

Um namespace é essencialmente uma tabela de símbolos (ou um mapeamento) que relaciona nomes com objetos (valores, funções, classes, etc.). Cada nome é uma chave, e o objeto associado a ele é o valor.

Exemplo :

Imagine que tenha duas variáveis com o mesmo nome em contextos diferentes :

```python
def funcao1():
    variavel = 10
    print(variavel)

def funcao2():
    variavel = 20
    print(variavel)

funcao1()  # saída : 10
funcao2()  # saída : 20
```

Aqui, `variavel` é usada em ambas as funções, mas cada uso pertence a um namespace diferente (o namespace de cada função). Portanto, as duas variáveis `variavel` não entram em conflito, pois estão em namespaces separados.

## tipos de namespaces

Em Python, existem três tipos principais de namespaces:

1. **namespace local**
2. **namespace global**
3. **namespace built-in**

### 1. namespace local

Este é o namespace que é criado cada vez que uma função é chamada. Ele contém os nomes das variáveis locais e outros objetos definidos dentro da função. Quando a função termina, seu namespace local é destruído.

```python
def minha_funcao():
    x = 5  # x está no namespace local de minha_funcao
    print(x)

minha_funcao()  # saída : 5
```

Dentro de `minha_funcao`, `x` pertence ao namespace local da função.

### 2. namespace global

O namespace global é o espaço que contém todos os nomes definidos no nível principal de um script ou módulo. Ele existe desde o início da execução do programa até o seu término. Todas as variáveis, funções e classes definidas fora de qualquer função pertencem ao namespace global.

```python
x = 10  # x está no namespace global

def minha_funcao():
    print(x)

minha_funcao()  # saída : 10
```

Aqui, `x` pertence ao namespace global, e `minha_funcao` pode acessar `x` diretamente, pois ela não tem uma variável `x` no seu namespace local.

### 3. namespace built-in

O namespace built-in é criado pelo próprio Python e contém todas as funções e objetos que estão sempre disponíveis, como `print()`, `len()`, `int()`, entre outros. Este namespace é acessível de qualquer lugar no código.

```python
print(len("Python"))  # len é uma função built-in
```

A função `len()` pertence ao namespace built-in, por isso pode ser usada sem precisar importar ou definir.

### hierarquia dos namespaces

A Python segue uma ordem específica para resolver nomes, conhecida como a regra LEGB :

1. **Local** : o primeiro lugar que Python procura por um nome é no namespace local (dentro de uma função, por exemplo);
2. **Enclosing** : se o nome não é encontrado no namespace local, Python procura no namespace da função que contém outra função (para casos de funções aninhadas);
3. **Global** : se não for encontrado no namespace local ou enclosing, Python procura no namespace global;
4. **Built-in** : finalmente, se o nome não for encontrado em nenhum dos namespaces anteriores, Python procura no namespace built-in;

Exemplo :

```python
x = "global"

def funcao_externa():
    x = "enclosing"

    def funcao_interna():
        x = "local"
        print(x)

    funcao_interna()

funcao_externa()  # saída : local
```

Aqui, a função `funcao_interna` encontra `x` no seu namespace local. Se a linha `x = "local"` fosse removida, ela procuraria `x` no namespace enclosing (o namespace de `funcao_externa`), e assim por diante até encontrar o nome ou gerar um erro.

## modificando variáveis globais dentro de funções

Se quiser modificar uma variável global dentro de uma função, precisa usar a palavra-chave `global`. Caso contrário, Python considerará que está criando uma nova variável local.

```python
x = 10

def modificar_x():
    global x
    x = 20

modificar_x()
print(x)  # saída : 20
```

Aqui, `global x` informa ao Python que `x` dentro da função refere-se à `x` do namespace global.

## namespaces e módulos

Cada módulo em Python tem seu próprio namespace global, que é independente dos namespaces globais de outros módulos. Isso permite que tenha variáveis e funções com os mesmos nomes em diferentes módulos sem que eles entrem em conflito.

Exemplo :

```python
# modulo1.py
x = 10

def mostrar():
    print("Modulo 1:", x)

# modulo2.py
x = 20

def mostrar():
    print("Modulo 2:", x)

# main.py
import modulo1
import modulo2

modulo1.mostrar()  # saída : Modulo 1: 10
modulo2.mostrar()  # saída : Modulo 2: 20
```

Aqui, `modulo1` e `modulo2` têm suas próprias variáveis `x`, e elas não interferem uma na outra porque estão em namespaces separados.

## exercícios

<details>
<summary>Lista de Exercícios</summary>

1. Crie um módulo chamado `animais.py` com uma variável global `especies` e uma função `listar_especies()`. No script principal, importe o módulo e altere a variável `especies` diretamente. Em seguida, use a função `listar_especies()` para imprimir as espécies.
1. Crie um módulo chamado `numeros.py` com uma variável global `n` e uma função `incrementar_n()` que aumenta o valor de `n` em 1. No script principal, importe o módulo e chame `incrementar_n()` duas vezes. Imprima o valor de `n` após cada chamada da função.
1. Crie um módulo chamado `contas.py` com uma variável global `saldo` e uma função `depositar(valor)` que adiciona um valor ao saldo. No script principal, importe o módulo e faça um depósito de `100` e depois de `50`. Imprima o saldo após cada depósito.
1. Crie um módulo chamado `mensagens.py` com uma variável global `mensagem` e uma função `atualizar_mensagem(nova_mensagem)`. No script principal, importe o módulo e atualize a `mensagem` para `"Olá, Mundo!"` e imprima o valor da mensagem após a atualização.
1. Crie um módulo chamado `configuracoes.py` com uma variável global `config` e uma função `alterar_configuracao(chave, valor)`. No script principal, importe o módulo e altere uma configuração específica. Imprima o valor da configuração alterada.
1. Crie um módulo chamado `matematica.py` com uma função `adicionar(a, b)` que retorna a soma de dois números e uma variável global `resultado`. No script principal, importe o módulo e use a função `adicionar()` para calcular a soma de `5` e `7`, e depois imprima o valor da variável `resultado`.
1. Crie um módulo chamado `util.py` com uma função `multiplicar(a, b)` que retorna o produto de dois números e uma variável global `produto`. No script principal, importe o módulo, use a função `multiplicar()` e depois imprima o valor da variável `produto`.
1. Crie um módulo chamado `lista_util.py` com uma função `adicionar_elemento(lista, elemento)` que adiciona um elemento a uma lista e uma variável global `lista`. No script principal, importe o módulo e adicione dois elementos à lista, imprimindo a lista após cada adição.
1. Crie um módulo chamado `calendario.py` com uma função `adicionar_dia(dias)` que adiciona dias à variável global `data` e uma variável global `data`. No script principal, importe o módulo e adicione `10` dias à data. Imprima a data após a adição.
1. Crie um módulo chamado `personagem.py` com uma variável global `nome` e uma função `alterar_nome(novo_nome)`. No script principal, importe o módulo, altere o nome do personagem e imprima o nome alterado.
1. Crie um módulo chamado `valores.py` com uma função `atribuir_valor(chave, valor)` e uma variável global `valores`. No script principal, importe o módulo e atribua valores a várias chaves. Imprima o dicionário `valores` após as atribuições.
1. Crie um módulo chamado `estatisticas.py` com uma função `calcular_media(lista)` que retorna a média dos valores em uma lista e uma variável global `media`. No script principal, importe o módulo e calcule a média de uma lista de números, imprimindo o valor da variável `media`.
1. Crie um módulo chamado `configuracoes_usuario.py` com uma função `definir_preferencias(preferencias)` e uma variável global `preferencias`. No script principal, importe o módulo e defina e imprima preferências de usuário.
1. Crie um módulo chamado `dados_pessoais.py` com uma função `atualizar_dados(nome, idade)` e variáveis globais `nome` e `idade`. No script principal, importe o módulo, atualize e imprima os dados pessoais.
1. Crie um módulo chamado `historia.py` com uma função `adicionar_evento(evento)` que adiciona eventos à lista global `eventos`. No script principal, importe o módulo e adicione três eventos à lista. Imprima a lista após cada adição.
1. Crie um módulo chamado `itens.py` com uma função `adicionar_item(item)` e uma variável global `itens`. No script principal, importe o módulo e adicione três itens à lista. Imprima a lista de itens após cada adição.
1. Crie um módulo chamado `estoque.py` com uma função `adicionar_estoque(item, quantidade)` e uma variável global `estoque`. No script principal, importe o módulo e adicione estoque para dois itens diferentes, imprimindo o estoque após cada adição.
1. Crie um módulo chamado `email.py` com uma função `enviar_email(destinatario, assunto, corpo)` e uma variável global `enviado`. No script principal, importe o módulo e envie um e-mail, alterando o valor da variável `enviado` para `True` após o envio. Imprima o valor da variável.
1. Crie um módulo chamado `jogador.py` com uma função `atualizar_pontuacao(pontuacao)` e uma variável global `pontuacao`. No script principal, importe o módulo e atualize a pontuação do jogador em três etapas. Imprima a pontuação após cada atualização.
1. Crie um módulo chamado `projetos.py` com uma função `adicionar_projeto(nome)` e uma variável global `projetos`. No script principal, importe o módulo e adicione três projetos à lista. Imprima a lista de projetos após cada adição.

</details>
Índice

1. [in](#in)
1. [exercícios in](#exercicios-in)
1. [del](#del)
1. [exercícios del](#exercicios-del)
1. [pass](#pass)
1. [break](#break)
1. [continue](#continue)
1. [break e continue](#break-e-continue)
1. [exercícios break e continue](#exercícios-break-e-continue)

# comandos built-in

## `in`

O comando `in` do Python é um operador que verifica a existência de um elemento em uma coleção de elementos, como listas, strings, tuplas, dicionários, sets, etc. Ele retorna um valor booleano: `True` se o elemento estiver presente na coleção e `False` caso contrário.

```python
# sintaxe básica
elemento in coleção
```

- `elemento` : é o item que você deseja verificar se está presente na coleção;
- `coleção` : é a estrutura de dados onde a verificação será feita;

### exemplos

#### `in` em strings

Quando usado com strings, o `in` verifica se uma substring está presente na string.

```python
>>> mensagem = "Olá, mundo!"
>>>
>>> print('Olá' in mensagem)
True
>>> print('mundo' in mensagem)
True
>>> print('Python' in mensagem)
False
>>> |
```

- aqui, `Olá` e `mundo` são substrings de `mensagem`, então o resultado é `True`;
- `Python` não é uma substring de `mensagem`, resultando em `False`;

#### `in` em listas

Em listas, o `in` verifica se o item existe em qualquer posição da lista.

```python
>>> frutas = ['maçã', 'banana', 'laranja']
>>>
>>> print('banana' in frutas)
True
>>> print('uva' in frutas)
False
>>> |
```

- no primeiro caso, `banana` está na lista `frutas`, então o resultado é `True`;
- no segundo caso, `uva` não está na lista, então o resultado é `False`;

#### `in` em tuplas

O funcionamento é semelhante ao das listas.

```python
>>> numeros = (1, 2, 3, 4)
>>>
>>> print(3 in numeros)
True
>>> print(5 in numeros)
False
>>> |
```

- `3` está na tupla `numeros`, então o resultado é `True`;
- `5` não está na tupla, resultando em `False`;

#### `in` em dicionários

Quando aplicado a dicionários, o `in` verifica a presença de uma chave, e não do valor associado a ela.

```python
>>> aluno = {'nome': 'Ana', 'idade': 21, 'curso': 'Engenharia'}
>>>
>>> print('nome' in aluno)
True
>>> print('Ana' in aluno)
False
>>> |
```

- `nome` é uma chave no dicionário `aluno`, portanto o resultado é `True`;
- `Ana` não é uma chave, é um valor, então o resultado é `False`;

#### `in` em sets

Em sets, o `in` verifica a presença de um elemento específico.

```python
>>> cores = {'vermelho', 'verde', 'azul'}
>>> print('verde' in cores)
True
>>> print('amarelo' in cores)
False
>>> |
```

- `verde` está no set `cores`, então o resultado é `True`;
- `amarelo` não está, resultando em `False`

### operador `not in`

O operador `not in` é o inverso de `in`. Ele verifica se o elemento **não** está presente na coleção.

```python
>>> frutas = ['maçã', 'banana', 'laranja']
>>> print('uva' not in frutas)
True
>>> print('banana' not in frutas)
False
>>> |
```

- no primeiro caso, `uva` não está na lista `frutas`, então o resultado é `True`;
- no segundo caso, `banana` está na lista, então o resultado é `False`;

## exercícios in

<details>
<summary>Lista de Exercícios</summary>

1. exercícios com strings
    1. Verifique se a substring `"Python"` está presente na string `"Eu estou aprendendo Python"` e imprima o resultado.
    1. Verifique se a letra `"a"` está presente na string `"Hello, World!"` e imprima o resultado.
    1. Crie uma string `"abcdefg"` e verifique se a letra `"h"` está presente nela. Imprima `True` ou `False`.
    1. Dada a string `"Programação"`, verifique se a substring `"ção"` está presente. Imprima o resultado.
    1. Verifique se a palavra `"code"` está na frase `"Escrever código é divertido"`. Imprima o resultado.
1. exercícios com listas
    1. Crie uma lista `["maçã", "banana", "laranja"]`. Verifique se `"banana"` está presente na lista e imprima o resultado.
    1. Dada a lista `[10, 20, 30, 40, 50]`, verifique se o número `25` está na lista e imprima `True` ou `False`.
    1. Crie uma lista de nomes `["Ana", "Beatriz", "Carlos"]`. Verifique se o nome `"Daniel"` está na lista e imprima o resultado.
    1. Dada a lista `["cachorro", "gato", "peixe"]`, verifique se `"passarinho"` está presente na lista e imprima o resultado.
    1. Crie uma lista vazia e verifique se o número `0` está presente nela. Imprima o resultado.
1. exercícios com tuplas
    1. Crie uma tupla `(1, 2, 3, 4, 5)` e verifique se o número `3` está presente. Imprima o resultado.
    1. Dada a tupla `("a", "b", "c", "d")`, verifique se a letra `"e"` está presente na tupla e imprima `True` ou `False`.
    1. Crie uma tupla com as cores `("vermelho", "verde", "azul")`. Verifique se a cor `"amarelo"` está na tupla e imprima o resultado.
    1. Verifique se o número `100` está na tupla `(10, 20, 30, 40, 50)` e imprima o resultado.
    1. Dada a tupla `(7, 14, 21, 28)`, verifique se o número `14` está presente e imprima o resultado.
1. exercícios com sets
    1. Crie um set `{"maçã", "banana", "uva"}` e verifique se `"laranja"` está presente no set. Imprima o resultado.
    1. Dado o set `{1, 3, 5, 7}`, verifique se o número `5` está presente e imprima `True` ou `False`.
    1. Verifique se o elemento `"Python"` está presente no set `{"Java", "C++", "Python", "JavaScript"}` e imprima o resultado.
    1. Crie um set com números `{2, 4, 6, 8}` e verifique se o número `10` está no set. Imprima o resultado.
    1. Dado o set `{"cachorro", "gato", "coelho"}`, verifique se o animal `"cavalo"` está presente e imprima `True` ou `False`.
1. exercícios com dicionários
    1. Crie um dicionário `aluno = {"nome": "João", "idade": 20, "curso": "Engenharia"}`. Verifique se a chave `"idade"` está presente no dicionário e imprima o resultado.
    1. Dado o dicionário `cidades = {"SP": "São Paulo", "RJ": "Rio de Janeiro", "MG": "Belo Horizonte"}`, verifique se a chave `"BA"` está no dicionário e imprima `True` ou `False`.
    1. Crie um dicionário `carro = {"marca": "Toyota", "modelo": "Corolla", "ano": 2020}`. Verifique se a chave `"cor"` está presente no dicionário e imprima o resultado.
    1. Dado o dicionário `estoque = {"caneta": 100, "caderno": 50, "borracha": 30}`, verifique se a chave `"lápis"` está presente no dicionário e imprima o resultado.
    1. Crie um dicionário `pessoa = {"nome": "Ana", "altura": 1.70, "peso": 65}`. Verifique se a chave `"idade"` está presente no dicionário e imprima `True` ou `False`.

</details>

## `del`

O comando `del` do Python é uma instrução usada para remover variáveis, elementos de uma lista, chave-valor de um dicionário, ou até mesmo fatias de listas e elementos em outros tipos de coleção. A instrução `del` também pode ser usada para deletar uma variável inteira da memória, tornando-a indisponível para uso posterior.

```python
# sintaxe básica
del objeto
```

- `objeto` : pode ser uma variável, um elemento de uma coleção, uma fatia de uma lista, ou uma chave de um dicionário;

### exemplos

#### deletando variáveis

É possível usar `del` para remover uma variável completamente, liberando o espaço de memória que ela estava ocupando.

```python
>>> x = 10
>>> print(x)
10
>>>
>>> del x
>>>
>>> print(x)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'x' is not defined
>>> |
```

- depois de `del x`, a variável `x` deixa de existir, e qualquer tentativa de acessá-la resultará em um erro;

#### deletando elementos de uma lista

O comando `del` pode ser usado para remover um elemento específico de uma lista, identificando-o pelo índice.

```python
>>> frutas = ['maçã', 'banana', 'laranja', 'uva']
>>>
>>> print(frutas)
['maçã', 'banana', 'laranja', 'uva']
>>>
>>> del frutas[1]
>>>
>>> print(frutas)
['maçã', 'laranja', 'uva']
>>> |
```

- aqui, `del frutas[1]` remove a `banana` da lista, que estava no índice `1`;

#### deletando fatias de uma lista

É possível usar `del` para remover uma fatia (slice) de elementos de uma lista.

```python
>>> numeros = list(range(1,7,1))
>>> print(numeros)
[1, 2, 3, 4, 5, 6]
>>>
>>> del numeros[2:5]
>>>
>>> print(numeros)
[1, 2, 6]
>>> |
```

- `del numeros[2:5]` remove os elementos nos índices `2`, `3` e `4` da lista original, que correspondem aos números `3`, `4` e `5`;

#### deletando chaves de um dicionário

No caso de dicionários, `del` é usado para remover um par chave-valor.

```python
>>> aluno = {'nome': 'Ana', 'idade': 21, 'curso': 'Engenharia'}
>>> print(aluno)
{'nome': 'Ana', 'idade': 21, 'curso': 'Engenharia'}
>>>
>>> del aluno['idade']
>>>
>>> print(aluno)
{'nome': 'Ana', 'curso': 'Engenharia'}
>>> |
```

- `del aluno['idade']` remove a chave `idade` e o valor associado a ela do dicionário;

#### deletando elementos de um set

Embora não se possa acessar diretamente um elemento em um set pelo índice (devido à natureza não ordenada dos sets), é possível deletar um set inteiro usando `del`.

```python
>>> cores = {'vermelho', 'verde', 'azul'}
>>> print(cores)
{'vermelho', 'azul', 'verde'}
>>>
>>> del cores
>>> print(cores)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'cores' is not defined
>>> |
```

- aqui, `del cores` remove completamente o set `cores` da memória;

### considerações adicionais

- **deletando múltiplas variáveis** : é possível deletar várias variáveis ao mesmo tempo, separando-as por vírgulas;
    ```python
    >>> a = 10
    >>> b = 20
    >>> c = 30
    >>>
    >>> del a, c
    >>>
    >>> print(a)
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    NameError: name 'a' is not defined
    >>>
    >>> print(b)
    20
    >>>
    >>> print(c)
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    NameError: name 'c' is not defined
    >>> |
    ```

- **deletando referências a objetos** : quando se deleta uma variável que se refere a um objeto, como uma lista ou um dicionário, e não há mais referências a esse objeto, ele é removido da memória pelo garbage collector do python;

- **uso em loops e funções** : é possível usar `del` dentro de loops e funções para remover elementos dinamicamente à medida que o programa é executado;

## exercícios del

<details>
<summary>Lista de Exercícios</summary>

1. exercícios com variáveis numéricas e strings
    1. Crie uma variável `x = 10`. Use `del` para deletar a variável `x`. Tente imprimir `x` e observe o que acontece.
    1. Defina duas variáveis `a = 5` e `b = 10`. Use `del` para deletar ambas as variáveis. Tente imprimir `a` e `b`.
    1. Crie uma string `frase = "Olá, Mundo!"`. Use `del` para deletar a variável `frase`. Tente imprimir `frase` e observe o resultado.
    1. Defina uma variável `nome = "Maria"`. Use `del` para deletar a variável. Tente acessar `nome` após deletá-la.
    1. Crie três variáveis: `num1 = 3`, `num2 = 6`, e `num3 = 9`. Use `del` para deletar `num1` e `num2`. Tente imprimir todas as três variáveis.
1. exercícios com listas
    1. Crie uma lista `numeros = [1, 2, 3, 4, 5]`. Use `del` para deletar o terceiro elemento da lista. Imprima a lista resultante.
    1. Defina uma lista `frutas = ["maçã", "banana", "laranja"]`. Use `del` para deletar o último item da lista. Imprima a lista.
    1. Crie uma lista `cores = ["vermelho", "azul", "verde", "amarelo"]`. Use `del` para deletar os elementos no índice 1 e 2. Imprima a lista resultante.
    1. Crie uma lista `alfabeto = ["a", "b", "c", "d", "e", "f"]`. Use `del` para deletar os primeiros dois elementos da lista. Imprima a lista.
    1. Defina uma lista `itens = ["caneta", "caderno", "borracha"]`. Use `del` para deletar a lista inteira. Tente imprimir `itens` e observe o que acontece.
    1. Crie uma lista `numeros = [10, 20, 30, 40, 50]`. Use `del` para deletar o elemento no índice `4`. Imprima a lista resultante.
    1. Dada a lista `animais = ["cachorro", "gato", "passarinho", "peixe"]`, use `del` para deletar o segundo e o terceiro elementos. Imprima a lista.
    1. Crie uma lista `dias = ["segunda", "terça", "quarta", "quinta", "sexta"]`. Use `del` para deletar os três últimos elementos. Imprima a lista.
    1. Crie uma lista `meses = ["janeiro", "fevereiro", "março", "abril"]`. Use `del` para deletar o primeiro elemento da lista. Imprima a lista.
    1. Defina uma lista `numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9]`. Use `del` para deletar os elementos nos índices 0 a 4 (inclusive). Imprima a lista resultante.
1. exercícios com tuplas
    1. Crie uma tupla `pares = (2, 4, 6, 8, 10)`. Use `del` para deletar a tupla inteira. Tente imprimir `pares`.
    1. Crie uma tupla `letras = ("a", "b", "c", "d")`. Use `del` para deletar a tupla inteira. Tente acessar `letras` e observe o resultado.
    1. Defina uma tupla `numeros = (1, 2, 3, 4, 5)`. Use `del` para deletar a variável `numeros`. Tente imprimir `numeros`.
1. exercícios com sets
    1. Crie um set `vogais = {"a", "e", "i", "o", "u"}`. Use `del` para deletar o set inteiro. Tente acessar `vogais`.
    1. Defina um set `numeros = {1, 2, 3, 4, 5}`. Use `del` para deletar o set. Tente imprimir `numeros`.
    1. Crie um set `cores = {"vermelho", "verde", "azul"}`. Use `del` para deletar o set. Verifique o que acontece ao tentar acessar `cores`.
1. exercícios com dicionários
    1. Crie um dicionário `aluno = {"nome": "João", "idade": 20, "curso": "Matemática"}`. Use `del` para deletar a chave `"idade"`. Imprima o dicionário resultante.
    1. Defina um dicionário `produto = {"nome": "caneta", "preço": 1.50, "estoque": 100}`. Use `del` para deletar a chave `"preço"`. Imprima o dicionário.
    1. Crie um dicionário `contato = {"nome": "Maria", "telefone": "1234-5678", "email": "maria@gmail.com"}`. Use `del` para deletar a chave `"telefone"`. Imprima o dicionário.
    1. Dado o dicionário `carro = {"marca": "Ford", "modelo": "Mustang", "ano": 1969}`, use `del` para deletar a chave `"ano"`. Imprima o dicionário resultante.

</details>

## `pass`

O comando `pass` em Python é uma instrução nula; quando é executado, nada acontece. Ele é utilizado em situações onde uma declaração é necessária sintaticamente, mas onde nenhum código precisa ser executado.

### formas de uso

1. **estrutura de código em desenvolvimento** : durante o desenvolvimento, pode ser usado para estruturar funções, classes ou blocos condicionais que ainda não foram implementados, mas deseja evitar erros de sintaxe. O `pass` é uma forma de “marcar” esses locais, sem precisar escrever o código definitivo imediatamente.
    ```python
    >>> def minha_funcao():
    >>>     pass  # vai ser implementado depois
    >>>
    >>> class MinhaClasse:
    >>>     pass  # classe em desenvolvimento
    >>>
    >>> if condicao:
    >>>     pass  # Ainda não sei o que fazer aqui
    ```

1. **blocos de código condicional**: em certos casos, pode ser necessário ter uma condicional que não faz nada, por exemplo, ao tratar um caso onde nenhuma ação é necessária.
    ```python
    >>> for item in minha_lista:
    >>>     if item == "pular":
    >>>         pass  # não faço nada para 'pular'
    >>>     else:
    >>>         print(item)
    ```

1. **estruturas de controle sem implementação imediata**: o `pass` é útil em loops, funções ou outras estruturas de controle onde ainda não se sabe qual será a lógica final, mas quer estruturar o código de forma que ele seja executável.
    ```python
    >>> while True:
    >>>     pass  # loop infinito em desenvolvimento, sem lógica definida
    ```

### exemplos

1. classe em desenvolvimento
    ```python
    >>> class Animal:
    >>>     pass  # classe animal a ser definida depois
    >>>
    >>> # não gera erro e a classe pode ser instanciada
    >>> cachorro = Animal()
    ```

1. função em desenvolvimento
    ```python
    >>> def funcao_complexa():
    >>>     pass  # lógica a ser implementada depois
    >>>
    >>> # função chamada, mas sem erros
    >>> funcao_complexa()
    ```

1. estrutura condicional
    ```python
    >>> x = 10
    >>>
    >>> if x > 0:
    >>>     pass  # sem ação específica para números positivos
    >>> else:
    >>>     print("Número não positivo")
    ```

### observações

- **evitar uso excessivo** : o `pass` é útil para o desenvolvimento inicial ou para marcar futuras implementações, mas em um código final, ele deve ser removido ou substituído por código funcional.

- **leitura do código** : o uso de `pass` pode indicar a necessidade de implementação futura, mas em código de produção, deixar blocos de código com `pass` pode sugerir funcionalidades incompletas ou mal implementadas.

### conclusão

O `pass` é uma ferramenta essencial em Python para a criação de esboços de código e para manter a estrutura do código correta durante o desenvolvimento. Ele garante que seja possível continuar a desenvolver outras partes do código sem ser interrompido por erros de sintaxe.


## `break`

O comando `break` em Python é utilizado dentro de loops (`for` e `while`) para interromper o loop imediatamente. Quando o Python encontra um `break`, ele sai do loop, ignorando todas as iterações restantes, e a execução do código continua após o bloco do loop.

Quando o comando `break` é executado dentro de um loop, ele interrompe o loop inteiro, não importa em qual ponto da iteração o `break` esteja. Isso é útil quando é preciso sair de um loop antes que ele termine todas as iterações, com base em uma condição específica.

```python
>>> # estrutura básica
>>> for item in sequencia:
>>>     if condicao:
>>>         break  # sai do loop completamente
>>>     # código que é executado até que o break seja chamado
```

### exemplos

1. interrompendo um loop ao encontrar um valor específico : vamos supor que tenha uma lista de números e queira parar a iteração assim que encontrar o número 5 :
    ```python
    >>> numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    >>>
    >>> for numero in numeros:
    >>>     if numero == 5:
    >>>         break  # interrompe o loop quando o número 5 é encontrado
    >>>     print(numero)
    1
    2
    3
    4
    >>> |
    ```
    Neste exemplo, o loop é interrompido assim que o número 5 é encontrado, e o Python sai do loop, ignorando os números restantes na lista.

1. encontrando um item em uma lista : pode usar o `break` para interromper a busca em uma lista assim que encontrar um item específico :
    ```python
    >>> frutas = ["maçã", "banana", "laranja", "abacaxi", "uva"]
    >>>
    >>> for fruta in frutas:
    >>>     print(f"Verificando {fruta}")
    >>>     if fruta == "laranja":
    >>>         print("Laranja encontrada, interrompendo a busca.")
    >>>         break  # Para a busca quando a laranja é encontrada
    Verificando maçã
    Verificando banana
    Verificando laranja
    Laranja encontrada, interrompendo a busca.
    >>> |
    ```
    Aqui, o loop para de executar assim que encontra "laranja", evitando verificar as frutas restantes.

1. interrompendo um loop infinito : um `break` é frequentemente usado para sair de um loop infinito quando uma certa condição é atendida :
    ```python
    >>> i = 1
    >>>
    >>> while True:
    >>>     print(i)
    >>>     if i == 10:
    >>>         break  # Interrompe o loop infinito quando i é igual a 10
    >>>     i += 1
    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    >>> |
    ```
    Neste exemplo, o loop `while` é infinito (`while True:`), mas o comando `break` faz com que o loop seja interrompido quando `i` atinge o valor 10.

### quando usar `break`

1. **interromper a busca** : quando está procurando por algo em uma lista ou sequência e deseja parar a busca assim que encontrar o que precisa;

1. **sair de loops infinitos** : em loops `while` que podem, teoricamente, rodar para sempre, o `break` pode ser usado para sair do loop quando uma condição específica é atingida;

1. **prevenir iterações desnecessárias** : se sabe que não precisa continuar o loop após encontrar um certo valor, o `break` pode melhorar a eficiência do código;

### conclusão

O `break` é uma ferramenta essencial para controle de fluxo em loops. Ele permite que você saia de loops imediatamente quando uma condição específica é atendida, evitando iterações desnecessárias e melhorando a eficiência do seu código.


## `continue`

O comando `continue` em Python é utilizado dentro de loops (`for` e `while`) para pular a iteração atual e passar para a próxima iteração do loop. Ele é útil quando se deseja ignorar o restante do código no bloco do loop para certas condições, sem interromper o loop completamente.

Quando o Python encontra o comando `continue` dentro de um loop, ele interrompe a execução do código restante na iteração atual e imediatamente volta ao início do loop, verificando a condição do loop novamente. Se a condição for verdadeira, uma nova iteração começa.

```python
>>> # estrurua básica
>>> for item in sequencia:
>>>     if condicao:
>>>         continue  # pula o resto do código no loop e vai para a próxima iteração
>>>     # código que será ignorado se a condição for verdadeira
```

### exemplos

1. pular números pares : vamos supor que se queira iterar por uma lista de números e imprimir apenas os números ímpares:
    ```python
    >>> numeros = list(range(1,11))
    >>>
    >>> for numero in numeros:
    >>>     if numero % 2 == 0:  # verifica se o número é par
    >>>          continue  # pula a iteração se o número for par
    >>>     print(numero)
    1
    3
    5
    7
    9
    >>> |
    ```
    Neste exemplo, o comando `continue` faz com que o loop pule a impressão dos números pares.

1. ignorar palavras específicas : pode usar `continue` para ignorar palavras específicas em uma lista de palavras :
    ```python
    >>> palavras = ["maçã", "banana", "laranja", "abacaxi", "uva"]
    >>>
    >>> for palavra in palavras:
    >>>     if palavra == "laranja":
    >>>         continue  # ignora a palavra "laranja"
    >>>     print(palavra)
    maçã
    banana
    abacaxi
    uva
    >>> |
    ```
    Aqui, a palavra "laranja" é ignorada e não é impressa.

1. contando iterações válidas : em um loop `while`, o `continue` pode ser usado para ignorar certos valores e continuar a contagem ou execução das iterações :
    ```python
    >>> i = 0
    >>> while i < 10:
    >>>     i += 1
    >>>     if i % 2 == 0:  # se i for par, pula para a próxima iteração
    >>>         continue
    >>>     print(i)
    1
    3
    5
    7
    9
    ```
    Neste exemplo, `continue` faz com que os números pares sejam pulados no loop `while`.

### quando usar `continue`

1. **filtragem de dados**: quando se deseja processar apenas certos itens de uma lista ou sequência e ignorar outros com base em uma condição específica;

2. **ignorar erros**: pode ser usado para pular uma iteração se uma operação específica falhar (por exemplo, um cálculo que pode causar uma exceção);

3. **simplificar estruturas de controle**: em vez de usar `else` ou aninhar múltiplas condições, `continue` pode simplificar o código, especialmente quando a lógica principal deve ser executada apenas para alguns casos;

### conclusão

O `continue` é uma ferramenta poderosa em Python para controle de fluxo dentro de loops. Ele permite que pular certas iterações com base em condições específicas, tornando o código mais flexível e legível.


## `break` e `continue`

Os comandos `break` e `continue` são ambos utilizados para controlar o fluxo de execução dentro de loops em Python. Embora possam ser usados de forma independente, existem situações em que é útil combiná-los dentro do mesmo loop para criar lógica mais complexa.

Quando combinado `break` e `continue` em um loop, por exemplo, é possível criar uma lógica em que determinadas condições pulem a iteração atual, enquanto outras condições interrompem completamente o loop.

### exemplos

1. filtragem e interrupção de processamento : suponha que tenha uma lista de números e queira processar apenas os números ímpares. Se um número for maior que 15, quer interromper o processamento completamente.
    ```python
    >>> numeros = [3, 7, 2, 9, 12, 17, 19, 6, 11]
    >>>
    >>> for numero in numeros:
    >>>     if numero % 2 == 0:  # se o número for par
    >>>         continue  # pula para a próxima iteração, ignorando o número par
    >>>
    >>>     if numero > 15:  # se o número for maior que 15
    >>>         print("Número maior que 15 encontrado. Interrompendo.")
    >>>         break  # interrompe o loop completamente
    >>>
    >>>     print(f"Processando número ímpar: {numero}")
    >>> Processando número ímpar: 3
    >>> Processando número ímpar: 7
    >>> Processando número ímpar: 9
    >>> Número maior que 15 encontrado. Interrompendo.
    >>> |
    ```
    Neste exemplo:
    - O `continue` é usado para pular números pares, ignorando-os;
    - O `break` é usado para interromper o loop assim que um número maior que 15 é encontrado;

1. looping com condições múltiplas : considere uma situação em que se precisa iterar sobre uma lista de números, mas deseja:
    1. Ignorar números negativos (`continue`);
    1. Interromper o loop ao encontrar um número que é um múltiplo de 7 (`break`);
    ```python
    >>> numeros = [5, -3, 10, 6, -1, 14, 12, -8, 20]
    >>>
    >>> for numero in numeros:
    >>>     if numero < 0:  # ignora números negativos
    >>>         continue  # pula para a próxima iteração
    >>>
    >>>     if numero % 7 == 0:  # encontra o primeiro múltiplo de 7
    >>>         print(f"Número múltiplo de 7 encontrado: {numero}. Interrompendo o loop.")
    >>>         break  # interrompe o loop ao encontrar múltiplo de 7
    >>>
    >>>     print(f"Processando número: {numero}")
    >>> Processando número: 5
    >>> Processando número: 10
    >>> Processando número: 6
    >>> Número múltiplo de 7 encontrado: 14. Interrompendo o loop.
    >>> |
    ```
    Neste exemplo:
    - O `continue` é utilizado para pular números negativos.
    - O `break` é utilizado para interromper o loop assim que um múltiplo de 7 é encontrado.

1. verificando condições em uma lista de strings : imagine que está processando uma lista de palavras e:
    1. Deseja pular qualquer palavra que comece com a letra "a" (`continue`);
    1. Quer interromper completamente o loop se encontrar a palavra "parar" (`break`);
    ```python
    >>> palavras = ["maçã", "banana", "abacate", "uva", "parar", "laranja"]
    >>>
    >>> for palavra in palavras:
    >>>     if palavra.startswith("a"):  # Ignora palavras que começam com "a"
    >>>         continue  # Pula para a próxima iteração
    >>>
    >>>     if palavra == "parar":  # Interrompe o loop se encontrar "parar"
    >>>         print("Palavra 'parar' encontrada. Interrompendo o loop.")
    >>>         break  # Interrompe o loop
    >>>
    >>>     print(f"Processando palavra: {palavra}")
    >>> Processando palavra: banana
    >>> Processando palavra: uva
    >>> Palavra 'parar' encontrada. Interrompendo o loop.
    >>> |
    ```
    Neste exemplo:
    - O `continue` ignora palavras que começam com a letra "a";
    - O `break` interrompe o loop ao encontrar a palavra "parar";

### considerações importantes

- **ordem importa**: a ordem que se coloca `continue` e `break` dentro do loop é crucial, pois determinará a lógica do fluxo de execução;
- **leitura do código**: usar `continue` e `break` no mesmo loop pode tornar o código mais difícil de ler, então é importante usar comentários claros ou refatorar o código para que a lógica seja intuitiva;

### conclusão

Combinar `break` e `continue` em um loop Python permite um controle granular sobre o fluxo de execução, permitindo que se pule iterações específicas enquanto também fornece uma maneira de sair completamente do loop quando certas condições são atendidas. Usados juntos, esses comandos podem tornar o código mais eficiente e focado, dependendo das necessidades da aplicação.

## exercícios break e continue

<details>
<summary>Lista de Exercícios</summary>

### `break`

1. **Interrupção em Lista de Números**: Crie um loop `for` que percorra uma lista de números de 1 a 10. Use `break` para interromper o loop quando o número 5 for encontrado.
1. **Busca em String**: Escreva um loop `for` que percorra uma string. Use `break` para parar o loop assim que a letra "a" for encontrada e imprima as letras anteriores.
1. **Loop com Condição**: Crie um loop `while` que incrementa uma variável `x` começando em 0. Use `break` para parar o loop quando `x` for igual a 10.
    ```python
    x = 0

    # while x < 20:
    while True:
        if x == 10:
            break
        x = x + 1

    print(f'saindo do while com {x = }')
    ```
1. **Interrupção em Lista de Strings**: Escreva um loop `for` que percorra uma lista de strings. Use `break` para sair do loop assim que encontrar uma string vazia.
1. **Número Múltiplo**: Crie um loop `for` que percorra uma lista de números. Use `break` para interromper o loop assim que encontrar um número divisível por 7.
1. **Interromper com Condicional**: Crie um loop `while` que soma números inteiros a partir de 1. Use `break` para sair do loop assim que a soma ultrapassar 50.
1. **Busca de Palavras**: Escreva um loop `for` que percorra uma lista de palavras. Use `break` para interromper o loop se encontrar uma palavra que começa com "Z".
1. **Busca em String**: Crie um loop `while` que percorra uma string caractere por caractere. Use `break` para parar o loop se encontrar um dígito numérico.
1. **Interrupção em Sublista**: Escreva um loop `for` que percorra uma lista de listas. Use `break` para sair do loop principal se encontrar uma sublista que contém um valor negativo.
1. **Interromper com Condição Complexa**: Crie um loop `for` que percorra uma lista de números e use `break` para sair do loop se encontrar um número maior que 100 ou menor que -100.
1. **Interrupção Condicional**: Crie um loop `while` que percorra os caracteres de uma string. Use `break` se encontrar duas vogais consecutivas e imprima o que foi lido até esse ponto.
1. **Busca de Substring**: Escreva um loop `for` que percorra uma lista de strings. Use `break` se encontrar uma string que contenha a substring "python".
1. **Parada em Número Específico**: Crie um loop `while` que gera números aleatórios entre 1 e 100. Use `break` para sair do loop quando um número específico (por exemplo, 42) for gerado.
1. **Interromper em Condição Composta**: Escreva um loop `for` que percorra uma lista de números. Use `break` para sair do loop se encontrar um número negativo seguido de um positivo.
1. **Interromper após Concatenar**: Crie um loop `for` que percorra uma lista de strings e as concatene em uma única string. Use `break` quando o comprimento total da string concatenada ultrapassar 50 caracteres.
1. **Interromper em Sequência**: Escreva um loop `for` que percorra uma lista de números. Use `break` se encontrar uma sequência de três números ímpares consecutivos.
1. **Interromper em Condição de Soma**: Crie um loop `while` que adicione números de uma lista a uma variável soma. Use `break` para interromper a adição se a soma exceder um valor limite (por exemplo, 100).
1. **Interrupção em String**: Escreva um loop `for` que percorra uma string caractere por caractere. Use `break` se encontrar uma combinação específica de caracteres (por exemplo, "ab").
1. **Parada em Condição Composta**: Crie um loop `for` que percorra uma lista de números. Use `break` para sair do loop se encontrar um número maior que 50 seguido de um número menor que 10.
1. **Interrupção em Verificação de Substring**: Escreva um loop `while` que verifique se uma substring existe em uma string. Use `break` para sair do loop quando encontrar a substring "stop".

### `continue`

1. **Lista de Números**: Crie um loop `for` que percorra uma lista de números de 1 a 10. Use `continue` para pular os números pares e imprima os ímpares.
1. **String com Vogais**: Escreva um loop `for` que percorra uma string. Use `continue` para pular as vogais e imprima as consoantes.
1. **Números Negativos**: Crie um loop `while` que diminua o valor de uma variável `x` a partir de 10. Use `continue` se `x` for negativo e imprima o restante.
1. **Strings com Espaços**: Escreva um loop `for` que percorra uma lista de strings. Use `continue` para pular as strings que contêm espaços e imprima as demais.
1. **Divisíveis por 3**: Crie um loop `for` que percorra uma lista de números. Use `continue` para pular os números divisíveis por 3 e imprima os outros.
1. **Índices Pares**: Escreva um loop `for` que percorra uma lista de palavras e seus índices. Use `continue` para pular as palavras nos índices pares e imprima as outras.
1. **Contagem Regressiva**: Crie um loop `while` que conta de 20 até 0. Use `continue` para pular os números ímpares e imprima os pares.
1. **Nomes Longos**: Escreva um loop `for` que percorra uma lista de nomes. Use `continue` para pular os nomes com mais de 5 caracteres e imprima os menores.
1. **String com Dígitos**: Crie um loop `for` que percorra uma string. Use `continue` para pular os caracteres que são dígitos e imprima os demais.
1. **Listas Vazias**: Escreva um loop `for` que percorra uma lista de listas. Use `continue` para pular listas vazias e imprima as outras.
1. **Soma de Números**: Crie um loop `for` que percorra uma lista de números e calcule a soma deles. Use `continue` para ignorar os números negativos.
1. **String Alternada**: Escreva um loop `for` que percorra uma string e use `continue` para pular os caracteres nas posições ímpares. Imprima apenas os caracteres nas posições pares.
1. **Números Primos**: Crie um loop `while` que verifica números de 2 a 50. Use `continue` para pular números que não são primos e imprima apenas os primos.
1. **Palavras Compostas**: Escreva um loop `for` que percorra uma lista de palavras. Use `continue` para pular palavras que contêm mais de uma vogal e imprima as demais.
1. **Listas com Zeros**: Crie um loop `for` que percorra uma lista de listas de números. Use `continue` para pular listas que contenham o número 0 e imprima as outras listas.
1. **Comparação de Strings**: Escreva um loop `for` que percorra duas listas de strings de tamanho igual. Use `continue` para pular a comparação se as strings não tiverem o mesmo comprimento.
1. **Nomes e Idades**: Crie um loop `for` que percorra duas listas (nomes e idades). Use `continue` para pular a impressão se a idade for menor que 18 e imprima apenas os nomes das pessoas maiores de idade.
1. **Soma de Dígitos**: Escreva um loop `while` que receba uma string de números. Use `continue` para pular caracteres que não são dígitos e calcule a soma dos dígitos.
1. **Filtros em Listas**: Crie um loop `for` que percorra uma lista de números. Use `continue` para ignorar números que são múltiplos de 5 e imprima os restantes.
1. **String Invertida**: Escreva um loop `for` que percorra uma string de trás para frente. Use `continue` para pular os caracteres nas posições ímpares e imprima apenas os caracteres nas posições pares.

### `break` e `continue`

1. **Interrupção com Condição**: Crie um loop `for` que percorra uma lista de números de 1 a 10. Use `continue` para pular números pares e `break` para sair do loop quando encontrar o número 7.
2. **Busca em String**: Escreva um loop `for` que percorra uma string. Use `continue` para pular os espaços em branco e `break` para sair do loop quando encontrar a letra "z".
3. **Loop com Condição**: Crie um loop `while` que incrementa uma variável `x` a partir de 0. Use `continue` para pular os números divisíveis por 3 e `break` para parar o loop quando `x` atingir 15.
4. **Lista de Strings**: Escreva um loop `for` que percorra uma lista de strings. Use `continue` para pular as strings que contêm o caractere "a" e `break` para sair do loop ao encontrar uma string com mais de 5 caracteres.
5. **Interrupção Condicional**: Crie um loop `for` que percorra uma lista de números. Use `continue` para pular números negativos e `break` para sair do loop ao encontrar um número maior que 50.
6. **Filtro de Números**: Crie um loop `while` que gera números aleatórios entre 1 e 50. Use `continue` para pular números menores que 10 e `break` para parar o loop quando um número maior que 40 for gerado.
7. **Verificação de String**: Escreva um loop `for` que percorra uma lista de strings. Use `continue` para pular strings que não começam com a letra "P" e `break` para sair do loop ao encontrar uma string que começa com "Python".
8. **Interrupção Condicional em String**: Crie um loop `while` que percorra uma string caractere por caractere. Use `continue` para pular vogais e `break` para sair do loop ao encontrar a letra "e".
9. **Filtragem em Sublistas**: Escreva um loop `for` que percorra uma lista de listas de números. Use `continue` para pular sublistas vazias e `break` para sair do loop ao encontrar uma sublista contendo um número negativo.
10. **Condicionais Múltiplas**: Crie um loop `for` que percorra uma lista de números. Use `continue` para pular números divisíveis por 2 ou 5 e `break` para sair do loop ao encontrar um número maior que 30.
11. **Verificação de Consoantes**: Crie um loop `while` que percorre uma string. Use `continue` para pular caracteres que são vogais e `break` para parar o loop ao encontrar uma consoante específica (por exemplo, "r").
12. **Busca em Lista**: Escreva um loop `for` que percorra uma lista de números. Use `continue` para pular números ímpares e `break` para sair do loop ao encontrar um número divisível por 4.
13. **Interrupção Condicional em Nomes**: Crie um loop `for` que percorra uma lista de nomes. Use `continue` para pular nomes com menos de 4 letras e `break` para sair do loop ao encontrar um nome começando com "A".
14. **Substituição em String**: Escreva um loop `while` que percorra uma string caractere por caractere. Use `continue` para pular caracteres que não são letras e `break` para sair do loop ao encontrar um espaço.
15. **Filtro de Listas**: Crie um loop `for` que percorra uma lista de listas de números. Use `continue` para pular listas que não contêm números maiores que 10 e `break` para sair do loop ao encontrar uma lista com mais de 3 números.
16. **Filtro de Substring**: Escreva um loop `for` que percorra uma lista de strings. Use `continue` para pular strings que não contêm a letra "x" e `break` para sair do loop ao encontrar uma string com mais de 8 caracteres.
17. **Verificação de Números**: Crie um loop `while` que percorra uma lista de números de 1 a 100. Use `continue` para pular números que não são primos e `break` para sair do loop ao encontrar um número primo maior que 50.
18. **Busca em String**: Escreva um loop `for` que percorra uma string. Use `continue` para pular os caracteres que não são dígitos e `break` para sair do loop ao encontrar dois dígitos consecutivos.
19. **Filtro em Listas**: Crie um loop `for` que percorra uma lista de listas de números. Use `continue` para pular listas que contêm números negativos e `break` para sair do loop ao encontrar uma lista com apenas números positivos.
20. **Verificação de Caracteres**: Escreva um loop `while` que percorra uma string. Use `continue` para pular os caracteres que não são letras maiúsculas e `break` para sair do loop ao encontrar três letras maiúsculas consecutivas.

</details>
Índice

1. [comando import](#comando-import)
1. [comandos from e as](#comandos-from-e-as)
1. [comparando as abordagens](#comparando-as-abordagens)
1. [exemplo completo](#exemplo-completo)
1. [exercícios](#execícios)

# comandos `from` `import` `as`

## comando `import`

O comando `import` em Python é usado para incluir funcionalidades de outros módulos (arquivos `.py`) em um script, permitindo a reutilização de código. Um módulo em Python é simplesmente um arquivo contendo definições e instruções Python, como funções, classes e variáveis. Ao usar `import`, é possível acessar essas definições de um módulo dentro de outro.

### estrutura básica do `import`

A sintaxe básica do comando `import` é :

```python
>>> import nome_do_modulo
```

Aqui, `nome_do_modulo` é o nome do arquivo `.py` sem a extensão. Por exemplo, se tiver um arquivo chamado `meu_modulo.py`, poderá importá-lo em outro arquivo Python com :

```python
>>> import meu_modulo
```

### como funciona o `import`

Quando um módulo é importado :

1. **localização do módulo** : o python verifica se o módulo está presente no local de trabalho atual ou nos diretórios especificados na variável `sys.path`;
2. **execução do código** : todo o código no módulo importado é executado uma vez no momento do import. Se o módulo contém funções ou classes, elas são definidas e prontas para uso no script que fez o import;
3. **criação de um namespace** : um namespace separado é criado para o módulo, o que significa que os nomes definidos no módulo não entram em conflito com os nomes no script importador;

### acessando componentes do módulo

Depois de importar um módulo, é possível acessar as funções, variáveis e outros componentes usando a notação de ponto (`.`).

- exemplo 1 : acessando funções e variáveis

Suponha que tenha um arquivo `meu_modulo.py` com o seguinte conteúdo :

```python
# meu_modulo.py

def saudacao():
    return "Olá, bem-vindo ao meu módulo!"

mensagem = "Este é um exemplo de módulo."
```

Agora, em outro arquivo Python `main.py`, pode-se fazer o seguinte :

```python
# main.py
import meu_modulo

# chamando a função saudacao() do módulo
print(f'{meu_modulo.saudacao() = }')

# acessa a variável mensagem do módulo
print(f'{meu_modulo.mensagem = }')
```

O código acima irá mostrar :

```
Olá, bem-vindo ao meu módulo!
Este é um exemplo de módulo.
```

### importando vários módulos

Pode-se importar múltiplos módulos em um único arquivo Python. Eles podem ser módulos que você criou ou módulos padrão do Python. Cada módulo importado será acessível pelo seu próprio namespace.

- exemplo 2 : importando múltiplos módulos

```python
# main.py
import meu_modulo
import outro_modulo

print(f'{meu_modulo.saudacao() = }')
print(f'{outro_modulo.outra_funcao() = }')
```

### importar módulos repetidamente

Uma vez que um módulo é importado, ele não é reexecutado se for importado novamente no mesmo programa, a menos que o programa seja reiniciado. Isso significa que o código do módulo será executado apenas na primeira vez que o `import` for chamado.

### organização do código com módulos

O uso do `import` é fundamental para organizar o código em partes menores e mais gerenciáveis. Em vez de ter um único arquivo grande, pode-se dividir funcionalidades em diferentes módulos, importando-os conforme necessário. Isso facilita a manutenção e o reuso de código.

- exemplo 3 : organização com módulos

Considere um projeto com três módulos: `matematica.py`, `mensagens.py` e `main.py`.

**arquivo : `matematica.py`**

```python
# matematica.py

def soma(a, b):
    return a + b

def subtracao(a, b):
    return a - b
```

**arquivo : `mensagens.py`**

```python
# mensagens.py

def boas_vindas():
    return "Bem-vindo ao sistema!"

def despedida():
    return "Obrigado por usar o sistema!"
```

**arquivo : `main.py`**

```python
import matematica
import mensagens

print(mensagens.boas_vindas())
resultado = matematica.soma(10, 5)
print(f'A soma é : {resultado}')
print(mensagens.despedida())
```

**saída esperada :**

```
Bem-vindo ao sistema!
A soma é : 15
Obrigado por usar o sistema!
```

## comandos `from` e `as`

O Python oferece várias maneiras de importar funcionalidades de outros módulos. Além do simples `import`, já discutido acima, é possível usar `from ... import`, `import ... as`, e `from ... import ... as` para gerenciar como as funções e variáveis são importadas e acessadas em seu código.

### `from ... import`

O comando `from ... import` é usado quando se deseja importar funções, classes ou variáveis específicas de um módulo, ao invés de importar todo o módulo. Isso é útil quando se quer evitar a importação de todo o conteúdo do módulo, especialmente se apenas precisa de alguns itens.

Veja a sintaxe :

```python
from nome_do_modulo import nome1, nome2, ...
```

Aqui, `nome_do_modulo` é o nome do módulo que se está importando, e `nome1`, `nome2`, etc., são os nomes das funções, variáveis ou classes que se deseja importar.

- exemplo 1 : importando funções específicas

Vamos supor que tenha um módulo chamado `matematica.py` com o seguinte conteúdo :

```python
# matematica.py

def soma(a, b):
    return a + b

def subtracao(a, b):
    return a - b

PI = 3.14159
```

Se quiser usar apenas a função `soma` no seu script, sem importar o restante do módulo, pode-se fazer o seguinte :

```python
from matematica import soma

resultado = soma(10, 5)
print(resultado)  # saída : 15
```

Neste caso, apenas a função `soma` foi importada. Se tentar usar `subtracao` ou `PI`, receberá um erro, pois eles não foram importados.

- exemplo 2: importando múltiplos itens

Também é possível importar várias funções e variáveis ao mesmo tempo :

```python
from matematica import soma, subtracao, PI

print(soma(10, 5))        # saída : 15
print(subtracao(10, 5))   # saída : 5
print(PI)                 # saída : 3.14159
```

### `import ... as`

O comando `import ... as` permite que importe um módulo e, ao mesmo tempo, atribua a ele um alias (ou pseudônimo). Isso é útil para encurtar o nome de um módulo ou para evitar conflitos de nomes quando dois módulos têm o mesmo nome.

Veja a sintaxe abaixo :

```python
import nome_do_modulo as alias
```

Aqui, `nome_do_modulo` é o nome do módulo que está importando, e `alias` é o nome que deseja usar para se referir ao módulo no código.

- exemplo 3 : usando alias para módulos

Vamos dizer exista um módulo chamado `calculadora.py` :

```python
# calculadora.py

def multiplicacao(a, b):
    return a * b

def divisao(a, b):
    if b != 0:
        return a / b
    else:
        return "Divisão por zero não é permitida"
```

Se o nome do módulo for longo, ou se quiser evitar conflitos de nomes, pode importá-lo com um alias :

```python
import calculadora as calc

resultado = calc.multiplicacao(6, 7)
print(resultado)  # saída : 42
```

Agora, pode-se usar `calc` em vez de `calculadora` para acessar as funções dentro desse módulo.

### `from ... import ... as`

O comando `from ... import ... as` combina as funcionalidades de `from ... import` e `import ... as`. Ele permite que se importe itens específicos de um módulo e lhes atribua novos nomes (alias) dentro do seu código.

Veja a sintaxe abaixo :

```python
from nome_do_modulo import nome as alias
```

Aqui, `nome_do_modulo` é o nome do módulo de onde se está importando, `nome` é a função, variável ou classe que se deseja importar, e `alias` é o novo nome que se deseja usar para referenciar esse item.

- exemplo 4 : usando alias para funções específicas

Voltando ao módulo `matematica.py` :

```python
from matematica import soma as adicionar

resultado = adicionar(10, 20)
print(resultado)  # saída : 30
```

Aqui, a função `soma` foi importada com o nome `adicionar`. Dentro do script, deve-se usar o nome `adicionar` para referir-se à função `soma`.

## comparando as abordagens

- **`import nome_do_modulo`** : importa todo o módulo. Deve-se usar o nome do módulo para acessar suas funções e variáveis;
- **`from nome_do_modulo import nome`** : importa apenas funções ou variáveis específicas, sem a necessidade de referenciar o módulo;
- **`import nome_do_modulo as alias`** : importa todo o módulo, mas permite que se use um nome diferente para referenciá-lo;
- **`from nome_do_modulo import nome as alias`** : importa funções ou variáveis específicas e permite que lhes atribua novos nomes;

### quando usar cada abordagem

- Use **`import nome_do_modulo`** quando precisar de várias funções ou variáveis de um módulo e não se importa em acessar essas funcionalidades usando o nome do módulo.
- Use **`from nome_do_modulo import nome`** quando você precisar de apenas algumas funcionalidades de um módulo e quer evitar a sobrecarga de importar tudo.
- Use **`import nome_do_modulo as alias`** quando o nome do módulo for muito longo ou se houver um conflito de nomes com outro módulo.
- Use **`from nome_do_modulo import nome as alias`** quando se quiser importar uma função ou variável específica e atribuir-lhe um nome que seja mais descritivo ou conveniente no contexto do código.

## exemplo completo

Vamos juntar tudo em um exemplo prático. Suponha que se tenha dois módulos: `geometria.py` e `algebra.py`.

**arquivo : `geometria.py`**

```python
# geometria.py

def area_quadrado(lado):
    return lado * lado

def area_retangulo(largura, altura):
    return largura * altura
```

**arquivo : `algebra.py`**

```python
# algebra.py

def quadrado(numero):
    return numero * numero

def raiz_quadrada(numero):
    return numero ** 0.5
```

Agora, pode-se usar as diferentes formas de `import` em um script principal:

```python
# main.py

from geometria import area_quadrado as quadrado_area
import algebra as alg

lado = 5
numero = 16

print(f"Área do quadrado: {quadrado_area(lado)}")  # Usando alias para a função de geometria
print(f"Quadrado de {lado}: {alg.quadrado(lado)}")  # Usando alias para o módulo de álgebra
print(f"Raiz quadrada de {numero}: {alg.raiz_quadrada(numero)}")
```

**Saída esperada:**

```
Área do quadrado: 25
Quadrado de 5: 25
Raiz quadrada de 16: 4.0
```

## execícios

<details>
<summary>Lista de Exercícios</summary>

1. Exercícios de `import`
    1. Crie um módulo chamado `matematica.py` que contenha funções `soma(a, b)` e `multiplicacao(a, b)`. No seu script principal, importe o módulo completo e use as funções para calcular `soma(5, 3)` e `multiplicacao(4, 6)`.
        ```python
        # main.py
        import matematica

        print(f'{matematica.soma(5, 3) = }')
        print(f'{matematica.multiplicacao(4, 6) = }')

        # matematica.py
        def soma(a, b):
            return a + b

        def multiplicacao(a, b):
            return a * b
        ```
    1. Crie um módulo chamado `utilidades.py` com uma função `menor(a, b)` e uma variável `pi`. No seu script principal, importe o módulo completo e imprima o valor de `pi` e o resultado de `menor(10, 20)`.
    1. Crie um módulo chamado `strings.py` com uma função `concatena(s1, s2)` que retorna a concatenação de duas strings. No seu script principal, importe o módulo completo e use a função para concatenar as strings `"Olá"` e `"Mundo"`.
    1. Crie um módulo chamado `calculos.py` com uma função `fatorial(n)` que retorna o fatorial de um número. No seu script principal, importe o módulo completo e calcule o fatorial de `5`.
        ```python
        # main.py
        import calculos as calc

        calc.fatorial(5)

        # calculos.py
        def fatorial(n):
            resultado = 1

            while n > 0:
                print(f'{n = }, {resultado = }')
                resultado *= n  # resultado = resultado * n
                n -= 1  # n = n - 1

            print(f'{n = }')
            print(f'{resultado = }')
        ```
    1. Crie um módulo chamado `data.py` com uma função `data_atual()` que retorna a data atual no formato `"YYYY-MM-DD"`. No seu script principal, importe o módulo completo e exiba a data atual.
        ```python
        # main.py
        import data

        print(f'{data.data_atual() = }')

        # data.py
        def data_atual():
            return "2024-09-03"
        ```
1. Exercícios de `from ... import`
    1. Crie um módulo chamado `matematica_basica.py` com funções `soma(a, b)`, `subtracao(a, b)`, e `multiplicacao(a, b)`. No seu script principal, importe apenas a função `soma` e utilize-a para somar `8` e `12`.
    1. Crie um módulo chamado `strings_avancadas.py` com funções `capitalizar(s)` e `inverter(s)`. No seu script principal, importe a função `inverter` e use-a para inverter a string `"Python"`.
    1. Crie um módulo chamado `geometria_basica.py` com funções `area_circulo(raio)` e `perimetro_quadrado(lado)`. No seu script principal, importe apenas a função `perimetro_quadrado` e calcule o perímetro de um quadrado com lado `7`.
    1. Crie um módulo chamado `algebra_basica.py` com funções `quadrado(x)` e `raiz_quadrada(x)`. No seu script principal, importe apenas a função `raiz_quadrada` e calcule a raiz quadrada de `16`.
    1. Crie um módulo chamado `conversao.py` com funções `km_para_milhas(km)` e `celsius_para_fahrenheit(celsius)`. No seu script principal, importe apenas a função `km_para_milhas` e converta `100` quilômetros para milhas.
1. Exercícios de `import ... as`
    1. Crie um módulo chamado `calculadora.py` com funções `adicao(a, b)`, `subtracao(a, b)`, e `multiplicacao(a, b)`. No seu script principal, importe o módulo usando o alias `calc` e use a função `adicao` para somar `15` e `25`.
    1. Crie um módulo chamado `convert.py` com funções `dolar_para_euro(dolares)` e `euro_para_reais(euros)`. No seu script principal, importe o módulo com o alias `conv` e converta `50` dólares para euros.
    1. Crie um módulo chamado `estatisticas.py` com funções `media(lista)` e `mediana(lista)`. No seu script principal, importe o módulo como `est` e calcule a média de `[1, 2, 3, 4, 5]`.
    1. Crie um módulo chamado `tempo.py` com funções `dias_para_horas(dias)` e `horas_para_minutos(horas)`. No seu script principal, importe o módulo com o alias `temp` e calcule o número de horas em `3` dias.
    1. Crie um módulo chamado `letras.py` com funções `contar_vogais(s)` e `contar_consoantes(s)`. No seu script principal, importe o módulo usando o alias `let` e conte o número de vogais na string `"Programação"`.
1. Exercícios de `from ... import ... as`
    1. Crie um módulo chamado `ferramentas.py` com funções `ordenar_lista(lista)` e `filtrar_lista(lista, critério)`. No seu script principal, importe `ordenar_lista` como `ordenar` e use-a para ordenar a lista `[4, 2, 9, 1]`.
    1. Crie um módulo chamado `textos.py` com funções `remover_espacos(s)` e `contar_palavras(s)`. No seu script principal, importe `contar_palavras` como `contar` e conte o número de palavras na string `"Python é divertido"`.
    1. Crie um módulo chamado `matematica_avancada.py` com funções `logaritmo(x, base)` e `potencia(base, expoente)`. No seu script principal, importe `potencia` como `exp` e calcule `2` elevado à `10`.
    1. Crie um módulo chamado `formatacao.py` com funções `formatar_data(data)` e `formatar_moeda(valor)`. No seu script principal, importe `formatar_data` como `formatar` e formate a data `"2024-09-03"`.
    1. Crie um módulo chamado `aleatorios.py` com funções `gerar_numero_aleatorio()` e `gerar_lista_aleatoria(tamanho)`. No seu script principal, importe `gerar_numero_aleatorio` como `numero_aleatorio` e gere um número aleatório.
1. Exercícios Combinados
    1. Crie um módulo chamado `financeiro.py` com funções `calcular_juros(principal, taxa, tempo)` e `calcular_investimento(principal, taxa, tempo)`. No seu script principal, importe `calcular_juros` como `juros` e `calcular_investimento` como `investimento`, e calcule o investimento inicial de `1000` com taxa de `5%` ao longo de `2` anos.
    1. Crie um módulo chamado `analise.py` com funções `media_lista(lista)` e `desvio_padrao(lista)`. No seu script principal, importe `desvio_padrao` como `desvio` e calcule o desvio padrão da lista `[2, 4, 4, 4, 5, 5, 7, 9]`.
        ```python
        # main.py
        from funcoes import desvio_padrao as desvio

        lista = [2, 4, 4, 4, 5, 5, 7, 9]
        desvio(lista)

        # analise.py
        def media_lista(lista):
            tamanho = len(lista)

            soma = 0
            for valor in lista:
                soma += valor

            media = soma / tamanho

            return media

        def desvio_padrao(lista):

            print(f'{lista = }')
            media = media_lista(lista)
            print(f'{media = }')

            difer_elem = []

            for valor in lista:
                diferenca = valor - media
                quadrado = diferenca ** 2
                difer_elem.append(quadrado)

            media_quad = media_lista(difer_elem)
            print(f'{media_quad = }')
            desvio_padrao = media_quad ** (1/2)

            print(f'o desvio da lista eh : {desvio_padrao = }')
        ```
    1. Crie um módulo chamado `comparacao.py` com funções `maior(a, b)` e `menor(a, b)`. No seu script principal, importe `menor` como `encontrar_menor` e calcule o menor entre `8` e `12`.
    1. Crie um módulo chamado `geometria.py` com funções `volume_cubo(lado)` e `volume_esfera(raio)`. No seu script principal, importe `volume_cubo` como `volume_c` e `volume_esfera` como `volume_e`, e calcule o volume de um cubo com lado `3` e uma esfera com raio `4`.
    1. Crie um módulo chamado `dados.py` com funções `criar_lista(tamanho)` e `criar_dicionario(chaves, valores)`. No seu script principal, importe `criar_lista` como `criar_lista_dados` e `criar_dicionario` como `criar_dict`, e crie uma lista com `5` elementos e um dicionário com as chaves `['a', 'b']` e valores `[1, 2]`.
    1. Crie um módulo chamado `crypto.py` com funções `criptografar(texto)` e `descriptografar(texto)`. No seu script principal, importe `criptografar` como `cripto` e `descriptografar` como `descripto`, e criptografe o texto `"Segredo"`.
    1. Crie um módulo chamado `geradores.py` com funções `gerar_username(nome)` e `gerar_senha(tamanho)`. No seu script principal, importe `gerar_username` como `username` e `gerar_senha` como `senha`, e gere um nome de usuário e uma senha de `12` caracteres.
    1. Crie um módulo chamado `contas.py` com funções `adicionar_conta(nome, valor)` e `remover_conta(nome)`. No seu script principal, importe `adicionar_conta` como `adicionar` e `remover_conta` como `remover`, e adicione uma conta chamada `"Aluguel"` com valor `1200`.
    1. Crie um módulo chamado `desenho.py` com funções `desenhar_circulo(raio)` e `desenhar_quadrado(lado)`. No seu script principal, importe `desenhar_circulo` como `circulo` e `desenhar_quadrado` como `quadrado`, e desenhe um círculo com raio `5` e um quadrado com lado `10`.
    1. Crie um módulo chamado `enderecos.py` com funções `formatar_endereco(cidade, estado)` e `validar_cep(cep)`. No seu script principal, importe `formatar_endereco` como `formatar_end` e `validar_cep` como `validar_cep`, e formate o endereço para `"São Paulo"` e `"SP"` e valide o CEP `"12345-678"`.
    1. Crie um módulo chamado `arquivos.py` com funções `ler_arquivo(caminho)` e `escrever_arquivo(caminho, conteudo)`. No seu script principal, importe `ler_arquivo` como `ler` e `escrever_arquivo` como `escrever`, e escreva o texto `"Exemplo"` em um arquivo chamado `"teste.txt"` e depois leia o conteúdo desse arquivo.
    1. Crie um módulo chamado `mensagens.py` com funções `enviar_email(remetente, destinatario, assunto, corpo)` e `enviar_sms(numero, mensagem)`. No seu script principal, importe `enviar_email` como `email` e `enviar_sms` como `sms`, e envie um e-mail para `"exemplo@dominio.com"` com o assunto `"Teste"` e uma mensagem `"Olá"`.
    1. Crie um módulo chamado `relatorios.py` com funções `gerar_relatorio(dados)` e `salvar_relatorio(caminho)`. No seu script principal, importe `gerar_relatorio` como `relatorio` e `salvar_relatorio` como `salvar`, e gere um relatório com dados `["Dados1", "Dados2"]` e salve-o no caminho `"relatorio.txt"`.
    1. Crie um módulo chamado `relogio.py` com funções `hora_atual()` e `tempo_decorrido(inicio, fim)`. No seu script principal, importe `hora_atual` como `hora` e `tempo_decorrido` como `tempo`, e exiba a hora atual e calcule o tempo decorrido entre `10` e `20`.
    1. Crie um módulo chamado `cartas.py` com funções `embaralhar_cartas()` e `distribuir_cartas(jogadores)`. No seu script principal, importe `embaralhar_cartas` como `embaralhar` e `distribuir_cartas` como `distribuir`, e embaralhe um baralho e distribua as cartas para `4` jogadores.
    1. Crie um módulo chamado `arquitetura.py` com funções `criar_plano(tipo)` e `revisar_plano(plano)`. No seu script principal, importe `criar_plano` como `plano` e `revisar_plano` como `revisar`, e crie um plano para um `"escritório"` e revise o plano.
    1. Crie um módulo chamado `conversores.py` com funções `farenheit_para_celsius(fahrenheit)` e `celsius_para_kelvin(celsius)`. No seu script principal, importe `farenheit_para_celsius` como `farenheit_celsius` e `celsius_para_kelvin` como `celsius_kelvin`, e converta `32` graus Fahrenheit para Celsius e depois para Kelvin.
    1. Crie um módulo chamado `financeiro_avancado.py` com funções `calcular_amortizacao(principal, taxa, anos)` e `calcular_juros_compostos(principal, taxa, anos)`. No seu script principal, importe `calcular_amortizacao` como `amortizacao` e `calcular_juros_compostos` como `juros_compostos`, e calcule a amortização e os juros compostos para um empréstimo de `10000` com taxa `5%` ao longo de `10` anos.
    1. Crie um módulo chamado `analises_avancadas.py` com funções `analise_temporal(dados)` e `analise_espacial(dados)`. No seu script principal, importe `analise_temporal` como `temporal` e `analise_espacial` como `espacial`, e faça uma análise temporal e espacial de um conjunto de dados fictícios.
    1. Crie um módulo chamado `crimes.py` com funções `relatar_crime(tipo, descricao)` e `consultar_crimes(local)`. No seu script principal, importe `relatar_crime` como `relatar` e `consultar_crimes` como `consultar`, e relate um crime de `"furto"` e consulte os crimes ocorridos no `"bairro"`.

</details>
Índice

1. [vantagens](#vantagens)
1. [sintaxe](#sintaxe)
1. [exemplos](#exemplos)
1. [exemplos aula](#exemplos-aula)
1. [conclusão](#conclusão)
1. [exercícios](#exercícios)

# compreensão de listas

A **compreensão de listas** (*list comprehension*) é uma maneira concisa e elegante de criar listas em Python. Ela permite construir novas listas aplicando uma expressão a cada item de uma sequência existente e, opcionalmente, filtrando itens com base em alguma condição.

## vantagens

- **sintaxe concisa** : reduz o número de linhas de código comparado aos loops tradicionais;
- **leitura fácil** : facilita a compreensão do código, tornando-o mais legível;
- **performance melhorada** : em muitos casos, compreensões de listas são mais rápidas do que construções de loops equivalentes;

## sintaxe

A sintaxe geral de uma compreensão de lista é :

```python
[<expressão> for <item_do_iterável> in <iterável>]
```

- **expressão** : operação ou valor que será aplicado a cada item;
- **item_do_iterável** : variável que representa cada elemento no iterável;
- **iterável** : uma sequência ou objeto que pode ser iterado (como listas, tuplas, strings, etc.);

Também é possível adicionar condições :

```python
[<expressão> for <item_do_iterável> in <iterável> if <condição>]
```

- **condição** : uma expressão booleana que filtra os itens do iterável;

## exemplos

### exemplo 1 : criando uma lista simples

```python
>>> # usando o loop tradicional
>>> numeros = []
>>> for i in range(10):
...     numeros.append(i)
...
>>> print(numeros)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>>
>>> # usando compreensão de lista
>>> numeros = [i for i in range(10)]
>>> print(numeros)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> |
```

- **loop tradicional** : é inicializada uma lista vazia e um loop `for` é usado para adicionar cada número de 0 a 9;
- **compreensão de lista** : a mesma operação é realizada em uma única linha, tornando o código mais conciso e legível;

### exemplo 2 : aplicando operações aos itens

```python
>>> # usando o loop tradicional
>>> quadrados = []
>>> for i in range(10):
...     quadrados.append(i**2)
...
>>> print(quadrados)
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
>>>
>>> # usando compreensão de lista
>>> quadrados = [i**2 for i in range(10)]
>>> print(quadrados)
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
>>> |
```

- **expressão** : `i**2` calcula o quadrado de cada número `i` no intervalo de 0 a 9;
- **iterável** : `range(10)` fornece os números de 0 a 9;

### exemplo 3 : filtrando itens com condição

```python
>>> # usando o loop tradicional
>>> pares = []
>>> for i in range(20):
...     if i % 2 == 0:
...         pares.append(i)
...
>>> print(pares)
[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
>>>
>>> # usando compreensão de lista
>>> pares = [i for i in range(20) if i % 2 == 0]
>>> print(pares)
[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
>>> |
```

- **condição** : `if i % 2 == 0` filtra apenas os números que são divisíveis por 2 (números pares);
- **vantagem** : a compreensão de lista combina a iteração e a filtragem em uma única linha;

### exemplo 4 : transformando strings

```python
>>> palavras = ['python', 'compreensão', 'lista', 'exemplo']
>>>
>>> # usando o loop tradicional
>>> maiusculas = []
>>> for palavra in palavras:
...     maiusculas.append(palavra.upper())
...
>>> print(maiusculas)
['PYTHON', 'COMPREENSÃO', 'LISTA', 'EXEMPLO']
>>>
>>> # usando a compreensão de lista
>>> maiusculas = [palavra.upper() for palavra in palavras]
>>> print(maiusculas)
['PYTHON', 'COMPREENSÃO', 'LISTA', 'EXEMPLO']
>>> |
```

- **expressão** : `palavra.upper()` converte cada palavra para letras maiúsculas;
- **iterável** : a lista `palavras` é percorrida, aplicando a transformação a cada elemento;

### exemplo 5 : compreensão com funções

```python
>>> frase = "Compreensões de listas são poderosas"
>>>
>>> # usando o loop tradicional
>>> comprimentos = []
>>> for palavra in frase.split():
...     comprimentos.append(len(palavra))
...
>>> print(comprimentos)
[12, 2, 6, 3, 10]
>>>
>>> # usando compreensão de lista
>>> comprimentos = [len(palavra) for palavra in frase.split()]
>>> print(comprimentos)
[12, 2, 6, 3, 10]
>>> |
```

- **`frase.split()`:** : divide a frase em uma lista de palavras;
- **`len(palavra)`** : calcula o comprimento de cada palavra;

### exemplo 6 : compreensão aninhada (nested)

```python
>>> # usando o loop tradicional
>>> coordenadas = []
>>> for x in range(3):
...     for y in range(3):
...         coordenadas.append((x, y))
...
>>> print(coordenadas)
[(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]
>>>
>>> # usando compreensão de lista
>>> coordenadas = [(x, y) for x in range(3) for y in range(3)]
>>> print(coordenadas)
[(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]
>>> |
```

- **loops aninhados** : para cada valor de `x`, o loop interno itera sobre `y`;
- **expressão** : cria tuplas `(x, y)` para cada combinação possível;

### exemplo 7 : filtrando com condição complexa

```python
>>> # usando o loop tradicional
>>> numeros = []
>>> for i in range(1, 51):
...     if i % 3 == 0 and i % 5 == 0:
...         numeros.append(i)
...
>>> print(numeros)
[15, 30, 45]
>>>
>>> # usando compreensão de lista
>>> numeros = [i for i in range(1, 51) if i % 3 == 0 and i % 5 == 0]
>>> print(numeros)
[15, 30, 45]
>>> |
```

- **condição** : `i % 3 == 0 and i % 5 == 0` seleciona números divisíveis por ambos 3 e 5;
- **iterável** : `range(1, 51)` fornece números de 1 a 50;

---

### exemplo 8 : compreensão de lista com função condicional

```python
>>> # usando o loop tradicional
>>> resultado = []
>>> for i in range(10):
...     if i % 2 == 0:
...         resultado.append("Par")
...     else:
...         resultado.append("Ímpar")
>>>
>>> print(resultado)
['Par', 'Ímpar', 'Par', 'Ímpar', 'Par', 'Ímpar', 'Par', 'Ímpar', 'Par', 'Ímpar']
>>>
>>> # usando compreensão de lista
>>> resultado = ["Par" if i % 2 == 0 else "Ímpar" for i in range(10)]
>>> print(resultado)
['Par', 'Ímpar', 'Par', 'Ímpar', 'Par', 'Ímpar', 'Par', 'Ímpar', 'Par', 'Ímpar']
>>> |
```

- **expressão condicional** : `"par" if i % 2 == 0 else "ímpar"` avalia cada número e retorna a string correspondente;
- **iterável** : itera sobre números de 0 a 9;

### exemplo 9 : compreensão de lista com funções e filtragem

```python
>>> nomes = ['Ana', 'Bruno', 'Carlos', 'Diana', 'Eduardo', 'Fátima']
>>>
>>> # usando o loop tradicional
>>> nomes_filtrados = []
>>> for nome in nomes:
...     if len(nome) > 5:
...         nomes_filtrados.append(nome.upper())
...
>>> print(nomes_filtrados)
['CARLOS', 'EDUARDO', 'FÁTIMA']
>>>
>>> # usando compreensão de lista
>>> nomes_filtrados = [nome.upper() for nome in nomes if len(nome) > 5]
>>> print(nomes_filtrados)
['CARLOS', 'EDUARDO', 'FÁTIMA']
>>> |
```

- **condição** : `if len(nome) > 5` filtra nomes com mais de 5 letras;
- **expressão** : `nome.upper()` converte os nomes filtrados para maiúsculas;

### exemplo 10 : achatar lista de listas

```python
>>> listas = [[1, 2], [3, 4], [5, 6]]
>>>
>>> # usando o loop tradicional
>>> lista_plana = []
>>> for sublista in listas:
...     for item in sublista:
...         lista_plana.append(item)
...
>>> print(lista_plana)
[1, 2, 3, 4, 5, 6]
>>>
>>> # usando compreensão de lista
>>> lista_plana = [item for sublista in listas for item in sublista]
>>> print(lista_plana)
[1, 2, 3, 4, 5, 6]
>>> |
```

- **loops aninhados** : o primeiro loop percorre cada sublista, e o segundo loop percorre cada item dentro das sublistas;
- **expressão** : cada `item` é adicionado à nova lista plana;

## exemplos aula

Segue abaixo os exemplos mais complexos realizados em aula :

```python
>>> # iterando sobre uma lista de 100 números,
>>> # primeiro filtrando pelos múltiplos de 4 E 5
>>> # depois separando em tuplas de string (par ou impar) e o valor de n
>>> tuplas = []
>>> for n in range(100):
...    if n % 4 == 0 and n % 5 == 0:
...        if n % 2 == 0:
...            tuplas.append(('par',n))
...        else:
...            tuplas.append(('impar',n))
...
>>> tuplas
[('par', 0), ('par', 20), ('par', 40), ('par', 60), ('par', 80)]
>>>
>>> # mesma coisa que acima, mas usando compreensao de lista
>>> # e operador ternário
>>> [('par',n) if n % 2 == 0 else ('impar',n) for n in range(100) if n % 4 == 0 and n % 5 == 0]
[('par', 0), ('par', 20), ('par', 40), ('par', 60), ('par', 80)]
>>> |
```
```python
>>> mista = [True, 'carlos', 42, 'maria', False, 3.14]
>>>
>>> resultado = []
>>> # filtragem da lista mista, separando apenas o valores dos tipos
>>> # string e inteiros, depois, se for string deixa em caixa alta
>>> # se for inteiro, eleva ao quadrado
>>> for item in mista:
...     if isinstance(item,str) or isinstance(item,int):
...         if isinstance(item,str):
...             resultado.append(item.upper())
...         else:
...             resultado.append(item ** 2)
...
>>> resultado
[1, 'CARLOS', 1764, 'MARIA', 0]
>>>
>>> # a mesma coisa que acima, mas agora usando compreensão de listas
>>> # e o operador ternário
>>> [item.upper() if isinstance(item,str) else item ** 2 for item in mista if isinstance(item,str) or isinstance(item,int)]
[1, 'CARLOS', 1764, 'MARIA', 0]
>>> |
```

## conclusão

As **compreensões de listas** são uma ferramenta poderosa em Python que permitem escrever código mais compacto e legível. Elas são particularmente úteis para :

- **transformar dados** : aplicando operações a todos os itens de uma sequência;
- **filtrar dados** : Selecionando itens que atendem a determinadas condições;
- **criar estruturas complexas** : Como listas aninhadas ou dicionários, de forma concisa;

## exercícios

<details>
<summary>Lista de Execícios</summary>

> [!TIP]
> para os seguintes execícios :
> - primeiro, crie a versão tradicional do exercício;
> - depois, a partir da primeira, crie a versão de compreensão de lista;

Exemplo :
```python
>>> # Dobro dos Números : Dada a lista `numeros = [1, 2, 3, 4, 5]`, crie
>>> # uma nova lista que contenha o dobro de cada número da lista original.
>>>
>>> numeros = [1, 2, 3, 4, 5]
>>>
>>> # usando o loop tradicional
>>> nova_lista = []
>>> for n in numeros:
...     nova_lista.append(n * 2)
...
>>> print(nova_lista)
[2, 4, 6, 8, 10]
>>>
>>> # usando compreensão de lista
>>> nova_lista = [n * 2 for n in numeros]
>>> nova_lista
[2, 4, 6, 8, 10]
>>> |
```

1. Nível Simples
    1. **Dobro dos Números**: Dada a lista `numeros = [1, 2, 3, 4, 5]`, crie uma nova lista que contenha o dobro de cada número da lista original.
    1. **Quadrado dos Números**: Dada a lista `numeros = [1, 2, 3, 4, 5]`, crie uma nova lista que contenha o quadrado de cada número da lista original.
    1. **Números Pares**: Dada a lista `numeros = [1, 2, 3, 4, 5, 6]`, crie uma nova lista que contenha apenas os números pares da lista original.
    1. **Números Ímpares**: Dada a lista `numeros = [1, 2, 3, 4, 5, 6]`, crie uma nova lista que contenha apenas os números ímpares da lista original.
    1. **Strings em Maiúsculas**: Dada a lista `palavras = ["python", "é", "legal"]`, crie uma nova lista que contenha cada palavra da lista original em maiúsculas.
1. Nível Intermediário
    1. **Comprimento das Strings**: Dada a lista `palavras = ["python", "é", "legal"]`, crie uma nova lista que contenha o comprimento de cada palavra da lista original.
    1. **Filtrar Booleans Verdadeiros**: Dada a lista `valores = [True, False, True, False]`, crie uma nova lista que contenha apenas os valores `True` da lista original.
    1. **Strings com mais de 3 Caracteres**: Dada a lista `palavras = ["oi", "python", "sim", "não"]`, crie uma nova lista que contenha apenas as palavras com mais de 3 caracteres.
    1. **Números Divisíveis por 3**: Dada a lista `numeros = [3, 6, 9, 12, 15, 18]`, crie uma nova lista que contenha apenas os números que são divisíveis por 3.
    1. **Negativos a partir de uma Tupla**: Dada a tupla `numeros = (1, -2, 3, -4, 5)`, crie uma nova lista que contenha apenas os números negativos da tupla.
1. Nível Avançado
    1. **Multiplicação de Pares por 2**: Dada a lista `numeros = [1, 2, 3, 4, 5, 6]`, crie uma nova lista onde os números pares são multiplicados por 2, e os ímpares permanecem inalterados.
    1. **Conversão de Strings em Booleans**: Dada a lista `strings = ["True", "False", "True", "False"]`, crie uma nova lista que converta as strings `"True"` e `"False"` para seus respectivos valores booleanos.
    1. **Filtrar Tuplas que Contêm Inteiros**: Dada a lista `tuplas = [(1, 2), ("a", "b"), (3, 4)]`, crie uma nova lista que contenha apenas as tuplas que contêm apenas inteiros.
    1. **Primeiros Caracteres de Strings**: Dada a lista `palavras = ["Python", "é", "incrível"]`, crie uma nova lista que contenha o primeiro caractere de cada palavra.
    1. **Listas com Todos os Valores Verdadeiros**: Dada a lista `listas = [[True, True], [True, False], [False, False]]`, crie uma nova lista que contenha apenas as listas onde todos os valores são `True`.
1. Nível Complexo
    1. **Somar Valores de Tuplas**: Dada a lista `tuplas = [(1, 2), (3, 4), (5, 6)]`, crie uma nova lista que contenha a soma dos valores de cada tupla.
    1. **Inverter Strings**: Dada a lista `palavras = ["Python", "é", "incrível"]`, crie uma nova lista que contenha cada palavra invertida.
    1. **Substituição Condicional**: Dada a lista `numeros = [1, 2, 3, 4, 5, 6]`, crie uma nova lista onde os números menores que 4 são substituídos por `"Pequeno"`, e os demais são substituídos por `"Grande"`.
    1. **Concatenar Listas**: Dada a lista de listas `listas = [[1, 2], [3, 4], [5, 6]]`, crie uma nova lista que contenha todos os elementos concatenados em uma única lista.
    1. **Números em Strings com Mais de 5 Dígitos**: Dada a lista `numeros = ["12345", "678901", "23456"]`, crie uma nova lista que contenha apenas os números que tenham mais de 5 dígitos.
1. Nível Muito Complexo
    1. **Intersecção de Listas**: Dadas as listas `a = [1, 2, 3]` e `b = [2, 3, 4]`, crie uma nova lista que contenha os elementos que estão em ambas as listas.
    1. **Números Flutuantes Menores que Inteiros**: Dada a lista `numeros = [1, 2.5, 3.7, 4]`, crie uma nova lista que contenha apenas os números flutuantes que são menores que os inteiros.
    1. **Filtragem Condicional em Tuplas**: Dada a lista de tuplas `tuplas = [(1, 2), (3, 4), (5, 6)]`, crie uma nova lista que contenha apenas as tuplas onde o primeiro valor é menor que o segundo.
    1. **Booleanos em Listas Mistas**: Dada a lista mista `mista = [True, 1, False, 0, "True", "False"]`, crie uma nova lista que contenha apenas os valores booleanos da lista.
    1. **Criação de Tuplas a partir de Listas**: Dada a lista `numeros = [1, 2, 3, 4]`, crie uma nova lista que contenha tuplas, onde cada tupla é composta por um número da lista original e seu quadrado.

</details>
Índice

1. [cópia atribuição direta](#cópia-atribuição-direta)
1. [cópia rasa](#cópia-rasa)
1. [exercícios cópia rasa](#exercícios-cópia-rasa)
1. [cópia profunda](#cópia-profunda)
1. [cópia rasa e profunda em outros tipos](#cópia-rasa-e-profunda-em-outros-tipos)

# operações de cópia

## cópia atribuição direta

A cópia com atribuição direta no Python é uma técnica simples, mas pode ser confusa se não entendida corretamente. Quando se faz uma atribuição direta, como `lista_b = lista_a`, não está criando uma nova lista independente; ao invés disso, está apenas criando uma nova referência ao mesmo objeto na memória. Isso significa que qualquer alteração feita em uma das listas será refletida na outra, pois ambas apontam para o mesmo local na memória.

### exemplo 1 : atribuição direta com objetos imutáveis

Embora a atribuição direta seja mais problemática com objetos mutáveis, é útil entender como ela funciona com objetos imutáveis para contrastar os comportamentos.

```python
>>> a = 10
>>> b = a
>>>
>>> print("Valor de a:", a)
10
>>> print("Valor de b:", b)
10
>>>
>>> b = 20
>>> print("Após mudar b:")
>>> print("Valor de a:", a)
10
>>> print("Valor de b:", b)
20
>>> |
```

**explicação :** neste exemplo, `a` e `b` inicialmente referenciam o mesmo valor imutável `10`. Porém, quando `b` é atribuído a `20`, ele passa a referenciar um novo objeto imutável `20`, enquanto `a` continua referenciando `10`. Isso ocorre porque, para objetos imutáveis, a atribuição direta não afeta o outro nome após a mudança de valor.

### exemplo 2 : atribuição direta com listas (objetos mutáveis)

Vamos explorar o que acontece quando se usa a atribuição direta com listas, que são objetos mutáveis.

```python
>>> lista_a = [1, 2, 3]
>>> lista_b = lista_a
>>>
>>> lista_b.append(4)
>>>
>>> print("Lista A:", lista_a)
[1, 2, 3, 4]
>>> print("Lista B:", lista_b)
[1, 2, 3, 4]
>>> |
```

**explicação :** aqui, `lista_a` e `lista_b` são referências ao mesmo objeto na memória. Portanto, quando se adiciona `4` a `lista_b`, `lista_a` também é alterada, porque ambas as variáveis apontam para a mesma lista.

### exemplo 3 : atribuição direta e modificação interna de listas

Considere um caso em que a lista contém objetos mutáveis, como sublistas:

```python
>>> lista_a = [[1, 2], [3, 4]]
>>> lista_b = lista_a
>>>
>>> lista_b[0].append(99)
>>>
>>> print("Lista A:", lista_a)
[[1, 2, 99], [3, 4]]
>>> print("Lista B:", lista_b)
[[1, 2, 99], [3, 4]]
>>> |
```

**explicação :** novamente, `lista_a` e `lista_b` referenciam o mesmo objeto. Quando se modifica uma das sublistas em `lista_b`, a alteração também aparece em `lista_a` porque as sublistas também são objetos mutáveis que ambas as variáveis referenciam.

### exemplo 4 : verificando referências com `id()`

Pode-se usar a função `id()` para verificar se duas variáveis realmente referenciam o mesmo objeto na memória.

```python
>>> lista_a = [1, 2, 3]
>>> lista_b = lista
>>>
>>> print(f'{id(lista_a) = }')
id(lista_a) = 124121926781376
>>> print(f'{id(lista_b) = }')
id(lista_b) = 124121926781376
>>> |
```

**explicação :** os IDs de `lista_a` e `lista_b` serão os mesmos, confirmando que ambas as variáveis referenciam o mesmo objeto na memória. Ao executar o código acima em sua máquina, certamente os valores dos IDs serão diferentes.

### quando usar atribuição direta

- **quando se deseja que duas variáveis compartilhem a mesma lista :** isso é útil em alguns casos onde se quer que todas as alterações sejam refletidas em ambas as variáveis;

- **em operações de otimização de memória :** atribuição direta é mais eficiente em termos de memória, pois não cria cópias adicionais dos dados;

### limitações da atribuição direta

- **risco de modificações indesejadas :** se não deseja que alterações em uma variável afetem outra, a atribuição direta pode causar problemas difíceis de depurar;

- **não adequado para listas que precisam ser independentes :** se precisa de listas independentes para manipular dados de maneira segura, evite a atribuição direta e opte por técnicas de cópia;

## cópia rasa

A cópia rasa (shallow copy) no Python é um conceito importante quando trabalhamos com listas e outros tipos de dados mutáveis. Embora uma cópia rasa crie uma nova lista, ela não cria cópias independentes dos objetos que estão dentro da lista original; ao invés disso, ela copia as referências para esses objetos. Isso significa que se os elementos dentro da lista forem mutáveis (como outras listas, dicionários ou objetos), modificações nesses elementos afetarão tanto a lista original quanto a cópia.

### como funciona a cópia rasa

Quando se faz uma cópia rasa de uma lista, o Python cria um novo objeto de lista, mas os elementos dentro dessa lista copiada ainda referenciam os mesmos objetos que os elementos da lista original. A cópia rasa é feita em um único nível da estrutura de dados. Se a lista contém objetos mutáveis (como outras listas ou dicionários), as referências para esses objetos são copiadas, mas os próprios objetos não são duplicados.

### exemplo 1 : cópia rasa com objetos imutáveis

Primeiro, veja como a cópia rasa funciona com objetos imutáveis como inteiros e strings:

```python
>>> lista_original = [1, 2, 3, "a", "b", "c"]
>>> lista_copiada = lista_original[:]
>>>
>>> lista_copiada[0] = 100
>>> lista_copiada[3] = "z"
>>>
>>> print("Lista original:", lista_original)
[1, 2, 3, "a", "b", "c"]
>>> print("Lista copiada:", lista_copiada)
[100, 2, 3, "z", "b", "c"]
>>> |
```

**explicação :** neste exemplo, `lista_copiada` é uma cópia rasa de `lista_original`. Como está sendo lidando com objetos imutáveis (inteiros e strings), a modificação em `lista_copiada` não afeta `lista_original`. Isso ocorre porque cada elemento da lista é imutável e, portanto, uma nova cópia do valor é feita na nova lista;

### exemplo 2: cópia rasa com objetos mutáveis (listas)

Agora, veja como a cópia rasa se comporta com objetos mutáveis, como listas aninhadas:

```python
>>> lista_original = [[1, 2, 3], [4, 5, 6]]
>>> lista_copiada = lista_original[:]
>>>
>>> lista_copiada[0].append(99)
>>>
>>> print("Lista original:", lista_original)
[[1, 2, 3, 99], [4, 5, 6]]
>>> print("Lista copiada:", lista_copiada)
[[1, 2, 3, 99], [4, 5, 6]]
>>> |
```

**explicação :** aqui, `lista_original` e `lista_copiada` são listas diferentes. No entanto, os elementos dentro de cada lista (que são eles mesmos listas) ainda referenciam os mesmos objetos na memória. Quando se altera um desses objetos (como adicionar `99` à primeira sublista), essa alteração é refletida em ambas as listas;

### exemplo 3 : cópia rasa com dicionários

O mesmo comportamento ocorre quando se trabalha com dicionários dentro de listas:

```python
>>> lista_original = [{"a": 1, "b": 2}, {"c": 3, "d": 4}]
>>> lista_copiada = lista_original[:]
>>>
>>> lista_copiada[0]["a"] = 100
>>>
>>> print("Lista original:", lista_original)
[{"a": 100, "b": 2}, {"c": 3, "d": 4}]
>>>
>>> print("Lista copiada:", lista_copiada)
[{"a": 100, "b": 2}, {"c": 3, "d": 4}]
>>> |
```

**explicação :** como os dicionários são mutáveis, a modificação feita em um dicionário dentro de `lista_copiada` é refletida em `lista_original`, pois ambos compartilham a referência ao mesmo dicionário;

### exemplo 4 : criando cópias rasas de diferentes formas

Além de usar o fatiamento (`[:]`) para criar uma cópia rasa, também pode usar outras técnicas como a função `list()` ou o método `copy()`:

#### usando `list()`
```python
>>> lista_original = [1, 2, 3]
>>> lista_copiada = list(lista_original)
>>>
>>> lista_copiada[0] = 100
>>>
>>> print("Lista original:", lista_original)
[1, 2, 3]
>>> print("Lista copiada:", lista_copiada)
[100, 2, 3]
>>> |
```

#### usando `copy()`
```python
>>> lista_original = [1, 2, 3]
>>> lista_copiada = lista_original.copy()
>>>
>>> lista_copiada[0] = 100
>>>
>>> print("Lista original:", lista_original)
[1, 2, 3]
>>> print("Lista copiada:", lista_copiada)
[100, 2, 3]
>>> |
```

**explicação :** ambos `list()` e `copy()` criam uma cópia rasa da lista. As mudanças em `lista_copiada` não afetam `lista_original` porque os objetos copiados são valores imutáveis. No entanto, se os objetos fossem mutáveis, as alterações internas ainda seriam compartilhadas;

### quando a cópia rasa é adequada?

- **listas de objetos imutáveis :** se a lista contém apenas objetos imutáveis (como números ou strings), a cópia rasa geralmente é segura e eficiente;

- **listas de objetos mutáveis com cuidado :** se precisar de uma nova lista, mas não se importa em compartilhar referências para objetos mutáveis dentro dessa lista, a cópia rasa é adequada;

### limitações da cópia rasa

A principal limitação da cópia rasa é que, para listas que contêm objetos mutáveis, as modificações nesses objetos refletirão tanto na lista original quanto na cópia. Se precisar de cópias independentes dos objetos internos, será necessário usar uma cópia profunda.

## exercícios cópia rasa

<details>
<summary>Lista de Exercícios</summary>

1. **Cópia de Lista Simples**: Dada a lista `original = [1, 2, 3, 4]`, faça uma cópia rasa dela e adicione o número 5 na cópia. Imprima ambas.
1. **Cópia de Tupla**: Dada a tupla `original = (1, 2, 3, 4)`, faça uma cópia rasa dela e modifique o valor do primeiro item da tupla original para 0. Imprima ambas.
1. **Cópia de Set**: Dado o conjunto `original = {1, 2, 3, 4}`, faça uma cópia rasa dele e adicione o número 5 à cópia. Imprima ambos.
1. **Cópia de Dicionário**: Dado o dicionário `original = {'a': 1, 'b': 2}`, faça uma cópia rasa dele e adicione uma nova chave `'c'` com valor 3 à cópia. Imprima ambos.
1. **Cópia de String**: Dada a string `original = "Python"`, faça uma cópia rasa dela e modifique o valor da cópia. Imprima ambas.
1. **Cópia de Lista com Sublista**: Dada a lista `original = [[1, 2], [3, 4]]`, faça uma cópia rasa dela e modifique o primeiro elemento da sublista na cópia. Imprima ambas.
1. **Cópia de Tupla com Lista**: Dada a tupla `original = ([1, 2], [3, 4])`, faça uma cópia rasa dela e modifique um valor na lista da cópia. Imprima ambas.
1. **Cópia de Set com Strings**: Dado o conjunto `original = {"apple", "banana"}`, faça uma cópia rasa dele e adicione um novo item à cópia. Imprima ambos.
1. **Cópia de Dicionário com Listas**: Dado o dicionário `original = {'numbers': [1, 2], 'letters': ['a', 'b']}`, faça uma cópia rasa dele e adicione um item à lista de números na cópia. Imprima ambos.
1. **Cópia de Lista com Strings**: Dada a lista `original = ["Python", "Java"]`, faça uma cópia rasa dela e substitua um item na cópia. Imprima ambas.
1. **Cópia de Tupla com Tuplas**: Dada a tupla `original = ((1, 2), (3, 4))`, faça uma cópia rasa dela e substitua um item na tupla da cópia. Imprima ambas.
1. **Cópia de Set com Números**: Dado o conjunto `original = {10, 20, 30}`, faça uma cópia rasa dele e remova um item da cópia. Imprima ambos.
1. **Cópia de Dicionário com Tuplas**: Dado o dicionário `original = {'coordinates': (10, 20), 'color': 'red'}`, faça uma cópia rasa dele e modifique um valor na cópia. Imprima ambos.
1. **Cópia de Lista com Dicionários**: Dada a lista `original = [{'a': 1}, {'b': 2}]`, faça uma cópia rasa dela e adicione uma nova chave a um dicionário na cópia. Imprima ambas.
1. **Cópia de Tupla com Set**: Dada a tupla `original = ({1, 2}, {3, 4})`, faça uma cópia rasa dela e adicione um item a um set na cópia. Imprima ambos.
1. **Cópia de Lista com Strings e Números**: Dada a lista `original = ["apple", 1, "banana", 2]`, faça uma cópia rasa dela e substitua um item na cópia. Imprima ambas.
1. **Cópia de Set com Dicionários**: Dado o conjunto `original = {{'a': 1}, {'b': 2}}`, faça uma cópia rasa dele e modifique um valor em um dicionário na cópia. Imprima ambos.
1. **Cópia de Dicionário com Listas Aninhadas**: Dado o dicionário `original = {'list1': [1, 2], 'list2': [3, 4]}`, faça uma cópia rasa dele e adicione um item a uma lista na cópia. Imprima ambos.
1. **Cópia de Lista com Tuplas Aninhadas**: Dada a lista `original = [(1, 2), (3, 4)]`, faça uma cópia rasa dela e substitua uma tupla na cópia. Imprima ambas.
1. **Cópia de Tupla com Listas e Dicionários**: Dada a tupla `original = ([1, 2], {'a': 3})`, faça uma cópia rasa dela e adicione um item à lista na cópia. Imprima ambas.
1. **Cópia de Lista com Booleans**: Dada a lista `original = [True, False]`, faça uma cópia rasa dela e altere um valor na cópia. Imprima ambas.
1. **Cópia de Tupla com Sets e Strings**: Dada a tupla `original = ({'apple'}, "banana")`, faça uma cópia rasa dela e adicione um item ao set na cópia. Imprima ambas.
1. **Cópia de Set com Strings e Números**: Dado o conjunto `original = {1, "apple", 2, "banana"}`, faça uma cópia rasa dele e remova um item da cópia. Imprima ambos.
1. **Cópia de Dicionário com Strings e Números**: Dado o dicionário `original = {'string': 'hello', 'number': 42}`, faça uma cópia rasa dele e modifique um valor na cópia. Imprima ambos.
1. **Cópia de Lista com Strings e Tuplas**: Dada a lista `original = ["hello", (1, 2), "world"]`, faça uma cópia rasa dela e substitua um item na cópia. Imprima ambas.
1. **Cópia de Tupla com Lista e Set**: Dada a tupla `original = ([1, 2], {3, 4})`, faça uma cópia rasa dela e modifique a lista na cópia. Imprima ambas.
1. **Cópia de Lista com Tuplas e Strings**: Dada a lista `original = [(1, 2), "foo", (3, 4)]`, faça uma cópia rasa dela e substitua um item na cópia. Imprima ambas.
1. **Cópia de Set com Inteiros e Strings**: Dado o conjunto `original = {1, 2, "a", "b"}`, faça uma cópia rasa dele e adicione um item à cópia. Imprima ambos.
1. **Cópia de Dicionário com Tuplas Aninhadas**: Dado o dicionário `original = {'pair1': (1, 2), 'pair2': (3, 4)}`, faça uma cópia rasa dele e substitua um valor na tupla da cópia. Imprima ambos.
1. **Cópia de Lista com Números e Strings**: Dada a lista `original = [1, "text", 3.5, "example"]`, faça uma cópia rasa dela e substitua um item na cópia. Imprima ambas.

</details>

## cópia profunda

<!--

A cópia profunda (deep copy) no Python é uma técnica usada para criar uma nova lista ou estrutura de dados que é completamente independente da original. Ao contrário da cópia rasa, que copia apenas as referências aos objetos contidos na lista original, a cópia profunda cria cópias reais e independentes desses objetos, resultando em uma duplicata completa e separada da estrutura de dados original.

### como funciona a cópia profunda

Quando você realiza uma cópia profunda de uma lista, o Python cria um novo objeto de lista, e então copia recursivamente todos os elementos dessa lista original. Se algum desses elementos for uma estrutura de dados mutável, como outra lista ou dicionário, ele também será copiado em profundidade, garantindo que a nova lista seja totalmente independente da original.

Para realizar uma cópia profunda em Python, utilizamos o módulo `copy` e sua função `deepcopy`.

### Importando a Função `deepcopy`

Antes de utilizá-la, é necessário importar a função `deepcopy` do módulo `copy`:

```python
import copy
```

### Exemplo 1: Cópia Profunda de uma Lista Simples

Vamos começar com um exemplo básico de cópia profunda:

```python
import copy

lista_original = [1, 2, 3, 4]
lista_copiada = copy.deepcopy(lista_original)

lista_copiada.append(5)

print("Lista original:", lista_original)  # Saída: [1, 2, 3, 4]
print("Lista copiada:", lista_copiada)    # Saída: [1, 2, 3, 4, 5]
```

**Explicação:** Aqui, `lista_copiada` é uma cópia profunda de `lista_original`. Como estamos lidando com objetos imutáveis (inteiros), o comportamento parece semelhante à cópia rasa. A diferença se torna mais evidente quando lidamos com objetos mutáveis.

### Exemplo 2: Cópia Profunda com Listas Aninhadas

Agora vamos ver o comportamento da cópia profunda com listas aninhadas:

```python
import copy

lista_original = [[1, 2, 3], [4, 5, 6]]
lista_copiada = copy.deepcopy(lista_original)

lista_copiada[0].append(99)

print("Lista original:", lista_original)  # Saída: [[1, 2, 3], [4, 5, 6]]
print("Lista copiada:", lista_copiada)    # Saída: [[1, 2, 3, 99], [4, 5, 6]]
```

**Explicação:** Neste exemplo, `lista_copiada` é uma cópia profunda de `lista_original`. Isso significa que `lista_copiada` é completamente independente, incluindo as sublistas. Quando você modifica uma sublista em `lista_copiada`, a sublista correspondente em `lista_original` permanece inalterada.

### Exemplo 3: Cópia Profunda com Dicionários em Listas

A cópia profunda também é importante quando você está lidando com listas que contêm dicionários:

```python
import copy

lista_original = [{"a": 1, "b": 2}, {"c": 3, "d": 4}]
lista_copiada = copy.deepcopy(lista_original)

lista_copiada[0]["a"] = 100

print("Lista original:", lista_original)  # Saída: [{"a": 1, "b": 2}, {"c": 3, "d": 4}]
print("Lista copiada:", lista_copiada)    # Saída: [{"a": 100, "b": 2}, {"c": 3, "d": 4}]
```

**Explicação:** No caso de `lista_copiada`, qualquer alteração feita nos dicionários contidos dentro da lista não afetará `lista_original`, pois cada dicionário foi duplicado completamente.

### Exemplo 4: Cópia Profunda com Estruturas de Dados Complexas

Vamos considerar uma estrutura de dados mais complexa, como uma lista contendo outras listas, dicionários, e até mesmo tuplas:

```python
import copy

lista_original = [[1, 2], {"chave": [3, 4]}, (5, 6)]
lista_copiada = copy.deepcopy(lista_original)

lista_copiada[0].append(99)
lista_copiada[1]["chave"].append(100)

print("Lista original:", lista_original)  # Saída: [[1, 2], {"chave": [3, 4]}, (5, 6)]
print("Lista copiada:", lista_copiada)    # Saída: [[1, 2, 99], {"chave": [3, 4, 100]}, (5, 6)]
```

**Explicação:** Neste exemplo, `lista_copiada` é uma cópia profunda de `lista_original`. Modificações feitas na cópia (como adicionar `99` à primeira sublista ou `100` ao valor da chave no dicionário) não afetam a lista original.

### Exemplo 5: Cópia Profunda e Objetos Personalizados

A cópia profunda também funciona com objetos de classes personalizadas, desde que esses objetos possam ser copiados.

```python
import copy

class Ponto:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __repr__(self):
        return f"Ponto({self.x}, {self.y})"

ponto_original = Ponto(1, 2)
lista_original = [ponto_original]

lista_copiada = copy.deepcopy(lista_original)

lista_copiada[0].x = 10
lista_copiada[0].y = 20

print("Lista original:", lista_original)  # Saída: [Ponto(1, 2)]
print("Lista copiada:", lista_copiada)    # Saída: [Ponto(10, 20)]
```

**Explicação:** `lista_copiada` aqui é uma cópia profunda de `lista_original`, incluindo o objeto `Ponto`. Alterar o objeto na cópia não afeta o objeto na lista original.

### Quando Usar Cópia Profunda

- **Quando você precisa de uma duplicação completa e independente:** Se você está lidando com uma estrutura de dados complexa e quer garantir que a cópia seja totalmente separada do original, a cópia profunda é o caminho.

- **Quando há objetos mutáveis aninhados:** Se a lista ou estrutura de dados contém listas, dicionários ou outros objetos mutáveis, a cópia profunda garantirá que todas as partes da estrutura sejam independentes.

### Limitações da Cópia Profunda

- **Desempenho:** A cópia profunda pode ser significativamente mais lenta e consumir mais memória do que a cópia rasa, especialmente para estruturas de dados grandes e complexas.

- **Complexidade:** Em casos onde não é necessário duplicar completamente todos os objetos internos, a cópia profunda pode ser excessiva.

-->

## cópia rasa e profunda em outros tipos

O conceito de cópia rasa e cópia profunda se aplica principalmente a estruturas de dados mutáveis, como listas e dicionários.

### tuplas

Tuplas são estruturas de dados imutáveis no Python. Por causa dessa imutabilidade, o conceito de cópia rasa e cópia profunda não se aplica da mesma forma que para listas.

- **cópia rasa :** para tuplas, uma cópia rasa é feita por atribuição direta, e não há necessidade de técnicas especiais para cópias rasas ou profundas, pois está apenas criando uma nova referência ao mesmo objeto imutável;
    ```python
    >>> tupla_original = (1, 2, 3)
    >>> tupla_copiada = tupla_original
    >>>
    >>> print("Tupla original:", tupla_original)
    (1, 2, 3)
    >>> print("Tupla copiada:", tupla_copiada)
    (1, 2, 3)
    >>> |
    ```
    **explicação :** a tupla `tupla_copiada` é uma nova referência à mesma tupla imutável. Não há necessidade de cópia rasa ou profunda aqui.

- **cópia profunda :**
<!--como tuplas são imutáveis e não podem ser alteradas após a criação, uma cópia profunda não é necessária ou aplicável. se a tupla contém objetos mutáveis (como listas), você ainda precisa considerar o impacto desses objetos na cópia, mas a tupla em si não precisa de uma cópia profunda.-->

### dicionários

Dicionários são mutáveis e, portanto, podem se beneficiar das técnicas de cópia rasa e profunda.

- **cópia rasa :** para fazer uma cópia rasa de um dicionário, pode-se usar o método `copy()` ou a função `dict()`.
    ```python
    >>> dicionario_original = {"a": 1, "b": [2, 3]}
    >>> dicionario_copiado = dicionario_original.copy()
    >>>
    >>> dicionario_copiado["b"].append(4)
    >>>
    >>> print("Dicionário original:", dicionario_original)
    {"a": 1, "b": [2, 3, 4]}
    >>> print("Dicionário copiado:", dicionario_copiado)
    {"a": 1, "b": [2, 3, 4]}
    >>> |
    ```
    **explicação :** a cópia rasa do dicionário cria um novo dicionário onde as referências para os objetos dentro do dicionário original são copiadas. Mudanças nos objetos mutáveis (como a lista associada à chave `"b"`) afetam ambos os dicionários.

- **cópia profunda :**
<!-- para criar uma cópia profunda de um dicionário, você pode usar `copy.deepcopy()`.

  ```python
  import copy

  dicionario_original = {"a": 1, "b": [2, 3]}
  dicionario_copiado = copy.deepcopy(dicionario_original)

  dicionario_copiado["b"].append(4)

  print("Dicionário original:", dicionario_original)  # Saída: {"a": 1, "b": [2, 3]}
  print("Dicionário copiado:", dicionario_copiado)    # Saída: {"a": 1, "b": [2, 3, 4]}
  ```

  **Explicação:** A cópia profunda cria um novo dicionário com cópias independentes dos objetos internos. Modificar a lista no dicionário copiado não afeta a lista no dicionário original.
-->
### sets

Sets são mutáveis, e o conceito de cópia rasa e profunda também se aplica a eles.

- **cópia rasa :** para fazer uma cópia rasa de um set, pode-se usar o método `copy()` ou a função `set()`.
    ```python
    >>> set_original = {1, 2, 3}
    >>> set_copiado = set_original.copy()
    >>>
    >>> set_copiado.add(4)
    >>>
    >>> print("Set original:", set_original)
    {1, 2, 3}
    >>> print("Set copiado:", set_copiado)
    {1, 2, 3}
    >>> |
    ```
    **explicação :** a cópia rasa do set cria um novo set, mas não copia objetos mutáveis que possam estar dentro do set. neste caso, os sets contêm apenas inteiros, que são imutáveis.

- **cópia profunda :**
<!--para sets, a cópia profunda não é frequentemente necessária, pois sets não podem conter objetos complexos que precisem de uma cópia profunda. se um set contém objetos mutáveis, você pode usar `copy.deepcopy()` para garantir uma cópia completamente independente.

  ```python
  import copy

  set_original = {frozenset([1, 2]), frozenset([3, 4])}
  set_copiado = copy.deepcopy(set_original)

  set_copiado.add(frozenset([5, 6]))

  print("Set original:", set_original)  # Saída: {frozenset({1, 2}), frozenset({3, 4})}
  print("Set copiado:", set_copiado)    # Saída: {frozenset({1, 2}), frozenset({3, 4}), frozenset({5, 6})}
  ```

  **Explicação:** A cópia profunda garante que o set copiado não compartilhe referências com o set original, mas, na prática, sets geralmente não precisam de cópia profunda porque eles não contêm tipos complexos mutáveis.
-->
### resumo

- **tuplas :** imutáveis, não requerem cópia rasa ou profunda;
- **dicionários :** mutáveis, podem se beneficiar de cópias rasas e profundas;
- **sets :** mutáveis, cópias rasas são comuns e cópias profundas podem ser usadas se o set contiver objetos complexos;
# desafios

Abaixo há uma lista de exercícios que são um pouco mais complexos que os exercícios propostos com o material. Sinta-se livre para realizá-los da melhor forma que achar (sempre usando **APENAS** o material de aula).


## árvore feliz

Faça um programa que peça um número ao usuário e monte um pinheiro como o mostrado abaixo. Se altura for menor que 3, o tronco terá apenas um de altura, senão será dois.
```
     #
    ###
   #####
  #######
 #########
###########
     #
     #
```
Exemplo de um pinheiro com altura 6.

## lanchonete

O cardápio de uma lanchonete é o seguinte :

```
Especificação......Código....Preço
Cachorro Quente.....100.....R$ 1,20
Bauru Simples.......101.....R$ 1,30
Bauru com ovo.......102.....R$ 1,50
Hambúrguer..........103.....R$ 1,20
Cheeseburguer.......104.....R$ 1,30
Refrigerante........105.....R$ 1,00
```

Faça um programa que leia o código dos itens pedidos e as quantidades desejadas. Calcule e mostre o valor a ser pago por item (preço * quantidade) e o total geral do pedido. Considere que o cliente deve informar quando o pedido deve ser encerrado.

## votação

Uma grande emissora de televisão quer fazer uma enquete entre os seus telespectadores para saber qual o melhor jogador após cada jogo. Para isto, faz-se necessário o desenvolvimento de um programa, que será utilizado pelas telefonistas, para a computação dos votos. Sua equipe foi contratada para desenvolver este programa, utilizando a linguagem de programação da sua escolha. Para computar cada voto, a telefonista digitará um número, entre 1 e 23, correspondente ao número da camisa do jogador. Um número de jogador igual zero, indica que a votação foi encerrada. Se um número inválido for digitado, o programa deve ignorá-lo, mostrando uma breve mensagem de aviso, e voltando a pedir outro número. Após o final da votação, o programa deverá exibir :
- O total de votos computados;
- Os númeos e respectivos votos de todos os jogadores que receberam votos;
- O percentual de votos de cada um destes jogadores;
- O número do jogador escolhido como o melhor jogador da partida, juntamente com o número de votos e o percentual de votos dados a ele.

Observe que os votos inválidos e o zero final não devem ser computados como votos. O resultado aparece ordenado pelo número do jogador. O programa deve fazer uso de listas. O programa deverá executar o cálculo do percentual de cada jogador através de uma função. Esta função receberá dois parâmetros: o número de votos de um jogador e o total de votos. A função calculará o percentual e retornará o valor calculado. Abaixo segue uma tela de exemplo. O disposição das informações deve ser o mais próxima possível ao exemplo. Os dados são fictícios e podem mudar a cada execução do programa. Ao final, o programa deve ainda gravar os dados referentes ao resultado da votação em um arquivo texto no disco, obedecendo a mesma disposição apresentada na tela.

```
Enquete: Quem foi o melhor jogador?

Número do jogador (0=fim): 9
Número do jogador (0=fim): 10
Número do jogador (0=fim): 9
Número do jogador (0=fim): 10
Número do jogador (0=fim): 11
Número do jogador (0=fim): 10
Número do jogador (0=fim): 50
Informe um valor entre 1 e 23 ou 0 para sair!
Número do jogador (0=fim): 9
Número do jogador (0=fim): 9
Número do jogador (0=fim): 0

Resultado da votação:

Foram computados 8 votos.

Jogador....Votos........%
...09........4......50,0%
...10........3......37,5%
...11........1......12,5%
O melhor jogador foi o número 9, com 4 votos, correspondendo a 50% do total de votos.
```

## tamanho strings

Faça um programa que leia 2 strings e informe o conteúdo delas seguido do seu comprimento. Informe também se as duas strings possuem o mesmo comprimento e são iguais ou diferentes no conteúdo.

```
Compara duas strings
String 1: Brasil Hexa 2006
String 2: Brasil! Hexa 2006!
Tamanho de "Brasil Hexa 2006": 16 caracteres
Tamanho de "Brasil! Hexa 2006!": 18 caracteres
As duas strings são de tamanhos diferentes.
As duas strings possuem conteúdo diferente.
```

## gerador leetspeak

Leet é uma forma de se escrever o alfabeto latino usando outros símbolos em lugar das letras, como números por exemplo. A própria palavra leet admite muitas variações, como l33t ou 1337. O uso do leet reflete uma subcultura relacionada ao mundo dos jogos de computador e internet, sendo muito usada para confundir os iniciantes e afirmar-se como parte de um grupo. Pesquise sobre as principais formas de traduzir as letras. Depois, faça um programa que peça uma texto e transforme-o para a grafia leet speak.

## sequência de fibonacci

A sequência de Fibonacci é uma série de números onde cada número é a soma dos dois anteriores. A sequência começa com os números 0 e 1, e então cada número subsequente é gerado somando-se os dois números anteriores. Os primeiros termos da sequência de Fibonacci são :

0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...

Observe que :
- O terceiro número (1) é a soma dos dois primeiros (0 + 1).
- O quarto número (2) é a soma do segundo e do terceiro (1 + 1).
- O quinto número (3) é a soma do terceiro e do quarto (1 + 2).

Para calcular a sequência de Fibonacci, é preciso seguir estas etapas :

1. **definir os dois primeiros números** da sequência como 0 e 1;
1. **calcular o próximo número** como a soma dos dois números anteriores;
1. **repetir o processo** até que a quantidade desejada de números na sequência seja gerada;

Seu objetivo é criar um algoritmo que gera os `n` primeiros números da sequência de Fibonacci, onde `n` é um valor fornecido pelo usuário.

## calculadora romanos

Crie uma calculadora de números romanos.

- crie uma calculadora romana das operações `+`, `-`, `*`, `/`, `**`;
    - o intervalo de entrada e resultado deve ser (-4000,4000);
    - isto é, o valor mínimo recebido e calculado será -3999;
    - e o valor máximo recebido e calculado será 3999;
- o resultado da divisão deve ser representado como quociente e resto;
- a entrada dos dois números deve ser em números romanos;
- o resultado deve ser mostrado em números romanos;
- todos os cálculos devem ser salvos em um dicionário, que deve ser armazenado em uma lista;
- encerre o programa quando o usuário digitar `sair`;
- ao final, mostre todos as operações realizadas;
- exemplos :
    - operação tradicional :
        - calculo = {'valor_1': 'X', 'valor_2': 'IV', 'operacao': '+', 'resposta': 'XIV'}
    - operação onde foi entrado um valor maior que 3999 ou menor que -3999 :
        - calculo = {'valor_1': 'erro', 'valor_2': 'MM', 'operacao': '/', 'resposta': 'erro'}
    - modelo usando subtração com algum valor negativo :
        - calculo = {'valor_1': '-C', 'valor_2': 'X', 'operacao': '-', 'resposta': '-CX'}
    - modelo de divisão :
        - calculo = {'valor_1': 'XI', 'valor_2': 'III', 'operacao': '/', 'resposta': 'III', 'resto': 'II'}
Índice

1. [empacotamento tuplas e listas](#empacotamento-tuplas-e-listas)
1. [empacotamento de dicionários](#empacotamento-de-dicionários)
1. [desempacotamento](#desempacotamento)
1. [exercícios](#exercícios)

# empacotamento e desempacotamento

## empacotamento tuplas e listas

Empacotamento de variáveis em Python refere-se ao processo de agrupar múltiplos valores em uma única estrutura de dados, como uma tupla ou lista. Isso é especialmente útil quando se deseja armazenar uma coleção de valores que pertencem a um mesmo contexto.

### tuplas

Por padrão, quando se agrupa vários valores separados por vírgulas, o Python automaticamente os empacota em uma tupla. Isso é conhecido como **empacotamento de tuplas**.

- exemplo 1 : empacotamento em uma tupla
```python
>>> # empacotando valores em uma tupla
>>> dados = 10, 20, 30
>>>
>>> print(f'{dados = }')
dados = (10, 20, 30)
>>>
>>> print(f'{type(dados) = }')
type(dados) = <class 'tuple'>
>>> |
```

Neste exemplo, `dados` é uma tupla que contém os valores `10`, `20` e `30`. O Python automaticamente criou essa tupla ao identificar múltiplos valores separados por vírgulas.

- exemplo 2 : tupla com um único elemento
Se quiser criar uma tupla com apenas um elemento, é necessário incluir uma vírgula, pois, sem a vírgula, o Python não interpretará o valor como uma tupla.

```python
>>> # empacotando um único valor em uma tupla
>>> item = 42,
>>> print(f'{item = }')
item = (42,)
>>> print(f'{type(item)}')
<class 'tuple'>
>>> |
```

Aqui, `item` é uma tupla contendo um único valor, `42`. Sem a vírgula, o Python trataria `42` apenas como um número inteiro.

### listas

Embora o empacotamento seja mais comumente associado a tuplas, também é possível empacotar valores em uma lista, mas isso requer a utilização de colchetes (`[]`).

- exemplo 3 : empacotamento em uma lista
```python
>>> # empacotando valores em uma lista
>>> dados_lista = [10, 20, 30]
>>>
>>> print(f'{dados_lista = }')
dados_lista = [10, 20, 30]
>>>
>>> print(f'{type(dados_lista) = }')
type(dados_lista) = <class 'list'>
>>> |
```

Aqui, `dados_lista` é uma lista que contém os valores `10`, `20` e `30`.

### empacotamento implícito

O Python permite empacotar valores sem a necessidade de utilizar parênteses ou colchetes explicitamente.

- exemplo 4 : empacotamento implícito
```python
>>> # empacotamento implícito em uma tupla
>>> valores = 5, 'Python', True
>>>
>>> print(f'{valores = }')
valores = (5, 'Python', True)
>>> |
```

Neste caso, `valores` é uma tupla, mesmo que os parênteses não tenham sido explicitamente utilizados.

### considerações importantes

1. **imutabilidade das tuplas** : uma vez que os valores são empacotados em uma tupla, eles não podem ser modificados individualmente, pois tuplas são imutáveis. Se for necessário alterar os valores, é recomendável usar uma lista;

2. **heterogeneidade de dados** : tanto tuplas quanto listas permitem armazenar valores de diferentes tipos de dados. Isso significa que se pode empacotar inteiros, strings, booleanos, entre outros, em uma única estrutura;

- exemplo 5 : empacotando diferentes tipos de dados
```python
>>> # empacotando diferentes tipos de dados
>>> dados_mistos = 100, 'Cem', 99.9, False
>>> print(f'{dados_mistos = }')
dados_mistos = (100, 'Cem', 99.9, False)
>>> |
```

3. **utilização de empacotamento** : o empacotamento é muito útil em situações onde se deseja passar múltiplos valores como um único objeto. Isso pode facilitar a manipulação de dados em várias operações, como armazenar os resultados de uma função que retorna múltiplos valores.

## empacotamento dicionários

O empacotamento de dicionários em Python é um recurso poderoso que permite a criação dinâmica de dicionários a partir de uma combinação de chaves e valores, ou mesmo a fusão de vários dicionários em um único. Diferente do desempacotamento, que trata de extrair itens de um dicionário, o empacotamento se concentra em como agrupar dados em um dicionário.

### empacotamento explícito

O empacotamento mais comum é feito de maneira explícita, onde se define as chaves e valores diretamente :

```python
>>> dados = {
...     "nome": "Maria",
...     "idade": 28,
...     "cidade": "Porto Alegre"
... }
>>>
>>> print(dados)
{'nome': 'Maria', 'idade': 28, 'cidade': 'Porto Alegre'}
>>> |
```

Aqui, foi criado um dicionário chamado `dados`, empacotando as chaves `"nome"`, `"idade"`, e `"cidade"` com seus respectivos valores `"Maria"`, `28`, e `"Porto Alegre"`.

### empacotamento com compreensão de dicionários

É possível empacotar dicionários de forma dinâmica usando compreensão de dicionários (similar à compreensão de listas) :

```python
>>> nomes = ["Ana", "Bruno", "Carlos"]
>>> idades = [25, 30, 22]
>>>
>>> dados = {nome: idade for nome, idade in zip(nomes, idades)}
>>>
>>> print(dados)
{'Ana': 25, 'Bruno': 30, 'Carlos': 22}
>>> |
```

Utilizou-se a função `zip()` para combinar as listas `nomes` e `idades`. O dicionário `dados` é empacotado onde cada nome é uma chave e a idade correspondente é o valor.

## desempacotamento

Desempacotamento de variáveis é o processo de extrair valores de uma estrutura de dados, como uma tupla ou lista, e atribuí-los a variáveis individuais. Essa técnica é extremamente útil para manipular dados de forma clara e organizada, permitindo que os valores sejam extraídos de uma coleção e atribuídos diretamente às variáveis correspondentes.

### desempacotamento simples

O desempacotamento mais básico acontece quando uma tupla ou lista é "desempacotada" em múltiplas variáveis, onde cada valor é atribuído a uma variável específica.

- exemplo 1 : desempacotamento de uma tupla
```python
>>> # desempacotando uma tupla
>>> dados = (10, 20, 30)
>>>
>>> a, b, c = dados
>>>
>>> print(f'{a = }')
a = 10
>>> print(f'{b = }')
b = 20
>>> print(f'{c = }')
c = 30
>>> |
```

Aqui, a tupla `dados` contém três valores. O desempacotamento ocorre quando esses valores são atribuídos diretamente às variáveis `a`, `b` e `c`.

- exemplo 2 : desempacotamento de uma lista
```python
>>> # desempacotando uma lista
>>> dados_lista = [40, 50, 60]
>>>
>>> x, y, z = dados_lista
>>>
>>> print(f'{x = }')
x = 40
>>> print(f'{y = }')
y = 50
>>> print(f'{z = }')
z = 60
>>> |
```

No caso acima, a lista `dados_lista` é desempacotada em três variáveis `x`, `y` e `z`.

### desempacotamento com empacotamento de resto

O Python permite que se desempacote apenas parte de uma estrutura de dados, ou que se utilize a técnica de "empacotamento de resto" para capturar valores excedentes.

- exemplo 3 : desempacotamento parcial com "restante"
```python
>>> # desempacotando com valores restantes
>>> valores = [1, 2, 3, 4, 5]
>>>
>>> a, b, *resto = valores
>>>
>>> print(f'{a = }')
a = 1
>>> print(f'{b = }')
b = 2
>>> print(f'{resto = }')
resto = [3, 4, 5]
>>> |
```

Neste exemplo, `a` recebe o primeiro valor da lista `valores`, `b` recebe o segundo, e o restante dos valores é empacotado na lista `resto` usando `*`.

- exemplo 4 : desempacotamento com valores ignorados
```python
>>> # desempacotando e ignorando valores
>>> dados = (100, 200, 300, 400)
>>>
>>> _, _, c, d = dados
>>>
>>> print(f'{c = }')
c = 300
>>> print(f'{d = }')
d = 400
>>> |
```

aqui, os dois primeiros valores da tupla `dados` são ignorados usando `_`, e os dois últimos valores são atribuídos a `c` e `d`.

### desempacotamento em estruturas aninhadas

também é possível desempacotar valores de estruturas de dados aninhadas, como tuplas dentro de tuplas ou listas dentro de listas.

- exemplo 5 : desempacotamento de tuplas aninhadas
```python
>>> # desempacotando tuplas aninhadas
>>> dados = (10, (20, 30))
>>>
>>> a, (b, c) = dados
>>>
>>> print(f'{a = }')
a = 10
>>> print(f'{b = }')
b = 20
>>> print(f'{c = }')
c = 30
>>> |
```

Neste caso, a variável `a` recebe o valor `10`, enquanto `b` e `c` recebem os valores `20` e `30` da tupla interna.

- exemplo 6 : desempacotamento de listas aninhadas
```python
>>> # desempacotando listas aninhadas
>>> dados_lista = [100, [200, 300], 400]
>>>
>>> x, (y, z), w = dados_lista
>>>
>>> print(f'{x = }')
x = 100
>>> print(f'{y = }')
y = 200
>>> print(f'{z = }')
z = 300
>>> print(f'{w = }')
w = 400
>>> |
```

Aqui, a lista `dados_lista` é desempacotada em variáveis `x`, `y`, `z` e `w`, onde `y` e `z` recebem os valores da lista interna `[200, 300]`.

### considerações importantes

1. **correspondência de quantidade** : ao desempacotar, é importante que o número de variáveis corresponda ao número de elementos na estrutura, a menos que se esteja usando `*` para capturar valores restantes;

2. **flexibilidade de desempacotamento** : o desempacotamento oferece uma maneira flexível e expressiva de extrair valores de estruturas complexas, como listas ou tuplas aninhadas, permitindo que se acesse dados específicos de forma direta e concisa;

3. **uso do caractere `*`** : o caractere `*` é uma ferramenta poderosa para capturar múltiplos valores restantes em uma lista ou tupla, oferecendo flexibilidade ao lidar com dados de tamanho variável;

## exercícios

<details>
<summary>Lista de Exercícios</summary>

1. Exercícios de Empacotamento
    1. Crie uma tupla com os números de 1 a 5 e mostre o resultado.
    1. Crie uma lista com os nomes de 3 cidades e mostre o resultado.
    1. Empacote os valores `10`, `20` e `30` em uma tupla e mostre a tupla resultante.
    1. Crie um dicionário empacotando as chaves "nome", "idade" e "cidade" com os valores "Ana", 25 e "São Paulo".
    1. Crie uma lista que empacote os números de 1 a 10 e mostre a lista resultante.
    1. Empacote os valores `True`, `False` e `None` em uma tupla e mostre a tupla.
    1. Crie uma lista que empacote três strings de cores (ex.: "vermelho", "azul", "verde") e mostre a lista resultante.
    1. Empacote os valores 3.14, 2.71 e 1.41 em uma tupla e mostre a tupla resultante.
    1. Crie um dicionário empacotando as chaves "produto", "preço" e "quantidade" com os valores "Notebook", 2500 e 5.
    1. Empacote três listas diferentes em uma lista maior e mostre o resultado.
1. Exercícios de Desempacotamento de Tuplas
    1. Desempacote a tupla `(1, 2, 3)` em três variáveis `a`, `b` e `c`, e mostre os valores de cada variável.
    1. Desempacote a tupla `("Python", "Java", "C++")` em três variáveis e mostre os valores de cada uma.
    1. Desempacote a tupla `(True, False, None)` em três variáveis e mostre os valores.
    1. Desempacote a tupla `("Alice", 30, "Engenheira")` em variáveis `nome`, `idade` e `profissao`, e mostre os valores.
    1. Dada a tupla `(10, 20, 30, 40, 50)`, desempacote o primeiro e o último valor em duas variáveis e mostre-os.
1. Exercícios de Desempacotamento de Listas
    1. Desempacote a lista `[5, 10, 15]` em três variáveis e mostre os valores de cada uma.
    1. Desempacote a lista `["Maçã", "Banana", "Laranja"]` em três variáveis e mostre os valores.
    1. Desempacote a lista `[1.1, 2.2, 3.3]` em três variáveis e mostre os valores.
    1. Dada a lista `[100, 200, 300, 400]`, desempacote o segundo e o terceiro valor em duas variáveis e mostre os valores.
    1. Desempacote a lista `[True, False]` em duas variáveis e mostre os valores.
1. Exercícios de Empacotamento e Desempacotamento Mistos
    1. Crie uma lista de tuplas, onde cada tupla empacota dois valores (ex.: `[("A", 1), ("B", 2)]`). Desempacote e mostre os valores de cada tupla.
    1. Dada uma lista `[(1, 2), (3, 4), (5, 6)]`, desempacote os pares de valores de cada tupla em variáveis `x` e `y` e mostre os resultados.
    1. Empacote três listas em uma tupla e depois desempacote cada lista em variáveis separadas.
    1. Crie um dicionário onde as chaves sejam strings e os valores sejam listas. Depois, desempacote uma das listas em variáveis separadas.
    1. Dada uma lista `[(10, 20), (30, 40), (50, 60)]`, desempacote os valores de cada tupla e mostre os resultados.
1. Exercícios com Dicionários
    1. Dado o dicionário `{"nome": "Carlos", "idade": 28, "cidade": "Rio"}`, desempacote os valores em variáveis separadas e mostre os resultados.
    1. Crie um dicionário onde as chaves sejam números e os valores sejam tuplas. Desempacote uma das tuplas em variáveis separadas.
    1. Dado o dicionário `{"a": 1, "b": 2, "c": 3}`, desempacote as chaves e valores em duas listas separadas.
    1. Empacote uma lista de tuplas em um dicionário onde a primeira posição da tupla é a chave e a segunda é o valor.
    1. Dado um dicionário `{"x": (10, 20), "y": (30, 40)}`, desempacote os valores das tuplas e mostre os resultados.

</details>
Índice

1. [while](#while)
1. [contador e acumulador](#contador-e-acumulador)
1. [exercícios while](#exercícios-while)
1. [comando for](#comando-for)
1. [exercícios for](#exercícios-for)
1. [loops aninhados](#loops-aninhados)
1. [exercícios loops aninhados](#exercícios-loops-aninhados)
1. [for vs while](#for-vs-while)
1. [exercícios for vs while](#exercícios-for-vs-while)
1. [else em loops](#else-em-loops)
1. [exercícios else](#exercícios-else)

# estruturas de repetição

## while

A estrutura de repetição `while` em Python é usada para executar um bloco de código repetidamente, desde que uma condição seja verdadeira. A cada iteração (a cada repetição), a condição é avaliada; se continuar sendo verdadeira, o loop continua, caso contrário, ele para.

Veja a sintaxe básica :

```python
while condicao:
    # Bloco de código a ser repetido
```

- **`condicao`**: uma expressão que será avaliada como `True` ou `False`;
- **bloco de código**: o conjunto de instruções que será executado repetidamente enquanto a condição for `true`;

### exemplo de contagem

Veja como fica uma contagem simples, iniciando em 1 e terminando em 5 :

```python
contador = 1

while contador <= 5:
    print("Contagem : ", contador)
    contador = contador + 1
```

O código inicia com a definição da variável `contador` e o valor 1 é atribuída a ela. Em seguida, o comando `while` testa a condição especificada nele, se `contador <= 5`. Enquanto a condição for verdadeira, seu bloco de código interno será executado. No bloco de código, é utilizado um `print` para exibir uma string e o valor da variável `contador`. Logo depois, é somado 1 ao conteúdo da variável contador usando `contador = contador + 1`.

Esse código terá como resultado :

```
Contagem : 1
Contagem : 2
Contagem : 3
Contagem : 4
Contagem : 5
```

Após `contador` chegar a 6, a condição `contador <= 5` se tornará `False`, e o loop será interrompido.

### exemplo com entrada do usuário

O `while` é frequentemente usado para repetir ações até que o usuário forneça uma resposta específica.

```python
resposta = ""

while resposta != "sair":
    resposta = input("Digite algo (ou 'sair' para encerrar): ")
    print('Você digitou :', resposta)
```

- O loop continuará pedindo uma entrada do usuário e imprimindo-a até que o usuário digite "sair";
- Quando a entrada for "sair", a condição `resposta != "sair"` será `False`, e o loop será interrompido;

### exemplo com uma condição complexa

Às vezes, a condição dentro de um `while` pode ser mais complexa e envolver múltiplas variáveis.

```python
numero = 10
divisor = 2

while numero % divisor == 0:
    print(numero, 'é divisível por', divisor)
    numero = numero / 2
```

- A condição `numero % divisor == 0` verifica se `numero` é divisível por `divisor`;
- Enquanto o `numero` for divisível por `2`, ele será dividido por 2 a cada iteração, e a mensagem será impressa;
- O loop para quando `numero` não for mais divisível por 2;

### cuidados com o `while`

Um cuidado importante ao usar `while` é evitar loops infinitos, que acontecem quando a condição nunca se torna `False`. Por exemplo:

```python
contador = 1

while contador <= 5:
    print("Contagem : ", contador)
    # Esquecemos de incrementar o contador!
```

Esse código nunca sairá do loop porque `contador` nunca muda, fazendo com que a condição seja sempre verdadeira. Isso pode travar o programa.

## contador e acumulador

Os conceitos de **acumulador** e **contador** são amplamente usados em loops, especialmente com `while`, para realizar operações repetitivas como somar valores ou contar ocorrências.

### contador

Um **contador** é uma variável que é usada para contar quantas vezes um evento ocorre. Geralmente, ele é incrementado por um valor fixo (como 1) a cada iteração do loop.

É possível contar quantas vezes um loop `while` é executado. Veja o código abaixo :

```python
contador = 0
resposta = ''

while resposta != "sair":
    resposta = input("Digite algo (ou 'sair' para encerrar): ")
    print('Você digitou :', resposta)
    contador = contador + 1

print('o loop while foi executado', contador, 'vezes')
```

O código acima começa declarando as variáveis `contador` e `resposta`. Em seguida, o comando `while` testa se a resposta é diferente a `sair`. Enquanto a condição for verdadeira, o bloco de código dentro do `while` é executado. Dentro dele, a cada iteração, é feita uma pergunta (`input("Digite algo (ou 'sair' para encerrar): ")`) para o usuário e salvar o for digitado na variável `resposta`. Em seguida, é mostrado o que o usuário digitou com usando um `print` e o contador é incrementado em 1.

Ao final, quando o usuário finalmente digitar **sair**, o loop (laço de repetição) será encerrado e o `print` final irá mostrar a quantidade de vezes que a pergunta fora feita ao usuário.

### acumulador

Um **acumulador** é uma variável que acumula valores ao longo das iterações de um loop. Geralmente, ele começa em um valor inicial (como 0) e a cada iteração, um novo valor é adicionado a ele.

Veja como somar os números de 1 a 5 usando um acumulador :

```python
soma = 0
numero = 1

while numero <= 5:
    soma = soma + numero
    print('Adicionando', numero, ', a soma agora é', soma)
    numero = numero + 1

print('a soma final é', soma)
```

A variável `soma` é inicializada com o valor 0 e a variável `numero` é inicializada com o valor 1. Depois, o comando `while` testa se a condição `numero <= 5` é verdadeira. Enquanto for, o bloco de código é executado. Dentro dele, a cada iteração, o valor e `numero` é adicionado a `soma` (`soma = soma + numero`). Em seguida, o `numero` é incrementado em 1 a cada iteração.

Ao final, é mostrado o valor final da variável `soma`.

### combinando acumulador e contador

É possível combinar um contador e um acumulador no mesmo loop.

Considere o seguinte, é preciso somar os números pares de 1 a 10 e contar quantos números pares existem nesse intervalo.

```python
contador_pares = 0
soma_pares = 0
numero = 1

while numero <= 10:
    if numero % 2 == 0:
        contador_pares = contador_pares + 1
        soma_pares = soma_pares + numero
    numero = numero + 1

print('Quantidade de números pares :', contador_pares)
print('Soma dos números pares :', soma_pares)
```

O código acima inicia com a declaração das variáveis `contador_pares`, `soma_pares` e `numero`. O comando `while` testa se `numero <= 10` é verdadeiro, se for o bloco de código é executado. Em seguida, é feito um testes para número par (`numero % 2 == 0`). Quando o teste der verdadeiro, o `contador_pares` é incrementado em 1 e a `soma_pares` é somado com o valor da variável `numero`. Em seguida, mesmo que a condição do `if` seja falsa, a variável `numero` é incrementada em 1.

Ao finalizar o loop, é mostrado os valores das variáveis `contador_pares` e `soma_pares`.

Veja agora um uso de um acumulador, mas agora usando com multiplicação :

```python
# algoritmo para calcular o fatorial de 5
produto = 1
numero = 1

while numero <= 5:
    produto = produto * numero
    print('Multiplicando por',numero,', produto agora é', produto)
    numero = numero + 1

print('o fatorial de 5 é', produto)
```

### exercícios `while`

<details>
<summary>Lista de Exercícios</summary>

1. Nível Simples
    1. Crie um programa que peça ao usuário para digitar um número inteiro positivo e continue pedindo até que o número digitado seja maior que 10.
    1. Crie um programa que peça ao usuário para digitar números inteiros e some esses números até que o usuário digite um número negativo.
    1. Crie um programa que peça ao usuário para digitar uma senha (string) até que ele acerte a senha correta "Python123".
    1. Crie um programa que peça ao usuário para digitar um número decimal até que ele digite um valor maior que 0.5.
    1. Crie um programa que exiba "Olá!" 5 vezes utilizando um while e uma variável contador.
1. Nível Simples com if-elif-else
    1. Crie um programa que peça ao usuário para digitar números inteiros até que ele digite um número maior que 50. Se o número for ímpar, exiba "Ímpar". Caso contrário, exiba "Par".
    1. Crie um programa que peça ao usuário para digitar palavras até que ele digite "sair". Se a palavra contiver a letra "a", exiba "Contém a letra 'a'". Caso contrário, exiba "Não contém a letra 'a'".
    1. Crie um programa que peça ao usuário para digitar números decimais até que a soma dos números seja maior que 100. Se o número digitado for maior que 10, exiba "Número grande". Caso contrário, exiba "Número pequeno".
    1. Crie um programa que peça ao usuário para digitar valores booleanos (True ou False) até que ele digite "False". Se for "True", exiba "Verdadeiro". Caso contrário, exiba "Falso".
    1. Crie um programa que peça ao usuário para digitar números inteiros até que ele digite um número negativo. Se o número for divisível por 3, exiba "Divisível por 3". Caso contrário, exiba "Não divisível por 3".
1. Nível Intermediário
    1. Crie um programa que peça ao usuário para digitar números inteiros até que ele digite um número maior que 20. Em seguida, exiba todos os números digitados em uma lista.
    1. Crie um programa que peça ao usuário para digitar números decimais até que ele digite um número menor que 1.5. Em seguida, exiba a média dos números digitados.
    1. Crie um programa que peça ao usuário para digitar palavras até que ele digite "stop". Em seguida, exiba todas as palavras em uma única string concatenada.
    1. Crie um programa que peça ao usuário para digitar valores booleanos (True ou False) até que ele digite "True". Em seguida, exiba quantas vezes o valor "False" foi digitado.
    1. Crie um programa que peça ao usuário para digitar números inteiros e adicione-os a uma lista até que a lista tenha 5 elementos. Em seguida, exiba a lista completa.
1. Nível Intermediário com if-elif-else
    1. Crie um programa que peça ao usuário para digitar números inteiros até que ele digite um número par. Se o número for maior que 10, adicione-o a uma lista de "números grandes". Caso contrário, adicione-o a uma lista de "números pequenos". Exiba as duas listas ao final.
    1. Crie um programa que peça ao usuário para digitar palavras até que ele digite "fim". Se a palavra tiver mais de 5 caracteres, adicione-a a uma lista de "palavras longas". Caso contrário, adicione-a a uma lista de "palavras curtas". Exiba as duas listas ao final.
    1. Crie um programa que peça ao usuário para digitar números decimais até que ele digite um número negativo. Se o número for maior que 1, exiba "Grande". Se for menor que 1, exiba "Pequeno". Se for igual a 1, exiba "Igual a 1".
    1. Crie um programa que peça ao usuário para digitar valores booleanos (True ou False) até que ele digite "False" duas vezes seguidas. Exiba quantas vezes "True" foi digitado.
    1. Crie um programa que peça ao usuário para digitar números inteiros até que ele digite um número maior que 100. Se o número for múltiplo de 5, adicione-o a uma lista de "múltiplos de 5". Caso contrário, adicione-o a uma lista de "não múltiplos de 5". Exiba as duas listas ao final.
1. Nível Avançado
    1. Crie um programa que peça ao usuário para digitar números inteiros até que ele digite um número primo. Exiba todos os números digitados até então.
    1. Crie um programa que peça ao usuário para digitar números decimais até que ele digite um número igual a 0. Em seguida, exiba o maior número digitado.
        ```python
        pedido = float(input('Digite um decimal : '))
        maior = pedido

        while pedido != 0:
            pedido = float(input('Digite um decimal : '))
            if pedido > maior:
                maior = pedido
        print('o maior numero foi :', maior)
        ```
    1. Crie um programa que peça ao usuário para digitar palavras até que ele digite uma palavra que comece com a letra "z". Em seguida, exiba a palavra mais longa digitada.
        ```python
        print('digite numeros, pare tudo digitando 0')

        numero = float(input('digite um numero : '))
        maior = numero

        while numero != 0.0:  # numero != 0
            numero = float(input('digite outro numero : '))

            if numero > maior:
                maior = numero

        print('o numero eh :', numero)
        print('o maior eh :', maior)
        ```
    1. Crie um programa que peça ao usuário para digitar valores booleanos (True ou False) até que ele digite "True" três vezes. Exiba a quantidade total de valores digitados.
    1. Crie um programa que peça ao usuário para digitar números inteiros até que ele digite um número negativo. Em seguida, exiba a soma de todos os números digitados.
1. Nível Avançado com if-elif-else
    1. Crie um programa que peça ao usuário para digitar números inteiros até que ele digite um múltiplo de 7. Se o número for par, adicione-o a uma lista de "pares". Se for ímpar, adicione-o a uma lista de "ímpares". Exiba as duas listas ao final.
    1. Crie um programa que peça ao usuário para digitar palavras até que ele digite "exit". Se a palavra contiver a letra "e", adicione-a a uma lista de "palavras com e". Caso contrário, adicione-a a uma lista de "palavras sem e". Exiba as duas listas ao final.
    1. Crie um programa que peça ao usuário para digitar números decimais até que ele digite um número menor que 0. Se o número for positivo, exiba "Positivo". Se for negativo, exiba "Negativo". Se for zero, exiba "Zero".
    1. Crie um programa que peça ao usuário para digitar valores booleanos (True ou False) até que ele digite "False" três vezes seguidas. Exiba a quantidade total de "True" digitados.
    1. Crie um programa que peça ao usuário para digitar números inteiros até que a soma dos números seja maior que 50. Se o número digitado for maior que 10, exiba "Grande". Caso contrário, exiba "Pequeno".
1. Nível Complexo
    1. Crie um programa que peça ao usuário para digitar números inteiros até que ele digite um número divisível por 4. Em seguida, exiba o menor número digitado.
    1. Crie um programa que peça ao usuário para digitar números decimais até que ele digite um número entre 0 e 1. Em seguida, exiba a média dos números digitados.
    1. Crie um programa que peça ao usuário para digitar palavras até que ele digite "fim". Em seguida, exiba as palavras digitadas em ordem inversa.
    1. Crie um programa que peça ao usuário para digitar valores booleanos (True ou False) até que ele digite "True" cinco vezes. Em seguida, exiba quantas vezes "False" foi digitado.
    1. Crie um programa que peça ao usuário para digitar números inteiros até que a soma dos números seja maior que 100. Em seguida, exiba todos os números digitados que sejam divisíveis por 5.
1. Nível Complexo com if-elif-else
    1. Crie um programa que peça ao usuário para digitar números inteiros até que ele digite um número primo. Se o número for maior que 50, adicione-o a uma lista de "números grandes". Caso contrário, adicione-o a uma lista de "números pequenos". Exiba as duas listas ao final.
    1. Crie um programa que peça ao usuário para digitar palavras até que ele digite uma palavra que tenha exatamente 5 letras. Se a palavra começar com "a", adicione-a a uma lista de "palavras com a". Caso contrário, adicione-a a uma lista de "outras palavras". Exiba as duas listas ao final.
    1. Crie um programa que peça ao usuário para digitar números decimais até que ele digite um número menor que 0. Se o número for maior que 5, adicione-o a uma lista de "números altos". Caso contrário, adicione-o a uma lista de "números baixos". Exiba as duas listas ao final.
    1. Crie um programa que peça ao usuário para digitar valores booleanos (True ou False) até que ele digite "True" quatro vezes seguidas. Se o valor for "True", adicione-o a uma lista de "verdadeiros". Caso contrário, adicione-o a uma lista de "falsos". Exiba ambas as listas ao final.
    1. Crie um programa que peça ao usuário para digitar números inteiros até que ele digite um número que seja a soma dos dois números anteriores. Se o número digitado for maior que 20, adicione-o a uma lista de "números grandes". Caso contrário, adicione-o a uma lista de "números pequenos". Exiba as duas listas ao final.
1. Nível Muito Complexo
    1. Crie um programa que peça ao usuário para digitar números inteiros até que ele digite um número que seja divisível por todos os números anteriormente digitados. Exiba a lista completa de números ao final.
    1. Crie um programa que peça ao usuário para digitar números decimais até que ele digite um número que seja a média de todos os números anteriormente digitados. Exiba o maior e o menor número digitado ao final.
    1. Crie um programa que peça ao usuário para digitar palavras até que ele digite uma palavra que tenha as mesmas letras (em qualquer ordem) que a primeira palavra digitada. Em seguida, exiba a quantidade total de palavras digitadas.
    1. Crie um programa que peça ao usuário para digitar valores booleanos (True ou False) até que ele digite uma sequência de "True", "False", "True", "False". Exiba quantas vezes "True" e "False" foram digitados ao final.
        ```python
        cont_true = 0
        cont_fals = 0
        parada = '0000'
        continua = True

        # cond parada TFTF
        while continua:
            resposta = bool(input('digite um boolean : '))

            if resposta:
                cont_true = cont_true + 1
                parada = parada[1:] + 'T'
            else:
                cont_fals = cont_fals + 1
                parada = parada[1:] + 'F'

            print(parada)
            if parada == 'TFTF':
                continua = False

        print('contagem True :', cont_true)
        print('contagem False :', cont_fals)
        ```
    1. Crie um programa que peça ao usuário para digitar números inteiros até que a soma dos números digitados seja igual ao produto dos números digitados. Em seguida, exiba todos os números digitados e a soma total.
1. Nível Muito Complexo com if-elif-else
    1. Crie um programa que peça ao usuário para digitar números inteiros até que ele digite um número que seja divisível pelo número de elementos já digitados. Se o número for maior que 100, adicione-o a uma lista de "números muito grandes". Caso contrário, adicione-o a uma lista de "outros números". Exiba ambas as listas ao final.
    1. Crie um programa que peça ao usuário para digitar palavras até que ele digite uma palavra que tenha um número de letras igual ao número total de palavras digitadas anteriormente. Se a palavra começar com uma vogal, adicione-a a uma lista de "palavras com vogal". Caso contrário, adicione-a a uma lista de "palavras com consoante". Exiba ambas as listas ao final.
    1. Crie um programa que peça ao usuário para digitar números decimais até que ele digite um número que seja o dobro de algum dos números já digitados. Se o número for maior que 10, adicione-o a uma lista de "números grandes". Caso contrário, adicione-o a uma lista de "números pequenos". Exiba ambas as listas ao final.
    1. Crie um programa que peça ao usuário para digitar valores booleanos (True ou False) até que ele digite um padrão alternado de "True" e "False" três vezes seguidas. Exiba a quantidade total de "True" e "False" digitados ao final.
    1. Crie um programa que peça ao usuário para digitar números inteiros até que ele digite um número que seja múltiplo da soma dos dígitos de um dos números anteriormente digitados. Se o número for par, adicione-o a uma lista de "pares". Caso contrário, adicione-o a uma lista de "ímpares". Exiba ambas as listas ao final.
</details>

## comando `for`

O comando `for` em Python é uma estrutura de repetição que permite iterar sobre elementos de uma sequência (como listas, tuplas, strings ou intervalos) ou qualquer outro objeto iterável. A cada iteração, ele atribui o próximo elemento da sequência a uma variável e executa um bloco de código.

```python
# sintaxe básica
for variável in sequência:
    # bloco de código
```

- **variável** : uma variável que assume o valor de cada item da sequência durante cada iteração;
- **sequência** : pode ser qualquer tipo de coleção, como uma lista, string, tupla, conjunto, ou até mesmo um intervalo (usando `range()`);
- **bloco de código** : o código que será executado para cada item na sequência;

Veja alguns exemplos

1. iterando sobre uma lista :

    Uma lista, nada mais é que uma sequência de itens. Então, é possível usar o comando `for` para passar por cada elemento individualmente.
    ```python
    >>> frutas = ["maçã", "banana", "laranja"]
    >>> for fruta in frutas:
    ...     print(fruta)
    ...
    maçã
    banana
    laranja
    >>> |
    ```

1. iterando sobre uma string :
    ```python
    >>> palavra = 'Arnold'
    >>> for letra in palavra:
    ...     print(letra)
    ...
    A
    r
    n
    o
    l
    d
    >>> |
    ```

### `for` e `if-elif-else`

É possível incluir declarações condicionais dentro de um loop `for` para controlar o fluxo de execução :

```python
>>> numeros = [1, 2, 3, 4, 5, 6]
>>> for num in numeros:
...     if num % 2 == 0:
...         print(f'{num} é par')
...     else:
...         print(f'{num} é ímpar')
...
1 é ímpar
2 é par
3 é ímpar
4 é par
5 é ímpar
6 é par
>>> |
```

### exercícios `for`

<details>
<summary>Lista de Exercícios</summary>

1. Itere sobre uma lista de números e imprima cada número.
1. Itere sobre uma string e imprima cada caractere.
1. Itere sobre uma lista de palavras e imprima cada palavra em maiúsculas.
1. Itere sobre uma lista de números e imprima o quadrado de cada número.
1. Itere sobre uma string e conte quantas letras "a" ela possui.
1. Crie uma lista de números e use um loop `for` para criar uma nova lista com o dobro de cada número.
1. Itere sobre uma lista de strings e imprima cada uma em ordem reversa.
1. Itere sobre uma lista de números e imprima apenas os números pares.
1. Itere sobre uma lista de palavras e imprima apenas as palavras que começam com a letra "p".
1. Itere sobre uma lista de números e imprima o cubo de cada número.
1. Crie uma lista de números e use `for` para somar todos os números da lista.
1. Itere sobre uma string e crie uma nova string com todas as vogais removidas.
1. Itere sobre uma lista de palavras e imprima o comprimento de cada uma.
1. Itere sobre uma lista de números e imprima a metade de cada número.
1. Itere sobre uma string e imprima cada caractere junto com seu índice.
1. Crie uma lista de palavras e use `for` para criar uma nova lista com cada palavra em maiúsculas.
1. Itere sobre uma lista de números e imprima apenas os números ímpares.
1. Itere sobre uma string e imprima apenas as letras que aparecem mais de uma vez.
1. Itere sobre uma lista de números e imprima o produto de todos os números.
1. Itere sobre uma lista de palavras e imprima apenas as palavras que contêm a letra "e".
1. Itere sobre uma lista de números e crie uma nova lista com apenas os números que são divisíveis por 3.
1. Itere sobre uma string e imprima cada caractere junto com a quantidade de vezes que ele aparece na string.
1. Itere sobre uma lista de palavras e imprima cada palavra com suas letras em ordem alfabética.
1. Itere sobre uma lista de números e imprima a soma de todos os números maiores que 10.
1. Itere sobre uma lista de strings e crie uma nova string que seja a concatenação de todas as strings da lista.

</details>

## loops aninhados

Loops aninhados em Python ocorrem quando se coloca um loop dentro de outro. Isso permite percorrer estruturas de dados mais complexas, como listas de listas (ou matrizes) e realizar operações em camadas diferentes de iteração.

### usando o loop `for` aninhado

Quando se aninha loops `for`, o loop externo inicia e, para cada iteração do loop externo, o loop interno percorre completamente sua estrutura.

1. iterando sobre uma matriz

```python
>>> matriz = [
...     [1, 2, 3],
...     [4, 5, 6],
...     [7, 8, 9]
... ]
>>>
>>> for linha in matriz:
...     for coluna in linha:
...         print(coluna, end=' ')
...     print()
...
1 2 3
4 5 6
7 8 9
>>> |
```

1. O loop externo `for linha in matriz` percorre cada lista dentro da lista principal `matriz`;
1. O loop interno `for coluna in linha` percorre cada elemento dentro da lista atual (`linha`);
1. O `print(coluna, end=' ')` imprime cada elemento da linha na mesma linha;
1. O `print()` fora do loop interno quebra a linha, garantindo que cada linha da matriz seja impressa em uma linha separada;

### usando o loop `while` aninhado

No caso do `while`, é necessário controlar explicitamente as condições de parada tanto do loop externo quanto do interno.

1. iterando sobre uma matriz com `while`

```python
>>> matriz = [
...     [1, 2, 3],
...     [4, 5, 6],
...     [7, 8, 9]
... ]
>>>
>>> i = 0
>>> while i < len(matriz):
>>>     j = 0
>>>     while j < len(matriz[i]):
>>>         print(matriz[i][j], end=' ')
>>>         j += 1
>>>     print()
>>>     i += 1
1 2 3
4 5 6
7 8 9
>>> |
```

1. O loop externo `while i < len(matriz)` controla a iteração sobre as linhas da matriz.
1. O loop interno `while j < len(matriz[i])` controla a iteração sobre os elementos dentro da linha atual.
1. O `print(matriz[i][j], end=' ')` imprime cada elemento da linha.
1. Após o loop interno, o `print()` cria uma nova linha.
1. `i += 1` e `j += 1` atualizam os contadores para mover-se para a próxima linha e próximo elemento, respectivamente.

### usando `for` e `while` juntos

É também possível combinar `for` e `while` em loops aninhados, dependendo da lógica que deseja implementar.

1. `for` e `while` juntos

```python
>>> matriz = [
...     [1, 2, 3],
...     [4, 5, 6],
...     [7, 8, 9]
... ]
>>>
>>> for linha in matriz:
...     j = 0
...     while j < len(linha):
...         print(linha[j], end=' ')
...         j += 1
...     print()
1 2 3
4 5 6
7 8 9
>>> |
```

1. O loop externo `for linha in matriz` percorre cada linha da matriz;
1. O loop interno `while j < len(linha)` percorre cada elemento da linha usando um contador manual `j`;
1. O `print(linha[j], end=' ')` imprime cada elemento;
1. O `print()` no final quebra a linha;

### exercícios loops aninhados

<details>
<summary>Lista de Exercícios</summary>

1. exercícios com `for` aninhado
    1. crie um programa que imprime o seguinte padrão utilizando loops aninhados `for`:
    ```
    *
    * *
    * * *
    * * * *
    * * * * *
    ```
    ```python
    for i in range(0,5):
        # print(f'{list(range(0,i+1)) = }')
        for j in range(0, i+1):
            print('*', end='')
        print()


    i = 0
    while i < 5:
        j = 0
        while j < i+1:
            print('*', end='')
            j = j + 1
        print()
        i = i + 1
    ```
    1. dda uma matriz 3x3, crie um programa que soma todos os elementos da matriz usando loops `for` aninhados.
    1. crie uma lista de listas onde cada sublista contém os números de 1 a 5. Use loops `for` aninhados para imprimir todos os elementos.
    1. dada uma matriz 4x4, use loops `for` aninhados para imprimir a diagonal principal (elementos onde o índice da linha é igual ao índice da coluna).
    1. escreva um programa que crie um tabuleiro de xadrez 8x8 utilizando loops `for` aninhados, onde o tabuleiro é representado por "X" e "O".
1. exercícios com `while` aninhado
    1. crie um programa que imprime o seguinte padrão utilizando loops aninhados `while`:
    ```
    1
    1 2
    1 2 3
    1 2 3 4
    1 2 3 4 5
    ```
    1. dada uma matriz 3x3, escreva um programa que encontra o maior valor da matriz utilizando loops `while` aninhados.
    1. usando loops `while` aninhados, crie um programa que imprime uma matriz identidade 4x4.
    1. escreva um programa que cria uma matriz 5x5 e preenche-a com números aleatórios entre 1 e 100. Use loops `while` aninhados para encontrar e imprimir o menor valor da matriz.
    1. crie um programa que usa loops `while` aninhados para imprimir todos os números pares de uma matriz 3x3.
1. exercícios com combinação de `for` e `while`
    1. dada uma lista de listas, use um loop `for` externo e um loop `while` interno para imprimir todos os elementos das sublistas.
    1. crie um programa que use um loop `while` externo para iterar sobre os índices de uma lista de listas e um loop `for` interno para somar os elementos de cada sublista.
    1. escreva um programa que leia uma matriz 4x4 e use um loop `for` para iterar sobre as linhas e um loop `while` para contar o número de elementos pares em cada linha.
    1. dada uma matriz 3x3, use um loop `for` externo para iterar sobre as linhas e um loop `while` interno para calcular o produto dos elementos de cada linha.
    1. crie um programa que usa um loop `while` para iterar sobre uma lista de listas e um loop `for` para encontrar a soma dos elementos ímpares em cada sublista.
1. Exercícios Avançados
    1. escreva um programa que gere uma matriz 3x3 com números aleatórios entre 1 e 50. Use loops `for` aninhados para transpor a matriz (trocar linhas por colunas).
    1. dada uma matriz `NxN`, escreva um programa que utilize loops aninhados `while` para calcular a soma dos elementos acima da diagonal principal.
    1. crie um programa que leia duas matrizes 3x3 e use loops `for` aninhados para calcular a soma dessas matrizes.
    1. dada uma matriz `M x N`, crie um programa que use loops `for` e `while` aninhados para imprimir os elementos na forma de espiral.
    1. crie um programa que usa um loop `for` para iterar sobre os índices de uma lista de listas e um loop `while` para encontrar o maior número primo em cada sublista.

</details>

## for vs while

No Python, os loops `for` e `while` são estruturas de repetição que permitem executar um bloco de código várias vezes, mas funcionam de maneiras diferentes.

### loop `for`

O loop `for` é utilizado para iterar sobre uma sequência (como uma lista, tupla, string ou range). Ele percorre cada elemento da sequência, um por um, até que todos os elementos tenham sido processados.

```python
>>> estrutura básica
>>> for elemento in sequencia:
...     # Bloco de código a ser repetido
```

- **`elemento`** : uma variável que assume o valor de cada item da sequência em cada iteração;
- **`sequencia`** : a sequência de elementos que será iterada;

#### características do `for`
1. **iteração pré-definida** : o número de iterações é conhecido desde o início, baseado no tamanho da sequência;
2. **fácil manipulação de sequências** : ideal para trabalhar com listas, strings, tuplas, etc;
3. **menos propenso a loops infinitos** : como o número de iterações é determinado pela sequência, é menos provável que o loop entre em um estado infinito;

### loop `while`

O loop `while` repete um bloco de código enquanto uma condição booleana é verdadeira. Ele é útil quando o número de iterações não é conhecido de antemão, mas depende de uma condição que pode mudar durante a execução do loop.

```python
>>> # estrutura básica
>>> while condicao:
>>>     # Bloco de código a ser repetido
```

- **`condicao`** : uma expressão que é avaliada antes de cada iteração. Se for `True`, o loop continua; se for `False`, o loop para;

#### características do `while`
1. **iteração não definida** : o número de iterações depende da condição, e pode não ser conhecido antecipadamente;
2. **flexibilidade** : permite loops mais complexos, onde a condição de término pode depender de várias variáveis;
3. **propenso a loops infinitos** : se a condição nunca se tornar `false`, o loop continuará indefinidamente;


### comparação `for` vs `while`

| característica | `for` | `while` |
| ---- | ---- | ---- |
| **uso principal** | iteração sobre sequências conhecidas | condições complexas ou indefinidas |
| **número de iterações** | pré-determinado (baseado na sequência) | indeterminado (baseado na condição)|
| **sintaxe** | mais concisa para iterar sequências | mais flexível, mas potencialmente mais longa |
| **segurança** | menos propenso a loops infinitos | maior risco de loops infinitos |
| **aplicabilidade** | ideal para listas, strings, tuplas, etc. | ideal para loops dependentes de condições variáveis |
| **controle do loop** | controlado pela sequência | controlado pela condição booleana |

### quando usar `for`?
- quando o número de iterações é conhecido ou pode ser determinado com base na sequência (como iterar sobre uma lista ou usando `range()`).
- quando se deseja iterar sobre cada elemento de uma estrutura de dados.

### quando usar `while`?
- quando o número de iterações não é conhecido antecipadamente e depende de uma condição que pode variar durante a execução.
- quando é necessário repetir uma ação até que uma determinada condição seja atendida.

### exemplos

1. iterar uma lista de números e imprimir cada elemento :
    ```python
    >>> numeros = [1, 2, 3, 4, 5]
    >>>
    >>> # iterando com for
    >>> for numero in numeros:
    ...     print(numero)
    ...
    1
    2
    3
    4
    5
    >>>
    >>> # iterando com o while
    >>> i = 0
    >>>
    >>> while i < len(numeros):
    ...     numero = numeros[i]
    ...     print(numero)
    ...     i += 1
    ...
    1
    2
    3
    4
    5
    >>> |
    ```

1. somar os números de 1 a 5 :
    ```python
    >>> # iterando com for
    >>> soma = 0
    >>>
    >>> for i in range(1, 6):
    ...     soma += i
    ...
    >>> print(soma)
    15
    >>>
    >>> # iterando com while
    >>>soma = 0
    >>> i = 1
    >>>
    >>> while i <= 5:
    ...     soma += i
    ...     i += 1
    ...
    >>> print(soma)
    15
    >>> |
    ```

1. encontrar o primeiro número par em uma lista :
    ```python
    >>> numeros = [1, 3, 5, 6, 7, 9]
    >>>
    >>> # iterando com for
    >>>
    >>> for numero in numeros:
    ...     if numero % 2 == 0:
    ...         print(f"Primeiro número par : {numero}")
    ...         break
    ...
    Primeiro número par : 6
    >>>
    >>> # iterando com while
    >>> i = 0
    >>>
    >>> while i < len(numeros):
    ...     numero = numeros[i]
    ...     if numero % 2 == 0:
    ...         print(f"Primeiro número par : {numero}")
    ...         break
    ...     i += 1
    ...
    Primeiro número par : 6
    >>> |
    ```

1. contar até que um número aleatório seja maior que 5 :

    Esse exemplo é mais adequado para `while`, mas pode ser adaptado com um loop controlado.

    ```python
    >>> import random
    >>>
    >>> # iterando com for
    >>> for _ in range(100):  # define um limite arbitrário para evitar loop infinito
    ...     numero = random.randint(1, 10)
    ...     print(numero)
    ...         if numero > 5:
    ...         break
    ...
    3
    1
    2
    6
    >>>
    >>> # iterando com while
    >>> numero = 0
    >>>
    >>> while numero <= 5:
    ...     numero = random.randint(1, 10)
    ...     print(numero)
    ...
    1
    4
    7
    >>> |
    ```

1. repetir uma string 5 vezes
    ```python
    >>> # iterando com for
    >>> for _ in range(5):
    ...     print("Olá")
    ...
    Olá
    Olá
    Olá
    Olá
    Olá
    >>>
    >>> # iterando com while
    >>> i = 0
    >>>
    >>> while i < 5:
    ...     print("Olá")
    ...     i += 1
    ...
    Olá
    Olá
    Olá
    Olá
    Olá
    >>> |
    ```

## exercícios for vs while

<details>
<summary>Lista de Exercícios</summary>

Para cada exercício abaixo, crie as duas versões, isto é, use tanto o loop `for` quanto o loop `while`.

Exemplo :
```python
# imprimir cada elemento de uma lista de frutas :
# dada a lista frutas = ['maçã', 'banana', 'cereja'],
# imprima cada fruta;
frutas = ['maçã', 'banana', 'cereja']

# iterando com for
for fruta in frutas:
    print(fruta)

# iterando com while
i = 0
while i < len(frutas):
    print(frutas[i])
    i += 1

# outra forma com while
i = 0
while i < len(frutas):
    fruta = frutas[i]
    print(fruta)
    i += 1
```

1. **imprimir cada elemento de uma lista de frutas** : dada a lista `frutas = ['maçã', 'banana', 'cereja']`, imprima cada fruta;
1. **somar todos os números em uma tupla** : dada a tupla `numeros = (1, 2, 3, 4, 5)`, calcule e imprima a soma de todos os elementos;
1. **contar o número de vogais em uma string** : dada a string `texto = "programacao"`, conte quantas vogais existem no texto;
1. **reverter uma lista de números** : dada a lista `numeros = [1, 2, 3, 4, 5]`, imprima os números na ordem inversa;
1. **concatenar todas as strings em uma lista** : dada a lista `palavras = ['Eu', 'gosto', 'de', 'programar']`, concatene todas as strings em uma única string e imprima o resultado;
1. **encontrar o maior número em uma lista** : dada a lista `numeros = [4, 7, 1, 9, 3]`, encontre e imprima o maior número;
1. **contar quantos números pares existem em uma tupla** : dada a tupla `numeros = (2, 5, 8, 11, 14)`, conte quantos números são pares;
1. **imprimir cada caractere de uma string** : dada a string `nome = "Python"`, imprima cada caractere em uma linha separada;
1. **somar os números ímpares em uma lista** : dada a lista `numeros = [1, 2, 3, 4, 5, 6, 7]`, calcule a soma de todos os números ímpares;
1. **verificar se uma lista contém um número específico** : dada a lista `numeros = [10, 20, 30, 40, 50]` e o número `30`, verifique se o número está presente na lista;
1. **contar quantas vezes uma letra específica aparece em uma string** : dada a string `frase = "banana"` e a letra `a`, conte quantas vezes a letra `a` aparece;
1. **imprimir os elementos de uma tupla que estão em posições pares** : dada a tupla `numeros = (10, 20, 30, 40, 50, 60)`, imprima os elementos que estão em posições pares;
1. **criar uma nova lista apenas com os elementos ímpares de uma lista** : dada a lista `numeros = [1, 2, 3, 4, 5, 6]`, crie e imprima uma nova lista contendo apenas os números ímpares;
1. **concatenar os caracteres de uma string em ordem inversa** : dada a string `texto = "abcd"`, crie e imprima uma nova string com os caracteres em ordem inversa;
1. **multiplicar todos os elementos de uma lista por 2** : dada a lista `numeros = [2, 4, 6, 8]`, crie uma nova lista onde cada elemento é o dobro do valor original;
1. **contar quantos números negativos existem em uma lista** : dada a lista `numeros = [-3, -2, 0, 1, 4]`, conte quantos números são negativos;
1. **verificar se uma string é um palíndromo** : dada a string `palavra = "radar"`, verifique se a palavra é um palíndromo (lê-se da mesma forma de trás para frente);
1. **imprimir os elementos de uma tupla até encontrar um valor específico** : dada a tupla `numeros = (5, 10, 15, 20, 25)` e o número `15`, imprima os elementos até encontrar o número 15 (inclusive);
1. **substituir todas as vogais de uma string por `*`** : dada a string `frase = "substituir vogais"`, crie e imprima uma nova string onde todas as vogais são substituídas por `*`;
1. **imprimir o índice e o valor de cada elemento em uma lista** : dada a lista `numeros = [10, 20, 30, 40]`, imprima o índice e o valor de cada elemento;
1. **criar uma nova tupla apenas com os números maiores que 10** : dada a tupla `numeros = (3, 10, 15, 7, 20)`, crie e imprima uma nova tupla contendo apenas os números maiores que 10;
1. **imprimir uma string em formato de pirâmide** : dada a string `texto = "PYTHON"`, imprima a string em formato de pirâmide :
    ```
    P
    PY
    PYT
    PYTH
    PYTHO
    PYTHON
    ```
1. **remover todos os elementos duplicados de uma lista**: dada a lista `numeros = [1, 2, 2, 3, 4, 4, 5]`, crie e imprima uma nova lista sem elementos duplicados;
1. **imprimir apenas os caracteres que são letras maiúsculas de uma string**: dada a string `texto = "Programação Em Python"`, imprima apenas as letras maiúsculas;
1. **imprimir todos os elementos de uma lista de trás para frente**: dada a lista `numeros = [1, 2, 3, 4, 5]`, imprima os elementos começando do último até o primeiro;

</details>

## `else` em loops

No Python, o bloco `else` pode ser usado em conjunto com os loops `for` e `while`, e seu comportamento é um pouco diferente do que se vê em outras linguagens de programação. O bloco `else` em um loop é executado quando o loop termina normalmente, ou seja, quando ele não é interrompido por um `break`.

### `else` com `for`

No contexto de um loop `for`, o bloco `else` é executado após o loop percorrer todos os elementos do iterável. Se o loop for interrompido por um comando `break`, o bloco `else` é ignorado.

**exemplo 1 : loop `for` sem `break`**

```python
numeros = [1, 2, 3, 4, 5]

for numero in numeros:
    print(numero)
else:
    print("Loop completado sem interrupções.")
```

- o loop `for` percorre todos os números na lista `numeros`;
- após o loop terminar, o bloco `else` é executado, imprimindo "Loop completado sem interrupções.";
- como não há `break`, o `else` sempre será executado;

**exemplo 2 : loop `for` com `break`**

```python
numeros = [1, 2, 3, 4, 5]

for numero in numeros:
    if numero == 3:
        print("Número 3 encontrado, interrompendo o loop.")
        break
    print(numero)
else:
    print("Loop completado sem interrupções.")
```

- o loop `for` percorre os números até encontrar o número 3;
- quando o número 3 é encontrado, o loop é interrompido com `break`;
- neste caso, o bloco `else` não é executado porque o loop foi interrompido;

### `else` com `while`

O funcionamento do `else` em um loop `while` é semelhante ao do `for`. O bloco `else` é executado quando o loop termina normalmente, ou seja, quando a condição do `while` se torna falsa. Se o loop for interrompido por um `break`, o bloco `else` não é executado.

**exemplo 3 : loop `while` sem `break`**

```python
contador = 0

while contador < 5:
    print(contador)
    contador += 1
else:
    print("Loop `while` completado sem interrupções.")
```

- o loop `while` continua enquanto `contador` for menor que 5;
- quando a condição `contador < 5` se torna falsa, o loop termina, e o bloco `else` é executado, imprimindo "Loop `while` completado sem interrupções.";

**exemplo 4 : loop `while` com `break`**

```python
contador = 0

while contador < 5:
    if contador == 3:
        print("Contador atingiu 3, interrompendo o loop.")
        break
    print(contador)
    contador += 1
else:
    print("Loop `while` completado sem interrupções.")
```

- O loop `while` continua até `contador` atingir 3.
- Quando `contador` é igual a 3, o loop é interrompido com `break`.
- O bloco `else` não é executado porque o loop foi interrompido antes que a condição se tornasse falsa.

### resumo

- o `else` no `for` ou `while` é executado quando o loop termina naturalmente, sem ser interrompido por um `break`;
- se o loop for interrompido com um `break`, o bloco `else` é ignorado;
- o uso de `else` com loops pode ser útil para executar código que deve rodar apenas se o loop percorrer todos os elementos ou todas as iterações sem interrupções;

Essa funcionalidade é especialmente útil em casos onde você está procurando um item em uma coleção. Se o item for encontrado e o loop for interrompido, você não deseja executar o bloco `else`, mas se o item não for encontrado e o loop terminar normalmente, o `else` pode ser usado para indicar que a busca não teve sucesso.

## exercícios else

<details>
<summary>Lista de Exercícios</summary>

1. Dada a lista `numeros = [1, 2, 3, 4, 5]`, crie um loop `for` que percorra a lista e imprima cada número. Use um bloco `else` para imprimir "Loop finalizado" após a conclusão do loop.
1. Crie um loop `for` que percorra a string `"python"` e imprima cada caractere. No bloco `else`, imprima "Todos os caracteres foram exibidos".
1. Dado o tuple `nomes = ("Alice", "Bob", "Carlos", "Diana")`, crie um loop `for` que pare quando encontrar o nome "Carlos". Use `else` para imprimir "Nome não encontrado" caso "Carlos" não esteja no tuple.
1. Crie um loop `while` que continue enquanto o comprimento da lista `numeros = [2, 4, 6, 8, 10]` for maior que 0. Remova um elemento da lista a cada iteração e, quando o loop terminar, use `else` para imprimir "Todos os elementos foram removidos".
1. Dado o set `letras = {'a', 'b', 'c', 'd'}`, crie um loop `for` que percorra o set e imprima cada letra. No bloco `else`, imprima "Loop completo sem interrupções".
1. Dada a lista `numeros = [10, 20, 30, 40, 50]`, crie um loop `for` que interrompa a execução quando encontrar o número 30. Use `else` para imprimir "Número não encontrado" se o loop não for interrompido.
1. Crie um loop `while` que continue a remover o último caractere da string `texto = "abcdef"` enquanto o comprimento da string for maior que 3. Use `else` para imprimir "Texto curto" ao final.
1. Dado o tuple `pontos = (10, 20, 30, 40, 50)`, crie um loop `for` que pare quando o valor 60 for encontrado. Use `else` para imprimir "Valor não encontrado" se o loop terminar sem interrupção.
1. Dado o set `numeros = {1, 2, 3, 4, 5}`, crie um loop `for` que percorra o set e imprima cada número. Use um `else` para indicar que todos os números foram exibidos.
1. Crie um loop `while` que percorra a string `"palavra"` e interrompa o loop se encontrar o caractere `"w"`. Use `else` para imprimir "Caractere não encontrado" se o loop não for interrompido.
1. Dado o tuple `numeros = (1, 2, 3, 4, 5)`, crie um loop `for` que imprima cada número. Use `else` para imprimir "Fim do loop" após o loop percorrer todos os números.
1. Crie um loop `while` que continue removendo o primeiro elemento da lista `letras = ['a', 'b', 'c', 'd']` enquanto o comprimento da lista for maior que 1. Use `else` para imprimir "Apenas uma letra restante".
1. Dado o set `vogais = {'a', 'e', 'i', 'o', 'u'}`, crie um loop `for` que pare quando a letra `"i"` for encontrada. Use `else` para imprimir "Letra não encontrada" se o loop não for interrompido.
1. Crie um loop `while` que continue a iterar enquanto o número de elementos na lista `numeros = [10, 20, 30]` for maior que 2. Use `else` para imprimir "Quantidade de elementos suficiente".
1. Dado o tuple `frutas = ("maçã", "banana", "laranja", "uva")`, crie um loop `for` que imprima cada fruta. Use `else` para imprimir "Todas as frutas foram exibidas" ao final.
1. Crie um loop `while` que continue enquanto a string `"abcdefg"` contiver o caractere `"c"`. Remova `"c"` da string e use `else` para imprimir "Caractere removido com sucesso".
1. Dado o set `numeros = {1, 2, 3, 4, 5}`, crie um loop `for` que interrompa quando encontrar o número 4. Use `else` para imprimir "Número não encontrado" caso o loop não seja interrompido.
1. Crie um loop `while` que percorra a string `"looping"` e pare se encontrar o caractere `"p"`. Use `else` para imprimir "Nenhum caractere 'p' encontrado" se o loop não for interrompido.
1. Dado o tuple `cores = ("vermelho", "azul", "verde", "amarelo")`, crie um loop `for` que imprima cada cor. Use `else` para imprimir "Fim das cores" após o loop.
1. Crie um loop `while` que continue removendo elementos do set `numeros = {5, 10, 15, 20}` enquanto ele não estiver vazio. Use `else` para imprimir "Set vazio".

</details>
Índice

1. [o que uma função?](#o-que-e-uma-funcao)
1. [por que usar fuções](#por-que-usar-funcoes)
1. [tipos de funções](#tipos-de-funcoes)
1. [boas práticas na definição de funções](#boas-praticas-na-definicao-de-funcoes)
1. [comando def](#comando-def)
1. [exercícios de funções](#exercicios-de-funcoes)
1. [argumentos posicionais](#argumentos-posicionais)
1. [exercícios argumentos posicionais](#exercícios-argumentos-posicionais)
1. [comando return](#comando-return)
1. [exercícios comando return](#exercícios-comando-return)
1. [argumentos com valor padrão](#argumentos-com-valor-padrão)
1. [argumentos nomeados](#argumentos-nomeados)
1. [exercícios valor padrão e argumentos nomeados](#exercicios-valor-padrao-e-argumentos-nomeados)
1. [empacotamento e desempacotamento nas funções](#empacotamento-e-desempacotamento-nas-funções)
    1. [`*args`](#args)
    1. [`**kwargs`](#kwargs)
1. [exercícios `args` `kwargs`](#exercícios-args-kwargs)
1. [exemplos](#exemplos)
    1. [funções com parâmetros posicionais](#funções-com-parâmetros-posicionais)
    1. [funções com parâmetros posicionais e parâmetros com valores padrão](#funções-com-parâmetros-posicionais-e-parâmetros-com-valores-padrão)
    1. [funções com parâmetros posicionais, parâmetros com valores padrão e `*args`](#funções-com-parâmetros-posicionais-parâmetros-com-valores-padrão-e-args)
    1. [funções com parâmetros posicionais, parâmetros com valores padrão, `*args` e `**kwargs`](#funções-com-parâmetros-posicionais-parâmetros-com-valores-padrão-args-e-kwargs)

# funções

As funções em Python são blocos de código reutilizáveis que realizam uma tarefa específica. Elas permitem que se organize e modularize o código, facilitando a manutenção, reutilização e a legibilidade.

## o que é uma função?

Uma função em Python é um trecho de código que é definido uma vez e pode ser executado (ou "chamado") quantas vezes for necessário. As funções podem receber entradas (chamadas de parâmetros ou argumentos) e podem retornar saídas (resultado). Elas são uma maneira de agrupar código que realiza uma tarefa específica, o que torna o programa mais estruturado e modular.

## por que usar funções?

- **reutilização de código** : uma função é definida uma vez e é possível usá-la em diferentes partes do programa sem precisar reescrever o código;
- **modularidade** : funções permitem dividir um programa grande em partes menores e mais manejáveis, cada uma responsável por uma tarefa específica;
- **facilidade de manutenção** : como o código é organizado em blocos lógicos, ele se torna mais fácil de entender, corrigir e atualizar;
- **redução de erros** : evitar repetição de código reduz a probabilidade de erros. se for necessário corrigir um bug, só precisará fazer isso em um lugar, na definição da função;

## tipos de funções

O Python, e outras linguagens de programação, podem usar funções de diferentes modos :

- funções sem parâmetros e sem retorno : elas não recebem dados externos e não retornam valores. Elas apenas executam um bloco de código;
- funções com parâmetros e sem retorno : recebem dados (argumentos) e realizam operações, mas não retornam valores;
- funções sem parâmetros e com retorno : não recebem dados, mas realizam operações e retornam um valor;
- funções com parâmetros e com retorno : recebem dados e retornam um valor após realizar operações;

## boas práticas na definição de funções

- **escolha bons nomes para funções e parâmetros** : nomes devem ser descritivos e refletir o propósito da função;
- **mantenha as funções curtas** : funções devem ser curtas e realizar apenas uma tarefa específica;
- **documente suas funções** : use docstrings para explicar o que a função faz, quais são seus parâmetros e o que ela retorna;
- **evite efeitos colaterais** : uma função idealmente deve receber entradas, processá-las e retornar um resultado sem alterar o estado externo;

## comando `def`

O comando `def` em Python é utilizado para declarar funções. Ele é uma das palavras-chave mais importantes na linguagem, pois permite que se defina blocos de código que podem ser chamados e reutilizados em diferentes partes de um programa.

### o que é o comando `def`?

O `def` é uma abreviação de "define" e é usado para definir uma nova função. Uma função, no contexto da programação, é um bloco de código que realiza uma tarefa específica e pode ser reutilizado sempre que necessário. Quando se usa `def`, se está essencialmente criando um novo comando personalizado que pode ser executado em qualquer ponto do seu código.

### sintaxe do comando `def`

A sintaxe básica do `def` para criar uma função é a seguinte :

```python
def nome_da_funcao(parâmetros_opcionais):
    """Docstring opcional"""
    corpo_da_funcao
```

O que é cada parte :

- **`def`** : esta palavra-chave inicia a definição da função;
- **`nome_da_funcao`** : este é o nome que se dá à função. Deve ser descritivo e seguir as regras de nomenclatura do Python (não pode começar com números, não pode conter espaços, e não pode ser uma palavra reservada);
- **`parâmetros_opcionais`** : entre parênteses, pode-se definir parâmetros que a função aceita. Eles são opcionais, o que significa que pode-se ter funções sem parâmetros;
- **`:`** : Os dois-pontos marcam o fim da linha de declaração e indicam que o corpo da função começa na linha seguinte;
- **`"""Docstring opcional"""`** : uma string entre três aspas, usada para documentar o que a função faz. Essa parte é opcional, mas é uma boa prática incluí-la;
- **`corpo_da_funcao`** : este é o bloco de código que define o que a função faz. Esse bloco deve ser indentado (geralmente com quatro espaços) em relação à linha de declaração;

### exemplo básico de definição de função

Abaixo está um exemplo de como definir uma função simples que imprime uma mensagem de saudação :

```python
>>> def saudacao():
...     """Esta função imprime uma saudação simples."""
...     print("Olá, bem-vindo ao Python!")
...
>>> |
```

Neste exemplo :
- **`def saudacao():`** : define uma função chamada `saudacao` que não aceita parâmetros;
- **`"""Esta função imprime uma saudação simples."""`** : é uma docstring que descreve a função;
- **`print("Olá, bem-vindo ao python!")`** : é o corpo da função, que será executado quando a função for chamada;

### execução do comando `def`

Quando o Python encontra o comando `def` durante a execução do programa, ele não executa imediatamente o código dentro da função. Em vez disso, ele "registra" a função com o nome fornecido, o que significa que a função existe na memória e pode ser chamada posteriormente no código.

Exemplo :

```python
>>> def saudacao():
...     print("Olá, bem-vindo ao Python!")
...
>>>
>>> print("Antes de chamar a função.")
Antes de chamar a função.
>>> saudacao()
Olá, bem-vindo ao Python!
>>> print("Depois de chamar a função.")
Depois de chamar a função.
>>> |
```

Neste exemplo :
- o python passa pela definição da função `saudacao` e a armazena;
- a função `saudacao()` é chamada, o que faz com que o código dentro da função seja executado;

### docstrings e comentários

As docstrings são usadas para documentar funções, tornando o código mais legível e fácil de entender. Elas podem ser acessadas usando a função `help()` ou o atributo `.__doc__` da função.

Exemplo :

```python
>>> def multiplicar(a, b):
...     """Esta função mostra o produto de dois números."""
...     print(f'{a * b = }')
...
>>> print(multiplicar.__doc__)
Esta função mostra o produto de dois números.
>>> |
```

## exercícios de funções

<details>
<summary>Lista de Exercícios</summary>

1. funções sem argumentos
    1. Crie uma função chamada `mostrar_boas_vindas` que imprime "Bem-vindo ao Python!".
    1. Defina uma função chamada `exibir_data_atual` que imprime a data atual.
    1. Escreva uma função chamada `mostrar_linha` que imprime uma linha de 40 asteriscos.
    1. Crie uma função chamada `exibir_mensagem_padrao` que imprime uma mensagem motivacional.
    1. Defina uma função chamada `mostrar_nota_maxima` que imprime a nota máxima possível em um exame.
    1. Crie uma função chamada `imprimir_autor` que imprime o nome do autor de um livro fictício.
    1. Escreva uma função chamada `exibir_versao_software` que imprime a versão atual de um software.
    1. Crie uma função chamada `mostrar_horario` que imprime o horário atual.
    1. Defina uma função chamada `exibir_pi` que imprime o valor de π (pi).
    1. Escreva uma função chamada `mostrar_linguagem_programacao` que imprime "Python" como a linguagem de programação favorita.

</details>

## argumentos posicionais

Em Python, funções podem aceitar entradas na forma de **parâmetros**. Quando uma função é definida, pode-se especificar os parâmetros, que atuam como variáveis que recebem valores quando a função é chamada. Esses valores são chamados de **argumentos**.

- **parâmetros** são os nomes usados na definição da função;
- **argumentos** são os valores que você passa para a função quando a chama;

**Argumentos posicionais** são a maneira mais comum de passar valores para uma função. Eles são chamados de "posicionais" porque os valores passados são associados aos parâmetros com base na posição.

Exemplo básico :

```python
>>> def soma(a, b):
...     print(f'{a + b = }')
...
>>> |
```

Aqui :
- **`a` e `b`** são os parâmetros da função;
- quando a função é chamada, são fornecidos dois argumentos que serão mapeados para `a` e `b` com base em sua ordem;

Chamando a função :

```python
>>> soma(3, 5)
a + b = 8
>>> |
```

Neste exemplo :
- **`3`** é o primeiro argumento, que é mapeado para o parâmetro `a`;
- **`5`** é o segundo argumento, que é mapeado para o parâmetro `b`;
- a função mostra a soma dos dois valores, `8`;

### como funciona a ordem dos argumentos?

A ordem dos argumentos é crucial em funções que utilizam parâmetros posicionais. O Python associa cada argumento ao seu respectivo parâmetro pela ordem em que são fornecidos. Se inverter a ordem dos argumentos, os valores atribuídos aos parâmetros mudam.

Exemplo :

```python
>>> def dividir(dividendo, divisor):
...     print(f'{dividendo / divisor = }')
...
>>>
>>> dividir(10, 2)
dividendo / divisor = 5.0
>>> dividir(2, 10)
dividendo / divisor = 0.2
>>> |
```

Aqui :
- em **`resultado1 = dividir(10, 2)`**, `10` é mapeado para `dividendo` e `2` é mapeado para `divisor`;
- em **`resultado2 = dividir(2, 10)`**, `2` é mapeado para `dividendo` e `10` é mapeado para `divisor`;

A ordem dos argumentos influencia diretamente o resultado da operação.

### número de argumentos e parâmetros

A função deve ser chamada com o mesmo número de argumentos que o número de parâmetros definidos, ou o Python levantará um erro.

Exemplo :

```python
>>> def multiplicar(a, b, c):
...     print(f'{a * b * c = }')
...
>>> multiplicar(2, 3)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: multiplicar() missing 1 required positional argument: 'c'
>>> |
```

Neste exemplo :
- A função `multiplicar` espera três argumentos. Se for fornecido menos ou mais, o Python levantará um erro `TypeError`;

### quando usar argumentos posicionais

Os argumentos posicionais são ideais quando :
- a ordem dos argumentos faz sentido para a operação da função;
- todos os parâmetros devem ser fornecidos para a função operar corretamente;
- a clareza do código é mantida quando os argumentos são passados em uma ordem específica;

## exercícios argumentos posicionais

<details>
<summary>Lista de Exercícios</summary>

1. funções com argumentos posicionais (sem valor padrão)
    1. Crie uma função chamada `saudacao` que recebe um nome e imprime uma saudação personalizada.
    1. Escreva uma função chamada `calcular_area_retangulo` que recebe a largura e a altura de um retângulo e imprima a área.
    1. Defina uma função chamada `calcular_perimetro` que recebe o comprimento e a largura de um retângulo e imprima o perímetro.
    1. Crie uma função chamada `multiplicar_numeros` que recebe dois números e imprima o produto deles.
    1. Escreva uma função chamada `converter_para_dolar` que recebe um valor em reais e a taxa de câmbio, e retorna o valor convertido para dólares.
    1. Crie uma função chamada `calcular_velocidade_media` que recebe a distância e o tempo, e retorna a velocidade média.
    1. Defina uma função chamada `calcular_desconto` que recebe o preço original e a porcentagem de desconto, e retorna o valor com desconto aplicado.
    1. Crie uma função chamada `exibir_nome_completo` que recebe o primeiro e o último nome de uma pessoa, e imprime o nome completo.
    1. Escreva uma função chamada `calcular_media` que recebe três notas e retorna a média aritmética.
    1. Crie uma função chamada `calcular_volume_cilindro` que recebe o raio e a altura de um cilindro, e retorna o volume.

</details>

## comando `return`

O comando `return` em Python é utilizado dentro de funções para indicar que a função deve devolver um valor ao ponto onde foi chamada. Quando uma função atinge o `return`, ela termina imediatamente sua execução e o controle do programa retorna para o código que chamou a função. Esse valor retornado pode ser usado, armazenado em uma variável, ou mesmo ignorado.

### o que é o comando `return`?

O `return` é uma palavra-chave em Python que serve para duas finalidades principais :
- **encerrar a execução da função** : quando o `return` é executado, a função para de executar, mesmo que haja código após o `return`;
- **retornar um valor** : o `return` pode devolver um valor específico, que pode ser utilizado no código que chamou a função;

### como o `return` funciona em funções?

Quando uma função tem um `return`, ela se comporta de forma diferente de uma função que apenas executa código sem `return`. Com `return`, a função pode fornecer resultados que podem ser armazenados e usados posteriormente.

Exemplo simples :

```python
>>> def soma(a, b):
...     return a + b
...
>>>
>>> # chamando a função
>>> resultado = soma(3, 5)
>>> print(resultado)
8
>>> |
```

Aqui, a função `soma` aceita dois argumentos `a` e `b`, e retorna a soma deles.

Neste exemplo :
- **`soma(3, 5)`** : chama a função e passa os valores 3 e 5 como argumentos;
- **`return a + b`** : calcula a soma de 3 e 5, que é 8, e retorna esse valor;
- **`resultado = soma(3, 5)`** : armazena o valor retornado, 8, na variável `resultado`;

### funções com `return` sem valor específico

Se `return` for utilizado sem nenhum valor, ele simplesmente encerra a função, mas não retorna nenhum dado. Essa prática é mais comum para indicar o fim prematuro de uma função, dependendo de uma condição específica.

Exemplo :

```python
>>> def verificar_par(n):
...     if n % 2 == 0:
...         print(f"{n} é par.")
...         return
...     print(f"{n} é ímpar.")
...
>>> # chamando a função
>>> verificar_par(4)
4 é par.
>>> verificar_par(7)
7 é ímpar.
>>> |
```

Aqui, quando o número é par, a função imprime que o número é par e usa `return` para encerrar a função. Quando o número é ímpar, o código continua até o próximo `print`.

### retornando múltiplos valores

Python permite que retorne múltiplos valores de uma função, utilizando uma vírgula para separá-los. Esses valores são retornados como uma tupla.

Exemplo :

```python
>>> def operacoes(a, b):
...     soma = a + b
...     diferenca = a - b
...     return soma, diferenca
...
>>>
>>> resultado_soma, resultado_diferenca = operacoes(10, 5)
>>> print(f"Soma: {resultado_soma}, Diferença: {resultado_diferenca}")
Soma: 15, Diferença: 5
>>> |
```

Neste exemplo :
- **`return soma, diferenca`** : retorna dois valores, `soma` e `diferenca`;
- **`resultado_soma, resultado_diferenca = operacoes(10, 5)`** : os valores retornados são desembrulhados em duas variáveis;

### retornando estruturas de dados

Funções podem retornar qualquer tipo de dado, incluindo listas, dicionários, tuplas, etc.

Exemplo :

```python
>>> def criar_lista(a, b, c):
...     return [a, b, c]
...
>>> minha_lista = criar_lista(1, 2, 3)
>>> print(minha_lista)
[1, 2, 3]
>>> |
```

### comportamento de `return` dentro de laços e condicionais

O `return` pode ser usado dentro de laços (`for`, `while`) ou condicionais (`if`, `else`). Ao ser executado, o `return` imediatamente encerra a função, mesmo que ainda existam laços ou código após o `return`.

Exemplo :

```python
>>> def encontrar_numero(lista, alvo):
...     for numero in lista:
...         if numero == alvo:
...             return True
...     return False
...
>>> encontrado = encontrar_numero([1, 2, 3, 4, 5], 3)
>>> print(encontrado)
True
>>> |
```

Neste exemplo:
- se o número `alvo` for encontrado na lista, a função retorna `true` e para a execução;
- se o laço terminar sem encontrar o `alvo`, a função retorna `false`;

### retorno implícito de `None`

Se uma função não tiver um `return` explícito, ou se o `return` não especificar um valor, a função retorna `None` por padrão.

Exemplo :

```python
>>> def funcao_sem_return():
...     pass
...
>>>
>>> resultado = funcao_sem_return()
>>> print(resultado)
None
>>> |
```

Neste exemplo, como não há `return` na função, o Python retorna automaticamente `None`.

## exercícios comando return

<details>
<summary>Lista de Exercícios</summary>

1. funções com retorno de um ou mais valores
    1. Defina uma função chamada `calcular_soma_e_produto` que recebe dois números e retorna a soma e o produto deles.
    1. Escreva uma função chamada `converter_temperatura` que recebe uma temperatura em Celsius e retorna a temperatura em Fahrenheit e Kelvin.
    1. Crie uma função chamada `calcular_diferenca_e_divisao` que recebe dois números e retorna a diferença e o quociente deles.
    1. Defina uma função chamada `calcular_potencia` que recebe uma base e um expoente, e retorna a base elevada ao expoente e a raiz quadrada da base.
    1. Escreva uma função chamada `calcular_min_e_max` que recebe três números e retorna o menor e o maior valor entre eles.
    1. Crie uma função chamada `calcular_imc` que recebe o peso e a altura de uma pessoa, e retorna o IMC (Índice de Massa Corporal) e a classificação (abaixo do peso, normal, sobrepeso, obesidade).
    1. Defina uma função chamada `calcular_distancias` que recebe duas coordenadas (x1, y1) e (x2, y2), e retorna a distância horizontal e vertical entre elas.
    1. Escreva uma função chamada `calcular_hipotenusa` que recebe os comprimentos dos dois catetos de um triângulo retângulo, e retorna o comprimento da hipotenusa.
    1. Crie uma função chamada `calcular_area_perimetro_retangulo` que recebe a largura e a altura de um retângulo, e retorna a área e o perímetro.
    1. Defina uma função chamada `calcular_media_variancia` que recebe uma lista de números, e retorna a média e a variância dos números.
1. retorno de estruturas mais complexas (listas, tuplas, sets e dicionários)
    1. Escreva uma função chamada `criar_lista_numeros` que recebe três números e retorna uma lista contendo esses números.
    1. Crie uma função chamada `criar_tupla_nomes` que recebe três nomes e retorna uma tupla contendo esses nomes.
    1. Defina uma função chamada `criar_set_numeros` que recebe três números e retorna um set contendo esses números.
    1. Escreva uma função chamada `criar_dicionario_pessoa` que recebe nome, idade e cidade, e retorna um dicionário contendo essas informações.
    1. Crie uma função chamada `criar_lista_quadrados` que recebe uma lista de números e retorna uma lista contendo o quadrado de cada número.
    1. Defina uma função chamada `criar_tupla_cubos` que recebe uma lista de números e retorna uma tupla contendo o cubo de cada número.
    1. Escreva uma função chamada `criar_set_palavras_unicas` que recebe uma lista de palavras e retorna um set contendo as palavras únicas.
    1. Crie uma função chamada `criar_dicionario_quantidade_letras` que recebe uma lista de palavras e retorna um dicionário onde as chaves são as palavras e os valores são a quantidade de letras em cada palavra.
    1. Defina uma função chamada `criar_lista_pares_impares` que recebe uma lista de números e retorna duas listas, uma contendo os números pares e outra os ímpares.
    1. Escreva uma função chamada `criar_dicionario_contagem_caracteres` que recebe uma string e retorna um dicionário onde as chaves são os caracteres e os valores são o número de vezes que cada caractere aparece na string.
1. retorno implícito
    1. Crie uma função chamada `verificar_positivo` que recebe um número e retorna True se o número for positivo, e False caso contrário.
    1. Defina uma função chamada `verificar_par` que recebe um número e retorna True se o número for par, e False se for ímpar.
    1. Escreva uma função chamada `verificar_palindromo` que recebe uma palavra e retorna True se a palavra for um palíndromo, e False caso contrário.
    1. Crie uma função chamada `verificar_maioridade` que recebe a idade de uma pessoa e retorna True se a pessoa for maior de idade, e False caso contrário.
    ```python
    def verificar_maioridade(idade):
        if idade >= 18:
            return False
        return True

    print(verificar_maioridade(20))
    print(verificar_maioridade(10))
    ```
    1. Defina uma função chamada `verificar_letra` que recebe uma string e uma letra, e retorna True se a letra estiver na string, e False caso contrário.
    1. Escreva uma função chamada `verificar_substring` que recebe duas strings, e retorna True se a segunda string for uma substring da primeira, e False caso contrário.
    1. Crie uma função chamada `verificar_numero_primo` que recebe um número e retorna True se o número for primo, e False caso contrário.
    1. Defina uma função chamada `verificar_lista_vazia` que recebe uma lista e retorna True se a lista estiver vazia, e False caso contrário.
    1. Escreva uma função chamada `verificar_todos_pares` que recebe uma lista de números e retorna True se todos os números forem pares, e False caso contrário.
    1. Crie uma função chamada `verificar_palavras_mesma_tamanho` que recebe duas palavras e retorna True se ambas tiverem o mesmo número de caracteres, e False caso contrário.

</details>

## argumentos com valor padrão

No Python, ao definir uma função, é possível atribuir valores padrão a alguns dos parâmetros. Isso permite que a função seja chamada sem a necessidade de fornecer explicitamente um valor para esses parâmetros, usando um valor predefinido caso o argumento não seja passado.

### o conceito de argumentos com valor padrão

Quando uma função é definida, é possível especificar valores padrão para um ou mais parâmetros. Esses valores são usados automaticamente se não fornecer um argumento correspondente quando chamar a função. Isso torna as funções mais flexíveis e fáceis de usar.

Veja um exemplo simples :

```python
>>> def saudar(nome, mensagem="Olá!"):
...     print(f"{mensagem} {nome}")
...
>>> |
```

Aqui, o parâmetro `mensagem` tem um valor padrão de `"Olá!"`. Isso significa que pode-se chamar a função `saudar` de duas maneiras diferentes:

1. **passando ambos os argumentos**:

```python
>>> saudar("João", "Bem-vindo")
Bem-vindo João
>>> |
```

2. **usando o valor padrão para `mensagem`**:

```python
>>> saudar("João")
Olá! João
>>> |
```

No segundo caso, como nenhum valor foi passado para `mensagem`, o valor padrão `"Olá!"` foi utilizado.

### vantagens dos argumentos com valor padrão

Os argumentos com valor padrão oferecem diversas vantagens, incluindo maior flexibilidade e simplicidade na chamada de funções.

#### 1. simplificação de chamada

Em funções com muitos parâmetros, os valores padrão permitem que o usuário da função forneça apenas os argumentos que são realmente necessários, simplificando a chamada.

#### 2. redução de erros

Ao fornecer valores padrão para parâmetros comuns, é possível evitar erros que ocorrem quando os usuários esquecem de passar um argumento importante.

#### 3. manutenção facilitada

Funções com valores padrão são mais fáceis de manter e atualizar, pois pode-se alterar os padrões para refletir mudanças nas necessidades sem exigir que todas as chamadas à função sejam modificadas.

### regras e comportamentos de argumentos com valor padrão

Existem algumas regras importantes e comportamentos a serem considerados ao usar valores padrão:

#### 1. ordem dos argumentos

Os argumentos com valor padrão devem vir após os argumentos sem valor padrão na definição da função. Isso porque o Python precisa saber quais argumentos são obrigatórios e quais são opcionais.

**Exemplo Correto**:

```python
>>> def conectar(host, porta=8080):
...     print(f"Conectando a {host} na porta {porta}")
...
>>> |
```

**Exemplo Incorreto**:

```python
>>> def conectar(porta=8080, host):
...     print(f"Conectando a {host} na porta {porta}")
...
>>> |
```

Este exemplo resultará em um erro de sintaxe porque um argumento obrigatório (`host`) vem após um argumento opcional (`porta`).

#### 2. argumentos com valor padrão e argumentos nomeados

Quando se define uma função com valores padrão, pode-se usar tanto argumentos posicionais quanto nomeados ao chamá-la.

```python
>>> def criar_conta(nome, tipo="Padrão", saldo_inicial=0):
...     print(f"Conta criada para {nome} do tipo {tipo} com saldo inicial de {saldo_inicial}")
...
>>> |
```

Essa função pode ser chamada de várias maneiras :

- **usando apenas argumentos posicionais** :

```python
>>> criar_conta("Maria", "Premium", 1000)
```

- **misturando argumentos posicionais e nomeados** :

```python
>>> criar_conta("Carlos", saldo_inicial=500)
```

Aqui, o valor de `saldo_inicial` foi alterado, mas o valor padrão de `tipo` foi mantido.

- **usando apenas argumentos nomeados** :

```python
>>> criar_conta(nome="Ana", saldo_inicial=250)
```

#### 3. avaliação de valores padrão

Os valores padrão dos argumentos são avaliados apenas uma vez, no momento em que a função é definida. Isso significa que se o valor padrão for um objeto mutável (como uma lista ou dicionário), ele será compartilhado entre todas as chamadas da função, o que pode levar a comportamentos inesperados.

**exemplo de comportamento inesperado**:

```python
>>> def adicionar_item(item, lista=[]):
...     lista.append(item)
...     return lista
...
>>> print(adicionar_item("maçã"))
['maçã']
>>> print(adicionar_item("banana"))
['maçã', 'banana']
>>> |
```

Aqui, o valor padrão da lista foi modificado entre as chamadas, porque a lista é um objeto mutável e é compartilhada entre as chamadas da função. Para evitar esse problema, uma prática comum é usar `None` como valor padrão e, em seguida, criar uma nova lista dentro da função, se necessário:

```python
>>> def adicionar_item(item, lista=None):
...     if lista is None:
...         lista = []
...     lista.append(item)
...     return lista
...
>>> print(adicionar_item("maçã"))
['maçã']
>>> print(adicionar_item("banana"))
['banana']
```

##### 4. usando `None` como valor padrão

Usar `None` como valor padrão é uma prática comum para argumentos que podem ter valores dinâmicos ou que devem ser inicializados dentro da função:

```python
>>> def conectar(host, porta=None):
...     if porta is None:
...         porta = 8080
...
...     print(f"Conectando a {host} na porta {porta}")
```

Neste exemplo, `porta` só será definido como `8080` se não for fornecido um valor ao chamar a função.

### exemplos práticos e comuns

Vamos ver alguns exemplos práticos onde os valores padrão são extremamente úteis.

#### 1. configurações de funções

Funções que lidam com configurações geralmente usam valores padrão para tornar a função mais versátil:

```python
>>> def configurar_banco_de_dados(host="localhost", usuario="root", senha=""):
...     print(f"Conectando ao banco de dados em {host} com o usuário {usuario}")
...
>>> |
```

Essa função pode ser chamada sem argumentos se quiser usar as configurações padrão:

```python
>>> configurar_banco_de_dados()
Conectando ao banco de dados localhost com o usuário root
>>> |
```

#### 2. funções com múltiplos cenários

Funções que podem ser usadas em múltiplos cenários podem ter valores padrão para tornar seu uso mais simples:

```python
>>> def calcular_preco(valor, desconto=0, taxa=0.1):
...     preco_final = valor - (valor * desconto) + (valor * taxa)
...     return preco_final
...
>>> print(calcular_preco(100))
110.0
>>> print(calcular_preco(100, desconto=0.2))
90.0
>>> |
```

Neste exemplo, o desconto e a taxa são opcionais, permitindo que a função seja usada em diferentes contextos sem exigir que todos os argumentos sejam sempre fornecidos.

## argumentos nomeados

No Python, funções podem receber argumentos de várias formas, e uma das mais flexíveis é o uso de **argumentos nomeados** (também conhecidos como **argumentos keyword**). Esse tipo de argumento permite que se especifique quais valores deseja passar para parâmetros específicos, utilizando o nome do parâmetro.

### o básico dos argumentos nomeados

Quando uma função é definida, é possível criar parâmetros que receberão valores quando a função for chamada. Esses parâmetros podem ser passados de duas maneiras:

- **argumentos posicionais** : os valores são passados na ordem em que os parâmetros foram definidos na função;
- **argumentos nomeados** : os valores são passados utilizando o nome do parâmetro, o que permite maior flexibilidade na ordem dos argumentos;

Veja um exemplo básico :

```python
>>> def saudar(nome, mensagem):
...     print(f"Olá, {nome}! {mensagem}")
...
>>> saudar("João", "Bem-vindo ao nosso curso!")
Olá, João! Bem-vindo ao nosso curso!
>>> |
```

No exemplo acima, `"João"` é o valor para o parâmetro `nome` e `"Bem-vindo ao nosso curso!"` é o valor para o parâmetro `mensagem`. Esses valores são passados de forma posicional, ou seja, na ordem em que os parâmetros foram definidos na função.

Agora, veja o mesmo exemplo usando argumentos nomeados:

```python
>>> saudar(nome="João", mensagem="Bem-vindo ao nosso curso!")
Olá, João! Bem-vindo ao nosso curso!
>>> |
```

Aqui, estamos explicitamente dizendo que `nome` deve receber o valor `"João"` e `mensagem` deve receber `"Bem-vindo ao nosso curso!"`. A ordem dos argumentos não importa mais:

```python
>>> saudar(mensagem="Bem-vindo ao nosso curso!", nome="João")
Olá, João! Bem-vindo ao nosso curso!
>>> |
```

Esse código produzirá o mesmo resultado, independentemente da ordem.

### vantagens dos argumentos nomeados

Os argumentos nomeados oferecem várias vantagens, especialmente em funções com muitos parâmetros ou com parâmetros que têm valores padrão.

#### clareza

Quando argumentos nomeados são usados, o código se torna mais legível, pois é claro qual valor está sendo passado para qual parâmetro. Considere a função abaixo:

```python
>>> def criar_usuario(nome, idade, ativo=True, admin=False):
...     print(f"Usuário: {nome}, Idade: {idade}, Ativo: {ativo}, Admin: {admin}")
...
>>> |
```

É possível chamar assim essa função :

```python
>>> criar_usuario("Maria", 28, False, True)
Usuário: Maria, Idade: 28, Ativo: False, Admin: True
>>> |
```

Esse código funciona, mas não é imediatamente óbvio o que cada `True` ou `False` representa. Usando argumentos nomeados, fica muito mais claro:

```python
>>> criar_usuario(nome="Maria", idade=28, ativo=False, admin=True)
Usuário: Maria, Idade: 28, Ativo: False, Admin: True
>>> |
```

#### flexibilidade

Outra vantagem é a flexibilidade. Em funções com muitos parâmetros, pode-se especificar apenas os que deseja alterar, sem se preocupar com a ordem ou ter que passar valores para todos os parâmetros.

Considere a função `criar_usuario` novamente:

```python
>>> criar_usuario(nome="Carlos", idade=30)
Usuário: Carlos, Idade: 30, Ativo: True, Admin: False
>>> |
```

Aqui, `ativo` e `admin` usarão seus valores padrão (`True` e `False`, respectivamente), e apenas `nome` e `idade` foram explicitamente definidos.

### combinando argumentos posicionais e nomeados

É possível combinar argumentos posicionais e nomeados em uma única chamada de função, mas existem algumas regras a seguir:

1. **argumentos posicionais devem vir antes dos argumentos nomeados**;
1. **argumentos nomeados podem vir em qualquer ordem, desde que não sejam duplicados com argumentos posicionais**;

Exemplo:

```python
>>> criar_usuario("Ana", 22, admin=True)
Usuário: Ana, Idade: 22, Ativo: True, Admin: True
>>> |
```

Neste exemplo, `nome` e `idade` são passados como argumentos posicionais, enquanto `admin` é um argumento nomeado.

### erros comuns e considerações

- **duplicação de argumentos** : se tentar passar o mesmo argumento tanto posicionalmente quanto nomeado, o python levantará um erro:

```python
>>> criar_usuario("Pedro", 35, nome="João")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: criar_usuario() got multiple values for argument 'nome'
>>> |
```

- **argumentos faltando**: se esquecer de passar um argumento obrigatório (sem valor padrão), o python levantará um erro indicando que o argumento está faltando:

```python
>>> criar_usuario(idade=25, admin=True)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: criar_usuario() missing 1 required positional argument: 'nome'
>>> |
```

### funções com muitos parâmetros e argumentos nomeados

Funções que recebem muitos parâmetros se beneficiam particularmente dos argumentos nomeados. Em APIs ou bibliotecas complexas, essa prática é comum para garantir que o código do usuário final seja mais legível e menos propenso a erros.

Imagine uma função que configura uma conexão de banco de dados:

```python
>>> def configurar_conexao(host, porta, usuario, senha, usar_ssl=False, timeout=30):
...     print(f"Conectando ao banco em {host}:{porta} como {usuario} com SSL={usar_ssl} e timeout={timeout}")
...
>>>
```

Aqui, o uso de argumentos nomeados facilita muito a chamada dessa função:

```python
>>> configurar_conexao(
...     host="localhost",
...     porta=5432,
...     usuario="admin",
...     senha="senha123",
...     usar_ssl=True,
...     timeout=10
... )
Conectando ao banco em localhost:5432 como admin com SSL=True e timeout=10
>>> |
```

## exercícios valor padrão e argumentos nomeados

<details>
<summary>Lista de Exercícios</summary>

1. Exercícios Básicos
    1. Crie uma função `saudar` que receba um nome e uma mensagem de saudação com valor padrão `"Olá!"`. Chame a função passando apenas o nome.
    1. Modifique a função `saudar` do exercício anterior para permitir que o usuário passe uma mensagem personalizada além do nome.
    1. Crie uma função `exibir_informacoes` que receba o nome de uma pessoa, idade (com valor padrão de 25 anos) e cidade (com valor padrão `"Porto Alegre"`). Chame a função sem passar a cidade.
    1. Crie uma função `calcular_desconto` que receba o valor de um produto e um desconto com valor padrão de 10%. Calcule o valor final do produto após aplicar o desconto.
    1. Crie uma função `mostrar_mensagem` que receba uma mensagem e um número de repetições (com valor padrão de 1). A função deve imprimir a mensagem o número de vezes especificado.
1. Exercícios Intermediários
    1. Crie uma função `criar_usuario` que receba `nome`, `idade` (valor padrão 18) e `ativo` (valor padrão True). A função deve imprimir os detalhes do usuário.
    1. Crie uma função `imprimir_lista` que receba uma lista e um separador (com valor padrão de vírgula). A função deve imprimir os elementos da lista separados pelo separador especificado.
    1. Crie uma função `conectar` que receba `host`, `porta` (com valor padrão 8080) e `usar_ssl` (com valor padrão False). A função deve imprimir as informações da conexão.
    1. Crie uma função `calcular_imposto` que receba o valor de um produto e uma taxa de imposto (com valor padrão de 5%). A função deve retornar o valor final do produto com o imposto aplicado.
    1. Crie uma função `formar_grupo` que receba uma lista de nomes e um número máximo de membros (com valor padrão de 5). A função deve dividir a lista de nomes em grupos do tamanho especificado.
    1. Crie uma função `calcular_media` que receba uma lista de notas e um parâmetro `peso` com valor padrão de 1. A função deve calcular e retornar a média ponderada das notas.
    1. Crie uma função `definir_cor` que receba um parâmetro `cor` com valor padrão `"azul"`. A função deve imprimir a cor definida.
    1. Crie uma função `enviar_email` que receba `destinatario`, `assunto` (com valor padrão `"Sem Assunto"`) e `corpo` (com valor padrão `"Sem Corpo"`). A função deve simular o envio de um e-mail.
    1. Crie uma função `calcular_preco` que receba o preço de um produto e uma taxa de desconto (com valor padrão de 10%). A função deve retornar o preço final após o desconto.
    1. Crie uma função `configurar_sistema` que receba `idioma` (com valor padrão `"Português"`) e `tema` (com valor padrão `"Claro"`). A função deve imprimir as configurações do sistema.
1. Exercícios Avançados
    1. Crie uma função `gerar_senha` que receba um comprimento e um caractere opcional (com valor padrão `None`). Se o caractere não for `None`, a senha gerada deve conter apenas esse caractere repetido o número de vezes especificado pelo comprimento.
    1. Crie uma função `formatar_texto` que receba um texto e um tamanho máximo (com valor padrão de 80 caracteres). A função deve truncar o texto se ele ultrapassar o tamanho máximo.
    1. Crie uma função `encontrar_maior` que receba uma lista de números e um valor mínimo opcional (com valor padrão `None`). A função deve retornar o maior número na lista maior que o valor mínimo, se especificado.
    1. Crie uma função `ordenar_lista` que receba uma lista e um parâmetro `reversa` com valor padrão `False`. A função deve ordenar a lista de forma crescente ou decrescente, dependendo do valor de `reversa`.
    1. Crie uma função `converter_temperatura` que receba uma temperatura e uma escala (`Celsius` ou `Fahrenheit`) com valor padrão `"Celsius"`. A função deve converter a temperatura para a outra escala.
    1. Crie uma função `contar_palavras` que receba um texto e um parâmetro `ignorar_case` (com valor padrão `True`). A função deve retornar a contagem de palavras, ignorando a diferença entre maiúsculas e minúsculas, se `ignorar_case` for True.
    1. Crie uma função `calcular_potencia` que receba uma base e um expoente (com valor padrão 2). A função deve retornar o resultado da base elevada ao expoente.
    1. Crie uma função `dividir_numero` que receba um número e um divisor (com valor padrão 1). A função deve retornar o quociente da divisão, mas levantar uma exceção se o divisor for 0.
    1. Crie uma função `criar_dicionario` que receba uma lista de chaves e um valor padrão (com valor padrão `None`). A função deve retornar um dicionário onde todas as chaves possuem o valor padrão.
    1. Crie uma função `substituir_vogais` que receba um texto e uma vogal (com valor padrão `"a"`). A função deve substituir todas as vogais no texto pela vogal especificada.
1. Exercícios de Desafios
    1. Crie uma função `soma_acumulada` que receba uma lista de números e um valor inicial (com valor padrão 0). A função deve retornar a soma acumulada de todos os números na lista, iniciando pelo valor inicial.
    1. Crie uma função `filtrar_palavras` que receba uma lista de palavras e um comprimento mínimo (com valor padrão 3). A função deve retornar uma nova lista contendo apenas as palavras com o comprimento igual ou maior que o mínimo.
    1. Crie uma função `calcular_fatorial` que receba um número e um parâmetro `mostrar_passos` (com valor padrão `False`). A função deve calcular e retornar o fatorial do número, mostrando os passos se `mostrar_passos` for True.
    1. Crie uma função `multiplicar_lista` que receba uma lista de números e um fator de multiplicação (com valor padrão 2). A função deve retornar uma nova lista com todos os elementos multiplicados pelo fator.
    1. Crie uma função `atualizar_configuracoes` que receba um dicionário de configurações e atualize valores usando argumentos nomeados com valores padrão. A função deve retornar o dicionário atualizado.

</details>

## empacotamento e desempacotamento nas funções

No Python, o empacotamento e desempacotamento são técnicas essenciais para manipular argumentos em funções. Essas técnicas permitem criar funções flexíveis que podem aceitar um número variável de argumentos, facilitando a escrita de código reutilizável e dinâmico.

### `*args`

No Python, `*args` é utilizado em funções para permitir que elas recebam uma quantidade variável de argumentos posicionais. Isso é muito útil quando não se sabe de antemão quantos argumentos serão passados para a função.

#### empacotamento com `*args`

Quando se usa `*args` na definição de uma função, todos os argumentos posicionais passados para a função são empacotados em uma tupla. Essa tupla é então passada para a função, e pode-se acessá-la e iterar sobre seus elementos como faria com qualquer outra tupla.

- exemplo 1 : empacotando argumentos com `*args`

```python
>>> def soma_todos(*args):
...     total = 0
...     for numero in args:
...         total += numero
...     return total
...
>>> # Chamando a função com diferentes números de argumentos
>>> resultado1 = soma_todos(1, 2, 3)
>>> resultado2 = soma_todos(4, 5, 6, 7, 8)
>>>
>>> print(resultado1)
6
>>> print(resultado2)
30
>>> |
```

1. **definição da função :** na função `soma_todos`, `*args` captura todos os argumentos posicionais em uma tupla chamada `args`;
1. **iteração :** a função então itera sobre a tupla `args` e soma cada valor;
1. **chamadas da função :** ao chamar `soma_todos(1, 2, 3)`, `args` é empacotado como `(1, 2, 3)`. para `soma_todos(4, 5, 6, 7, 8)`, `args` é empacotado como `(4, 5, 6, 7, 8)`;

#### desempacotamento com `*args`

O desempacotamento com `*args` permite que se passe uma coleção (como uma lista ou tupla) como argumentos para uma função. Os elementos da coleção são "desempacotados" e passados como argumentos individuais.

- exemplo 2 : desempacotando argumentos com `*args`

```python
>>> def mostra_argumentos(*args):
...     for i, valor in enumerate(args):
...         print(f"Argumento {i+1}: {valor}")
...
>>> # criando uma lista de argumentos
>>> valores = [10, 20, 30, 40]
>>>
>>> # desempacotando a lista e passando seus elementos como argumentos
>>> mostra_argumentos(*valores)
Argumento 1: 10
Argumento 2: 20
Argumento 3: 30
Argumento 4: 40
>>> |
```

1. **desempacotamento :** na chamada `mostra_argumentos(*valores)`, a lista `valores` é desempacotada. Isso é equivalente a chamar `mostra_argumentos(10, 20, 30, 40)`;
1. **iteração :** a função `mostra_argumentos` itera sobre os valores passados e os exibe com seu índice correspondente;

#### empacotamento e desempacotamento juntos

É possível combinar empacotamento e desempacotamento em funções, o que pode ser útil para repassar argumentos de uma função para outra.

- exemplo 3 : combinando empacotamento e desempacotamento

```python
>>> def soma_todos(*args):
...     total = sum(args)
...     return total
...
>>> def multiplica(valor_1, valor_2):
...     return valor_1 * valor_2
...
>>> def soma_e_multiplica(mult, *args):
...     soma = soma_todos(*args)  # desempacota args e repassa para soma_todos
...     resultado = multiplica(mult, soma)
...     return resultado
...
>>> # chamada da função com múltiplos argumentos
>>> resultado = soma_e_multiplica(2, 1, 2, 3, 4)
>>>
>>> print(resultado)
20
>>> |
```

1. **função `soma_todos` :** recebe um número variável de argumentos, empacotados em `args`;
1. **função `soma_e_multiplica` :** recebe um argumento `mult` e um número variável de argumentos posicionais. Esses argumentos são desempacotados e repassados para a função `soma_todos`;
1. **função `multiplica` :** recebe dois valores (o mult e o resultado da soma) e os retorna multiplicados;
1. **resultado :** a soma dos valores (`1 + 2 + 3 + 4 = 10`) é multiplicada por `mult` (2), resultando em `20`;

### `**kwargs`

No Python, `**kwargs` (abreviação de "keyword arguments") é utilizado em funções para permitir que elas recebam uma quantidade variável de argumentos nomeados. Esses argumentos são passados para a função como um dicionário, onde as chaves são os nomes dos argumentos e os valores são os respectivos valores passados.

#### empacotamento com `**kwargs`

Quando se usa `**kwargs` na definição de uma função, todos os argumentos nomeados (ou seja, passados como `chave=valor`) são empacotados em um dicionário. Este dicionário pode ser utilizado dentro da função para acessar e manipular esses valores.

- exemplo 1 : empacotando argumentos nomeados com `**kwargs`

```python
>>> def exibir_informacoes(**kwargs):
...     for chave, valor in kwargs.items():
...         print(f"{chave}: {valor}")
...
>>> # Chamando a função com diferentes argumentos nomeados
>>> exibir_informacoes(nome="Alice", idade=30, profissao="Engenheira")
nome: Alice
idade: 30
profissao: Engenheira
>>>
>>> exibir_informacoes(marca="Toyota", modelo="Corolla", ano=2020)
marca: Toyota
modelo: Corolla
ano: 2020
>>> |
```

1. **definição da função :** na função `exibir_informacoes`, `**kwargs` captura todos os argumentos nomeados passados para a função e os empacota em um dicionário chamado `kwargs`;
1. **iteração :** a função itera sobre os pares `chave, valor` do dicionário `kwargs` usando o método `.items()`;
1. **chamadas da função :** cada chamada da função passa um conjunto diferente de argumentos nomeados, e eles são todos empacotados no dicionário `kwargs`;

#### desempacotamento com `**kwargs`

O desempacotamento com `**kwargs` permite que se passe um dicionário de argumentos nomeados para uma função. O dicionário é "desempacotado" e seus pares `chave=valor` são passados como argumentos nomeados.

- exemplo 2 : desempacotando argumentos nomeados com `**kwargs`

```python
>>> def mostrar_caracteristicas(**kwargs):
...     for chave, valor in kwargs.items():
...         print(f"{chave.capitalize()}: {valor}")
...
>>> # Criando um dicionário de argumentos
>>> dados_pessoais = {
...     "nome": "Carlos",
...     "idade": 28,
...     "cidade": "Porto Alegre"
... }
>>>
>>> # desempacotando o dicionário e passando seus pares como argumentos nomeados
>>> mostrar_caracteristicas(**dados_pessoais)
Nome: Carlos
Idade: 28
Cidade: Porto Alegre
>>> |
```

1. **desempacotamento :** na chamada `mostrar_caracteristicas(**dados_pessoais)`, o dicionário `dados_pessoais` é desempacotado. isso é equivalente a chamar `mostrar_caracteristicas(nome="Carlos", idade=28, cidade="Porto Alegre")`;
2. **iteração :** a função `mostrar_caracteristicas` então itera sobre os pares `chave=valor` e os exibe;

#### empacotamento e desempacotamento juntos

É possível combinar empacotamento e desempacotamento em funções para repassar um dicionário de argumentos nomeados de uma função para outra.

- exemplo 3 : combinando empacotamento e desempacotamento

```python
>>> def registrar_usuario(**kwargs):
...     print("Registrando usuário com as seguintes informações:")
...     for chave, valor in kwargs.items():
...         print(f"{chave.capitalize()}: {valor}")
...
>>>def criar_usuario_padrao():
...     info_padrao = {
...         "nome": "Usuário Padrão",
...         "email": "padrao@example.com",
...         "nivel": "iniciante"
...     }
...     registrar_usuario(**info_padrao)
...
>>>
>>> # chamada da função para criar um usuário padrão
>>> criar_usuario_padrao()
Registrando usuário com as seguintes informações:
Nome: Usuário Padrão
Email: padrao@example.com
Nivel: iniciante
>>> |
```

1. **função `registrar_usuario` :** recebe os argumentos nomeados empacotados em `**kwargs`;
1. **função `criar_usuario_padrao` :** define um dicionário `info_padrao` com as informações padrão do usuário;
1. **desempacotamento :** o dicionário `info_padrao` é desempacotado e repassado para `registrar_usuario` usando `**info_padrao`;

#### modificando `**kwargs` antes de repassar

É também possível modificar o dicionário `kwargs` antes de repassá-lo para outra função, o que pode ser útil em situações onde se deseja adicionar, remover ou alterar argumentos.

- exemplo 4 : modificando `**kwargs`

```python
>>> def registrar_usuario(**kwargs):
...     print("Registrando usuário com as seguintes informações:")
...     for chave, valor in kwargs.items():
...         print(f"{chave.capitalize()}: {valor}")
...
>>> def criar_usuario_personalizado(**kwargs):
...     # adicionando um campo de registro
...     kwargs['registro_completo'] = True
...     registrar_usuario(**kwargs)
...
>>>
>>> # chamada da função para criar um usuário personalizado
>>> criar_usuario_personalizado(nome="Maria", email="maria@example.com", nivel="avançado")
Registrando usuário com as seguintes informações:
Nome: Maria
Email: maria@example.com
Nivel: Avançado
Registro_completo: True
>>> |
```

1. **modificação de `kwargs` :** na função `criar_usuario_personalizado`, o dicionário `kwargs` é modificado ao adicionar um novo par `chave=valor`;
2. **repassando `kwargs` :** o dicionário modificado é desempacotado e passado para a função `registrar_usuario`;

## exercícios `args` `kwargs`

<details>
<summary>Lista de Exercícios</summary>

1. Exercícios com `*args`
    1. **Função Soma:** Crie uma função que receba um número variável de argumentos e retorne a soma de todos eles.
    1. **Multiplicação de Números:** Crie uma função que receba vários números como argumentos e retorne o produto deles.
    1. **Contagem de Argumentos:** Crie uma função que receba um número variável de argumentos e retorne a quantidade de argumentos recebidos.
    1. **Listagem de Argumentos:** Crie uma função que receba vários argumentos e os imprima, um por linha.
    1. **Concatenação de Strings:** Crie uma função que receba várias strings como argumentos e as concatene em uma única string.
    1. **Média de Números:** Crie uma função que receba vários números e retorne a média aritmética.
    1. **Maior Número:** Crie uma função que receba vários números e retorne o maior número entre eles.
    1. **Menor Número:** Crie uma função que receba vários números e retorne o menor número entre eles.
    1. **Primeiro Argumento:** Crie uma função que receba vários argumentos e retorne o primeiro argumento recebido.
    1. **Último Argumento:** Crie uma função que receba vários argumentos e retorne o último argumento recebido.
    1. **Soma de Argumentos Positivos:** Crie uma função que receba vários números e retorne a soma dos números positivos.
    1. **Argumentos Ordenados:** Crie uma função que receba vários argumentos numéricos e retorne uma lista com os argumentos ordenados.
    1. **Contagem de Strings:** Crie uma função que receba vários argumentos e retorne a quantidade de argumentos que são strings.
    1. **Função Potência:** Crie uma função que receba um número base e vários expoentes como argumentos, retornando uma lista com os resultados das potências.
    1. **Combinação de Listas:** Crie uma função que receba várias listas como argumentos e retorne uma única lista contendo todos os elementos das listas recebidas.
    1. **Repetição de String:** Crie uma função que receba uma string e um número variável de números como argumentos, e retorne a string repetida de acordo com cada número.
    1. **Imprimir Índice e Argumento:** Crie uma função que receba vários argumentos e imprima o índice e o valor de cada argumento.
    1. **Argumentos Pares:** Crie uma função que receba vários números e retorne uma lista contendo apenas os números pares.
    1. **Somar Listas:** Crie uma função que receba várias listas de números como argumentos e retorne a soma de todos os números em todas as listas.
    1. **Concatenar com Separador:** Crie uma função que receba uma string separadora e um número variável de strings como argumentos, e retorne uma única string onde as strings são concatenadas utilizando o separador.
1. Exercícios com `**kwargs`
    1. **Função de Boas-vindas:** Crie uma função que receba `**kwargs` com as chaves `nome` e `idade`, e imprima uma mensagem de boas-vindas utilizando esses valores.
    1. **Informações de Produto:** Crie uma função que receba `**kwargs` com chaves como `nome`, `preço`, `categoria` e `disponibilidade`, e imprima uma descrição formatada do produto.
    1. **Contagem de Chaves:** Crie uma função que receba `**kwargs` e retorne a quantidade de chaves no dicionário `kwargs`.
    1. **Imprimir Valores:** Crie uma função que receba `**kwargs` e imprima apenas os valores dos argumentos nomeados recebidos.
    1. **Verificar Chave:** Crie uma função que receba `**kwargs` e uma chave específica, retornando se a chave está presente em `kwargs`.
    1. **Adicionar Chave:** Crie uma função que receba `**kwargs` e adicione uma chave `status` com o valor `ativo`, retornando o dicionário atualizado.
    1. **Combinar Dicionários:** Crie uma função que receba dois dicionários como `**kwargs` e combine-os em um único dicionário.
    1. **Filtrar Chaves:** Crie uma função que receba `**kwargs` e retorne um dicionário contendo apenas as chaves que começam com a letra "a".
    1. **Imprimir Chaves e Valores:** Crie uma função que receba `**kwargs` e imprima cada chave e valor, um por linha.
    1. **Chaves como Lista:** Crie uma função que receba `**kwargs` e retorne uma lista contendo todas as chaves do dicionário `kwargs`.
    1. **Concatenar Strings:** Crie uma função que receba `**kwargs` com várias strings e retorne uma única string concatenando todas elas.
    1. **Multiplicar Valores Numéricos:** Crie uma função que receba `**kwargs` e retorne o produto de todos os valores numéricos (inteiros ou floats) contidos em `kwargs`.
    1. **Filtrar Números:** Crie uma função que receba `**kwargs` e retorne um dicionário contendo apenas os pares `chave:valor` onde o valor seja um número.
    1. **Combinar com Defaults:** Crie uma função que receba `**kwargs` e combine os valores recebidos com um dicionário padrão de valores, retornando o dicionário final.
    1. **Ordenar por Valor:** Crie uma função que receba `**kwargs` e retorne um dicionário onde os pares `chave:valor` estejam ordenados pelo valor.
    1. **Verificar Tipos:** Crie uma função que receba `**kwargs` e retorne um dicionário onde as chaves são os nomes dos argumentos e os valores são os tipos dos argumentos.
    1. **Soma de Valores:** Crie uma função que receba `**kwargs` com valores numéricos e retorne a soma desses valores.
    1. **Alterar Valor:** Crie uma função que receba `**kwargs` e uma chave específica, alterando o valor dessa chave para um novo valor, e retornando o dicionário atualizado.
    1. **Remover Chave:** Crie uma função que receba `**kwargs` e uma chave específica, removendo essa chave do dicionário `kwargs` e retornando o dicionário final.
    1. **Contagem de Tipos:** Crie uma função que receba `**kwargs` e retorne um dicionário onde as chaves são os tipos dos valores em `kwargs` e os valores são a quantidade de vezes que cada tipo apareceu.

</details>

## exemplos

### funções com parâmetros posicionais

**exemplo 1 : soma de dois números**

```python
>>> def soma(a, b):
...     resultado = a + b
...     return resultado
...
>>>
>>> # chamando a função
>>> print(soma(10, 20))
30
>>> |
```

**explicação :**
- **declaração da função :** `def soma(a, b):` define uma função chamada `soma` que aceita dois parâmetros posicionais, `a` e `b`;
- **parâmetros posicionais :** quando a função `soma` é chamada, os valores são passados na ordem definida. No exemplo, `a` recebe `10` e `b` recebe `20`;
- **cálculo e retorno :** dentro da função, somamos `a` e `b` e armazenamos o resultado na variável `resultado`, que é então retornada;
- **chamada da função :** ao chamar `soma(10, 20)`, a função retorna `30`;

**exemplo 2 : calcular a área de um retângulo**

```python
>>> def calcular_area_comprimento(comprimento, largura):
...     area = comprimento * largura
...     return area
...
>>>
>>> # chamando a função
>>> print(calcular_area_comprimento(5, 3))  # Saída: 15
15
>>> |
```

**explicação :**
- **declaração da função :** `def calcular_area_comprimento(comprimento, largura):` define uma função que calcula a área de um retângulo;
- **parâmetros posicionais :** a função recebe dois parâmetros: `comprimento` e `largura`. No exemplo, `comprimento` recebe `5` e `largura` recebe `3`;
- **cálculo e retorno :** multiplicamos `comprimento` por `largura` para obter a área, que é então retornada;
- **chamada da função :** ao chamar `calcular_area_comprimento(5, 3)`, a função retorna `15`;

### funções com parâmetros posicionais e parâmetros com valores padrão

**exemplo 1 : saudação personalizada**

```python
>>> def saudacao(nome, saudacao="Olá"):
...     return f"{saudacao}, {nome}!"
...
>>>
>>> # chamando a função com o valor padrão
>>> print(saudacao("João"))
Olá, João!
>>>
>>> # chamando a função com um valor diferente do padrão
>>> print(saudacao("Maria", "Bem-vinda"))
Bem-vinda, Maria!
>>> |
```

**explicação :**
- **declaração da função :** `def saudacao(nome, saudacao="olá"):` define uma função que faz uma saudação. O parâmetro `nome` é posicional, enquanto `saudacao` tem um valor padrão, `olá`;
- **parâmetro com valor padrão :** se o argumento para `saudacao` não for fornecido, a função usará "olá";
- **chamada da função (valor padrão) :** ao chamar `saudacao("joão")`, a função usa o valor padrão `olá` e retorna `"olá, joão!"`;
- **chamada da função (novo valor) :** ao chamar `saudacao("maria", "bem-vinda")`, o valor padrão é substituído por `"bem-vinda"`, retornando `"bem-vinda, maria!"`;

**exemplo 2 : cálculo do preço com desconto**

```python
>>> def calcular_preco_com_desconto(preco, desconto=10):
...     preco_final = preco - (preco * desconto / 100)
...     return preco_final
...
>>>
>>> # chamando a função com o valor padrão
>>> print(calcular_preco_com_desconto(100))
90.0
>>>
>>> # chamando a função com um valor diferente do padrão
>>> print(calcular_preco_com_desconto(100, 20))
80.0
>>> |
```

**explicação :**
- **declaração da função :** `def calcular_preco_com_desconto(preco, desconto=10):` define uma função que calcula o preço final após aplicar um desconto. `preco` é um parâmetro posicional e `desconto` tem um valor padrão de 10%;
- **parâmetro com valor padrão :** se o desconto não for especificado, a função aplicará um desconto de 10%;
- **chamada da função (valor padrão) :** ao chamar `calcular_preco_com_desconto(100)`, a função usa o desconto padrão de 10%, retornando `90.0`;
- **chamada da função (novo valor) :** ao chamar `calcular_preco_com_desconto(100, 20)`, o desconto é de 20%, retornando `80.0`;

### funções com parâmetros posicionais, parâmetros com valores padrão e `*args`

**exemplo 1 : calculando o total de vendas**

```python
>>> def calcular_vendas(base_vendas, bonus=0, *extras):
...     total = base_vendas + bonus
...     for extra in extras:
...         total += extra
...     return total
...
>>>
>>> # chamando a função sem extras
>>> print(calcular_vendas(1000, 200))
1200
>>>
>>> # chamando a função com extras
>>> print(calcular_vendas(1000, 200, 50, 30, 20))
1300
>>> |
```

**explicação :**
- **declaração da função :** `def calcular_vendas(base_vendas, bonus=0, *extras):` define uma função que calcula o total de vendas. O parâmetro `base_vendas` é posicional, `bonus` tem um valor padrão de `0`, e `*extras` captura argumentos adicionais;
- **parâmetros posicionais e valor padrão :** `base_vendas` é obrigatório e `bonus` é opcional (com valor padrão);
- **uso de `*args`:** `*extras` permite que a função aceite um número variável de argumentos adicionais. Eles são armazenados como uma tupla e somados ao `total`;
- **chamada da função (sem extras) :** `calcular_vendas(1000, 200)` retorna `1200`, somando `base_vendas` e `bonus`;
- **chamada da função (com extras) :** `calcular_vendas(1000, 200, 50, 30, 20)` retorna `1300`, somando `base_vendas`, `bonus` e os valores em `*extras`;

**exemplo 2 : criando uma mensagem com várias palavras**

```python
>>> def criar_mensagem(inicio, separador=" ", *palavras):
...     mensagem = inicio
...     for palavra in palavras:
...         mensagem += separador + palavra
...     return mensagem
...
>>>
>>> # chamando a função com um separador padrão
>>> print(criar_mensagem("Olá"))
Olá
>>>
>>> # chamando a função com várias palavras e um separador personalizado
>>> print(criar_mensagem("Olá", "-", "mundo", "como", "vai", "você"))
Olá-mundo-como-vai-você
>>> |
```

**explicação :**
- **declaração da função :** `def criar_mensagem(inicio, separador=" ", *palavras):` define uma função que cria uma mensagem concatenando várias palavras. `inicio` é um parâmetro posicional, `separador` tem um valor padrão de `" "`, e `*palavras` captura argumentos adicionais;
- **parâmetros posicionais e valor padrão :** `inicio` é obrigatório e `separador` é opcional;
- **uso de `*args` :** `*palavras` permite adicionar um número variável de palavras que serão concatenadas usando o `separador`;
- **chamada da função (sem `*args`) :** `criar_mensagem("olá")` retorna `"olá"`, já que não há palavras adicionais;
- **chamada da função (com `*args`) :** `criar_mensagem("olá", "-", "mundo", "como", "vai", "você")` retorna `"olá-mundo-como-vai-você"`, concatenando as palavras com o separador `"-"`;

### funções com parâmetros posicionais, parâmetros com valores padrão, `*args` e `**kwargs`

**exemplo 1 : configurando um pedido de comida**

```python
>>> def configurar_pedido(prato_principal, bebida="água", *acompanhamentos, **detalhes):
...     pedido = f"Prato principal: {prato_principal}, Bebida: {bebida}"
...     if acompanhamentos:
...         pedido += ", Acompanhamentos: " + ", ".join(acompanhamentos)
...     if detalhes:
...         pedido += ", Detalhes: " + ", ".join([f"{k}={v}" for k, v in detalhes.items()])
...     return pedido
...
>>>
>>> # chamando a função sem detalhes adicionais
>>> print(configurar_pedido("bife", "suco", "arroz", "batata"))
Prato principal: bife, Bebida: suco, Acompanhamentos: arroz, batata
>>>
>>> # chamando a função com detalhes adicionais
>>> print(configurar_pedido("bife", "suco", "arroz", "batata", sem_sal=True, ao_ponto="mal"))
Prato principal: bife, Bebida: suco, Acompanhamentos: arroz, batata, Detalhes: sem_sal=True, ao_ponto=mal
>>> |
```

**explicação :**
- **declaração da função :** `def configurar_pedido(prato_principal, bebida="água", *acompanhamentos, **detalhes):` define uma função para configurar um pedido de comida;
- **parâmetros posicionais e valor padrão :** `prato_principal` é obrigatório e `bebida` é opcional;
- **uso de `*args` e `**kwargs` :** `*acompanhamentos` captura acompanhamentos adicionais, e `**detalhes` captura detalhes adicionais como pares chave-valor;
- **chamada da função (sem `**kwargs`) :** `configurar_pedido("bife", "suco", "arroz", "batata")` retorna uma string descrevendo o prato principal, a bebida e os acompanhamentos;
- **chamada da função (com `**kwargs`) :** `configurar_pedido("bife", "suco", "arroz", "batata", sem_sal=true, ao_ponto="mal")` inclui detalhes adicionais no pedido;

**exemplo 2 : criando uma conta de usuário**

```python
>>> def criar_usuario(nome, sobrenome, idade=18, *interesses, **detalhes_adicionais):
...     usuario = f"Nome: {nome} {sobrenome}, Idade: {idade}"
...     if interesses:
...         usuario += ", Interesses: " + ", ".join(interesses)
...     if detalhes_adicionais:
...         usuario += ", Detalhes Adicionais: " + ", ".join([f"{k}={v}" for k, v in detalhes_adicionais.items()])
...     return usuario
...
>>>
>>> # chamando a função sem detalhes adicionais
>>> print(criar_usuario("João", "Silva", 25, "programação", "leitura"))
Nome: João Silva, Idade: 25, Interesses: programação, leitura
>>>
>>> # chamando a função com detalhes adicionais
>>> print(criar_usuario("João", "Silva", 25, "programação", "leitura", cidade="Porto Alegre", profissão="Engenheiro"))
Nome: João Silva, Idade: 25, Interesses: programação, leitura, Detalhes Adicionais: cidade=Porto Alegre, profissão=Engenheiro
>>> |
```

**explicação :**
- **declaração da função :** `def criar_usuario(nome, sobrenome, idade=18, *interesses, **detalhes_adicionais):` define uma função para criar uma conta de usuário;
- **parâmetros posicionais e valor padrão :** `nome` e `sobrenome` são obrigatórios, `idade` é opcional;
- **uso de `*args` e `**kwargs` :** `*interesses` captura uma lista de interesses do usuário, e `**detalhes_adicionais` captura informações adicionais como pares chave-valor;
- **chamada da função (sem `**kwargs`) :** `criar_usuario("joão", "silva", 25, "programação", "leitura")` retorna uma string descrevendo o nome, a idade e os interesses do usuário;
- **chamada da função (com `**kwargs`) :** `criar_usuario("joão", "silva", 25, "programação", "leitura", cidade="porto alegre", profissão="engenheiro")` inclui detalhes adicionais na descrição;
Índice

1. [print()](#print)
1. [exercícios print()](#exercícios-print)
1. [len()](#len)
1. [sum()](#sum)
1. [pow()](#pow)
1. [max() e min()](#max-e-min)
1. [abs()](#abs)
1. [round()](#round)
1. [type()](#type)
1. [isinstance()](#isinstance)
1. [ord() e chr()](#ord-e-chr)
1. [help()](#help)
1. [exercícios()](#exercícios)
1. [input()](#input)
1. [range()](#range)
1. [exercícios range](#exercícios-range)
1. [enumerate()](#enumerate)
1. [exercícios enumerate](#exercícios-enumerate)
1. [zip()](#zip)
1. [exercícios zip](#exercícios-zip)

# funções built-in

As funções built-in do Python são funções que já vêm integradas na linguagem, ou seja, estão disponíveis para uso imediato sem a necessidade de importação de módulos ou bibliotecas adicionais. Essas funções são projetadas para realizar tarefas comuns, como manipulação de strings, números, listas, entre outros, de forma simples e eficiente.

## `print()`

A função `print()` no Python é uma das funções mais fundamentais e amplamente utilizadas. Ela serve para exibir informações na tela, o que é útil tanto para o desenvolvimento e depuração de código quanto para fornecer feedback ao usuário.

A função `print()` exibe os valores que você passa como argumentos, convertendo-os em strings (se necessário) e mostrando-os na tela.

Veja um exemplo básico :

```python
>>> print("Olá, mundo!")
Olá, mundo!
```

Além disso, a função `print()` também possui diversas outras funcionalidades, além de exibir strings e conteúdo de variáveis.

### outras funcionalidades

1. **exibir múltiplos valores** : é possível passar vários argumentos para `print()`, e eles serão exibidos em sequência, separados por um espaço por padrão. os argumentos podem ser valores literais ou variáveis contendo valores.
    ```python
    >>> print("Python", "é", "nota", 10, "!")
    Python é nota 10 !
    >>>
    >>> nota = 10
    >>> linguagem = "Python"
    >>>
    >>> print(linguagem, "é", 'nota', nota, "!")
    Python é nota 10 !
    ```

1. **separador personalizado** : sempre que vários argumentos são passados para o `print()` (separados por vírgulas), por padrão, a função adiciona um espaço em branco entre os argumentos. contudo, é possível alterar esse comportamento especificando o argumento `sep` logo antes de fechar o parênteses. o valor que for passado ao `sep` deverá ser uma `string`.
    ```python
    >>> print("Python", "é", "incrível!", sep="-")
    Python-é-incrível!
    >>>
    >>> print("Python", "é", "incrível!", sep="_")
    Python_é_incrível!
    >>>
    >>> print("Python", "é", "incrível!", sep=" - ")
    Python - é - incrível!
    ```

1. **fim da linha personalizado** : sempre que se usa o `print()`, por padrão ele adiciona uma nova linha (`\n`) após exibir os valores. esse comportamento pode ser alterado usando o argumento `end` logo antes de fechar os parênteses. o valor que for passado ao `end` deverá ser uma `string`.
    ```python
    >>> print("Olá,", end=" ")
    >>> print("mundo!")
    Olá, mundo!
    >>>
    >>> nome = 'Arnold Schwarzenegger'
    >>> i = 0  # abreviação de índice
    >>> while i < len(nome):
    ...     print(nome[i], end='+-+')
    ...     i = i + 1
    ...
    A+-+r+-+n+-+o+-+l+-+d+-+ +-+S+-+c+-+h+-+w+-+a+-+r+-+z+-+e+-+n+-+e+-+g+-+g+-+e+-+r+-+
    ```
    Repare que, no exemplo acima, o `print()` dentro do loop `while` adiciona um `+-+` sempre que é executado, mesmo no último caractere do nome.

1. **combinando** : tanto o `sep` quanto o `end` podem ser usados juntos.
    ```python
    >>> linguagem = 'Python'
    >>> print(linguagem, "é", "incrível", sep="-", end="!")
    Python-é-incrível!>>> |
    ```
    No exemplo acima, é usado o `sep` para adicionar um traço entre cada argumento e é usado o `end` para adicionar o sinal de exclamação ao final da frase. Por causa desse comportamento do `end`, o prompt de entrada do Python fica na mesma linha.

### tudo para string

Qualquer objeto passado para `print()` é convertido em uma string usando a função `str()`. Isso significa que mesmo se você passar um número, uma lista, ou outro tipo de objeto, ele será exibido como uma string correspondente.

```python
>>> numeros = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> valor = 42
>>>
>>> print(valor, numeros)
42 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> |
```

### exercícios print()

<details>
<summary>Lista de Exercícios</summary>

1. exercícios usando o argumento `sep`
    1. Crie três variáveis inteiras e exiba-as usando `print()` com `sep='-'` entre os valores.
    1. Crie uma lista de números inteiros e exiba seus elementos separados por espaços usando `print()` e `sep=' '`.
    1. Crie três variáveis de tipo `float` e exiba-as usando `print()` com `sep=' | '`.
    1. Crie uma lista de strings e exiba os elementos separados por vírgulas usando `print()` e `sep=', '`.
    1. Crie quatro variáveis booleanas e exiba-as usando `print()` com `sep=' & '`.
    1. Crie uma lista de números inteiros e use um loop `while` para exibir os elementos separados por ponto e vírgula (`;`) usando `print()` e `sep=';'`.
    1. Crie três variáveis do tipo `str` e exiba-as usando `print()` com `sep='-'` somente se a primeira variável for igual à segunda.
    1. Crie uma lista de números `float` e exiba os elementos separados por um asterisco (`*`) usando `print()` e `sep='*'`.
    1. Crie uma lista de variáveis booleanas e exiba os elementos separados por dois pontos (`:`) usando `print()` e `sep=':'`.
    1. Crie quatro variáveis do tipo `int`, `float`, `bool` e `str`, e exiba-as usando `print()` com `sep=' -> '`.
1. Exercícios usando o argumento `end`
    1. Crie três variáveis inteiras e exiba-as em uma linha usando `print()` com `end=' '`.
    1. Crie uma lista de strings e exiba cada elemento em uma linha separada, mas sem quebrar a linha ao final, usando `print()` com `end=''`.
    1. Crie duas variáveis `float` e exiba-as com `print()` usando `end='|'` entre elas.
    1. Crie uma lista de variáveis booleanas e use um loop `while` para exibir cada elemento em uma linha, seguido por uma vírgula, usando `print()` com `end=','`.
    1. Crie três variáveis de tipo `str` e exiba-as usando `print()` com `end=' END '`.
    1. Crie uma lista de números inteiros e use um loop `while` para exibir os elementos, cada um seguido de três pontos (`...`), usando `print()` com `end='...'`.
    1. Crie quatro variáveis do tipo `bool`, `int`, `str`, e `float`, e exiba-as usando `print()` com `end=' -> '`.
    1. Crie três variáveis do tipo `float` e exiba-as em uma linha usando `print()` com `end=' | '`.
    1. Crie uma lista de strings e use um loop `while` para exibir cada elemento, seguido por uma barra (`/`), usando `print()` com `end='/'`.
    1. Crie quatro variáveis do tipo `str` e exiba-as em uma linha usando `print()` com `end=' === '`.
1. Exercícios usando `sep` e `end` combinados
    1. Crie três variáveis inteiras e exiba-as em uma linha usando `print()` com `sep='-'` e `end='.'`.
    1. Crie uma lista de strings e exiba os elementos separados por vírgulas e finalizando com um ponto (`.`) usando `print()` com `sep=','` e `end='.'`.
    1. Crie três variáveis do tipo `float` e exiba-as em uma linha usando `print()` com `sep=':'` e `end=' END'`.
    1. Crie uma lista de números inteiros e exiba os elementos separados por espaço e finalizando com três pontos (`...`) usando `print()` com `sep=' '` e `end='...'`.
    1. Crie três variáveis do tipo `bool` e exiba-as em uma linha usando `print()` com `sep=' | '` e `end=' END'`.
    1. Crie uma lista de números `float` e exiba os elementos separados por asteriscos e finalizando com uma barra (`/`) usando `print()` com `sep='*'` e `end='/'`.
    1. Crie quatro variáveis do tipo `str`, `int`, `float`, e `bool`, e exiba-as em uma linha usando `print()` com `sep=' -> '` e `end=' END'`.
    1. Crie uma lista de strings e exiba os elementos separados por vírgulas e finalizando com uma linha em branco usando `print()` com `sep=','` e `end='\n'`.
    1. Crie três variáveis do tipo `str` e exiba-as em uma linha usando `print()` com `sep='-'` e `end=' !'`.
    1. Crie uma lista de números inteiros e exiba os elementos separados por ponto e finalizando com uma mensagem personalizada usando `print()` com `sep='.'` e `end=' - Fim da lista'`.

</details>

## `len()`

A função `len()` retorna o comprimento (número de itens) de um objeto, como uma string, lista, tupla, conjunto.

```python
planetas = ["Mercúrio", "Vênus", "Terra", "Marte"]
sobrenome = 'Schwarzenegger'

print(len(planetas))  # saída : 4
print(len(planetas[2]))  # saída (tamanho da palavra Terra) : 5
print(len(sobrenome))  # saída : 14
```

## `sum()`

A função `sum()` soma todos os elementos de um iterável, como uma lista ou tupla. Opcionalmente, pode-se passar um valor inicial para a soma.

```python
numeros = [10, 20, 30]
print(sum(numeros))        # saída : 60
print(sum(numeros, 10))    # saída : 70 (60 + 10)
```

## `pow()`

A função `pow()` retorna o valor de um número elevado a uma determinada potência. Ela aceita dois ou três argumentos. Se três argumentos forem fornecidos, a função calcula a potência e, em seguida, faz o módulo da resposta -> (x^y) % z.

```python
print(pow(2, 3))        # saída : 8 (2^3)
print(pow(2, 3, 5))     # saída : 3 (2^3 % 5)
```

## `max()` e `min()`

As funções `max()` e `min()` retornam, respectivamente, o maior e o menor valor em um iterável.

```python
numeros = [20, 10, 30, 40]
print(max(numeros))  # saída : 40
print(min(numeros))  # saída : 10
```

## `abs()`

A função `abs()` retorna o valor absoluto de um número, ou seja, seu valor sem o sinal.

```python
print(abs(-10))  # saída : 10
print(abs(4.5))  # saída : 4.5
```

## `round()`

A função `round()` arredonda um número para o número especificado de dígitos.

```python
print(round(3.14159, 2))  # saída : 3.14
print(round(2.71828))     # saída : 3
```

## `type()`

A função `type()` retorna o tipo do objeto passado como argumento.

```python
print(type(10))          # saída : <class 'int'>
print(type(3.14))        # saída : <class 'float'>
print(type(False))       # saída : <class 'bool'>
print(type("Python"))    # saída : <class 'str'>
print(type([1, 2, 3]))   # saída : <class 'list'>
```

## `isinstance()`

A função `isinstance()` verifica se um objeto é uma instância de uma classe ou de uma tupla de classes.

```python
print(isinstance(10, int))             # saída : True
print(isinstance("Python", str))       # saída : True
print(isinstance("Python", float))     # saída : False
print(isinstance(3.14, (int, float)))  # saída : True
```

## `ord()` e `chr()`

A função `ord()` retorna o número inteiro representando o código Unicode de um dado caractere. Já a função `chr()` faz o inverso, convertendo um número inteiro para o caractere correspondente ao seu código Unicode.

```python
print(ord('A'))  # saída : 65
print(chr(65))   # saída : 'A'
```

## `help()`

A função `help()` exibe a documentação de uma função, módulo, ou classe.

```python
help(print)
```

## exercícios

<details>
<summary>Lista de Exercícios</summary>

1. Nível Simples
    1. Crie uma lista de números inteiros e use a função `len()` para encontrar quantos elementos há na lista.
    1. Crie uma string e use a função `len()` para contar o número de caracteres na string.
    1. Crie uma lista de números inteiros e use a função `sum()` para calcular a soma de todos os elementos da lista.
    1. Crie uma lista de números inteiros, use a função `max()` para encontrar o maior número na lista e `min()` para encontrar o menor.
    1. Use a função `pow()` para calcular o valor de 2 elevado à 3ª potência.
    1. Crie uma variável com um número negativo e use a função `abs()` para encontrar o valor absoluto desse número.
    1. Use a função `round()` para arredondar o número 7.654 para duas casas decimais.
    1. Crie uma variável com um valor inteiro e use a função `type()` para verificar seu tipo.
    1. Crie uma variável com um valor float e use a função `isinstance()` para verificar se ela é do tipo `float`.
    1. Use a função `ord()` para encontrar o valor numérico da letra 'A'.
1. Nível Intermediário
    1. Crie uma string com várias palavras e use a função `len()` para contar o número de caracteres, incluindo os espaços.
    1. Crie uma lista de números decimais e use a função `sum()` para calcular a soma de todos os elementos da lista.
    1. Use a função `max()` e `min()` para encontrar o maior e o menor número entre 3, 9 e 4.
    1. Use a função `pow()` para calcular o valor de 5 elevado à 4ª potência.
    1. Crie uma lista com números positivos e negativos e use a função `abs()` para criar uma nova lista com os valores absolutos.
    1. Use a função `round()` para arredondar o número 3.14159 para três casas decimais.
    1. Crie uma lista de diferentes tipos de dados (int, str, bool) e use a função `type()` para verificar o tipo de cada elemento.
    1. Use a função `isinstance()` para verificar se o número 10.5 é um `int`.
    1. Use a função `chr()` para encontrar o caractere correspondente ao número 97.
    1. Use a função `help()` para exibir a documentação da função `len()`.
1. Nível Avançado
    1. Crie uma lista de listas (matriz) e use a função `len()` para encontrar o número de linhas e o número de colunas.
    1. Crie uma lista de listas (matriz) e use a função `sum()` para calcular a soma de todos os elementos da matriz.
    1. Use a função `max()` para encontrar o maior número em uma lista de listas (matriz).
    1. Use a função `pow()` para calcular o valor de 2 elevado à 10ª potência e, em seguida, divida por 3.3 e arredonde o resultado para a casa decimal mais próxima.
    1. Crie um algoritmo que peça um número e mostre seu valor absoluto usando a função `abs()`.
    1. Use a função `round()` para arredondar uma lista de números decimais para o inteiro mais próximo.
    1. Crie uma lista com diferentes tipos de dados (int, str, bool, list) e use a função `type()` para verificar o tipo de cada elemento.
    1. Crie um algoritmo que verifique se um número é inteiro usando a função `isinstance()`.
    1. Crie um algoritmo que converta uma lista de caracteres em seus valores numéricos usando `ord()`.
    1. Crie um algoritmo que converta uma lista de números em seus caracteres correspondentes usando `chr()`.
1. Nível Complexo
    1. Crie um algoritmo que peça uma lista de strings ao usuário e mostre uma lista com o comprimento de cada string digitada usando a função `len()`.
    1. Crie um algoritmo que peça duas listas de inteiros distintas e mostre a soma dos elementos de cada lista usando a função `sum()`.
    1. Crie um algoritmo que peça três (matriz) e retorne o maior número de cada lista usando a função `max()`.
    1. Crie um algoritmo que peça duas listas de números de mesmo tamanho e mostre uma lista com os resultados da exponenciação entre os elementos correspondentes usando a função `pow()`.
    1. Crie um algoritmo que peça uma lista de números e mostre uma lista com os valores absolutos de cada número usando a função `abs()`.
    1. Crie um algoritmo que peça uma lista de números decimais e mostre uma lista com os números arredondados para uma casa decimal usando a função `round()`.
    1. Crie um algoritmo que peça uma lista de diferentes tipos de dados e mostre uma lista com o tipo de cada elemento usando a função `type()`.
    1. Crie um algoritmo que peça uma lista de valores e mostre uma lista de booleanos indicando se cada valor é um inteiro usando a função `isinstance()`.
    1. Crie um algoritmo que peça uma string e mostre uma lista com os valores numéricos de cada caractere da string usando a função `ord()`.
    1. Crie um algoritmo que peça uma lista de números e retorne uma string formada pelos caracteres correspondentes a esses números usando a função `chr()`.
1. Nível Muito Complexo
    1. Crie um algoritmo que peça uma string e mostre a média dos valores numéricos de seus caracteres usando as funções `ord()` e `sum()`.
    1. Crie um algoritmo que peça duas strings e mostre a soma dos valores numéricos de seus caracteres correspondentes usando as funções `ord()` e `sum()`.
    1. Crie um algoritmo que peça uma lista de números e retorne o valor máximo absoluto dos números usando as funções `abs()` e `max()`.
    1. Crie um algoritmo que peça uma string e mostre o caractere que representa o valor numérico mais próximo da média dos valores dos caracteres da string usando as funções `ord()`, `sum()`, `len()` e `chr()`.
    1. Crie um algoritmo que peça uma lista de números decimais e mostre uma lista com os números arredondados para o inteiro mais próximo usando as funções `round()` e `type()` para garantir que os elementos sejam do tipo `float`.
    1. Crie um algoritmo que peça uma lista de números e mostre a soma dos números que são inteiros usando as funções `isinstance()` e `sum()`.
    1. Crie um algoritmo que peça uma lista de strings e mostre uma lista de listas, onde cada lista interna conterá cada string e o seu tamanho usando as funções `len()`.

</details>

## `input()`
A função `input()` lê uma entrada do usuário e a retorna como uma string.

```python
nome = input("Digite seu nome: ")
print("Olá, " + nome + "!")
```

```
Digite seu nome: Schwarzenegger
Olá, Schwarzenegger!
```

## `range()`

A função `range()` é usada para gerar uma sequência de números. Ela é frequentemente utilizada em loops `for` para iterar um número específico de vezes. O `range()` pode ser utilizado de três maneiras diferentes, dependendo de quantos argumentos você fornecer.

```python
# sintaxe básica
range(stop)
range(start, stop[, step])
```

- **`start`** (opcional): O número inicial da sequência. O valor padrão é `0`;
- **`stop`**: O número onde a sequência termina (não incluído);
- **`step`** (opcional): A diferença entre cada número na sequência. O valor padrão é `1`;

Veja alguns exemplos de uso

1. gerando uma sequência simples de 0 a n-1 :
    ```python
    >>> for i in range(5):
    ...     print(i)
    ...
    0
    1
    2
    3
    4
    >>> |
    ```

1. especificando o valor inicial (`start`) e final (`stop`) :
    ```python
    >>> for i in range(2,7):
    ...     print(i)
    ...
    2
    3
    4
    5
    6
    >>>
    ```

1. usando um `step` crescente (incremento) :
    ```python
    >>> for i in range(1, 10, 2):
    ...     print(i)
    ...
    1
    3
    5
    7
    9
    >>>
    ```

1. usando um `step` decrescente (step negativo) :
    ```python
    >>> for i in range(10, 0, -2):
    ...     print(i)
    ...
    10
    8
    6
    4
    2
    >>>
    ```

1. embora `range()` crie um objeto de intervalo (e não uma lista), é possível convertê-lo em uma lista usando a função `list()` :
    ```python
    >>> lista = list(range(10))
    >>> lista
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    >>> |
    ```
    É muito útil para gerar sequências de números de forma instantânea.

1. se precisar acessar os índices de uma lista em vez de seus valores diretamente, é possível combinar `range()` com `len()` :
    ```python
    >>> frutas = ['maçã', 'banana', 'laranja']
    >>> for i in range(len(frutas)):
    ...     print(f'índice {i} tem a fruta {frutas[i]}')
    ...
    índice 0 tem a fruta maçã
    índice 1 tem a fruta banana
    índice 2 tem a fruta laranja
    >>>
    ```

1. veja mais alguns usos do `range()` :
   ```python
    >>> # criando uma sequência de números pares
    >>> pares = list(range(0, 21, 0))
    >>> pares
    [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
    >>>
    >>> # criando uma sequência de números ímpares
    >>> impares = list(range(1, 22, 2))
    >>> impares
    [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21]
    >>>
    >>> # criando uma sequência decrescente
    >>> descrescente = list(range(10, 0, -1))
    >>> descrescente
    [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
    >>>
    >>> # combinando for, range e condicionais
    >>> for i in range(1, 10):
    ...     if i % 2 == 0:
    ...         print(f'{i} é par')
    ...     else:
    ...          print(f'{i} é ímpar')
    ...
    1 é ímpar
    2 é par
    3 é ímpar
    4 é par
    5 é ímpar
    6 é par
    7 é ímpar
    8 é par
    9 é ímpar
    >>> |
    ```

### exercícios range

<details>
<summary>Lista de Exercícios</summary>

1. Use `range()` para imprimir os números de 0 a 10.
1. Use `range()` para imprimir os números de 5 a 15.
1. Use `range()` para imprimir os números pares de 0 a 20.
1. Use `range()` para imprimir os números ímpares de 1 a 19.
1. Use `range()` para imprimir os números de 10 a 0 em ordem decrescente.
1. Use `range()` para criar uma lista de números de 0 a 9 e imprimi-la.
1. Use `range()` para somar todos os números de 1 a 100.
1. Use `range()` para imprimir todos os múltiplos de 3 entre 0 e 30.
1. Use `range()` para criar uma lista de números de 5 a 15 e imprimi-la.
1. Use `range()` para imprimir os números de 0 a 10, com passos de 2.
1. Use `range()` para criar uma lista com os números de 50 a 100, com passos de 5, e imprimi-la.
1. Use `range()` para imprimir os números de 100 a 50 em ordem decrescente.
1. Use `range()` para calcular o produto de todos os números de 1 a 10.
1. Use `range()` para criar uma lista de números de 1 a 9 e imprimi-la.
1. Use `range()` para imprimir os números negativos de -10 a -1.
1. Use `range()` para criar uma lista de números de 0 a 100 com passos de 10 e imprimi-la.
1. Use `range()` para imprimir os números de 5 a 25, com passos de 5.
1. Use `range()` para somar todos os números ímpares entre 0 e 100.
1. Use `range()` para imprimir os números de 10 a 1 em ordem decrescente.
1. Use `range()` para criar uma lista de números de 20 a 30 e imprimi-la.
1. Use `range()` para imprimir os números de 2 a 20, com passos de 2.
1. Use `range()` para calcular a soma dos números múltiplos de 5 entre 0 e 50.
1. Use `range()` para criar uma lista de números de 10 a 100, com passos de 10, e imprimi-la.
1. Use `range()` para imprimir os números de -5 a 5.
1. Use `range()` para criar uma lista com os números de 0 a 9 em ordem reversa e imprimi-la.

</details>

## `enumerate()`

A função `enumerate()` em Python é usada para iterar sobre uma sequência (como uma lista, tupla ou string) e retornar tanto o índice quanto o valor dos elementos dessa sequência. Isso é particularmente útil quando é preciso de acesso ao índice do elemento dentro de um loop, sem precisar gerenciá-lo manualmente.

```python
# sintaxe básica
enumerate(iterável, start=0)
```

- **`iterável`** : a sequência sobre a qual você deseja iterar (como uma lista, tupla, string, etc.);
- **`start`** (opcional) : o valor inicial do índice (o valor padrão é 0);

Quando usado dentro de um loop `for`, `enumerate()` retorna uma tupla que contém o índice e o valor do elemento na sequência. Esse índice começa no valor especificado pelo parâmetro `start`.

Veja alguns exemplos

1. iterando sobre uma lista com `enumerate()` :
    ```python
    >>> frutas = ['maçã', 'banana', 'laranja']
    >>> for i, fruta in enumerate(frutas):
    ...     print(f'Índice {i}: {fruta}')
    ...
    Índice 0: maçã
    Índice 1: banana
    Índice 2: laranja
    >>> |
    ```

1. especificando um valor inicial para o índice :
    ```python
    >>> frutas = ['maçã', 'banana', 'laranja']
    >>> for i, fruta in enumerate(frutas, start=1):
    ...     print(f'Índice {i}: {fruta}')
    ...
    Índice 1: maçã
    Índice 2: banana
    Índice 4: laranja
    >>> |
    ```

1. acessando índices ao iterar sobre strings :
    ```python
    >>> palavra = 'Python'
    >>> for i, letra in enumerate(palavra):
    ...     print(f'Letra {letra} está na posição {i}')
    ...
    Letra P está na posição 0
    Letra y está na posição 1
    Letra t está na posição 2
    Letra h está na posição 3
    Letra o está na posição 4
    Letra n está na posição 5
    >>> |
    ```

1. identificando posições de elementos específicos em uma lista :
    ```python
    >>> numeros = list(range(10, 60, 10))
    >>> numeros
    [10, 20, 30, 40, 50]
    >>> for i, num in enumerate(numeros):
    ...     if num == 30:
    ...         print(f'Encontrado {num} na posição {i}')
    ...
    Encontrado 30 na posição 2
    >>> |
    ```

1. se precisar modificar os elementos de uma lista com base em sua posição, `enumerate()` pode ser útil:
    ```python
    >>> numeros = list(range(10, 60, 10))
    >>> numeros
    [10, 20, 30, 40, 50]
    >>>
    >>> for i, num in enumerate(numeros):
    ...     numeros[i] = num * 2
    ...
    >>> numeros
    [20, 40, 60, 80, 100]
    >>> |
    ```

### exercícios enumerate

<details>
<summary>Lista de Exercícios</summary>

1. Use `enumerate()` para imprimir cada elemento de uma lista de frutas, junto com seu índice.
1. Use `enumerate()` para imprimir cada letra de uma string, junto com seu índice.
1. Crie uma lista de números e use `enumerate()` para imprimir cada número junto com seu índice.
1. Use `enumerate()` para iterar sobre uma lista de palavras e imprimir o índice das palavras que contêm a letra "a".
1. Crie uma lista de nomes e use `enumerate()` para imprimir cada nome com seu respectivo índice.
1. Use `enumerate()` para criar uma nova lista de lista, onde cada nova lista contém um índice e um valor de uma lista de números.
1. Use `enumerate()` para imprimir os índices e elementos de uma lista de números pares.
1. Use `enumerate()` para iterar sobre uma string e imprimir o índice das letras maiúsculas.
1. Crie uma lista de cidades e use `enumerate()` para imprimir cada cidade com seu respectivo índice.
1. Use `enumerate()` para contar quantos elementos em uma lista de números são maiores que 10.
1. Use `enumerate()` para imprimir os índices e letras de uma string que começam com "p".
1. Crie uma lista de palavras e use `enumerate()` para imprimir o índice das palavras que têm mais de 5 letras.
1. Use `enumerate()` para somar os índices de todos os elementos de uma lista de números.
1. Use `enumerate()` para criar uma nova lista com as letras de uma string, onde o índice é par.
1. Use `enumerate()` para imprimir o índice e o valor de cada elemento em uma lista de números negativos.
1. Use `enumerate()` para criar uma nova lista de strings, onde cada string contém o índice e o valor correspondente.
1. Use `enumerate()` para imprimir os índices dos elementos em uma lista de números que são múltiplos de 3.
1. Use `enumerate()` para iterar sobre uma lista de palavras e imprimir o índice das palavras que começam com "s".
1. Use `enumerate()` para contar quantos elementos em uma lista de números são negativos.
1. Use `enumerate()` para criar uma nova lista onde cada elemento é o dobro do índice original de uma lista de números.
1. Use `enumerate()` para imprimir os índices das letras em uma string que são vogais.
1. Use `enumerate()` para criar uma nova lista de listas, onde cada nova lista contém um índice e uma palavra de uma lista original.
1. Use `enumerate()` para imprimir o índice e o valor dos elementos em uma lista de strings que contêm a letra "e".
1. Use `enumerate()` para iterar sobre uma lista de números e imprimir o índice dos números que são pares.
1. Use `enumerate()` para criar uma nova lista de strings, onde cada string contém o índice e o valor correspondente de uma lista de nomes.

</details>

## `zip()`

A função `zip()` em Python é usada para combinar dois ou mais iteráveis (como listas, tuplas, ou qualquer objeto que suporte iteração) em um único iterável de pares ou tuplas. Cada tupla gerada pelo `zip()` conterá os elementos correspondentes dos iteráveis fornecidos.

```python
# sintaxe básica
zip(iterável1, iterável2, ...)
```

- **`iterável1, iterável2, ...`** : um ou mais iteráveis (listas, tuplas, strings, etc.) que deseja combinar;

A função `zip()` retorna um iterador de tuplas, onde cada tupla contém um elemento de cada iterável. Se os iteráveis tiverem comprimentos diferentes, o `zip()` truncará ao comprimento do menor iterável.

Veja exemplos de uso

1. zip de duas listas :
    ```python
    >>> nomes = ['Ana', 'João', 'Maria']
    >>> idades = [25, 30, 22]
    >>>
    >>> combinados = zip(nomes, idades)
    >>> list(combinados)
    [('Ana', 25), ('João', 30), ('Maria', 22)]
    >>> |
    ```

1. zip de três listas :
    ```python
    >>> nomes = ['Ana', 'João', 'Maria']
    >>> idades = [25, 30, 22]
    >>> cidades = ['São Paulo', 'Rio de Janeiro', 'Curitiba']
    >>>
    >>> combinados = zip(nomes, idades, cidades)
    >>> list(combinados)
    [('Ana', 25, 'São Paulo'), ('João', 30, 'Rio de Janeiro'), ('Maria', 22, 'Curitiba')]
    >>> |
    ```

1. iterando com `zip()` em um loop `for` :
    ```python
    >>> nomes = ['Ana', 'João', 'Maria']
    >>> idades = [25, 30, 22]

    >>> for nome, idade in zip(nomes, idades):
    >>>     print(f'{nome} tem {idade} anos.')
    Ana tem 25 anos.
    João tem 30 anos.
    Maria tem 22 anos.
    >>> |
    ```

1. quando os iteráveis passados para `zip()` têm tamanhos diferentes, o `zip()` para de emparelhar assim que o menor iterável é consumido :
    ```python
    >>> nomes = ['Ana', 'João']
    >>> idades = [25, 30, 22]  # Uma lista mais longa
    >>>
    >>> combinados = zip(nomes, idades)
    >>> list(combinados)
    [('Ana', 25), ('João', 30)]
    >>> |
    ```
    No exemplo acima, o terceiro valor de `idades` (22) é ignorado porque `nomes` só tem dois elementos.

1. zip com strings :
    ```python
    >>> letras = 'abc'
    >>> numeros = [1, 2, 3]
    >>>
    >>> combinados = zip(letras, numeros)
    >>> list(combinados)
    [('a', 1), ('b', 2), ('c', 3)]
    >>> |
    ```

### exercícios zip

<details>
<summary>Lista de Exercícios</summary>

1. Use `zip()` para combinar duas listas de números e imprimir os pares resultantes.
1. Use `zip()` para combinar duas listas de palavras e imprimir os pares resultantes.
1. Use `zip()` para combinar uma lista de números com uma lista de palavras e imprimir os pares.
1. Crie duas listas de nomes e sobrenomes e use `zip()` para combiná-las em uma lista de nomes completos.
1. Use `zip()` para combinar uma string e uma lista de números, imprimindo os pares resultantes.
1. Crie duas listas de números e use `zip()` para somá-los em pares.
1. Use `zip()` para combinar uma lista de palavras com seus respectivos comprimentos.
1. Use `zip()` para iterar sobre duas listas de números e imprimir a multiplicação dos pares.
1. Crie duas listas de cidades e estados e use `zip()` para combiná-las em uma lista de listas.
1. Use `zip()` para combinar uma string e uma lista de índices, imprimindo os pares.
1. Crie duas listas de produtos e preços e use `zip()` para imprimir os produtos com seus preços.
1. Use `zip()` para combinar três listas de números e imprimir as listas resultantes.
1. Use `zip()` para combinar duas strings e imprimir os pares de caracteres.
1. Crie duas listas de números e use `zip()` para criar uma nova lista de listas e imprimir seus pares.
1. Crie duas listas de palavras e use `zip()` para criar uma nova lista onde cada elemento é a concatenação das palavras nas duas listas.
1. Use `zip()` para combinar uma lista de números com uma lista de booleanos e imprimir os pares.
1. Crie duas listas de notas e use `zip()` para calcular a média de cada par de notas.
1. Use `zip()` para combinar três listas de palavras e imprimir as listas resultantes.
1. Crie duas listas de letras e use `zip()` para criar uma string onde as letras das duas listas estejam intercaladas.
1. Use `zip()` para combinar uma lista de nomes com uma lista de idades e imprimir as listas resultantes.
1. Crie duas listas de números e use `zip()` para subtrair os pares e imprimir os resultados.
1. Use `zip()` para combinar uma lista de cidades com uma lista de países e imprimir os pares.
1. Crie duas listas de números e use `zip()` para encontrar o maior número em cada par.
1. Use `zip()` para combinar uma lista de palavras com uma lista de números e imprimir as palavras repetidas de acordo com os números.
1. Crie três listas de strings e use `zip()` para combinar e imprimir as listas formadas pelos elementos correspondentes.

</details>
Índice Intercalando e Formatando Strings

1. [introduçao](#introdução)
1. [intercalando strings com +](#intercalando-strings-com-)
1. [operador %](#operador-)
1. [str.format](#strformat)
1. [f-string](#f-string)
1. [formatando strings](#formatando-strings)
1. [exercícios](#exercícios)

# Intercalando Strings

## introdução

Quando se está trabalhando com strings, é comum precisar integrar ou inserir valores e objetos nelas, para então criar novas strings dinamicamente. Essa tarefa é conhecida como intercalação de stings.

O Python possiu três ferramentas para realizar essa tarefa :
- O operador `módulo` (`%`);
- O método `str.format()`;
- Literais `f-strings`;

> [!IMPORTANT]
>
> Antes de seguir adiante, é importante saber que há duas formas de intercalação de strings :
> - `Intercalação Ansionsa` : é quando o Python insere os valores dos objetos na strings em tempo de exeucução enquanto a strings está sendo definida;
> - `Intercalação Preguiçosa` : é quando o Python atrasa a inserção dos objetos na strings até o seu uso. Nesse caso, serão criados modelos em um ponto do código e o preenchimento com os valores é feito em outro momento;
>
> Ao explorarmos os métodos adiante, isso será melhor explicado com exemplos para cada caso de uso.

## intercalando strings com +

Como foi visto anteriormente, uma forma de criar uma string é usando o operador `+` para intercalar strings e assim gerar novas strings. É possível usar para salvar em uma nova variável ou então exibir um texto já formatado :

```python
>>> nome = 'Arnold'
>>> sobrenome = 'Schwarzenegger'
>>>
>>> nome_completo = nome + ' ' + sobrenome
>>> nome_completo
'Arnold Schwarzenegger'
>>> print(nome + ' ' + sobrenome)
Arnold Schwarzenegger
>>> |
```

Embora essa forma funcione, ela não é muito prática pois torna difícil a leitura do código.

## operador %

Intercalar strings com o operador `%` é uma forma obsoleta, mas ainda funcional para isso. É importante saber que existe pois muitos códigos antigos ainda os usam. Ele pode ser usado tanto para *intercalação ansiosa* quanto para *intercalação preguiçosa*.

Veja exemplos de intercalação ansiosa :

```python
>>> x = 30
>>> y = 12
>>>
>>> operador = '+'
>>> 'A operação é %d %s %d = %d.' % (x, operador, y, x + y)
'A operação é 30 + 12 = 42.'
>>>
>>> operador = '-'
>>> 'A operação é %d %s %d = %d.' % (x, operador, y, x - y)
'A operação é 30 - 12 = 18.'
>>>
>>> operador = '/'
>>> 'A operação é %d %s %d = %d.' % (x, operador, y, x / y)
'A operação é 30 / 12 = 2.'
>>> |
```

A combinação de caracteres iniciando com o sinal de percentual `%` é conhecida como conversão específica. Nos exemplos acima, foi usado o especificador `%d`, usado quando se quer converter um valor decimal ou inteiro para uma strings. Repare no último exemplo que o valor decimal do resultado foi perdido na conversão.

Uma intercalação preguiçosa pode ser feita como abaixo :

```python
>>> x = 30
>>> y = 12
>>>
>>> modelo = 'A operação é %d %s %d = %d.'
>>>
>>> operador = '+'
>>> modelo % (x, operador, y, x + y)
'A operação é 30 + 12 = 42.'
>>>
>>> operador = '-'
>>> modelo % (x, operador, y, x - y)
'A operação é 30 - 12 = 18.'
>>>
>>> operador = '/'
>>> modelo % (x, operador, y, x / y)
'A operação é 30 / 12 = 2.'
>>> |
```

Essa forma de uso é útil quando se precisa reutilizar o mesmo modelo em mais de um local do código. Outros formatos incluem `%f` para números do tipo `float` e `%s` para strings.

```python
>>> pi = 3.141592
>>> 'o valor de PI é %f' % pi
'o valor de PI é 3.141592'
>>>
>>> nome_completo = 'Arnold Schwarzenegger'
>>> 'O nome completo é %s' % nome_completo
'O nome completo é Arnold Schwarzenegger'
>>> |
```

Por ser um método já muito antigo, datando dos primórdios da criação do Python, ele quase não é mais usando atualmente. Então maiores detalhes não serão abordados. Contudo, a documentação do Python é bem extensa sobre esse recurso. Mais pode ser encontrado [aqui](https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting).

## str.format()
Se for necessário intercalar valores em uma strings preguiçosamente, então o método `str.format()` é o que precisa. Ele proporciona uma sintaxe legível e permite ambos as intercalação preguiçosa e ansiosa.

Este método permite três abordagens diferentes :

1. Campo de substituição vazio, `{}`;
    ```python
    >>> modelo = """
    ... Caro {},
    ... Obrigado pela figurinha do {} que comprou.
    ... Atencionamente,
    ... {}
    ... """
    >>>
    >>> print(modelo.format('Tom', 'Campeonato Brasileiro', 'Seu amigo'))

    Caro Tom,
    Obrigado pela figurinha do Campeonato Brasileiro que comprou.
    Atencionamente,
    Seu amigo

    >>> |
    ```
    No exemplo acima, é criado um modelo de mensagem agradecendo pela compra de uma figurinha, podendo ser de qualquer álbum e agradecendo qualquer pessoa. Nesse exemplo, foi usado uma variável para guardar o texto como modelo.

    Veja abaixo um modelo usado na string diretamente.

    ```python
    >>> x = 10
    >>> y = 32
    >>> print('a soma de {} com {} é {}'.format(x, y, x+y))
    a soma de 10 com 32 é 42
    >>> |
    ```

2. Campo de substituição com índices iniciado em zero, `{0} ... {n}`;

    ```python
    >>> modelo = 'Disciplina : {0}\nNota : {1}'
    >>> print(modelo.format('Python', 'A'))
    Disciplina : Python
    Nota : A
    >>> print(modelo.format('C++', 'C'))
    Disciplina : C++
    Nota : C
    >>> print(modelo.format('C', 'Java'))
    Disciplina : C
    Nota : Java
    >>>
    >>> modelo = 'Disciplina : {1}\nNota : {0}'
    >>> print(modelo.format('C', 'Java'))
    Disciplina : Java
    Nota : C
    >>> |
    ```
    Como pode ser visto no modelo acima, foi criado um modelo com os campos determinados usando um índice iniciando em 0 e seguido de 1. É possível ver, também, que ao alterar a ordem, os valores são impressos errados. Em seguida, o modelo é alterado para aceitar as novas posições.

    Também é possível usar para criar prefixos, veja abaixo :
    ```python
    >>> prefixo = 're'
    >>> print('{0}criar, {0}iniciar, {0}nascer, {0}abastecer'.format(prefixo))
    recriar, reiniciar, renascer, reabastecer
    >>> |
    ```

3. Campo de susbtituição com argumentos nomeados, `{arg_1} ... {arg_n}`;

    Apesar dos métodos anteriores serem práticos, eles não são exatamente muito fáceis de ler. Mesmo quando a string é lida, não é claro o que será substituído. Para contornar esse problema, é possível usar palavras-chave para determinar os campos.

    ```python
    >>> modelo = """
    ... Caro {cliente},
    ... Obrigado por comprar o {produto}
    ... Com carinho
    ... {vendedor}
    ... """
    >>>
    >>> print(modelo.format(
    ...     cliente='Tom',
    ...     produto='Galaxy S90',
    ...     vendedor='Fulano'
    ... ))

    Caro Tom,
    Obrigado por comprar o Galaxy S90
    Com carinho
    Fulano

    >>> |
    ```
    Nessa string, é muito mais fácil de indentificar o que cada campo {} vai receber como parâmetro. Isso facilita tanto para a legibilidade quanto para atualizar o código, se necessário.

## f-string

Para a maioria das intercalações de strings, o método usado será a `f-string`. Ela foi adicionada ao Python em sua versão 3.6 e possui uma legibilidade muito melhor e concisa, além de possuir uma performance superior às demais.

Uma situação onde a `f-string` talvez não seja a melhor escolha é quando se faz necessário usar a intercalação preguiçosa. Outra consideração importante é que, como ela é executada de imediato, ela pode expor a aplicação a ataques maliciosos se não for tomado o devido cuidado.

```python
>>> x = 5
>>> y = 37
>>> f'A expressão é {x} + {y} = {x + y}.'
'A expressão é 5 + 37 = 42.'
>>> |
```

No exemplo acima, há duas variáveis que são somadas dentro do terceiro campo diretamente na `f-string`. Isso permite, inclusive, realizar operações mais complexas dentro das chaves.

```python
>>> pi = 3.14159265
>>> raio = 17
>>> f'A área do círculo é {pi * (raio ** 2)}.'
'A área do círculo é 907.9202768874502.'
>>>
>>> nome = 'Arnold'
>>> sobrenome = 'Schwarzenegger'
>>> f'Olá, {nome.upper()}. Seu nome completo é {nome + " " + sobrenome}.'
'Olá, ARNOLD. Seu nome completo é Arnold Schwarzenegger.'
>>>
>>> f'{[2**i for i in range(2, 20, 2)]}.'
'[4, 16, 64, 256, 1024, 4096, 16384, 65536, 262144].'
>>> |
```

A `f-string`, assim como a `str.format()` automaticamente convertem os números para strings.

Outro ponto muito interessante da `f-string` é ser possível realizar uma auto documentação. Isso é muito útil quando se quer documentar o que tem uma variável ou então quando se quer mostrar qual variável tem qual valor.

```python
>>> um_texto = 'contenho um texto muito interessante'
>>>
>>> f'O que é isso : <{um_texto = }>'
"O que é isso : <um_texto = 'contenho um texto muito interessante'>"
>>>
>>> f'{2 * 21 = }.'
'2 * 21 = 42.'
>>>
>>> print(f'{2 * 21 = }.')
2 * 21 = 42.
>>> |
```

## formatando strings

O Python também permite formatar as strings quando for exibir elas.

```python
>>> pi = 3.1415926535
>>>
>>> print('o valor de pi é {}'.format(pi))
o valor de pi é 3.1415926535
>>> print('o valor de pi é {:.2f}'.format(pi))
o valor de pi é 3.14
>>> print('o valor de pi é {:.4f}'.format(pi))
o valor de pi é 3.1416
>>>
>>> print(f'o valor de pi é {pi:.2f}')
o valor de pi é 3.14
>>> |
```
Esse tipo de formatação é válido tanto para `str.format()` quanto para `f-string`.

Também permite especificar o tamanho do campo e o alinhamento :
```python
>>> # alinhando à esquerda
>>> print(f'-{saudacao:<10}-')
-olá       -
>>>
>>> # alinhando à direita
>>> print(f'-{saudacao:>10}-')
-       olá-
>>>
>>> # centralizando
>>> print(f'-{saudacao:^10}-')
-   olá    -
>>> |
```

E especificar um preenchimento :
```python
>>> # alinhando à esquerda e preenchendo com _
>>> print(f'-{saudacao:_<20}-')
-olá_________________-
>>>
>>> # alinhando à direita e preenchendo com +
>>> print(f'-{saudacao:+>20}-')
-+++++++++++++++++olá-
>>>
>>> # centralizando e preenchendo com *
>>> print(f'-{saudacao:*^20}-')
-********olá*********-
>>>
>>> # preenchendo com zero a esquerda ou a direita
>>> print(f'-{3.14:0<20}-')
-3.140000000000000000-
>>> print(f'-{3.14:0>20}-')
-00000000000000003.14-
>>> |
```

## exercícios

<details>
<summary>Lista de Exercícios</summary>

1. Intercalação de Strings usando `+`
    1. Crie duas variáveis do tipo `str` e concatene-as usando o operador `+`.
    1. Crie três variáveis do tipo `str` e concatene-as usando o operador `+` para formar uma frase completa.
    1. Crie uma variável `str` que armazene um nome e outra que armazene uma saudação, depois concatene-as para exibir uma mensagem de boas-vindas.
    1. Crie uma variável `str` com o nome de uma pessoa e outra com a cidade onde ela mora. Concatene-as para exibir uma mensagem informando a cidade de residência.
    1. Crie uma variável `str` com o nome de uma fruta e outra com a cor dela. Concatene as strings para formar a frase "A [fruta] é [cor]".
    1. Crie três variáveis `str` que armazenem o primeiro nome, o sobrenome e a idade de uma pessoa. Concatene-as para exibir a frase "Nome: [primeiro nome] [sobrenome], Idade: [idade]".
    1. Crie uma variável `str` com o nome de uma cidade e outra com o nome de um país. Concatene-as para formar a frase "Cidade: [cidade], País: [país]".
    1. Crie duas variáveis `str` contendo uma saudação e um nome. Concatene as strings para exibir "Olá, [nome]!".
    1. Crie uma variável `str` com o nome de uma pessoa e outra com a profissão dela. Concatene-as para formar a frase "A [nome] é [profissão]".
    1. Crie uma variável `str` com o nome de um produto e outra com o preço dele. Concatene as strings para exibir "Produto: [produto], Preço: [preço]".
1. Intercalação de Strings usando o Operador `%`
    1. Crie uma variável `str` que armazene um nome e exiba "Meu nome é %s" usando o operador `%`.
    1. Crie uma variável `int` com a idade de uma pessoa e exiba "Eu tenho %d anos" usando o operador `%`.
    1. Crie uma variável `str` com o nome de uma fruta e outra com a cor dela. Exiba "A %s é %s" usando o operador `%`.
    1. Crie uma variável `float` com a altura de uma pessoa e exiba "Minha altura é %.2f metros" usando o operador `%`.
    1. Crie duas variáveis `str`, uma com o nome de um filme e outra com o diretor. Exiba "O filme %s foi dirigido por %s" usando o operador `%`.
    1. Crie uma variável `float` com o valor de um produto e exiba "O preço do produto é R$ %.2f" usando o operador `%`.
    1. Crie uma variável `str` com o nome de uma pessoa e outra com a profissão dela. Exiba "A %s é uma excelente %s" usando o operador `%`.
    1. Crie duas variáveis `str`, uma com o nome de uma cidade e outra com o nome de um país. Exiba "A cidade de %s está localizada em %s" usando o operador `%`.
    1. Crie uma variável `int` com a idade de uma pessoa e outra com a quantidade de anos de experiência dela. Exiba "Tenho %d anos e %d anos de experiência" usando o operador `%`.
    1. Crie uma variável `float` com o valor de um desconto e exiba "O desconto é de %.1f%%" usando o operador `%`.
1. Intercalação de Strings usando o Método `str.format()`
    1. Crie uma variável `str` que armazene um nome e exiba "Meu nome é {}" usando o método `str.format()`.
    1. Crie uma variável `int` com a idade de uma pessoa e exiba "Eu tenho {} anos" usando o método `str.format()`.
    1. Crie uma variável `str` com o nome de uma fruta e outra com a cor dela. Exiba "A {} é {}" usando o método `str.format()`.
    1. Crie uma variável `float` com a altura de uma pessoa e exiba "Minha altura é {:.2f} metros" usando o método `str.format()`.
    1. Crie duas variáveis `str`, uma com o nome de um filme e outra com o diretor. Exiba "O filme {} foi dirigido por {}" usando o método `str.format()`.
    1. Crie uma variável `float` com o valor de um produto e exiba "O preço do produto é R$ {:.2f}" usando o método `str.format()`.
    1. Crie uma variável `str` com o nome de uma pessoa e outra com a profissão dela. Exiba "A {} é uma excelente {}" usando o método `str.format()`.
    1. Crie duas variáveis `str`, uma com o nome de uma cidade e outra com o nome de um país. Exiba "A cidade de {} está localizada em {}" usando o método `str.format()`.
    1. Crie uma variável `int` com a idade de uma pessoa e outra com a quantidade de anos de experiência dela. Exiba "Tenho {} anos e {} anos de experiência" usando o método `str.format()`.
    1. Crie uma variável `float` com o valor de um desconto e exiba "O desconto é de {:.1f}%" usando o método `str.format()`.
1. Intercalação de Strings usando `f-strings`
    1. Crie uma variável `str` que armazene um nome e exiba "Meu nome é {nome}" usando uma `f-string`.
    1. Crie uma variável `int` com a idade de uma pessoa e exiba "Eu tenho {idade} anos" usando uma `f-string`.
    1. Crie uma variável `str` com o nome de uma fruta e outra com a cor dela. Exiba "A {fruta} é {cor}" usando uma `f-string`.
    1. Crie uma variável `float` com a altura de uma pessoa e exiba "Minha altura é {altura:.2f} metros" usando uma `f-string`.
    1. Crie duas variáveis `str`, uma com o nome de um filme e outra com o diretor. Exiba "O filme {filme} foi dirigido por {diretor}" usando uma `f-string`.
    1. Crie uma variável `float` com o valor de um produto e exiba "O preço do produto é R$ {preco:.2f}" usando uma `f-string`.
    1. Crie uma variável `str` com o nome de uma pessoa e outra com a profissão dela. Exiba "A {nome} é uma excelente {profissao}" usando uma `f-string`.
    1. Crie duas variáveis `str`, uma com o nome de uma cidade e outra com o nome de um país. Exiba "A cidade de {cidade} está localizada em {pais}" usando uma `f-string`.
    1. Crie uma variável `int` com a idade de uma pessoa e outra com a quantidade de anos de experiência dela. Exiba "Tenho {idade} anos e {experiencia} anos de experiência" usando uma `f-string`.
    1. Crie uma variável `float` com o valor de um desconto e exiba "O desconto é de {desconto:.1f}%" usando uma `f-string`.
1. Exercícios de Alinhamento de Strings
	1. Crie uma variável `str` com seu nome e exiba-a alinhada à esquerda em um campo de 20 caracteres.
	1. Crie uma variável `str` com o nome de uma cidade e exiba-a alinhada à direita em um campo de 30 caracteres.
	1. Crie uma variável `str` com o nome de um filme e exiba-a centralizada em um campo de 25 caracteres.
	1. Crie uma variável `str` com o nome de uma fruta e exiba-a alinhada à esquerda em um campo de 15 caracteres.
	1. Crie uma variável `str` com o título de um livro e exiba-o alinhado à direita em um campo de 40 caracteres.
	1. Crie uma variável `str` com o nome de uma banda e exiba-a centralizada em um campo de 30 caracteres.
	1. Crie uma variável `str` com o nome de uma cor e exiba-a alinhada à esquerda em um campo de 10 caracteres.
	1. Crie uma variável `str` com o nome de uma estação do ano e exiba-a alinhada à direita em um campo de 25 caracteres.
	1. Crie uma variável `str` com o nome de um país e exiba-o centralizado em um campo de 20 caracteres.
	1. Crie uma variável `str` com o nome de uma linguagem de programação e exiba-a alinhada à direita em um campo de 50 caracteres.
1. Exercícios de Preenchimento de Strings
    1. Crie uma variável `str` com seu nome e exiba-a preenchida com `*` à esquerda até completar 20 caracteres.
    1. Crie uma variável `str` com o nome de uma cidade e exiba-a preenchida com `-` à direita até completar 30 caracteres.
    1. Crie uma variável `str` com o nome de um filme e exiba-a preenchida com `.` centralizada em um campo de 25 caracteres.
    1. Crie uma variável `str` com o nome de uma fruta e exiba-a preenchida com `#` à esquerda até completar 15 caracteres.
    1. Crie uma variável `str` com o título de um livro e exiba-o preenchido com `~` à direita até completar 40 caracteres.
    1. Crie uma variável `str` com o nome de uma banda e exiba-a preenchida com `=` centralizada em um campo de 30 caracteres.
    1. Crie uma variável `str` com o nome de uma cor e exiba-a preenchida com `+` à esquerda até completar 10 caracteres.
    1. Crie uma variável `str` com o nome de uma estação do ano e exiba-a preenchida com `.` à direita até completar 25 caracteres.
    1. Crie uma variável `str` com o nome de um país e exiba-o preenchido com `*` centralizado em um campo de 20 caracteres.
    1. Crie uma variável `str` com o nome de uma linguagem de programação e exiba-a preenchida com `-` à direita até completar 50 caracteres.

</details>
Índice

1. [módulo `sys`](#módulo-sys)
    1. [`sys.argv`](#sysargv)
    1. [`sys.exit`](#sysexit)
    1. [`sys.path`](#syspath)
    1. [`sys.stdin` `sys.stdout` `sys.stderr`](#sysstdin-sysstdout-sysstderr)
    1. [`sys.platform`](#sysplatform)
    1. [`sys.getsizeof`](#sysgetsizeof)
    1. [`sys.version` e `sys.version_info`](#sysversion-e-sysversion_info)
1. [exercícios módulo `sys`](#exercícios-módulo-sys)
1. [módulo `os`](#módulo-os)
    1. [`os.name`](#osname)
    1. [`os.getenv()` e `os.environ`](#osgetenv-e-osenviron)
    1. [`os.getcwd()` e `os.chdir`](#osgetcwd-e-oschdir)
    1. [`os.listdir()`](#oslistdir)
    1. [`os.mkdir()` e `os.makedirs()`](#osmodir-e-osmakedirs)
    1. [`os.remove()` e `os.rmdir()`](#osremove-e-osrmdir)
    1. [`os.rename()`](#osrename)
    1. [`os.path`](#ospath)
    1. [`os.system()`](#ossystem)
    1. [`os.popen()`](#ospopen)
1. [exercícios módulo `os`](#exercícios-módulo-os)
1. [módulo `random`](#módulo-random)
    1. [`random.random()`](#randomrandom)
    1. [`random.uniform(a, b)`](#randomuniformab)
    1. [`random.randint(a, b)`](#randomrandintab)
    1. [`random.randrange(start, stop, step)`](#randomrandrangestartstopstep)
    1. [`random.choice(seq)`](#randomchoiceseq)
    1. [`random.choices(population, k=1)`](#randomchoicespopulatiok)
    1. [`random.sample(population, k)`](#randomsamplepopulationk)
    1. [`random.shuffle(seq)`](#randomshuffleseq)
    1. [`random.seed()`](#randomseed)
    1. [`random.gauss(mu, sigma)`](#randomgaussmusgima)
    1. [`random.betavariate(alpha, beta)`](#randombetavariatealphabeta)
1. [exercícios módulo `random`](#exercícios-módulo-random)
1. [módulo `time`](#módulo-time)
    1.[`time.time()`](#timetime)
    1.[`time.sleep(segundos)`](#timesleepsegundos)
    1.[`time.localtime([segundos])`](#timelocaltimesegundos)
    1.[`time.strftime(formato[, struct_time])`](#timestrftimeformatostruct_time)
    1.[`time.gmtime([segundos])`](#timegmtimesegundos)
    1.[`time.mktime(t)`](#timemktimet)
    1.[`time.asctime([struct_time])`](#timeasctimestruct_time)
    1.[`time.ctime([segundos])`](#timectimesegundos)
    1.[`time.perf_counter()`](#timeperf_counter)
    1.[`time.monotonic()`](#timemonotonic)
    1.[`time.process_time()`](#timeprocess_time)
1. [exercícios módulo `time`](#exercícios-módulo-time)

# módulos

## módulo `sys`

O módulo `sys` em Python é um dos módulos built-in que fornecem funções e variáveis usadas para manipular diferentes partes do ambiente de execução do Python. Esse módulo é essencial para interagir com o sistema e o interpretador do Python.

### `sys.argv`

O atributo `sys.argv` é uma lista que armazena os argumentos passados ao script via linha de comando. O primeiro item da lista (`sys.argv[0]`) é sempre o nome do script. Os outros elementos são os argumentos que o usuário passou ao rodar o script.

**exemplo** :
Considere um script chamado `script.py` que é executado com alguns argumentos.

```python
# script.py
import sys

# imprime o nome do script
print("Nome do script :", sys.argv[0])

# verifica se foram passados argumentos
if len(sys.argv) > 1:
    # imprime os argumentos
    print("Argumentos :", sys.argv[1:])
else:
    print("Nenhum argumento foi passado.")
```

Se rodar o script com o comando :

```bash
python script.py argumento1 argumento2
```

A saída será :

```
Nome do script : script.py
Argumentos : ['argumento1', 'argumento2']
```

### `sys.exit()`

O `sys.exit()` é usado para encerrar o programa. Ele pode aceitar um argumento opcional para especificar o código de saída. Se for um número inteiro, o sistema usará esse número como código de status. O valor `0` geralmente indica que o programa foi finalizado com sucesso, e qualquer valor diferente de zero indica que ocorreu um erro.

**exemplo** :

```python
# script.py
import sys

def verificar_entrada():
    if len(sys.argv) < 2:
        print("Erro: Nenhum argumento foi passado!")
        sys.exit(1)  # Código de saída 1 indica erro
    else:
        print(f"Argumento fornecido: {sys.argv[1]}")

verificar_entrada()
```

Se rodarmos o script sem argumentos:

```bash
python script.py
```

A saída será:

```
Erro: Nenhum argumento foi passado!
```

E o código de saída será `1`, indicando que houve um erro.

### `sys.path`

O `sys.path` é uma lista de strings que especifica os diretórios onde o Python procura módulos quando se usa a instrução `import`. O Python verifica cada diretório dessa lista ao tentar localizar o módulo que você está importando.

**exemplo** :

```python
# script.py
import sys

# imprime o caminho de busca dos módulos
print("Caminhos de busca:")
for caminho in sys.path:
    print(caminho)
```

Se quiser adicionar um diretório específico para que o Python busque módulos nele, pode fazer o seguinte :

```python
import sys

# adiciona um novo caminho de busca
sys.path.append('/meu/diretorio/de/modulos')

# agora o python também buscará nesse caminho
print("Novo caminho de busca adicionado.")
```

Isso pode ser útil quando se tem módulos personalizados em diretórios fora do padrão.

### `sys.stdin`, `sys.stdout`, `sys.stderr`

Esses três atributos representam a entrada padrão (`sys.stdin`), a saída padrão (`sys.stdout`) e a saída de erro padrão (`sys.stderr`) do sistema.

- `sys.stdin` : usado para ler dados de entrada;
- `sys.stdout` : usado para exibir saídas normais;
- `sys.stderr` : usado para exibir mensagens de erro;

Por padrão, `sys.stdout` e `sys.stderr` são o console, e `sys.stdin` é o teclado, mas é possível redirecioná-los.

**exemplo** 1 : redirecionando a saída para um arquivo

```python
# script.py
import sys

# redireciona a saída padrão para um arquivo
with open("saida.txt", "w") as f:
    sys.stdout = f
    print("Essa mensagem será gravada no arquivo, não no console.")
```

Aqui, ao executar o script, a mensagem será escrita no arquivo `saida.txt`, em vez de aparecer no console. Posteriormente será visto como manipular arquivos.

**exemplo** 2 : usando `sys.stdin` para ler da entrada padrão

```python
# script.py
import sys

print("Digite algo:")
entrada = sys.stdin.read(5)  # Lê até 5 caracteres da entrada
print("Você digitou:", entrada)
```

Esse código permite que o usuário digite algo, e o Python lê até 5 caracteres.

### `sys.platform`

O `sys.platform` retorna uma string que identifica o sistema operacional em que o Python está sendo executado. Isso pode ser útil para garantir que o código seja executado corretamente em diferentes sistemas operacionais.

**exemplo** :

```python
# script.py
import sys

print(f"Este código está rodando no sistema: {sys.platform}")

if sys.platform.startswith("win"):
    print("O sistema é Windows.")
elif sys.platform.startswith("linux"):
    print("O sistema é Linux.")
elif sys.platform == "darwin":
    print("O sistema é macOS.")
```

### `sys.getsizeof()`

O `sys.getsizeof()` retorna o tamanho em bytes de um objeto em Python. Isso pode ser útil para verificar o consumo de memória de diferentes estruturas de dados.

**exemplo** :

```python
# script.py
import sys

lista = [1, 2, 3, 4, 5]
dicionario = {1: 'a', 2: 'b', 3: 'c'}

print(f"Tamanho da lista : {sys.getsizeof(lista)} bytes")
print(f"Tamanho do dicionário : {sys.getsizeof(dicionario)} bytes")
```

### `sys.version` e `sys.version_info`

- `sys.version` retorna a versão completa do Python como uma string;
- `sys.version_info` retorna a versão como uma tupla, o que é útil para verificações de compatibilidade;

**exemplo** :

```python
# script.py
import sys

print("Versão do Python (string):", sys.version)
print("Versão do Python (tupla):", sys.version_info)

# Verifica se está rodando no Python 3.x
if sys.version_info[0] == 3:
    print("Este script está sendo executado no Python 3.")
```

## exercícios módulo `sys`

<details>
<summary>Lista de Exercícios</summary>

1. Obtenha o caminho completo do Python instalado no sistema. Utilize `sys.executable` para imprimir o caminho.
1. Mostre a versão do Python que está sendo usada. Utilize `sys.version` para exibir a versão completa do Python.
1. Liste todos os diretórios em que o Python procura por módulos. Use `sys.path` para exibir os diretórios de busca.
1. Adicione um novo caminho ao `sys.path`. Adicione um diretório fictício à lista de caminhos de busca por módulos.
1. Faça com que o programa saia com um código de erro 1. Utilize `sys.exit(1)` para sair com o código de erro 1.
1. Implemente um programa que peça para o usuário inserir um número e saia se o número for negativo. Utilize `sys.exit()` para terminar o programa se a condição for satisfeita.
1. Mostre o tamanho da referência de um objeto. Utilize `sys.getsizeof()` para imprimir o tamanho de diferentes tipos de objetos (por exemplo, `int`, `str`, `list`).
1. Obtenha o nome da plataforma que o Python está executando. Use `sys.platform` para mostrar o nome da plataforma.
1. Escreva um programa que leia argumentos da linha de comando e os imprima. Utilize `sys.argv` para capturar e exibir argumentos passados via linha de comando.
1. Calcule a soma de dois números passados como argumentos da linha de comando. Use `sys.argv` para capturar dois números e calcule a soma deles.
1. Verifique quantos argumentos foram passados ao programa via linha de comando. Utilize `len(sys.argv)` para contar os argumentos passados.
1. Limite o recursão máxima do Python para 100 chamadas. Utilize `sys.setrecursionlimit(100)` e faça um programa para verificar o novo limite.
1. Imprima o limite máximo de recursão atual do Python. Utilize `sys.getrecursionlimit()` para exibir o limite.
1. Implemente uma função recursiva para calcular o fatorial e teste os limites de recursão. Use `sys.getrecursionlimit()` e ajuste o limite para testar diferentes profundidades de recursão.
1. Verifique se o sistema tem suporte para Unicode. Utilize `sys.maxunicode` para verificar a maior representação de Unicode disponível no sistema.
1. Calcule e mostre o número máximo de objetos que podem ser armazenados em uma variável. Utilize `sys.maxsize` para exibir o maior número que o Python consegue manipular.
1. Escreva um programa que imprima a saída de um número grande e identifique como ele é representado no sistema. Utilize `sys.float_info` para exibir os detalhes de representação de números em ponto flutuante.
1. Crie um programa que exiba o nome do arquivo atualmente sendo executado. Utilize `sys.argv[0]` para exibir o nome do script Python em execução.
1. Exiba o tamanho máximo de um número inteiro suportado pelo sistema. Utilize `sys.maxsize` para mostrar o maior número de inteiro que o Python suporta.
1. Capture e exiba o status final do interpretador Python antes da saída. Use `sys.flags` para exibir os diferentes sinais e flags que controlam o comportamento do interpretador.

</details>

## módulo `os`

O módulo `os` do Python fornece várias funcionalidades para interagir com o sistema operacional de maneira independente da plataforma. Isso significa que ele funciona tanto no Windows, quanto no Linux ou macOS, facilitando operações como manipulação de arquivos, diretórios, variáveis de ambiente, e muito mais.

### `os.name`

O `os.name` retorna uma string que indica o nome do sistema operacional no qual o código está sendo executado. Dependendo do sistema, a string pode ser:
- `'posix'` para sistemas como Linux e macOS;
- `'nt'` para sistemas Windows;

**exemplo** :

```python
# main.py
import os

print(f"Sistema operacional: {os.name}")

if os.name == 'nt':
    print("Este código está sendo executado no Windows.")
else:
    print("Este código está sendo executado em um sistema tipo Unix (Linux ou macOS).")
```

### `os.getenv()` e `os.environ`

O `os.getenv()` permite acessar variáveis de ambiente, enquanto `os.environ` é um dicionário que contém todas as variáveis de ambiente do sistema.

**exemplo** 1 : acessando uma variável de ambiente

```python
# main.py
import os

# acessa a variável de ambiente path
path = os.getenv('PATH')
print(f"Variável PATH: {path}")
```

**exemplo** 2 : listando todas as variáveis de ambiente

```python
# main.py
import os

# imprime todas as variáveis de ambiente
for chave, valor in os.environ.items():
    print(f"{chave}: {valor}")
```

**exemplo** 3: definindo uma variável de ambiente temporária

```python
# main.py
import os

# Define uma variável de ambiente temporária
os.environ['MINHA_VARIAVEL'] = 'valor_exemplo'

# Verifica se foi definida
print(f"MINHA_VARIAVEL: {os.getenv('MINHA_VARIAVEL')}")
```

### `os.getcwd()` e `os.chdir()`

O `os.getcwd()` retorna o diretório de trabalho atual (onde o script está sendo executado), e `os.chdir()` altera o diretório de trabalho para outro especificado.

**exemplo** 1 : obtendo o diretório atual

```python
# main.py
import os

# obtém o diretório de trabalho atual
diretorio_atual = os.getcwd()
print(f"Diretório atual: {diretorio_atual}")
```

**exemplo** 2 : mudando o diretório atual

```python
# main.py
import os

# muda o diretório de trabalho para "/home/user" (ou outro caminho válido no seu sistema)
os.chdir("/home/user")

# Verifica o diretório atual após a mudança
print(f"Novo diretório atual: {os.getcwd()}")
```

### `os.listdir()`

O `os.listdir()` retorna uma lista de todos os arquivos e diretórios em um determinado caminho.

**exemplo** :

```python
# main.py
import os

# Lista todos os arquivos e diretórios no diretório atual
arquivos = os.listdir()
print("Arquivos e diretórios no diretório atual:")
for arquivo in arquivos:
    print(arquivo)
```

Também é possível passar um caminho específico :

```python
# main.py
import os

# lista arquivos em um diretório específico
arquivos = os.listdir("/home/user")
print("Arquivos no diretório /home/user:")
for arquivo in arquivos:
    print(arquivo)
```

### `os.mkdir()` e `os.makedirs()`

- `os.mkdir()` cria um único diretório;
- `os.makedirs()` cria um diretório, incluindo todos os diretórios intermediários, se necessário;

**exemplo** 1 : criando um único diretório

```python
# main.py
import os

# cria um diretório chamado "novo_diretorio" no diretório atual
os.mkdir("novo_diretorio")
print("Diretório 'novo_diretorio' criado.")
```

**exemplo** 2 : criando diretórios intermediários

```python
# main.py
import os

# cria o diretório "dir1/dir2/dir3", incluindo todos os diretórios intermediários
os.makedirs("dir1/dir2/dir3")
print("Diretórios 'dir1/dir2/dir3' criados.")
```

### `os.remove()` e `os.rmdir()`

- `os.remove()` exclui um arquivo;
- `os.rmdir()` exclui um diretório vazio;

**exemplo** 1 : excluindo um arquivo

```python
# main.py
import os

# remove um arquivo chamado "arquivo.txt"
os.remove("arquivo.txt")
print("Arquivo 'arquivo.txt' removido.")
```

**exemplo** 2 : excluindo um diretório vazio

```python
# main.py
import os

# remove um diretório vazio chamado "meu_diretorio"
os.rmdir("meu_diretorio")
print("Diretório 'meu_diretorio' removido.")
```

### `os.rename()`

O `os.rename()` renomeia um arquivo ou diretório.

**exemplo** :

```python
# main.py
import os

# renomeia o arquivo "arquivo_velho.txt" para "arquivo_novo.txt"
os.rename("arquivo_velho.txt", "arquivo_novo.txt")
print("Arquivo renomeado para 'arquivo_novo.txt'.")
```

### `os.path`

O módulo `os` também contém o submódulo `os.path`, que oferece várias funções para manipulação de caminhos de arquivos.

**exemplo** 1 : verificando se um arquivo ou diretório existe

```python
# main.py
import os

# Verifica se o arquivo "meu_arquivo.txt" existe
if os.path.exists("meu_arquivo.txt"):
    print("O arquivo 'meu_arquivo.txt' existe.")
else:
    print("O arquivo 'meu_arquivo.txt' não existe.")
```

**exemplo** 2 : verificando se é um arquivo ou um diretório

```python
# main.py
import os

caminho = "meu_arquivo.txt"

if os.path.isfile(caminho):
    print(f"{caminho} é um arquivo.")
elif os.path.isdir(caminho):
    print(f"{caminho} é um diretório.")
else:
    print(f"{caminho} não é um arquivo nem um diretório.")
```

**exemplo** 3 : unindo partes de um caminho

```python
# main.py
import os

# junta diferentes partes de um caminho
caminho_completo = os.path.join("/home/user", "documentos", "arquivo.txt")
print(f"Caminho completo: {caminho_completo}")
```

### `os.system()`

O `os.system()` executa comandos diretamente no sistema operacional, como se fosse executado no terminal.

**exemplo** :

```python
# main.py
import os

# Executa o comando 'ls' no Linux/macOS ou 'dir' no Windows
os.system("ls")  # Use "dir" no Windows
```

Esse comando executa a listagem de arquivos no diretório atual (o comando específico varia conforme o sistema operacional).

### `os.popen()`

Enquanto `os.system()` executa um comando sem capturar a saída, `os.popen()` permite capturar a saída do comando.

**exemplo** :

```python
# main.py
import os

# executa o comando 'ls' e captura sua saída
comando = os.popen("ls")  # Use "dir" no Windows
saida = comando.read()

# exibe a saída capturada
print("Saída do comando:")
print(saida)
```

## exerícios módulo `os`

<details>
<summary>Lista de Exercícios</summary>

1. Liste todos os arquivos e diretórios do diretório atual. Utilize `os.listdir()` para listar o conteúdo do diretório atual.
1. Crie um novo diretório chamado `novo_diretorio` no diretório atual. Use `os.mkdir()` para criar o diretório.
1. Altere o diretório de trabalho atual para o diretório `novo_diretorio`. Utilize `os.chdir()` para alterar o diretório de trabalho.
1. Mostre o caminho completo do diretório de trabalho atual. Use `os.getcwd()` para obter o diretório atual.
1. Remova o diretório `novo_diretorio`. Utilize `os.rmdir()` para remover o diretório criado.
1. Crie um diretório aninhado chamado `pasta1/pasta2/pasta3`. Use `os.makedirs()` para criar a estrutura de diretórios.
1. Remova os diretórios aninhados `pasta1/pasta2/pasta3`. Utilize `os.removedirs()` para remover a árvore de diretórios.
1. Renomeie um arquivo ou diretório. Crie um arquivo ou diretório e renomeie-o usando `os.rename()`.
1. Obtenha informações sobre um arquivo, como seu tamanho e data de modificação. Utilize `os.stat()` para exibir informações detalhadas de um arquivo.
1. Verifique se um arquivo ou diretório existe. Use `os.path.exists()` para verificar se um arquivo ou diretório existe.
1. Verifique se o caminho é um diretório. Utilize `os.path.isdir()` para verificar se o caminho fornecido é um diretório.
1. Verifique se o caminho é um arquivo. Use `os.path.isfile()` para verificar se o caminho fornecido é um arquivo.
1. Obtenha o nome do diretório de um caminho fornecido. Utilize `os.path.dirname()` para extrair o diretório de um caminho.
1. Obtenha o nome do arquivo de um caminho fornecido. Use `os.path.basename()` para extrair o nome do arquivo de um caminho.
1. Separe a extensão do nome de um arquivo. Utilize `os.path.splitext()` para separar o nome e a extensão de um arquivo.
1. Junte dois caminhos de forma adequada ao sistema operacional. Use `os.path.join()` para combinar dois caminhos.
1. Obtenha o caminho absoluto de um arquivo. Utilize `os.path.abspath()` para converter um caminho relativo em absoluto.
1. Descubra o tamanho de um arquivo em bytes. Use `os.path.getsize()` para obter o tamanho de um arquivo.
1. Obtenha o nome de usuário que está executando o programa. Utilize `os.getlogin()` para exibir o nome do usuário atual.
1. Obtenha o ID do processo atual. Use `os.getpid()` para obter o ID do processo em execução.
1. Obtenha o ID do processo pai. Utilize `os.getppid()` para obter o ID do processo pai.
1. Defina uma nova variável de ambiente e exiba seu valor. Use `os.environ` para definir uma nova variável de ambiente e depois acesse seu valor.
1. Exiba todas as variáveis de ambiente do sistema. Utilize `os.environ` para listar todas as variáveis de ambiente.
1. Remova uma variável de ambiente do sistema. Use `os.environ.pop()` para remover uma variável de ambiente.
1. Execute um comando do sistema operacional usando Python. Utilize `os.system()` para executar um comando, como listar arquivos (`ls` ou `dir`).
1. Obtenha o caminho do diretório inicial do usuário. Use `os.path.expanduser('~')` para obter o diretório inicial do usuário.
1. Obtenha o separador de diretórios do sistema operacional atual. Utilize `os.sep` para exibir o separador de diretórios (`/` no Linux/Mac, `\` no Windows).
1. Obtenha o caminho do dispositivo null do sistema operacional. Use `os.devnull` para obter o caminho para o dispositivo null (`/dev/null` no Unix, `NUL` no Windows).
1. Suspenda a execução do programa por 5 segundos. Utilize `os.sleep(5)` para pausar a execução por 5 segundos.
1. Obtenha uma lista de todos os drives disponíveis no sistema (apenas Windows). Use `os.listdir()` com as letras dos drives e filtre os que estão disponíveis no sistema (Windows).

</details>

## módulo `random`

O módulo `random` do Python é utilizado para gerar números aleatórios e realizar operações aleatórias, como escolher itens de uma lista, embaralhar elementos e gerar números em diferentes intervalos. Ele é amplamente utilizado em várias aplicações, como simulações, jogos, amostragem e mais.

### `random.random()`

A função `random()` gera um número de ponto flutuante (decimal) entre 0.0 e 1.0, incluindo 0, mas excluindo 1.

**exemplo** :

```python
# main.py
import random

numero = random.random()
print(f"Número aleatório entre 0 e 1: {numero}")
```

Saída típica :
```
Número aleatório entre 0 e 1: 0.573019845657438
```

### `random.uniform(a, b)`

A função `uniform(a, b)` gera um número de ponto flutuante entre os valores `a` e `b`, incluindo ambos os limites.

**exemplo** :

```python
# main.py
import random

numero = random.uniform(10, 20)
print(f"Número aleatório entre 10 e 20: {numero}")
```

Saída típica :
```
Número aleatório entre 10 e 20: 15.678921305495
```

### `random.randint(a, b)`

A função `randint(a, b)` gera um número inteiro aleatório entre `a` e `b`, incluindo ambos os limites.

**exemplo** :

```python
# main.py
import random

numero = random.randint(1, 6)
print(f"Número inteiro aleatório entre 1 e 6: {numero}")
```

Saída típica :
```
Número inteiro aleatório entre 1 e 6: 4
```

### `random.randrange(start, stop, step)`

A função `randrange(start, stop, step)` gera um número inteiro aleatório no intervalo de `start` até `stop - 1`, com um incremento de `step`.

**exemplo** :

```python
# main.py
import random

numero = random.randrange(0, 10, 2)
print(f"Número aleatório par entre 0 e 10: {numero}")
```

Saída típica :
```
Número aleatório par entre 0 e 10: 4
```

Aqui, o valor gerado será um número par entre 0 e 8 (pois o `stop` é 10, mas o intervalo é até 9, e os números são gerados de 2 em 2).

### `random.choice(seq)`

A função `choice(seq)` escolhe aleatoriamente um item de uma sequência, como uma lista, tupla ou string.

**exemplo** :

```python
# main.py
import random

opcoes = ['pedra', 'papel', 'tesoura']
escolha = random.choice(opcoes)
print(f"Escolha aleatória: {escolha}")
```

Saída típica :
```
Escolha aleatória: papel
```

### `random.choices(population, k=1)`

A função `choices(population, k)` retorna uma lista com `k` elementos escolhidos aleatoriamente de uma população, permitindo repetições.

**exemplo** :

```python
# main.py
import random

cores = ['vermelho', 'verde', 'azul', 'amarelo']
escolhas = random.choices(cores, k=3)
print(f"Escolhas aleatórias: {escolhas}")
```

Saída típica :
```
Escolhas aleatórias: ['azul', 'verde', 'azul']
```

### `random.sample(population, k)`

A função `sample(population, k)` retorna uma lista com `k` elementos escolhidos aleatoriamente de uma população, sem repetições.

**exemplo** :

```python
# main.py
import random

numeros = list(range(1, 50))
sorteados = random.sample(numeros, k=6)
print(f"Números sorteados: {sorteados}")
```

Saída típica :
```
Números sorteados: [12, 8, 42, 33, 19, 7]
```

### `random.shuffle(seq)`

A função `shuffle(seq)` embaralha os itens de uma lista in-place, ou seja, a própria lista é modificada.

**exemplo** :

```python
import random

cartas = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']
random.shuffle(cartas)
print(f"Cartas embaralhadas: {cartas}")
```

Saída típica:
```
Cartas embaralhadas: ['7', '2', 'J', '4', '8', '3', 'A', 'K', '9', '10', '6', '5', 'Q']
```

### `random.seed()`

O comportamento da aleatoriedade no Python pode ser controlado usando `seed()`. Isso é útil quando você deseja que uma sequência de números aleatórios seja reprodutível.

**exemplo** :

```python
# main.py
import random

random.seed(10)
print(random.random())  # Sempre produzirá o mesmo resultado se seed(10) for usado.
print(random.random())  # Os mesmos números serão gerados sempre que seed(10) for usado.
```

Saída (sempre a mesma com `seed(10)`) :
```
0.5714025946899135
0.4288890546751146
```

### `random.gauss(mu, sigma)`

A função `gauss(mu, sigma)` gera números aleatórios seguindo uma distribuição normal (ou gaussiana). O parâmetro `mu` é a média da distribuição, e `sigma` é o desvio padrão.

**exemplo** :

```python
# main.py
import random

media = 0
desvio_padrao = 1

for _ in range(5):
    print(random.gauss(media, desvio_padrao))
```

Saída típica :
```
-0.3653743596198731
1.0199221852790466
0.1918015869367224
-0.9074770176164197
-0.19738118153188115
```

### `random.betavariate(alpha, beta)`

A função `betavariate(alpha, beta)` gera números seguindo uma distribuição beta, onde `alpha` e `beta` são parâmetros da distribuição.

**exemplo** :

```python
# main.py
import random

alpha = 2.0
beta = 5.0

for _ in range(5):
    print(random.betavariate(alpha, beta))
```

Saída típica :
```
0.2944020013389468
0.4153640288354197
0.28646777115539996
0.292441360879948
0.21664462489450598
```

## exercícios módulo `random`

<details>
<summary>Lista de Exercícios</summary>

1. Gere um número aleatório inteiro entre 1 e 10. Use `random.randint(1, 10)`.
1. Gere um número de ponto flutuante aleatório entre 0 e 1. Utilize `random.random()`.
1. Escolha aleatoriamente um elemento de uma lista. Use `random.choice()` com uma lista como argumento.
1. Escolha aleatoriamente 3 elementos diferentes de uma lista de 10 itens. Utilize `random.sample()` para selecionar 3 elementos.
1. Embaralhe aleatoriamente os elementos de uma lista. Use `random.shuffle()` para embaralhar os itens da lista.
1. Gere um número de ponto flutuante entre 5 e 10. Utilize `random.uniform(5, 10)`.
1. Gere um número aleatório de ponto flutuante com distribuição normal (gaussiana) com média 0 e desvio padrão 1. Use `random.gauss(0, 1)`.
1. Simule o lançamento de um dado de 6 lados 100 vezes e conte quantas vezes cada número apareceu. Use `random.randint()` e armazene os resultados em um dicionário ou lista.
1. Gere uma sequência aleatória de 5 números inteiros entre 1 e 50, sem repetição. Utilize `random.sample(range(1, 51), 5)`.
1. Gere uma senha aleatória de 8 caracteres usando letras e números. Use `random.choices()` com letras e números como entrada.
1. Escolha aleatoriamente um nome de uma lista de alunos. Utilize `random.choice()`.
1. Simule uma moeda sendo lançada 100 vezes e conte quantas vezes deu cara e quantas vezes deu coroa. Use `random.choice(['cara', 'coroa'])` em um loop.
1. Gere uma sequência aleatória de 6 números entre 1 e 60 (como uma simulação de loteria). Utilize `random.sample()` para gerar a sequência.
1. Gere um número aleatório entre 1 e 100 que seja múltiplo de 5. Use `random.choice(range(5, 101, 5))`.
1. Simule um jogo de roleta onde os números variam de 0 a 36. Utilize `random.randint(0, 36)` para simular a roleta.
1. Gere uma cor hexadecimal aleatória. Use `random.choice()` para selecionar valores de `0-9` e `A-F` e formar uma cor hexadecimal.
1. Crie uma lista de 10 números aleatórios e ordene-os em ordem crescente. Utilize `random.randint()` para gerar a lista e `sorted()` para ordená-la.
1. Implemente uma função que retorna um número aleatório par entre 1 e 100. Use `random.choice(range(2, 101, 2))`.
1. Simule o lançamento de dois dados e calcule a soma dos dois resultados. Utilize `random.randint(1, 6)` duas vezes e some os resultados.
1. Embaralhe uma lista de cartas (A, 2, 3, ..., K) e distribua 5 cartas. Use `random.shuffle()` e depois extraia os primeiros 5 elementos.
1. Simule o sorteio de uma rifa em que há 100 números e 5 são sorteados. Utilize `random.sample(range(1, 101), 5)`.
1. Gere uma lista de 10 números aleatórios entre 1 e 20, sem repetição, e verifique se há números repetidos. Use `random.sample()` e depois verifique duplicatas (não devem existir).
1. Gere uma sequência de 20 números aleatórios de ponto flutuante entre 0 e 1 e calcule a média. Use `random.random()` em um loop e calcule a média.
1. Implemente uma função que retorne um caractere aleatório de uma string. Utilize `random.choice()` para selecionar um caractere de uma string fornecida.
1. Crie um sistema simples de sorteio de prêmios, onde uma lista de prêmios é dada e um prêmio é escolhido aleatoriamente. Use `random.choice()` para selecionar o prêmio.
1. Simule a seleção de 3 alunos para um trabalho em grupo de uma turma de 20 alunos. Utilize `random.sample()` para selecionar 3 alunos de uma lista de 20.
1. Implemente uma função que simule o lançamento de 5 dados e retorne a soma dos valores. Utilize `random.randint()` em um loop para somar os resultados.
1. Crie um programa que simule uma senha de 4 dígitos numéricos. Use `random.choices(string.digits, k=4)` para gerar a senha.
1. Gere uma sequência aleatória de 8 caracteres composta de letras maiúsculas e minúsculas. Utilize `random.choices(string.ascii_letters, k=8)`.
1. Simule a geração de números de uma loteria onde 6 números são sorteados entre 1 e 49. Use `random.sample(range(1, 50), 6)`.
1. Implemente uma função que retorna um número aleatório ímpar entre 1 e 50. Use `random.choice(range(1, 51, 2))`.
1. Crie um programa que simule o embaralhamento de um baralho de cartas (semelhante ao exercício 20). Utilize `random.shuffle()` para embaralhar as cartas.
1. Gere uma lista de 10 números aleatórios entre 1 e 100 e encontre o maior valor. Use `random.randint()` para gerar a lista e `max()` para encontrar o maior valor.
1. Simule um jogo de dados em que 5 dados são lançados e o jogador ganha se a soma for maior que 18. Use `random.randint(1, 6)` em um loop e calcule a soma.
1. Crie uma função que simule uma rodada de "pedra, papel e tesoura" entre dois jogadores. Utilize `random.choice(['pedra', 'papel', 'tesoura'])` para cada jogador.
1. Simule a escolha de um elemento de uma lista ponderada, onde alguns elementos têm mais chances de serem escolhidos. Use `random.choices()` com pesos fornecidos.
1. Implemente uma função que retorne uma lista de 5 números aleatórios inteiros entre 10 e 100. Utilize `random.randint(10, 100)` em um loop ou `random.sample()`.
1. Implemente um jogo simples de adivinhação onde o programa gera um número entre 1 e 20 e o usuário tem que adivinhar. Utilize `random.randint(1, 20)` para gerar o número e peça ao usuário para adivinhar.
1. Gere uma lista de 5 números de ponto flutuante entre 0 e 10 e calcule o valor mínimo. Utilize `random.uniform(0, 10)` e `min()` para encontrar o menor valor.
1. Implemente um jogo de "cara ou coroa" onde o usuário pode jogar quantas vezes quiser. Use `random.choice(['cara', 'coroa'])`.
1. Crie uma função que gere uma lista de 5 números aleatórios entre 0 e 1 e retorne o maior valor. Utilize `random.random()` em um loop e `max()` para o maior valor.
1. Simule a distribuição de cartas em um jogo de pôquer para 4 jogadores. Use `random.sample()` para distribuir as cartas de um baralho.
1. Crie uma função que retorne uma letra aleatória (maiúscula ou minúscula). Use `random.choice(string.ascii_letters)`.
1. Simule o lançamento de uma moeda 1000 vezes e conte quantas vezes deu "cara". Use `random.choice()` em um loop.
1. Gere uma sequência aleatória de 20 números inteiros entre 0 e 100 e calcule a média. Utilize `random.randint(0, 100)` e `sum()` para calcular a média.

</details>

## módulo `time`

O módulo `time` do Python oferece várias funções para trabalhar com tempo, como a manipulação de horas, minutos, segundos, e funções para medir o tempo que uma ação leva para ser concluída. Ele é muito utilizado para calcular a duração de eventos, fazer pausas (delays) no código, além de obter e manipular o tempo no formato de segundos desde a *"época"* (epoch), que geralmente é 1º de janeiro de 1970 no sistema UNIX.

### `time.time()`

Essa função retorna o número de segundos desde a *"época"*, ou seja, um número do tipo *float* que representa o tempo em segundos.  A *"época"* (epoch) é o ponto de referência para a contagem do tempo. No Unix, a *epoch* é definida como meia-noite (00:00:00) de 1 de janeiro de 1970.

**exemplo :**
```python
import time
segundos = time.time()
print(f"Segundos desde 1º de janeiro de 1970: {segundos}")
```

### `time.sleep(segundos)`

Essa função faz com que o programa pause ou "durma" por um determinado número de segundos. É útil em casos onde se deseja que o código aguarde um certo tempo antes de prosseguir.

**exemplo :**
```python
import time
print("Esperando 5 segundos...")
time.sleep(5)
print("Fim da espera.")
```

### `time.localtime([segundos])`

Essa função converte o tempo dado em segundos desde a *epoch* em um objeto de tempo local (`struct_time`). Se nenhum argumento for fornecido, ela utiliza o tempo atual (retornado por `time.time()`). O objeto `struct_time` tem vários atributos como `tm_year` (ano), `tm_mon` (mês), `tm_mday` (dia do mês), `tm_hour` (hora), etc.

**exemplo :**
```python
import time
tempo_atual = time.localtime()
print(f"Ano atual: {tempo_atual.tm_year}")
print(f"Mês atual: {tempo_atual.tm_mon}")
print(f"Dia atual: {tempo_atual.tm_mday}")
```

### `time.strftime(formato[, struct_time])`

Converte um objeto `struct_time` em uma string formatada, de acordo com a especificação de formato fornecida. Por exemplo, `%Y` para ano completo, `%m` para mês, `%d` para dia do mês, `%H` para hora (formato 24h), `%M` para minutos, `%S` para segundos.

Mais Formatos [aqui](https://docs.python.org/3/library/time.html#time.strftime)

**exemplo :**
```python
import time
tempo_atual = time.localtime()
formato = time.strftime("%Y-%m-%d %H:%M:%S", tempo_atual)
print(f"Data e hora formatada: {formato}")
```

### `time.gmtime([segundos])`

Semelhante a `time.localtime()`, mas retorna o tempo no fuso horário UTC (Tempo Universal Coordenado), em vez do fuso horário local.

**exemplo :**
```python
import time
tempo_utc = time.gmtime()
print(f"Ano atual (UTC): {tempo_utc.tm_year}")
```

### `time.mktime(t)`

Faz o inverso de `time.localtime()` ou `time.gmtime()`, convertendo uma estrutura de tempo (`struct_time`) em segundos desde a *epoch*.

**exemplo :**
```python
import time
tempo_local = time.localtime()
segundos = time.mktime(tempo_local)
print(f"Segundos desde a epoch para a hora local: {segundos}")
```

### `time.asctime([struct_time])`

Converte um objeto `struct_time` em uma string no formato: `'Dia_sem Mês Dia Hora:Min:Seg Ano'`. Se não for fornecido nenhum argumento, usa o tempo local.

**exemplo :**
```python
import time
print(time.asctime())  # Exemplo de saída: 'Tue Sep  6 10:05:12 2024'
```

### `time.ctime([segundos])`

Converte o tempo, em segundos desde a epoch, em uma string legível. Se nenhum argumento for passado, usa o tempo atual.

**exemplo :**
```python
import time
print(time.ctime())  # Exemplo de saída: 'Tue Sep  6 10:05:12 2024'
```

### `time.perf_counter()`

Retorna o valor de um temporizador de alta resolução, medido em segundos. É útil para medir o tempo de execução de trechos de código.

**exemplo :**
```python
import time
inicio = time.perf_counter()
time.sleep(2)
fim = time.perf_counter()
print(f"Tempo decorrido: {fim - inicio} segundos")
```

### `time.monotonic()`

Similar a `time.perf_counter()`, mas este temporizador não pode ser ajustado para frente ou para trás (não é afetado por mudanças no relógio do sistema).

**exemplo :**
```python
import time
inicio = time.monotonic()
time.sleep(1)
fim = time.monotonic()
print(f"Tempo decorrido: {fim - inicio} segundos")
```

### `time.process_time()`

Retorna o tempo de CPU usado pelo processo atual, em segundos.

**exemplo :**
```python
import time
inicio = time.process_time()
# Simulando um processo que consome CPU
for i in range(1000000):
    pass
fim = time.process_time()
print(f"Tempo de CPU usado: {fim - inicio} segundos")
```

---

### exemplos práticos do módulo `time`

#### exemplo de contagem regressiva

Use `time.sleep()` para implementar uma contagem regressiva.

```python
import time

def contagem_regressiva(segundos):
    while segundos:
        mins, secs = divmod(segundos, 60)
        timer = '{:02d}:{:02d}'.format(mins, secs)
        print(timer, end="\r")
        time.sleep(1)
        segundos -= 1
    print("Tempo esgotado!")

contagem_regressiva(10)
```

#### medição do tempo de execução de uma função

Usando `time.perf_counter()` para medir quanto tempo uma função leva para ser executada.

```python
import time

def funcao_lenta():
    print("Executando uma função lenta...")
    time.sleep(3)
    print("Função concluída.")

inicio = time.perf_counter()
funcao_lenta()
fim = time.perf_counter()

print(f"A função demorou {fim - inicio:.2f} segundos para ser executada.")
```

#### imprimindo a data e hora atual formatada

Usando `time.strftime()` para formatar a hora em um formato legível.

```python
import time

agora = time.localtime()
formato = time.strftime("%A, %d de %B de %Y, %H:%M:%S", agora)
print(f"Data e hora atual: {formato}")
```

#### medindo o tempo de cpu usado por um processo

Usando `time.process_time()` para ver quanto tempo de CPU foi utilizado.

```python
import time

inicio = time.process_time()
for i in range(10000000):
    pass
fim = time.process_time()

print(f"Tempo de CPU usado: {fim - inicio:.4f} segundos")
```

## exercícios módulo `time`

<details>
<summary>Lista de Exercícios</summary>

1. Exibindo o Tempo Atual. Use a função `time.time()` para exibir a quantidade de segundos desde o "Epoch" (01/01/1970).
1. Exibindo o Tempo em Formato Estruturado. Use a função `time.gmtime()` para exibir a data e hora atual no formato UTC (tempo universal coordenado).
1. Formatando o Tempo Local. Utilize a função `time.localtime()` para exibir a data e hora local. Em seguida, formate essa saída para mostrar apenas o ano, mês e dia.
1. Formatando uma Data Customizada. Use `time.strftime()` para formatar a data atual no formato `"Ano-Mês-Dia Hora:Minuto:Segundo"`.
1. Convertendo uma String de Data para um Struct_time. Utilize a função `time.strptime()` para converter a string `"12/09/2024 14:30:00"` para um objeto `struct_time`.
1. Exibindo Apenas o Ano Atual. Use a função `time.localtime()` para obter o ano atual e exibi-lo.
1. Medição de Tempo de Execução de Código. Crie um script que utilize `time.time()` para medir quanto tempo demora para executar um loop que itera 1 milhão de vezes.
1. Pausando a Execução do Programa. Use `time.sleep()` para pausar a execução do programa por 5 segundos.
1. Imprimindo um Relógio Simples. Crie um loop que utilize `time.sleep()` e `time.localtime()` para imprimir a hora atual a cada segundo, como um relógio simples.
1. Calculando a Diferença Entre Duas Datas. Use a função `time.mktime()` para calcular a diferença em segundos entre duas datas fornecidas.
1. Convertendo Tempo UTC para Tempo Local. Use a função `time.gmtime()` para pegar o tempo atual em UTC e, em seguida, converta para a hora local usando `time.localtime()`.
1. Exibindo o Tempo em Milissegundos. Modifique o programa para exibir o tempo atual em milissegundos usando `time.time()`.
1. Gerando um Timestamp Customizado. Crie um timestamp customizado para a data `01/01/2020 00:00:00` usando `time.mktime()`.
1. Exibindo a Data Atual em Diferentes Formatos. Use `time.strftime()` para exibir a data atual em três formatos diferentes (como "dd-mm-aaaa", "aaaa/mm/dd", etc.).
1. Validando uma Data a Partir de uma String. Use `time.strptime()` para validar se a string `"30/02/2020"` é uma data válida.
1. Verificando se é Horário de Verão. Use a função `time.localtime()` para verificar se o horário atual está em horário de verão (DST).
1. Simulando uma Contagem Regressiva. Crie um script que faça uma contagem regressiva de 10 segundos usando `time.sleep()`.
1. Comparando Duas Datas. Use `time.mktime()` para comparar duas datas fornecidas e determine qual é a mais recente.
1. Exibindo o Dia da Semana Atual. Utilize `time.localtime()` para determinar o dia da semana (onde 0 é segunda-feira e 6 é domingo).
1. Calculando o Tempo Restante para o Próximo Ano. Calcule quantos segundos faltam para o início do próximo ano (01/01/2025 00:00:00) a partir da data e hora atual.
1. Imprimindo a Data e Hora de 7 Dias Atrás. Use `time.time()` e `time.localtime()` para calcular e exibir a data e hora de 7 dias atrás.
1. Formatando o Tempo para Horário Completo e Amigável. Use `time.strftime()` para formatar a hora atual no formato `"12-hour:minute AM/PM"`.
1. Convertendo uma Data e Hora para o Timestamp. Crie uma data e hora arbitrária, como `"25/12/2024 15:00:00"`, e converta para o timestamp usando `time.mktime()`.
1. Exibindo o Mês Atual. Extraia e exiba o mês atual usando `time.localtime()`.
1. Implementando um Temporizador de 10 Segundos. Crie um programa que avise o usuário após 10 segundos, utilizando `time.sleep()`.
1. Calculando o Intervalo de Tempo Entre Duas Execuções. Crie um programa que execute duas funções e calcule o intervalo de tempo entre elas usando `time.perf_counter()`.
1. Convertendo uma Hora UTC para Horário Local. Pegue a hora UTC usando `time.gmtime()` e converta para a hora local usando `time.localtime()`.
1. Exibindo o Tempo de Início do Script. Use `time.ctime()` para exibir o horário em que o script foi iniciado.
1. Exibindo a Data Atual em Diferentes Idiomas. Use `time.strftime()` e altere as configurações de idioma do sistema para exibir a data atual em diferentes idiomas (pode ser feito manualmente no sistema operacional).

</details>
Índice

1. [sintaxe](#sintaxe)
1. [exemplos](#exemplos)
1. [cuidados](#cuidados)
1. [comparando](#comparando)
1. [exercícios](#exercícios)

# operador ternário

O operador ternário em Python é uma forma concisa de escrever uma expressão condicional, permitindo que você atribua um valor a uma variável ou execute uma operação com base em uma condição, tudo em uma única linha de código. Em vez de usar a estrutura tradicional `if-else`, o operador ternário simplifica a sintaxe.

## sintaxe

A sintaxe do operador ternário em Python é a seguinte:

```python
<valor_se_verdadeiro> if <condicao> else <valor_se_falso>
```

- **condicao** : a expressão que será avaliada como `True` ou `False`;
- **valor_se_verdadeiro** : o valor ou expressão que será retornado se a condição for `True`;
- **valor_se_falso** : o valor ou expressão que será retornado se a condição for `False`;

## exemplos

### 1. atribuição simples

```python
>>> idade = 18
>>> status = "Maior de idade" if idade >= 18 else "Menor de idade"
>>> print(status)
Maior de idade
>>> |
```

- aqui, a condição `idade >= 18` é verificada;
- se for `True`, a variável `status` recebe o valor `"Maior de idade"`;
- caso contrário, ela recebe `"Menor de idade"`;

### 2. verificação de paridade

```python
>>> numero = 4
>>> paridade = "Par" if numero % 2 == 0 else "Ímpar"
>>> print(paridade)
Par
>>> |
```

- a condição `numero % 2 == 0` verifica se o número é par;
- se for `True`, `paridade` recebe `"Par"`;
- caso contrário, recebe `"Ímpar"`;

### 3. usando o operador ternário com funções

```python
>>> def obter_preco(desconto):
...     return 50 if desconto else 100
...
>>> preco = obter_preco(True)
>>> print(preco)
50
>>> |
```

- a função `obter_preco` retorna 50 se `desconto` for `True`, e 100 caso contrário;
- no exemplo, a função é chamada com `True`, então o preço será 50;

### 4. múltiplas condições

```python
>>> nota = 85
>>> resultado = "Aprovado" if nota >= 60 else "Reprovado"
>>> print(resultado)
Aprovado
>>> |
```

- a condição `nota >= 60` verifica se a nota é suficiente para aprovação;
- se `True`, retorna `"Aprovado"`, caso contrário, `"Reprovado"`;

### 5. encadeamento de operadores ternários

```python
>>> idade = 17
>>> categoria = "Criança" if idade < 13 else "Adolescente" if idade < 18 else "Adulto"
>>> print(categoria)
Adolescente
>>> |
```

- aqui, é verificado várias condições em sequência :
  1. se `idade < 13`, retorna `"Criança"`;
  1. se `idade < 18` (mas não menor que 13), retorna `"Adolescente"`;
  1. se nenhuma das anteriores for verdadeira, retorna `"Adulto"`;

Veja o exemplo acima, mas usando parênteses para melhor visualização de cada bloco :

```python
>>> idade = 17
>>> categoria = ("Criança" if idade < 13 else ("Adolescente" if idade < 18 else "Adulto"))
>>> print(categoria)
Adolescente
>>> |
```

### 6. usando com valores booleanos

```python
>>> x = True
>>> y = False
>>> resultado = "Ambos Verdadeiros" if x and y else "Ao menos um Falso"
>>> print(resultado)
Ao menos um Falso
>>> |
```

- a condição `x and y` é avaliada;
- se ambos `x` e `y` forem `True`, retorna `"Ambos Verdadeiros"`;
- caso contrário, retorna `"Ao menos um Falso"`;

### 7. atribuindo resultados a variáveis

```python
>>> a = 5
>>> b = 10
>>> maior = a if a > b else b
>>> print(maior)
10
>>> |
```

- A condição `a > b` é verificada.
- Se for `True`, `maior` recebe `a`, caso contrário, `b`.

## cuidados

Embora a estrutura ajude a deixar o código mais claro e mais conciso, ela também pode deixar o código bem complicado de ler.

Veja um exemplo abaixo :

```python
>>> nota = 95
>>>
>>> # vários if-else ternários
>>> resultado = 'A+' if nota > 90 else 'A' if nota > 80 else 'B' if nota > 70 else 'C' if nota > 60 else 'D' if nota > 40 else 'Reprovado'
>>> resultado
'A+'
>>>
>>> # mesma estrutura, mas com os parênteses para "melhor" visualização
>>> resultado = ('A+' if nota > 90 else ('A' if nota > 80 else ('B' if nota > 70 else ('C' if nota > 60 else ('D' if nota > 40 else ('Reprovado'))))))
>>> resultado
'A+'
>>>
>>> # agora usando os parênteses e separando em blocos individuais
>>> resultado = (
...     'A+' if nota > 90 else (
...         'A' if nota > 80 else (
...             'B' if nota > 70 else (
...                 'C' if nota > 60 else (
...                     'D' if nota > 40 else (
...                         'Reprovado'
...                     )
...                 )
...             )
...         )
...     )
... )
...
>>> resultado
'A+'
>>> |
```

Embora ela seja prática, o exemplo acima fica **muito** melhor de entender e visualizar se usar o `if-elif-else` tradicional. Veja abaixo como ficaria :

```python
>>> if nota > 90:
...     resultado = 'A+'
... elif nota > 80:
...     resultado = 'A'
... elif nota > 70:
...     resultado = 'B'
... elif nota > 60:
...     resultado = 'C'
... elif nota > 40:
...     resultado = 'D'
... else:
...     resultado = 'Reprovado'
...
>>> resultado
'A+'
>>> |
```

## comparando

Abaixo há diversos exemplos do *mesmo* uso do `if` tradicional e do `if` com operador ternário :

1. verificando positivo e negativo :
    ```python
    >>> numero = -3
    >>>
    >>> # versão tradicional
    >>> if numero > 0:
    ...     resultado = "Positivo"
    ... else:
    ...     resultado = "Negativo ou Zero"
    ...
    >>> print(resultado)
    Negativo ou Zero
    >>>
    >>> # operador ternário
    >>> resultado = "Positivo" if numero > 0 else "Negativo ou Zero"
    >>> print(resultado)
    Negativo ou Zero
    >>> |
    ```

1. verificação de maioridade
    ```python
    >>> idade = 20
    >>>
    >>> # versão tradicional
    >>> if idade >= 18:
    ...     maioridade = True
    ... else:
    ...     maioridade = False
    ...
    >>> print(maioridade)
    True
    >>>
    >>> # operador ternário
    >>> maioridade = True if idade >= 18 else False
    >>> print(maioridade)
    True
    >>> |
    ```

1. verificação de vazio em uma string
    ```python
    >>> texto = ""
    >>>
    >>> # versão tradicional
    >>> if not texto:
    ...     status = "Vazio"
    ... else:
    ...     status = "Contém Texto"
    ...
    >>> print(status)
    Vazio
    >>>
    >>> # operador ternário
    >>> status = "Vazio" if not texto else "Contém Texto"
    >>> print(status)
    Vazio
    >>> |
    ```

1. verificação de paridade com números
    ```python
    >>> numero = 7
    >>>
    >>> # versão tradicional
    >>> if numero % 2 == 0:
    ...     paridade = "Par"
    ... else:
    ...     paridade = "Ímpar"
    ...
    >>> print(paridade)
    Ímpar
    >>>
    >>> # operador ternário
    >>> paridade = "Par" if numero % 2 == 0 else "Ímpar"
    >>> print(paridade)
    Ímpar
    >>> |
    ```

1. seleção de mensagem baseada em horário
    ```python
    >>> hora = 15
    >>>
    >>> # versão tradicional
    >>> if hora < 12:
    ...     mensagem = "Bom dia"
    ... else:
    ...     mensagem = "Boa tarde"
    ...
    >>> print(mensagem)
    Boa tarde
    >>>
    >>> # operador ternário
    >>> mensagem = "Bom dia" if hora < 12 else "Boa tarde"
    >>> print(mensagem)
    Boa tarde
    >>> |
    ```

## exercícios

<details>
<summary>Lista de Exercícios</summary>

> [!TIP]
> para os seguintes execícios :
> - primeiro, crie a versão tradicional do exercício;
> - depois, a partir da primeira, crie a versão de operador ternário;

Exemplo :
```python
>>> # **Verificação Simples**: Dada uma variável `x = 10`, use o operador
>>> # ternário para definir uma variável `resultado` como `"Maior que 5"` se
>>> # `x` for maior que 5, caso contrário `"Menor ou igual a 5"`.
>>> # Imprima `resultado`.
>>>
>>> x = 10
>>>
>>> # usando o if-else tradicional
>>> resultado = ''
>>> if x > 5:
...     resultado = "Maior que 5"
... else:
...     resultado = "Menor ou igual a 5"
...
>>> print(resultado)
Menor ou igual a 5
>>>
>>> # usando operador ternário
>>> resultado = "Maior que 5" if x > 5 else "Menor ou igual a 5"
>>> print(resultado)
Menor ou igual a 5
>>> |
```

1. Nível Simples
    1. **Verificação Simples**: Dada uma variável `x = 10`, use o operador ternário para definir uma variável `resultado` como `"Maior que 5"` se `x` for maior que 5, caso contrário `"Menor ou igual a 5"`. Imprima `resultado`.
    1. **Par ou Ímpar**: Dado um número `n = 7`, use o operador ternário para definir uma variável `paridade` como `"Par"` se `n % 2 == 0`, caso contrário `"Ímpar"`. Imprima `paridade`.
    1. **Verificação de String Vazia**: Dada uma string `s = "Python"`, use o operador ternário para definir uma variável `status` como `"Vazia"` se `s` for vazia, caso contrário `"Não vazia"`. Imprima `status`.
    1. **Maior de Dois Números**: Dadas duas variáveis `a = 8` e `b = 5`, use o operador ternário para definir a variável `maior` como o maior entre `a` e `b`. Imprima `maior`.
    1. **Verificação de Booleano**: Dado um booleano `flag = True`, use o operador ternário para definir uma variável `mensagem` como `"Ativo"` se `flag` for `True`, caso contrário `"Inativo"`. Imprima `mensagem`.
1. Nível Intermediário
    1. **Comprimento de Lista**: Dada uma lista `lst = [1, 2, 3, 4]`, use o operador ternário para definir uma variável `comprimento` como `"Curta"` se a lista tiver menos de 5 elementos, caso contrário `"Longa"`. Imprima `comprimento`.
    1. **Verificação de Tupla**: Dada uma tupla `t = (5, 10)`, use o operador ternário para definir uma variável `tipo` como `"Par"` se a soma dos elementos for par, caso contrário `"Ímpar"`. Imprima `tipo`.
    1. **Multiplicação ou Soma**: Dado um número `x = 3`, use o operador ternário para definir uma variável `resultado` como `x * 2` se `x` for maior que 5, caso contrário `x + 2`. Imprima `resultado`.
    1. **Verificação de String Maiúscula**: Dada uma string `s = "Hello"`, use o operador ternário para definir uma variável `case` como `"Maiúscula"` se `s` estiver em maiúsculas, caso contrário `"Minúscula ou mista"`. Imprima `case`.
    1. **Positivo ou Negativo**: Dado um número `n = -4`, use o operador ternário para definir uma variável `sinal` como `"Positivo"` se `n` for maior ou igual a 0, caso contrário `"Negativo"`. Imprima `sinal`.
1. Nível Avançado
    1. **Verificação de Elemento em Lista**: Dada uma lista `lst = [1, 2, 3]`, use o operador ternário para definir uma variável `presente` como `"Contém 2"` se `2` estiver na lista, caso contrário `"Não contém 2"`. Imprima `presente`.
    1. **Comprimento de String**: Dada uma string `s = "Python"`, use o operador ternário para definir uma variável `comprimento` como `"Curta"` se a string tiver menos de 6 caracteres, caso contrário `"Longa"`. Imprima `comprimento`.
    1. **Verificação de Tupla Vazia**: Dada uma tupla `t = ()`, use o operador ternário para definir uma variável `status` como `"Vazia"` se a tupla estiver vazia, caso contrário `"Não vazia"`. Imprima `status`.
    1. **Verificação de Lista Aninhada**: Dada uma lista `lst = [[1, 2], [3, 4]]`, use o operador ternário para definir uma variável `aninhada` como `"Contém listas"` se o primeiro elemento de `lst` for uma lista, caso contrário `"Não contém listas"`. Imprima `aninhada`.
    1. **Escolha de String Baseada em Comprimento**: Dada uma string `s = "Hello"`, use o operador ternário para definir uma variável `mensagem` como `"Curta"` se `s` tiver 5 caracteres ou menos, caso contrário `"Longa"`. Imprima `mensagem`.
1. Nível Complexo
    1. **Operação Condicional**: Dado um número `n = 15`, use o operador ternário para definir uma variável `resultado` como `n ** 2` se `n` for maior que 10, caso contrário `n / 2`. Imprima `resultado`.
    1. **Verificação de Paridade com Lista**: Dada uma lista `lst = [2, 4, 6]`, use o operador ternário para definir uma variável `paridade` como `"Par"` se a soma dos elementos da lista for par, caso contrário `"Ímpar"`. Imprima `paridade`.
    1. **Verificação de Multiplicidade**: Dado um número `x = 21`, use o operador ternário para definir uma variável `multiplicidade` como `"Multiplo de 7"` se `x` for múltiplo de 7, caso contrário `"Não é múltiplo de 7"`. Imprima `multiplicidade`.
    1. **Verificação de Tupla Aninhada**: Dada uma tupla `t = ((1, 2), (3, 4))`, use o operador ternário para definir uma variável `aninhada` como `"Aninhada"` se o primeiro elemento de `t` for uma tupla, caso contrário `"Não aninhada"`. Imprima `aninhada`.
    1. **Escolha de Lista Baseada em Comprimento**: Dada uma lista `lst = [1, 2, 3, 4, 5, 6]`, use o operador ternário para definir uma variável `tamanho` como `"Curta"` se a lista tiver 5 elementos ou menos, caso contrário `"Longa"`. Imprima `tamanho`.
1. Nível Muito Complexo
    1. **Escolha de Elemento em Lista**: Dada uma lista `lst = [10, 20, 30]`, use o operador ternário para definir uma variável `elemento` como o primeiro elemento da lista se ela tiver mais de 2 elementos, caso contrário o último elemento. Imprima `elemento`.
    1. **Verificação de Substring**: Dada uma string `s = "Python é divertido"`, use o operador ternário para definir uma variável `existe` como `"Contém 'divertido'"` se `"divertido"` estiver presente na string, caso contrário `"Não contém 'divertido'"`. Imprima `existe`.
    1. **Verificação de Comprimento de Tupla**: Dada uma tupla `t = (1, 2, 3, 4)`, use o operador ternário para definir uma variável `quantidade` como `"Mais de 3 elementos"` se a tupla tiver mais de 3 elementos, caso contrário `"3 ou menos elementos"`. Imprima `quantidade`.
    1. **Comparação de Tuplas**: Dadas duas tuplas `t1 = (1, 2)` e `t2 = (3, 4)`, use o operador ternário para definir uma variável `comparação` como `"Tupla 1 maior"` se o primeiro elemento de `t1` for maior que o de `t2`, caso contrário `"Tupla 2 maior"`. Imprima `comparação`.

</details>
# recursão

A **recursão** é uma técnica de programação onde uma função chama a si mesma para resolver um problema. É usada quando um problema pode ser dividido em subproblemas menores de forma semelhante ao problema original, permitindo que o código se repita até alcançar uma condição de parada (base case), que é quando o problema não pode mais ser dividido ou resolvido por chamadas subsequentes.

## como funciona

A recursão segue um padrão em que uma função realiza duas ações principais:

1. **condição base (ou condição de parada)** : esta é a condição que determina quando a recursão deve parar. Sem uma condição base, a recursão continuaria indefinidamente, causando um erro de "stack overflow" (estouro da pilha) porque a memória reservada para as chamadas da função ficaria esgotada;

2. **chamada recursiva** : a função chama a si mesma com um novo argumento, que é uma versão reduzida ou alterada do problema original. Essa chamada recursiva é o que permite que a função repita o processo para resolver o subproblema;

A cada vez que uma função é chamada, o Python cria um novo **frame de execução** na pilha de chamadas (call stack), o que significa que cada chamada recursiva aguarda a conclusão da chamada anterior. Quando a condição base é atingida, o resultado é retornado e a pilha de chamadas começa a "desenrolar", retornando os resultados de volta pelas chamadas anteriores até o ponto inicial.

## exemplos de uso

### fatorial

Um exemplo clássico de recursão é o cálculo do fatorial de um número. O fatorial de um número (n) (denotado como (n!)) é o produto de todos os números inteiros positivos até (n).

**definição matemática** :
- n! = n * (n - 1) * (n - 2) * ... * 1

- Ou, recursivamente :
  - n! = n * (n - 1)! (com (1! = 1) como caso base)

Em Python, isso pode ser escrito assim:

```python
>>> def fatorial(n):
...     # condição base: fatorial de 0 ou 1 é 1
...     if n == 0 or n == 1:
...         return 1
...     # chamada recursiva: n * fatorial de (n - 1)
...     return n * fatorial(n - 1)
...
>>> print(fatorial(5))
120
>>> |
```

Aqui, o `fatorial(5)` chamará `fatorial(4)`, que chamará `fatorial(3)`, e assim por diante até chegar em `fatorial(1)`. A partir daí, os valores são retornados até a função original.

### sequência de fibonacci

Outro exemplo clássico é a **Sequência de Fibonacci**, onde o próximo número na sequência é a soma dos dois anteriores. A sequência começa com 0 e 1.

**definição recursiva** :
- Fibonacci(n) = Fibonacci(n-1) + Fibonacci(n-2)
- Caso base: Fibonacci(0) = 0, Fibonacci(1) = 1

A implementação em Python seria :

```python
>>> def fibonacci(n):
...     # condição base: fibonacci(0) é 0 e fibonacci(1) é 1
...     if n == 0:
...         return 0
...     elif n == 1:
...         return 1
...     # chamada recursiva: fibonacci(n-1) + fibonacci(n-2)
...     return fibonacci(n - 1) + fibonacci(n - 2)
...
>>> print(fibonacci(6))
8
>>> |
```

Nesse exemplo, `fibonacci(6)` chamará `fibonacci(5)` e `fibonacci(4)`, e assim por diante, até que os casos base sejam alcançados.

## para que se usa

A recursão é útil em várias situações onde um problema pode ser dividido de forma natural em subproblemas menores que podem ser resolvidos da mesma maneira. Alguns exemplos incluem:

1. **problemas de divisão e conquista** : como algoritmos de ordenação como merge sort e quick sort, que dividem um problema grande em partes menores e resolvem essas partes recursivamente;

2. **problemas com árvores ou grafos** : a recursão é frequentemente usada em estruturas de dados como árvores e grafos, onde cada nó pode ser tratado de maneira recursiva;

3. **soluções elegantes para problemas matemáticos** : muitos problemas matemáticos, como o cálculo de potências, combinações, ou recorrências, podem ser resolvidos recursivamente;

4. **algoritmos de busca** : como a busca em profundidade (depth first search) em grafos, onde cada vizinho é visitado recursivamente;

## como usar

Para usar recursão de forma eficaz, siga estas etapas :

1. **defina a condição base** : esta é a parte mais importante para evitar loops infinitos. Sempre certifique-se de que a função possui uma condição clara que encerra a recursão;

2. **reduza o problema** : a cada chamada recursiva, reduza o problema, de forma que ele se aproxime da condição base. Isso pode ser feito alterando o argumento da função;

3. **chame a função recursivamente** : chame a função novamente com o argumento modificado para resolver o subproblema;

## ponto de atenção

### pilha de chamadas e limite de recursão

Cada chamada recursiva consome memória na **pilha de chamadas** (call stack). Em Python, há um limite de profundidade de recursão (padrão de 1000 chamadas), que pode ser verificado e alterado, se necessário:

```python
>>> import sys
>>> print(f'{sys.getrecursionlimit() = }')
sys.getrecursionlimit() = 1000
>>>
>>> sys.setrecursionlimit(2000)
>>>
>>> print(f'{sys.getrecursionlimit() = }')
sys.getrecursionlimit() = 2000
>>>
>>> |
```

Isso evita o "stack overflow" em situações onde a recursão não termina ou o número de chamadas recursivas é muito grande.

## quando evitar

Embora a recursão possa ser elegante e direta, nem sempre é a solução mais eficiente. Recursões mal planejadas podem levar a desperdício de memória e tempo, especialmente em problemas onde as chamadas se repetem muitas vezes, como no exemplo da sequência de Fibonacci. Nestes casos, técnicas como **memorização** ou transformar a recursão em **iteração** podem ser mais eficientes.

## recursão vs. iteração

- **recursão** : resolve o problema chamando a função repetidamente e dividindo o problema em subproblemas;
- **iteração** : resolve o problema usando laços (como `while` ou `for`) e controlando diretamente o fluxo com variáveis de estado;

Exemplo da sequência de Fibonacci de forma iterativa:

```python
>>> def fibonacci_iterativo(n):
...     a, b = 0, 1
...     for _ in range(n):
...         a, b = b, a + b
...     return a
...
>>> print(fibonacci_iterativo(6))
8
>>> |
```

A versão iterativa costuma ser mais eficiente em termos de uso de memória e tempo de execução.

## exemplos

Abaixo há 5 exemplos que mostram como resolver problemas tanto de forma **recursiva** quanto **iterativa**. Cada problema é resolvido com essas duas abordagens.

---

### 1. soma de uma lista de números

#### versão recursiva :

```python
>>> def soma_recursiva(lista):
...     # condição base : lista vazia
...     if len(lista) == 0:
...         return 0
...     # chamada recursiva : soma o primeiro elemento com a soma do restante da lista
...     return lista[0] + soma_recursiva(lista[1:])
...
>>> print(soma_recursiva([1, 2, 3, 4]))
10
>>> |
```

#### versão iterativa :

```python
>>> def soma_iterativa(lista):
...     soma = 0
...     for num in lista:
...         soma += num
...     return soma
...
>>> print(soma_iterativa([1, 2, 3, 4]))
10
>>> |
```

---

### 2. contagem regressiva

#### versão recursiva :

```python
>>> def contagem_regressiva_recursiva(n):
...     if n == 0:
...         print("Lançar!")
...     else:
...         print(n)
...         contagem_regressiva_recursiva(n - 1)
...
>>> contagem_regressiva_recursiva(5)
5, 4, 3, 2, 1, Lançar!
>>> |
```

#### versão iterativa :

```python
>>> def contagem_regressiva_iterativa(n):
...     while n > 0:
...         print(n)
...         n -= 1
...     print("Lançar!")
...
>>> contagem_regressiva_iterativa(5)
5, 4, 3, 2, 1, Lançar!
>>> |
```

---

### 3. produto dos elementos de uma lista

#### versão recursiva :

```python
>>> def produto_recursivo(lista):
...     if len(lista) == 0:
...         return 1
...     return lista[0] * produto_recursivo(lista[1:])
...
>>> print(produto_recursivo([1, 2, 3, 4]))
24
>>> |
```

#### versão iterativa :

```python
>>> def produto_iterativo(lista):
...     produto = 1
...     for num in lista:
...         produto *= num
...     return produto
...
>>> print(produto_iterativo([1, 2, 3, 4]))
24
>>> |
```

---

### 4. reverter uma string

#### versão recursiva :

```python
>>> def reverter_string_recursiva(s):
...     if len(s) == 0:
...         return ""
...     return s[-1] + reverter_string_recursiva(s[:-1])
...
>>> print(reverter_string_recursiva("python"))
nohtyp
>>> |
```

#### versão iterativa :

```python
>>> def reverter_string_iterativa(s):
...     resultado = ""
...     for char in s:
...         resultado = char + resultado
...     return resultado
...
>>> print(reverter_string_iterativa("python"))
nohtyp
>>> |
```

---

### 5. verificar se um número é par

#### versão recursiva :

```python
>>> def eh_par_recursivo(n):
...     if n == 0:
...         return True
...     elif n == 1:
...         return False
...     return eh_par_recursivo(n - 2)
...
>>> print(eh_par_recursivo(8))
True
>>> print(eh_par_recursivo(7))
False
>>> |
```

#### versão iterativa :

```python
>>> def eh_par_iterativo(n):
...     while n > 1:
...         n -= 2
...     return n == 0
...
>>> print(eh_par_iterativo(8))
True
>>> print(eh_par_iterativo(7))
False
>>> |
```

---

Esses exemplos mostram como a recursão é usada para quebrar um problema em subproblemas menores, enquanto a iteração usa laços para alcançar o mesmo resultado. Dependendo do problema e da sua complexidade, uma abordagem pode ser mais eficiente que a outra.

## exercícios

<details>
<summary>Lista de Exercícios</summary>

Para cada exercício abaixo, primeiro monte uma função de sua versão usando a iteração e depois sua versão usando a recursão.

1. **Soma dos primeiros N números naturais** : Escreva uma função recursiva que calcule a soma dos primeiros N números naturais.
1. **Fatorial de um número** : Crie uma função recursiva que calcule o fatorial de um número \(n!\).
1. **Soma dos elementos de uma lista** : Escreva uma função recursiva que receba uma lista de números e retorne a soma de seus elementos.
1. **Produto dos elementos de uma lista** : Crie uma função recursiva que calcule o produto dos elementos de uma lista.
1. **Contagem regressiva** : Implemente uma função recursiva que faça uma contagem regressiva de um número N até 0.
1. **Sequência de Fibonacci** : Escreva uma função recursiva para calcular o N-ésimo número da sequência de Fibonacci.
1. **Inverter uma string** : Crie uma função recursiva que inverta uma string.
1. **Contar ocorrências de um caractere em uma string** : Implemente uma função recursiva que conte quantas vezes um determinado caractere aparece em uma string.
1. **Número de dígitos de um número** : Escreva uma função recursiva que determine o número de dígitos de um número inteiro.
1. **Verificar se um número é par** : Crie uma função recursiva para verificar se um número é par sem usar operadores aritméticos além de subtração.
1. **Máximo divisor comum (MDC)** : Implemente o algoritmo de Euclides para encontrar o MDC entre dois números usando recursão.
1. **Imprimir os elementos de uma lista de trás para frente** : Escreva uma função recursiva que imprima os elementos de uma lista em ordem inversa.
1. **Somar todos os dígitos de um número** : Crie uma função recursiva que receba um número inteiro e retorne a soma de seus dígitos.
1. **Verificar se uma palavra é palíndromo** : Implemente uma função recursiva que verifique se uma string é um palíndromo (lê-se da mesma forma de trás para frente).
1. **Exponenciação** : Escreva uma função recursiva que calcule o valor de \(a^b\), onde \(a\) é a base e \(b\) é o expoente.
1. **Soma dos números pares de uma lista** : Crie uma função recursiva que receba uma lista de números e retorne a soma de todos os números pares.
1. **Somar elementos de uma lista de listas** : Escreva uma função recursiva que some todos os elementos de uma lista que contém outras listas.
1. **Encontrar o menor elemento de uma lista** : Implemente uma função recursiva que encontre o menor número em uma lista de números.
1. **Substituir um caractere em uma string** : Crie uma função recursiva que substitua todas as ocorrências de um caractere específico em uma string por outro caractere.
1. **Contar elementos em uma lista aninhada** : Escreva uma função recursiva que conte quantos elementos (incluindo os das sublistas) existem em uma lista aninhada.

</details>

# revisão

## contador e acumulador

Acumuladores e contadores são muito comuns em estruturas de repetição.

- **contador** é usado para realizar uma determinada contagem na repetição;
- **acumulador** é usado para realizar uma operação onde os valores se acumulam ao longo das repetições;

```python
# declarando as variáveis antes do loop while
contador = 0  # via de regra se inicia em 0, mas não é obrigatório
acumulador = 0  # aqui, terá o comportamento de somar a cada repetição
controlador = 10  # usada para controlar a quando a condição no while será falsa

while controlador < 43:
    # mostra cada valor em cada repetição
    print(f'{contador = }')
    print(f'{acumulador = }')
    print(f'{controlador = }\n')

    // incrementa o acumulador com o valor do contador
    acumulador = acumulador + controlador

    // incrementa o controlador
    controlador = controlador + 3

    // aumenta o contador em 1
    contador = contador + 1

print(f'o while repetiu {contador}x')
print(f'o acumulador somou {acumulador}.')
```

## iterando sobre uma lista

Há diversas formas de se iterar (passar por cada element) sobre uma lista.

Quando se usa o loop `while`, é preciso manualmente definir uma variável de controle de suas repetições. Se é preciso que ele passe por uma lista de 4 palavras (como no exemplo abaixo), então é comum usar uma variável de índice (chamada de `indice` ou apenas `i`) para que, ao mesmo tempo que é usada como condição de parada do `while`, é usada para passar por todos os elementos da lista.

Quando se usa o loop `for`, ele precisa que uma variável seja especificada. Essa variável irá, a cada repetição, receber um valor da lista. Sempre o seguinte. Ele faz isso automaticamente a cada repetição. Dessa forma, torna-se desnecessário criar uma variável de controle, pois o `for` controla quando o final do iterável é atingido.

Entende-se por iterável no Python qualquer tipo de variável onde seja possível passar por seus subelementos individualmente.

```python
lista_palavras = ['uma', 'dois', 'tres', 'quatro']

print('for loop')
for uma_palavra in lista_palavras:
    print(f'{uma_palavra = }')

print('\nwhile loop')
i = 0
while i < len(lista_palavras):
    uma_palavra = lista_palavras[i]
    print(f'{uma_palavra = }')
    i = i + 1
```

Eventualmente, pode ser necessário que o loop seja repetido infinitamente. Então, pode-se usar um `True` na sua condição, mas é necessário que seja criada uma forma de interromper a repetição. No exemplo abaixo, enquando a resposta não for igual a `sim`, a repetição irá acontecer indefinidamente.

```python
sair = False
while not sair:
    resposta = input('quer sair ?')
    if resposta == 'sim':
        sair = True
```

## formas de mostrar o valor das variáveis

Existem várias formas de mostrar o valor de uma variável.
No exemplo abaixo, as formas 1 e 2 são as mais antigas.
- a forma 1, apesar de funcionar perfeitamente, ela não permite muita formatação na hora de exibir o valor de suas variáveis, além de deixar a leitura do código mais complicada, por conta de todas as vírgulas e aspas necessárias entre as strings e variáveis.
- a forma 2, apesar de ainda funcionar, não é mais usada.
- a forma 3 já permite uma maior flexibilidade na hora de exibir os valores das variáveis.
- a forma 4 é a mais moderna de todas. Ela permite uma leitura muito mais fluída do código, além de facilitar saber que variável está indo aonde.

```python
v1 = 10
v2 = 12
v3 = 15

print('v1 =',v1,'\nv2 =',v2,'\nv3 =',v3)  # forma 1
print()
print('v1 = %d\nv2 = %d\nv3 = %d' % (v1,v2,v3))  # forma 2
print()
print('v1 = {}\nv2 = {}\nv3 = {}'.format(v1,v2,v3))  # forma 3
print()
print(f'v1 = {v1}\nv2 = {v2}\nv3 = {v3}')  # forma 4
```

## índices nas strings

As strings nada mais são que agrupamentos de letras (caracteres). Então, é possível iterar sobre elas de modo a obter seus caracteres individualmente.

```python
# posicoes na string
#            01234567890123
sobrenome = 'Schwarzenegger'
i = 0

while i < len(sobrenome):
    letra = sobrenome[i]

    if i in (9, 10):
        print(f'{letra = }')
    else:
        print('nao sei')

    i = i + 1
```
Índice

1. [características](#características)
1. [criando dicionários](#criando-dicionários)
1. [adicionando itens ao dicionário](#adicionando-itens-ao-dicionário)
1. [métodos](#métodos)
    1. [dict.keys()](#dictkeys)
    1. [dict.values()](#dictvalues)
    1. [dict.items()](#dictitems)
1. [exercícios](#exercícios)

# tipo dicionário

Um dicionário em Python é uma estrutura de dados que armazena pares de chave-valor, onde cada chave é única e mapeia para um valor. Essa estrutura é semelhante a um mapa ou tabela de associação, onde a chave atua como um identificador que permite acessar seu valor correspondente de forma rápida e eficiente.

## características

1. **pares chave-valor** : cada elemento em um dicionário é composto por uma chave e um valor associados. Por exemplo, em `{'nome': 'João', 'idade': 25}`, `'nome'` e `'idade'` são chaves, enquanto `'João'` e `25` são os valores associados a essas chaves;

2. **chaves únicas** : as chaves em um dicionário devem ser únicas. Se você tentar adicionar uma chave que já existe, o valor associado a essa chave será sobrescrito;

3. **ordem de inserção** : a partir do Python 3.7, os dicionários mantêm a ordem de inserção dos itens. Isso significa que ao iterar sobre um dicionário, os pares chave-valor aparecerão na ordem em que foram adicionados;

4. **mutabilidade** : os dicionários são mutáveis, ou seja, é possível adicionar, remover ou modificar pares chave-valor após a criação do dicionário;

5. **tipagem mista** : tanto as chaves quanto os valores em um dicionário podem ser de qualquer tipo de dado, desde que as chaves sejam de um tipo imutável (como strings, números ou tuplas). Os valores podem ser de qualquer tipo, incluindo listas, outros dicionários ou até mesmo funções;

## criando dicionários

### criação de um dicionário simples
```python
# criando um dicionário simples
aluno = {
    'nome': 'Maria',
    'idade': 22,
    'curso': 'Engenharia'
}

# acessando valores através das chaves
print(aluno['nome'])   # saída : Maria
print(aluno['idade'])  # saída : 22
```

- **chaves** : no exemplo acima, `'nome'`, `'idade'` e `'curso'` são as chaves. Elas são usadas para identificar cada valor armazenado no dicionário;
- **valores** : `'Maria'`, `22` e `'Engenharia'` são os valores correspondentes às chaves;

### chaves de diferentes tipos
```python
# dicionário com chaves de diferentes tipos
informacoes = {
    'nome': 'Carlos',
    1: [2, 4, 8],
    (3, 4): 'tupla como chave'
}

print(informacoes['nome'])   # saída : Carlos
print(informacoes[1])        # saída : [2, 4, 8]
print(informacoes[(3, 4)])   # saída : tupla como chave
```

Neste exemplo:
- A chave `'nome'` é uma string;
- A chave `1` é um número inteiro;
- A chave `(3, 4)` é uma tupla;

### sobrescrita de valores
```python
# dicionário simples
dados = {
    'cidade': 'São Paulo',
    'populacao': 12000000
}

# sobrescrevendo o valor associado à chave 'populacao'
dados['populacao'] = 12300000

print(dados['populacao'])  # saída : 12300000
```

Neste caso, o valor associado à chave `'populacao'` foi atualizado de `12000000` para `12300000`.

## adicionando itens ao dicionário

Adicionar itens a um dicionário em Python é um processo simples e pode ser feito de várias maneiras.

### utilizando a notação de colchetes

A maneira mais comum de adicionar um item a um dicionário é utilizando a notação de colchetes. Uma nova chave é especificada entre colchetes e atribuida a ela um valor. Se a chave já existir, o valor associado a essa chave será atualizado; se a chave não existir, um novo par chave-valor será adicionado ao dicionário.

```python
# dicionário inicial
dados = {
    'nome': 'Ana',
    'idade': 30
}

# adicionando um novo item
dados['cidade'] = 'Rio de Janeiro'

print(dados)
# saída: {'nome': 'Ana', 'idade': 30, 'cidade': 'Rio de Janeiro'}
```

Neste exemplo:
- Adicionamos a chave `'cidade'` com o valor `'Rio de Janeiro'` ao dicionário `dados`.

### adicionando itens dentro de um loop

Também é possível adicionar itens a um dicionário dentro de um loop, o que é útil quando se está processando uma lista de dados ou precisa construir um dicionário dinamicamente.

```python
# lista de dados
nomes = ['João', 'Maria', 'José']
idades = [25, 22, 30]

# dicionário inicial vazio
dados = {}

# populando o dicionário dentro de um loop
for i in range(len(nomes)):
    dados[nomes[i]] = idades[i]

print(dados)
# Saída: {'João': 25, 'Maria': 22, 'José': 30}
```

Neste exemplo:
- Usamos um loop para adicionar os nomes como chaves e as idades como valores ao dicionário `dados`.

### adicionar itens usando compreensão de dicionários

A compreensão de dicionários é uma maneira concisa de criar e adicionar itens a um dicionário em uma única linha de código, especialmente quando se está transformando ou filtrando dados.

```python
# Lista de dados
nomes = ['Ana', 'Bruno', 'Clara']
idades = [23, 31, 29]

# Usando compreensão de dicionários
dados = {nomes[i]: idades[i] for i in range(len(nomes))}

print(dados)
# Saída: {'Ana': 23, 'Bruno': 31, 'Clara': 29}
```

Neste exemplo:
- Criamos o dicionário `dados` utilizando compreensão de dicionários, onde as chaves são os nomes e os valores são as idades.

## métodos

Os métodos `keys()`, `values()` e `items()` dos dicionários em Python são utilizados para acessar diferentes partes do dicionário de forma organizada e eficiente. Esses métodos são muito úteis quando se precisa iterar sobre as chaves, valores ou pares chave-valor de um dicionário.

### `dict.keys()`

O método `keys()` retorna uma visão (`view`) das chaves do dicionário. Essa visão é um objeto especial que reflete as chaves atuais do dicionário e pode ser usada para iterar sobre elas. Se o dicionário for modificado (por exemplo, se novas chaves forem adicionadas ou removidas), a visão retornada por `keys()` será automaticamente atualizada.

```python
# dicionário exemplo
dados = {
    'nome': 'Alice',
    'idade': 27,
    'cidade': 'Brasília'
}

# usando keys() para obter as chaves
chaves = dados.keys()

print(chaves)
# Saída: dict_keys(['nome', 'idade', 'cidade'])

# iterando sobre as chaves
for chave in chaves:
    print(chave)
# Saída:
# nome
# idade
# cidade
```

Neste exemplo:
- `keys()` retorna um objeto `dict_keys`, que é uma visão das chaves do dicionário.
- Podemos iterar sobre esse objeto para acessar cada chave.

### `dict.values()`

O método `values()` retorna uma visão dos valores contidos no dicionário. Assim como o `keys()`, a visão retornada por `values()` reflete qualquer modificação feita no dicionário, mantendo os valores atualizados.

```python
# dicionário exemplo
dados = {
    'nome': 'Roberto',
    'idade': 34,
    'cidade': 'Salvador'
}

# Usando values() para obter os valores
valores = dados.values()

print(valores)
# Saída: dict_values(['Roberto', 34, 'Salvador'])

# Iterando sobre os valores
for valor in valores:
    print(valor)
# Saída:
# Roberto
# 34
# Salvador
```

Neste exemplo:
- `values()` retorna um objeto `dict_values`, que é uma visão dos valores do dicionário.
- Podemos iterar sobre esse objeto para acessar cada valor armazenado no dicionário.

### `dict.items()`

O método `items()` retorna uma visão dos pares chave-valor do dicionário, onde cada item é representado por uma tupla. Essa tupla contém a chave como o primeiro elemento e o valor associado como o segundo. Assim como nos outros métodos, a visão retornada por `items()` é dinâmica e reflete qualquer modificação feita no dicionário.

```python
# dicionário exemplo
dados = {
    'nome': 'Lucas',
    'idade': 21,
    'cidade': 'Fortaleza'
}

# Usando items() para obter os pares chave-valor
pares = dados.items()

print(pares)
# Saída: dict_items([('nome', 'Lucas'), ('idade', 21), ('cidade', 'Fortaleza')])

# Iterando sobre os pares chave-valor
for chave, valor in pares:
    print(f'{chave}: {valor}')
# Saída:
# nome: Lucas
# idade: 21
# cidade: Fortaleza
```

Neste exemplo:
- `items()` retorna um objeto `dict_items`, que é uma visão dos pares chave-valor do dicionário.
- Podemos iterar sobre esse objeto, onde cada iteração nos dá uma tupla contendo a chave e seu valor associado.

### comparação entre os métodos

| Método     | O que retorna                      | Exemplo de Uso                              |
|------------|------------------------------------|---------------------------------------------|
| `keys()`   | Visão (`dict_keys`) das chaves     | Iterar sobre as chaves ou verificar sua existência |
| `values()` | Visão (`dict_values`) dos valores  | Iterar sobre os valores ou manipular diretamente os dados armazenados |
| `items()`  | Visão (`dict_items`) dos pares chave-valor | Iterar sobre pares chave-valor para operações que envolvem tanto a chave quanto o valor |

## execícios

<details>
<sumamry>Lista de Exercícios</sumamry>

1. Criação e Modificação de Dicionários
    1. **Crie um dicionário** chamado `produto` com as chaves `'nome'`, `'preco'` e `'quantidade'`, atribuindo valores de sua escolha a essas chaves.
    1. **Altere o valor** da chave `'preco'` do dicionário `produto` para um novo valor.
    1. **Adicione uma nova chave** `'categoria'` ao dicionário `produto`, com o valor `'eletrônico'`.
    1. **Remova a chave `'quantidade'`** do dicionário `produto`.
    1. **Crie um dicionário vazio** chamado `aluno` e adicione as chaves `'nome'`, `'idade'` e `'curso'` com valores apropriados.
    1. **Atualize o valor** da chave `'curso'` no dicionário `aluno` para `'Medicina'`.
    1. **Crie um dicionário** chamado `endereco` com as chaves `'rua'`, `'numero'` e `'cidade'`. Altere o valor da chave `'cidade'` para uma nova cidade.
    1. **Crie um dicionário** `carro` com as chaves `'marca'`, `'modelo'`, `'ano'`, e `'cor'`. Adicione a chave `'placa'` com um valor ao dicionário.
    1. **Altere o valor** da chave `'ano'` no dicionário `carro` para o ano atual.
    1. **Crie um dicionário** `pedido` com as chaves `'item'`, `'quantidade'` e `'preco_unitario'`. Adicione uma nova chave `'total'` que multiplica `'quantidade'` por `'preco_unitario'`.
1. Compreensão de Dicionários
    1. **Crie um dicionário** usando compreensão onde as chaves são números de 1 a 5 e os valores são os quadrados desses números.
    1. **Crie um dicionário** usando compreensão onde as chaves são letras de `'a'` a `'e'` e os valores são essas letras em maiúsculo.
    1. **Crie um dicionário** usando compreensão onde as chaves são os primeiros 5 números ímpares e os valores são os cubos desses números.
    1. **Crie um dicionário** usando compreensão onde as chaves são os números de 1 a 10 e os valores são `'par'` ou `'ímpar'`, dependendo do número.
    1. **Crie um dicionário** usando compreensão onde as chaves são os números de 1 a 5 e os valores são strings que descrevem se o número é `'pequeno'`, `'médio'` ou `'grande'` (1-2, 3, 4-5).
    1. **Crie um dicionário** onde as chaves são os nomes de 5 frutas e os valores são os comprimentos desses nomes.
    1. **Crie um dicionário** usando compreensão onde as chaves são os números de 1 a 5 e os valores são as chaves multiplicadas por 10.
    1. **Crie um dicionário** com compreensão onde as chaves são as primeiras 5 letras do alfabeto e os valores são seus respectivos índices (a=1, b=2, etc.).
    1. **Crie um dicionário** onde as chaves são os nomes de 4 cidades e os valores são o número de letras em cada nome.
    1. **Crie um dicionário** onde as chaves são os números de 1 a 10 e os valores são `'positivo'` ou `'negativo'`, dependendo se o número é positivo ou negativo (considerando 1 a 5 como positivos).
1. Métodos `keys()`, `values()` e `items()`
    1. **Crie um dicionário** com três chaves: `'nome'`, `'idade'` e `'cidade'`. Use o método `keys()` para imprimir todas as chaves do dicionário.
    1. **Crie um dicionário** com três chaves: `'produto'`, `'preco'` e `'quantidade'`. Use o método `values()` para imprimir todos os valores do dicionário.
    1. **Crie um dicionário** com três chaves: `'pais'`, `'capital'`, `'populacao'`. Use o método `items()` para imprimir todos os pares chave-valor.
    1. **Crie um dicionário** com cinco pares chave-valor. Use um loop para iterar sobre as chaves do dicionário usando o método `keys()`.
    1. **Crie um dicionário** com cinco pares chave-valor. Use um loop para iterar sobre os valores do dicionário usando o método `values()`.
    1. **Crie um dicionário** com cinco pares chave-valor. Use um loop para iterar sobre os pares chave-valor do dicionário usando o método `items()`.
    1. **Crie um dicionário** com três pares chave-valor. Adicione uma nova chave ao dicionário e observe como o método `keys()` reflete essa alteração.
    1. **Crie um dicionário** com três pares chave-valor. Altere o valor de uma das chaves e observe como o método `values()` reflete essa alteração.
    1. **Crie um dicionário** com três pares chave-valor. Remova uma chave do dicionário e observe como o método `items()` reflete essa alteração.
    1. **Crie um dicionário** com chaves de diferentes tipos (string, número, tupla). Use o método `keys()` para listar as chaves e comente sobre os tipos de dados das chaves.
1. Operações Combinadas
    1. **Crie um dicionário** com três pares chave-valor. Adicione uma nova chave e depois use `items()` para verificar o novo par.
    1. **Crie um dicionário** com cinco pares chave-valor. Use `keys()` para obter as chaves e adicione um novo par chave-valor ao dicionário. Imprima as chaves novamente para verificar a alteração.
    1. **Crie um dicionário** que associa nomes de alunos a suas notas. Adicione uma nova nota para um aluno existente e use `items()` para verificar a alteração.
    1. **Crie um dicionário** com os nomes de três cidades como chaves e suas populações como valores. Use `values()` para calcular a população total.
    1. **Crie um dicionário** com três pares chave-valor. Altere um valor existente e adicione um novo par. Verifique as mudanças usando `items()`.
    1. **Crie um dicionário** com três chaves. Use `keys()` para iterar e alterar os valores associados a essas chaves.
    1. **Crie um dicionário** usando compreensão de dicionários. Use `values()` para verificar os valores gerados.
    1. **Crie um dicionário** onde as chaves são os nomes de alunos e os valores são suas idades. Use `keys()` para imprimir todos os nomes e depois adicione um novo aluno.
    1. **Crie um dicionário** que associa produtos a seus preços. Aumente o preço de cada produto em 10% usando `items()` e um loop.
    1. **Crie um dicionário** onde as chaves são países e os valores são suas capitais. Use `items()` para iterar e imprimir cada país e sua capital no formato "A capital de X é Y".

</details>
Índice

1. [características do frozenset](#características-do-frozenset)
1. [criando um frozenset](#criando-um-frozenset)
1. [operações com frozensets](#operações-com-frozensets)
1. [métodos do frozenset](#métodos-do-frozenset)
    1. [frozenset.copy()](#frozensetcopy)
    1. [frozenset.union()](#frozensetunion)
    1. [frozenset.intersection()](#frozensetintersection)
    1. [frozenset.difference()](#frozensetdifference)
    1. [frozenset.issubset()](#frozensetissubset)
    1. [frozenset.issuperset()](#frozensetissuperset)
    1. [frozenset.isdisjoint()](#frozensetisdisjoint)
1. [aplicações práticas](#aplicações-práticas)
1. [limitações](#limitações)
1. [exercícios](#exercícios)

# `frozenset`

O tipo `frozenset` no Python é uma variação imutável do tipo `set`. Enquanto os conjuntos (`sets`) são coleções de elementos que não permitem duplicatas e cujas ordens não são garantidas, os `frozensets` adicionam a característica de imutabilidade a essa estrutura, tornando os elementos dentro dela impossíveis de serem modificados após sua criação.

## características do `frozenset`

- **imutabilidade** : ao contrário de um `set`, um `frozenset` não pode ser alterado depois de criado. Isso significa que não se pode adicionar, remover ou modificar elementos dentro de um `frozenset` após a sua criação;

- **sem elementos duplicados** : assim como os `sets`, `frozensets` não permitem elementos duplicados. se tentar criar um `frozenset` com elementos repetidos, ele automaticamente removerá as duplicatas;

- **ordenação indefinida** : os elementos dentro de um `frozenset` não têm uma ordem específica. mesmo que os insira em uma determinada ordem, eles podem não ser recuperados nessa mesma ordem;

- **hashable** : como os `frozensets` são imutáveis, eles são hashable. isso significa que um `frozenset` pode ser usado como chave em um dicionário ou como elemento em outro `set`;

## criando um `frozenset`

Pode-se criar um `frozenset` de diferentes maneiras:

1. **a partir de um set ou outro iterável** :
    ```python
    >>> fs = frozenset({1, 2, 3, 4})
    >>> print(fs)
    frozenset({1, 2, 3, 4})
    >>> |
    ```

2. **a partir de uma lista** :
    ```python
    >>> fs = frozenset([1, 2, 3, 3, 4])
    >>> print(fs)
    frozenset({1, 2, 3, 4})
    >>> |
    ```

3. **a partir de uma string** :
    ```python
    >>> fs = frozenset("abracadabra")
    >>> print(fs)
    frozenset({'a', 'r', 'b', 'c', 'd'})
    >>> |
    ```

## operações com `frozensets`

Mesmo sendo imutáveis, ainda pode-se realizar várias operações com `frozensets`, muitas das quais são similares às operações que se pode fazer com `sets`.

- **união (`|`)** :
    Combina todos os elementos de dois `frozensets` sem duplicação.
    ```python
    >>> fs1 = frozenset({1, 2, 3})
    >>> fs2 = frozenset({3, 4, 5})
    >>> fs3 = fs1 | fs2
    >>> print(fs3)
    frozenset({1, 2, 3, 4, 5})
    >>> |
    ```

- **interseção (`&`)** :
    Retorna apenas os elementos que estão presentes em ambos os `frozensets`.
    ```python
    >>> fs1 = frozenset({1, 2, 3})
    >>> fs2 = frozenset({2, 3, 4})
    >>> fs3 = fs1 & fs2
    >>> print(fs3)
    frozenset({2, 3})
    >>> |
    ```

- **diferença (`-`)** :
    Retorna os elementos que estão no primeiro `frozenset`, mas não no segundo.
    ```python
    >>> fs1 = frozenset({1, 2, 3})
    >>> fs2 = frozenset({2, 3, 4})
    >>> fs3 = fs1 - fs2
    >>> print(fs3)
    frozenset({1})
    >>> |
    ```

- **diferença simétrica (`^`)** :
    Retorna os elementos que estão em um `frozenset` ou no outro, mas não em ambos.
    ```python
    >>> fs1 = frozenset({1, 2, 3})
    >>> fs2 = frozenset({2, 3, 4})
    >>> fs3 = fs1 ^ fs2
    >>> print(fs3)
    frozenset({1, 4})
    >>> |
    ```

## métodos do frozenset

Apesar de sua imutabilidade, `frozensets` ainda possuem alguns métodos úteis, tais como:

### `frozenset.copy()`

Retorna uma cópia do `frozenset`.
```python
>>> fs = frozenset({1, 2, 3})
>>> fs_copy = fs.copy()
>>> print(fs_copy)
frozenset({1, 2, 3})
>>> |
```

### `frozenset.union()`

Retorna a união com outros `sets` ou `frozensets`.
```python
>>> fs1 = frozenset({1, 2, 3})
>>> fs2 = frozenset({3, 4, 5})
>>> fs3 = fs1.union(fs2)
>>> print(fs3)
frozenset({1, 2, 3, 4, 5})
>>> |
```

### `frozenset.intersection()`

Retorna a interseção com outros `sets` ou `frozensets`.
```python
>>> fs1 = frozenset({1, 2, 3})
>>> fs2 = frozenset({2, 3, 4})
>>> fs3 = fs1.intersection(fs2)
>>> print(fs3)
frozenset({2, 3})
>>> |
```

### `frozenset.difference()`

Retorna a diferença com outros `sets` ou `frozensets`.
```python
>>> fs1 = frozenset({1, 2, 3})
>>> fs2 = frozenset({2, 3, 4})
>>> fs3 = fs1.difference(fs2)
>>> print(fs3)
frozenset({1})
>>> |
```

### `frozenset.issubset()`

Verifica se o `frozenset` é um subconjunto de outro.
```python
>>> fs1 = frozenset({1, 2})
>>> fs2 = frozenset({1, 2, 3})
>>> print(fs1.issubset(fs2))
True
>>> |
```

### `frozenset.issuperset()`

Verifica se o `frozenset` é um superconjunto de outro.
```python
>>> fs1 = frozenset({1, 2, 3})
>>> fs2 = frozenset({1, 2})
>>> print(fs1.issuperset(fs2))
True
>>> |
```

### `frozenset.isdisjoint()`

Verifica se dois `frozensets` não têm elementos em comum.
```python
>>> fs1 = frozenset({1, 2})
>>> fs2 = frozenset({3, 4})
>>> print(fs1.isdisjoint(fs2))
True
>>> |
```

## aplicações práticas

- **uso como chaves de dicionário** : como `frozensets` são imutáveis e hashable, eles podem ser usados como chaves de dicionários, ao contrário de `sets` comuns.
    ```python
    >>> my_dict = {}
    >>> fs = frozenset({1, 2, 3})
    >>> my_dict[fs] = "valor associado ao frozenset"
    >>> print(my_dict)
    {frozenset({1, 2, 3}): 'valor associado ao frozenset'}
    >>> |
    ```

- **operações que requerem imutabilidade** : sempre que precisa garantir que um conjunto de valores não será alterado, um `frozenset` é uma escolha ideal.

## limitações

Devido à imutabilidade, métodos como `add()`, `remove()`, `pop()`, e outros que alterariam um conjunto não estão disponíveis para `frozensets`.

## exercícios

<details>
<summary>Lista de Exercícios</summary>

1. Exercícios Básicos
    1. **Criando um `frozenset`**: Crie um `frozenset` a partir de uma lista de números `[1, 2, 3, 4, 5]` e imprima-o.
    1. **Eliminando duplicatas**: Crie um `frozenset` a partir da lista `[1, 2, 2, 3, 4, 4, 5]` e mostre o resultado.
    1. **Conversão de string para `frozenset`**: Converta a string `"abracadabra"` em um `frozenset` e imprima-o.
    1. **Verificação de imutabilidade**: Tente adicionar um novo elemento ao `frozenset` `{1, 2, 3}` e observe o que acontece.
    1. **Comparando `sets` e `frozensets`**: Crie um `set` e um `frozenset` com os mesmos elementos e verifique se são iguais.
1. Operações com `frozensets`
    1. **União de `frozensets`**: Crie dois `frozensets`, `{1, 2, 3}` e `{3, 4, 5}`, e faça a união entre eles.
    1. **Interseção de `frozensets`**: Crie dois `frozensets`, `{1, 2, 3}` e `{2, 3, 4}`, e encontre a interseção entre eles.
    1. **Diferença entre `frozensets`**: Crie dois `frozensets`, `{1, 2, 3}` e `{3, 4, 5}`, e calcule a diferença entre eles (`fs1 - fs2`).
    1. **Diferença simétrica**: Crie dois `frozensets`, `{1, 2, 3}` e `{2, 3, 4}`, e calcule a diferença simétrica entre eles.
    1. **União de vários `frozensets`**: Crie três `frozensets`, `{1, 2}`, `{2, 3}` e `{3, 4}`, e faça a união de todos.
1. Verificação e Comparação
    1. **Verificando subconjunto**: Verifique se o `frozenset` `{1, 2}` é um subconjunto de `{1, 2, 3}`.
    1. **Verificando superconjunto**: Verifique se o `frozenset` `{1, 2, 3}` é um superconjunto de `{1, 2}`.
    1. **Conjuntos disjuntos**: Verifique se os `frozensets` `{1, 2}` e `{3, 4}` são disjuntos.
    1. **Comparação de `frozensets`**: Compare os `frozensets` `{1, 2, 3}` e `{3, 2, 1}` e verifique se são iguais.
    1. **Verificando existência de elemento**: Verifique se o número `3` está presente no `frozenset` `{1, 2, 3, 4}`.
1. Aplicações Práticas
    1. **Usando `frozenset` como chave de dicionário**: Crie um dicionário onde as chaves são `frozensets` e os valores são strings. Atribua o valor `"grupo1"` para a chave `frozenset({1, 2, 3})`.
    1. **Criando um `frozenset` a partir de uma lista de tuplas**: Converta uma lista de tuplas `[(1, 2), (2, 3), (3, 4)]` em um `frozenset`.
    1. **Ordenando elementos de um `frozenset`**: Crie um `frozenset` a partir dos números `[4, 1, 3, 2]` e exiba os elementos em ordem crescente.
    1. **Verificando imutabilidade dentro de uma lista**: Crie uma lista que contém um `frozenset` e tente modificar o `frozenset` dentro da lista. O que acontece?
    1. **Criando `frozensets` a partir de diferentes tipos de dados**: Crie `frozensets` a partir de uma string, uma lista e uma tupla, e compare os resultados.
1. Desafios
    1. **Removendo duplicatas de uma lista de listas**: Suponha que você tem uma lista de listas `[[1, 2], [2, 3], [1, 2]]`. Use `frozensets` para eliminar as listas duplicadas.
    1. **Comparando frozensets com subsets**: Dado dois `frozensets`, `{1, 2, 3}` e `{1, 2}`, verifique se o segundo é subconjunto do primeiro e depois faça a união dos dois.
    1. **Verificação de pertença em dicionário**: Dado um dicionário onde as chaves são `frozensets`, verifique se um `frozenset` específico é uma chave no dicionário.
    1. **Frozenset a partir de outra coleção**: Crie um `frozenset` a partir de um `set` que contém os elementos `{1, 2, 3}`. Depois, tente alterar o `set` original e verifique se o `frozenset` foi afetado.
    1. **Comparação entre diferentes coleções**: Crie um `frozenset`, um `set` e uma lista com os mesmos elementos e verifique como eles se comportam em operações como união, interseção e diferença.
    1. **Trabalhando com caracteres únicos**: Converta a string `"banana"` em um `frozenset` e conte quantos caracteres únicos há.
    1. **Analisando frozensets aninhados**: Crie um `frozenset` que contém outros `frozensets` como elementos. Exiba o resultado e discuta o que você observa.
    1. **Uso de `frozenset` em conjunto com `map`**: Use `map()` para aplicar uma função que retorna o quadrado de cada número em um `frozenset`.
    1. **Conversão e comparação de coleções**: Converta uma lista de números `[1, 2, 3, 4]` para um `frozenset`, e compare-o com outro `frozenset` que você cria diretamente.
    1. **Verificação de imutabilidade em operações**: Crie um `frozenset` e realize operações de união e interseção com outros conjuntos. Verifique se o `frozenset` original foi alterado após essas operações.

</details>

Índice

1. [manipulando a lista](#manipulando-a-lista)
1. [métodos da lista](#métodos-da-lista)
    1. [list.append()](#listappend)
    1. [list.insert()](#listinsert)
    1. [list.remove()](#listremove)
    1. [list.pop()](#listpop)
1. [string e list](#string-e-list)
1. [exercícios lista](#exercícios-lista)

# lista

Uma lista é uma coleção de itens ordenados e mutáveis. Isso significa que podemos adicionar, remover ou alterar os itens de uma lista após a sua criação. No Python, uma lista é representada por colchetes `[]` e os itens dentro dela são separados por vírgulas. O tipo lista é representado por `list`.

## manipulando a lista

A mainpulação da lista pode ser feita sem usar seus métodos. Veja abaixo algumas formas :

### criando uma lista

Você pode criar uma lista simplesmente colocando uma série de valores entre colchetes.

Veja alguns exemplos de criação de lista :

```python
# criando uma lista de números inteiros
numeros = [1, 2, 3, 4, 5]

# criando uma lista de floats
mais_numeros = [3.14, 2.77, 1.00001]

# criando uma lista de strings
planetas = ["Mercúrio", "Vênus", "Terra", "Marte"]

# criando uma lista mista
misto = [42, 3.14, 'uma string', False, "outra string"]

# criando uma lista com outra variáveis dentro
nome = "Arnold"
valor = 42
lista_mista = [42, nome, 'Schwarzenegger', True, "olá", valor]
```

### acessando itens da lista

Cada item de uma lista tem uma posição (ou índice). No Python, os índices começam em 0. Isso significa que o primeiro item tem índice 0, o segundo item tem índice 1, e assim por diante.

Veja abaixo como fica o acesso :

```python
print('Planeta no índice 0 :', planetas[0])  # saída : Mercúrio
print('Planeta no índice 2 :', planetas[2])  # saída : Terra
print('Número no índice 1 :', numeros[1])  # saída : 2
```

### modificando itens da lista

Como as listas são mutáveis, você pode alterar qualquer item da lista usando o índice:

```python
planetas[2] = 'Saturno'
print(planetas)  # saída : ['Mercúrio', 'Vênus', 'Saturno', 'Marte']
```

## métodos da lista

### `list.append()`

Adiciona um item ao **final** da lista.

```python
planetas.append("Plutão")
print(planetas)  # saída : ['Mercúrio', 'Vênus', 'Saturno', 'Marte', 'Plutão']
```

### `list.insert()`

Adiciona um item em uma posição específica.

```python
# insere a string "Júpiter" no índice 1 da lista
planetas.insert(1, "Júpiter")
print(planetas)  # saída : ['Mercúrio', 'Júpiter', 'Vênus', 'Saturno', 'Marte', 'Plutão']
```

Se for usado um índice maior que o tamanho da lista, então ele será adicionado ao final dela.

```python
planetas.insert(100, "Terra")
print(planetas)  # saída : ['Mercúrio', 'Júpiter', 'Vênus', 'Saturno', 'Marte', 'Plutão', 'Terra']
```

### `list.remove()`

Remove a primeira ocorrência de um item específico.

```python
planetas.remove("Plutão")
print(planetas)  # saída : ['Mercúrio', 'Júpiter', 'Vênus', 'Saturno', 'Marte', 'Terra']
```

Se o item removido não estiver na lista, então irá levantar um erro.

### `list.pop()`

Remove um item pela sua posição (índice) e retorna esse item. Se nenhum índice for fornecido, ele remove o último item.

```python
ultimo = planetas.pop()
print(ultimo)  # saída : "Terra"
print(planetas)  # saída : ['Mercúrio', 'Júpiter', 'Vênus', 'Saturno', 'Marte']

especifico = planetas.pop(2)
print(especifico)  # saída : "Vênus"
print(planetas)  # saída : ['Mercúrio', 'Júpiter', 'Saturno', 'Marte']
```

Se o índice passado não existir, então irá ocorrer um erro.

## string e list

Strings e listas tem algumas características em comum, como ambas serem compostas de mais de um item. Uma string é composta por um ou mais caracteres, tão somente. Enquanto que uma lista é composta por diferentes tipos.

Por conta disso, elas possuem alguns comportamentos em comum.

### juntando e multiplicando listas

Assim como nas strings, o operador `+` é usado para juntar (concatenar) duas listas e o operador `*` é usado para multiplicar o conteúdo de uma lista :

```python
lista1 = [1, 2, 3]
lista2 = [4, 5, 6]
junta = lista1 + lista2
print(junta)  # saída : [1, 2, 3, 4, 5, 6]

multiplica = lista1 * 2
print(multiplica)  # saída : [1, 2, 3, 1, 2, 3]
```

### fatiamento

O fatiamento das listas funcionam exatamente como o fatiamento das strings :

```python
print(planetas[::2])  # saída : ['Mercúrio', 'Terra']
print(planetas[1:])  # saída : ['Vênus', 'Terra', 'Marte']
print(planetas[2:4])  # saída : ['Terra', 'Marte']
print(planetas[:3])  # saída : ['Mercúrio', 'Vênus', 'Terra']
```

## cast de listas

Assim como os outros tipos vistos até agora, o tipo lista também possui uma função capaz de converter outros tipos para lista, embora haja algumas particularidades. Para converter, usa-se a função `list()`.

### `list()`
A função `list()` é o principal built-in usado para converter (ou "castar") outros tipos de dados em listas. Ela aceita qualquer **iterável** como argumento e retorna uma nova lista contendo os elementos desse iterável.

Quando você converte uma string em uma lista, cada caractere da string se torna um elemento separado na lista.

```python
sobrenome = 'Schwarzenegger'
lista = list(sobrenome)
print(lista)  # saída : ['S', 'c', 'h', 'w', 'a', 'r', 'z', 'e', 'n', 'e', 'g', 'g', 'e', 'r']
```

Como os tipos `int`, `float`, `bool` não são iteráveis, não é possível converter para uma lista um objeto sozinho desses tipos.

## exercícios lista

<details>
<summary>Lista de Exercícios</summary>

1. Exercícios Simples
    1. Crie uma lista com três números inteiros e exiba o primeiro elemento.
    1. Crie uma lista com três strings e exiba o último elemento.
    1. Crie uma lista com cinco números decimais e exiba o terceiro elemento.
    1. Crie uma lista com quatro valores booleanos e exiba o segundo elemento.
    1. Crie uma lista com três strings e altere o primeiro elemento para "Python".
1. Exercícios Simples com if-elif-else
    1. Crie uma lista com três números inteiros. Se o primeiro elemento for maior que 10, altere o segundo elemento para 20. Caso contrário, altere o segundo elemento para 5.
        ```python
        numeros = [1, 2, 3]
        # numeros = [100, 2, 3]

        print('numeros :', numeros)

        if numeros[0] > 10:
            numeros[1] = 20
        else:
            numeros[1] = 5

        print('numeros :', numeros)
        ```
    1. Crie uma lista com três strings. Se a lista contiver a string "Python", exiba "Encontrado". Caso contrário, exiba "Não encontrado".
    1. Crie uma lista com cinco números decimais. Se o terceiro elemento for maior que 2.5, altere o último elemento para 0. Caso contrário, altere o primeiro elemento para 1.
        ```python
        lista_dec = [1.1, 1.5, 2.6, 2.1, 5.0]
        indice = 0

        print(lista_dec)

        if lista_dec[2] > 2.5:
            lista_dec[-1] = 0
        else:
            lista_dec[0] = 1

        print(lista_dec)
        ```
    1. Crie uma lista com quatro valores booleanos. Se o primeiro elemento for True, altere o segundo elemento para False. Caso contrário, altere o terceiro elemento para True.
    1. Crie uma lista com três strings. Se a lista não contiver a string "Hello", adicione "Hello" no final da lista. Caso contrário, remova o último elemento.
1. Exercícios Intermediários
    1. Crie uma lista com seis números inteiros e exiba a quantidade de elementos na lista.
    1. Crie uma lista com cinco strings e exiba a string no índice 2.
    1. Crie uma lista com sete números decimais e insira o número 3.14 no índice 4.
    1. Crie uma lista com quatro valores booleanos e remova o terceiro elemento.
    1. Crie uma lista com três números inteiros e adicione o número 7 no final da lista.
1. Exercícios Intermediários com if-elif-else
    1. Crie uma lista com seis números inteiros. Se o comprimento da lista for maior que 5, exiba o primeiro e o último elemento. Caso contrário, exiba "Lista pequena".
    1. Crie uma lista com cinco strings. Se a lista contiver a string "Python", altere o último elemento para "Coding". Caso contrário, adicione "Learning" no final da lista.
    1. Crie uma lista com sete números decimais. Se o quarto elemento for maior que 1.5, remova o primeiro elemento. Caso contrário, insira o número 0 no início da lista.
    1. Crie uma lista com quatro valores booleanos. Se a lista contiver o valor True, exiba "True encontrado". Caso contrário, exiba "Nenhum True".
    1. Crie uma lista com três números inteiros. Se a soma dos elementos for maior que 20, adicione o número 5 no final da lista. Caso contrário, remova o último elemento.
1. Exercícios Avançados
    1. Crie uma lista com cinco números inteiros e troque o primeiro e o último elemento de lugar.
    1. Crie uma lista com quatro strings e adicione uma nova string na segunda posição.
    1. Crie uma lista com seis números decimais e remova o número no índice 3.
    1. Crie uma lista com três valores booleanos e adicione o valor True no início da lista.
    1. Crie uma lista com cinco números inteiros e insira o número 10 na penúltima posição.
1. Exercícios Avançados com if-elif-else
    1. Crie uma lista com cinco números inteiros. Se a lista contiver o número 5, remova-o. Caso contrário, adicione o número 5 no final da lista.
    1. Crie uma lista com quatro strings. Se o segundo elemento for "Python", altere o terceiro elemento para "Programação". Caso contrário, insira "Estudo" na terceira posição.
    1. Crie uma lista com seis números decimais. Se a soma dos elementos for maior que 10, remova o último elemento. Caso contrário, adicione o número 1.1 no início da lista.
    1. Crie uma lista com três valores booleanos. Se a lista contiver dois valores True, altere o último elemento para False. Caso contrário, adicione True no final da lista.
    1. Crie uma lista com quatro números inteiros. Se o comprimento da lista for igual a 4, exiba o segundo e o terceiro elemento. Caso contrário, exiba "Lista incorreta".
1. Exercícios Complexos
    1. Crie uma lista com cinco números inteiros e substitua todos os números pares por zero.
    1. Crie uma lista com quatro strings e converta todas as strings para maiúsculas.
    1. Crie uma lista com seis números decimais e insira o número 2.5 após cada número maior que 2.
    1. Crie uma lista com três valores booleanos e adicione um valor booleano alternado após cada elemento.
    1. Crie uma lista com cinco números inteiros e remova todos os números ímpares.
1. Exercícios Complexos com if-elif-else
    1. Crie uma lista com cinco números inteiros. Se todos os números forem positivos, substitua o último número por -1. Caso contrário, adicione -1 no final da lista.
    1. Crie uma lista com quatro strings. Se a lista contiver a string "Python", altere todas as strings para "Code". Caso contrário, adicione "Python" no final da lista.
    1. Crie uma lista com seis números decimais. Se a média dos números for maior que 3, remova o primeiro e o último elemento. Caso contrário, adicione 0.5 no início e no final da lista.
    1. Crie uma lista com três valores booleanos. Se a lista contiver dois valores False, altere o primeiro elemento para True. Caso contrário, insira False no início da lista.
    1. Crie uma lista com quatro números inteiros. Se a soma dos elementos for maior que 15, remova o número no índice 2. Caso contrário, insira o número 7 na posição 1.
1. Exercícios Muito Complexos
    1. Crie uma lista com cinco números inteiros e inverta a ordem dos elementos.
    1. Crie uma lista com quatro strings e remova todas as strings que contêm a letra "a".
        ```python
        palavras = ['aula', 'premia', 'sala', 'movel']
        indice = 0

        while indice < len(palavras):

            if 'a' in palavras[indice]:
                palavras.pop(indice)
            else:
                indice = indice + 1

        print('palavras :', palavras)
        ```
    1. Crie uma lista com seis números decimais e insira um número aleatório após cada elemento.
    1. Crie uma lista com três valores booleanos e remova todos os valores False.
    1. Crie uma lista com cinco números inteiros e substitua cada elemento pelo seu quadrado.
1. Exercícios Muito Complexos com if-elif-else
    1. Crie uma lista com cinco números inteiros. Se a lista contiver números negativos, remova todos eles. Caso contrário, adicione -1 no início e no final da lista.
        ```python
        numeros = [1, 4, 6, 8, 10]

        indice = 0

        while indice < len(numeros):
            if numeros[indice] < 0:
                print('numero negativo :', numeros[indice])

                numeros = []

            print('valor do indice :', indice)
            indice = indice + 1

        if len(numeros) > 0:
            numeros.append(-1)
            numeros.insert(0, -1)

        print('a lista ficou :', numeros)
        print('fim do programa')
        ```
    1. Crie uma lista com quatro strings. Se a lista tiver mais de uma string com a letra "e", remova todas essas strings. Caso contrário, adicione "No e" no final da lista.
    1. Crie uma lista com seis números decimais. Se a soma dos números for menor que 10, insira o número 5.5 no meio da lista. Caso contrário, remova o número no meio da lista.
    1. Crie uma lista com três valores booleanos. Se todos os valores forem True, altere o segundo elemento para False. Caso contrário, adicione True no final da lista.
    1. Crie uma lista com quatro números inteiros. Se a soma dos elementos for maior que 20, remova todos os números pares. Caso contrário, adicione 2 após cada número ímpar.

</details>
# tipo none

O tipo `None` em Python é um tipo de dado especial que representa a ausência de valor ou um valor nulo. Ele é usado em várias situações para indicar que algo está "vazio", "não definido" ou "não possui valor". Em Python, o valor `None` é único e é uma instância da classe `NoneType`.

## características do `none`:

1. **Singleton** : o `None` é um objeto único no Python. Ou seja, em toda a aplicação, existe apenas uma instância do `None`. Isso significa que se você comparar dois objetos `None` usando `is`, eles sempre serão iguais (`True`), pois ambos apontam para o mesmo objeto na memória;

2. **avaliação booleana** : em uma expressão booleana, `None` é avaliado como `False`. Portanto, se usar `None` em uma estrutura de controle como `if`, ele será considerado como `False`;

3. **Utilização Comum** :
   - **Valores de Retorno de Funções** : uma função que não possui uma declaração explícita de retorno (`return`) retorna `None` por padrão;
   - **Inicialização de Variáveis** : o `None` é frequentemente usado para inicializar variáveis que serão atribuídas posteriormente com valores reais;
   - **Placeholder** : em estruturas de dados, como listas ou dicionários, `None` pode ser usado como um valor temporário até que um valor "real" seja atribuído;

### exemplo de uso:

```python
>>> # função que não retorna nada explicitamente
>>> def minha_funcao():
...     pass
...
>>> resultado = minha_funcao()
>>> print(resultado)
None
>>>
>>> # inicializando uma variável com None
>>> variavel = None
>>> if variavel is None:
...     print("A variável não tem valor atribuído.")
...
>>> # uso de None como placeholder
>>> dados = {"nome": None, "idade": None}
>>> dados["nome"] = "Alice"
>>> dados["idade"] = 30
>>> print(dados)
{'nome': 'Alice', 'idade': 30}
>>> |
```

## comparando `None`:
- **usando `is`** : como `None` é um singleton, a comparação correta para verificar se uma variável é `None` é usando o operador `is`, não `==`. Exemplo:
    ```python
    >>> if variavel is None:
    ...     print("É None")
    ...
    >>> |
    ```

Índice

1. [criando um set](#criando-um-set)
1. [métodos do set](#métodos-do-set)
    1. [set.union()](#setunion)
    1. [set.intersection()](#setintersection)
    1. [set.difference()](#setdifference)
    1. [set.symmetric_difference()](#setsymmetric_difference)
    1. [set.copy()](#setcopy)
    1. [set.issubset()](#setissubset)
    1. [set.issuperset()](#setissuperset)
    1. [set.isdisjoint()](#setisdisjoint)
    1. [set.add()](#setadd)
    1. [set.remove()](#setremove)
    1. [set.discard()](#setdiscard)
1. [cast](#cast)
    1. [convertendo tuplas em set](#1-convertendo-tuplas-em-set)
    1. [convertendo listas em set](#1-convertendo-listas-em-set)
    1. [convertendo strings em set](#1-convertendo-strings-em-set)
1. [exercícios](#exercícios)
1. [operadores do set](#operadores-do-set)
1. [exercícios com operadores](#exercícios-com-operadores)

# `set`

O tipo `set` no Python é uma coleção de elementos únicos e desordenados. Isso significa que ele não permite elementos duplicados e a ordem dos elementos não é garantida. Os `sets` são úteis quando se precisa garantir que uma coleção de itens não contenha duplicatas ou quando precisa realizar operações matemáticas de conjuntos, como união, interseção e diferença.

## criando um `set`
Para criar um `set`, é preciso utilizar as chaves `{}` ou a função `set()` :

```python
>>> meu_set = {1, 2, 3, 4}
>>> outro_set = set([4, 5, 6])
```

## métodos do `set`

Veja abaixo alguns métodos importantes do `set` :

### `set.union()`

O método `union()` retorna um novo `set` que contém todos os elementos presentes em ambos os conjuntos, sem duplicatas :

```python
>>> set1 = {1, 2, 3}
>>> set2 = {3, 4, 5}
>>>
>>> resultado = set1.union(set2)
>>> print(resultado)
{1, 2, 3, 4, 5}
>>> |
```

Aqui, o `union()` combina `set1` e `set2`, resultando em um novo `set` que contém todos os elementos dos dois conjuntos.

### `set.intersection()`

O método `intersection()` retorna um novo `set` contendo apenas os elementos que estão presentes em ambos os conjuntos :

```python
>>> set1 = {1, 2, 3}
>>> set2 = {2, 3, 4}
>>>
>>> resultado = set1.intersection(set2)
>>> print(resultado)
{2, 3}
>>> |
```

No exemplo, `intersection()` retorna um `set` com os elementos comuns entre `set1` e `set2`.

### `set.difference()`

O método `difference()` retorna um novo `set` contendo os elementos que estão no primeiro conjunto, mas não no segundo :

```python
>>> set1 = {1, 2, 3}
>>> set2 = {2, 3, 4}
>>>
>>> resultado = set1.difference(set2)
>>> print(resultado)
{1}
>>> |
```

Aqui, `difference()` retorna os elementos de `set1` que não estão em `set2`.

### `set.symmetric_difference()`

O método `symmetric_difference()` retorna um novo `set` contendo os elementos que estão no primeiro e no segundo conjunto, mas não são comuns entre eles :

```python
>>> set1 = {1, 2, 3}
>>> set2 = {2, 3, 4}
>>>
>>> resultado = set1.symmetric_difference(set2)
>>> print(resultado)
{1, 4}
>>> |
```

Aqui, `symmetric_difference()` retorna os elementos de `set1` e `set2` que não são comuns entre eles.

### `set.add()`

O método `add()` adiciona um elemento ao `set`. Como `sets` não permitem duplicatas, se o elemento já estiver presente, nada acontece :

```python
>>> meu_set = {1, 2, 3}
>>> meu_set.add(4)
>>> print(meu_set)
{1, 2, 3, 4}
>>>
>>> meu_set.add(2)
>>> print(meu_set)
{1, 2, 3, 4}
>>> |
```

Neste exemplo, o número `4` é adicionado ao `set`, mas quando tentamos adicionar `2` novamente, o `set` permanece inalterado.

### `set.remove()`

O método `remove()` remove um elemento específico do `set`. Se o elemento não estiver presente, ele gera um erro (`KeyError`) :

```python
>>> meu_set = {1, 2, 3}
>>> meu_set.remove(2)
>>> print(meu_set)
{1, 3}
>>>
>>> meu_set.remove(5)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 5
>>> |
```

Aqui, `remove(2)` retira o `2` do `set`, mas tentar remover o `5`, que não está no `set`, resulta em um erro.

### `set.discard()`

O método `discard()` também remove um elemento do `set`, mas se o elemento não estiver presente, ele simplesmente não faz nada e não gera erro :

```python
>>> meu_set = {1, 2, 3}
>>> meu_set.discard(2)
>>> print(meu_set)
{1, 3}
>>>
>>> meu_set.discard(5)  # Não gera erro
>>> print(meu_set)
{1, 3}
>>> |
```

No exemplo acima, `discard(2)` remove o `2`, mas quando tentamos `discard(5)`, nada acontece, e o `set` permanece o mesmo.

### `set.copy()`

O método `copy()` cria uma cópia superficial do conjunto, retornando um novo conjunto que contém os mesmos elementos do original. A cópia é independente, ou seja, alterações no conjunto copiado não afetam o conjunto original, e vice-versa:

```python
>>> set1 = {1, 2, 3}
>>>
>>> copia = set1.copy()
>>> print(copia)
{1, 2, 3}
>>>
>>> set1.add(4)
>>> print(set1)
{1, 2, 3, 4}
>>> print(copia)
{1, 2, 3}
>>> |
```

Aqui, `copy()` cria uma cópia de `set1` chamada `copia`. Quando `set1` é modificado com a adição do elemento `4`, a cópia (`copia`) permanece inalterada, demonstrando que são conjuntos distintos.

### `set.issubset()`

O método `issubset()` verifica se todos os elementos de um conjunto estão presentes em outro conjunto. Ele retorna `True` se o conjunto é um subconjunto do conjunto passado como argumento, caso contrário, retorna `False`:

```python
>>> set1 = {1, 2, 3}
>>> set2 = {1, 2, 3, 4, 5}
>>>
>>> resultado = set1.issubset(set2)
>>> print(resultado)
True
>>> |
```

Aqui, `issubset()` retorna `True` porque todos os elementos de `set1` estão presentes em `set2`.

### `set.issuperset()`

O método `issuperset()` verifica se todos os elementos de outro conjunto estão presentes no conjunto. Ele retorna `True` se o conjunto contém todos os elementos do conjunto passado como argumento, caso contrário, retorna `False`:

```python
>>> set1 = {1, 2, 3, 4, 5}
>>> set2 = {1, 2, 3}
>>>
>>> resultado = set1.issuperset(set2)
>>> print(resultado)
True
>>> |
```

Aqui, `issuperset()` retorna `True` porque `set1` contém todos os elementos de `set2`.

### `set.isdisjoint()`

O método `isdisjoint()` verifica se dois conjuntos não possuem nenhum elemento em comum. Ele retorna `True` se os conjuntos não compartilham nenhum elemento, caso contrário, retorna `False`:

```python
>>> set1 = {1, 2, 3}
>>> set2 = {4, 5, 6}
>>>
>>> resultado = set1.isdisjoint(set2)
>>> print(resultado)
True
>>> |
```

Aqui, `isdisjoint()` retorna `True` porque `set1` e `set2` não têm elementos em comum.

## cast

O cast para `set` em Python significa converter outros tipos de coleções (como listas, tuplas e strings) em um `set`. Essa conversão é feita usando a função `set()`. A principal característica do `set` é que ele elimina quaisquer elementos duplicados, pois um `set` só pode conter elementos únicos.

### 1. convertendo tuplas em `set`

Tuplas são coleções ordenadas e imutáveis de elementos. Quando uma tupla é comvertida para um `set`, todos os elementos duplicados são removidos e a ordem dos elementos não é preservada.

```python
>>> minha_tupla = (1, 2, 3, 4, 4, 5)
>>> meu_set = set(minha_tupla)
>>> print(meu_set)
{1, 2, 3, 4, 5}
>>> |
```

Aqui, a tupla `(1, 2, 3, 4, 4, 5)` é convertida em um `set`, e os números duplicados são removidos.

### 2. convertendo listas em `set`

Listas são coleções ordenadas e mutáveis de elementos. Assim como com as tuplas, ao converter uma lista em um `set`, os elementos duplicados são eliminados e a ordem original pode ser perdida.

```python
>>> minha_lista = [1, 2, 2, 3, 4, 5, 5]
>>> meu_set = set(minha_lista)
>>> print(meu_set)
{1, 2, 3, 4, 5}
>>> |

```
Aqui, a lista `[1, 2, 2, 3, 4, 5, 5]` é convertida em um `set`, e os elementos duplicados são removidos.

### 3. convertendo strings em `set`

Strings são sequências de caracteres. Quando uma string é convertida em um `set`, cada caractere da string se torna um elemento do `set`, e os caracteres duplicados são removidos. Como em todos os `sets`, a ordem dos elementos pode mudar.

```python
>>> minha_string = "banana"
>>> meu_set = set(minha_string)
>>> print(meu_set)
{'b', 'n', 'a'}
>>> |
```

Aqui, a string `"banana"` é convertida em um `set`. Como o `set` elimina duplicatas, os caracteres repetidos `a` e `n` aparecem apenas uma vez.

### considerações finais

- **eliminação de duplicatas** : a conversão para `set` é útil quando é preciso remover duplicatas de uma coleção;
- **ordem não garantida** : diferente de listas e tuplas, a ordem dos elementos em um `set` não é preservada após a conversão;
- **imutabilidade das tuplas** : apesar de as tuplas serem imutáveis, quando convertidas em `set`, os elementos se tornam mutáveis no contexto do `set`;

## exercícios

<details>
<summary>Lista de Exercícios</summary>

1. Exercícios de Criação e Conversão
    1. Crie um `set` vazio e adicione os números 1, 2 e 3.
    1. Converta a lista `[1, 2, 3, 4, 4, 5]` em um `set` e imprima o resultado.
    1. Dada a tupla `(5, 6, 7, 8, 8, 9)`, converta-a em um `set` e imprima o resultado.
    1. Converta a string `"programming"` em um `set` e imprima os caracteres únicos.
        ```python
        palavra = 'programming'
        palavra_set = set(palavra)
        print(f'{''.join(list(palavra_set)) = }')
        ```
    1. Crie um `set` a partir da lista `[‘apple’, ‘banana’, ‘orange’, ‘apple’]` e imprima o resultado.
    1. Converta a tupla `(1, 1, 2, 2, 3, 3)` em um `set` e imprima o resultado.
    1. Dada a string `"abracadabra"`, converta-a em um `set` e imprima os caracteres únicos.
        ```python
        palavra = 'abracadabra'
        palavra_set = set(palavra)
        for letra in palavra_set:
            print(f'{letra = }')
        ```
    1. Crie um `set` com os elementos da lista `[10, 20, 30, 40, 50, 50, 60]`.
    1. Converta a string `"hello world"` em um `set` e imprima os caracteres únicos.
    1. Crie um `set` a partir da tupla `(100, 200, 200, 300, 400)` e imprima o resultado.
1. Exercícios com Métodos Básicos
    1. Adicione o número `7` ao `set` `{1, 2, 3}` e imprima o resultado.
    1. Remova o número `2` do `set` `{1, 2, 3}` e imprima o resultado.
    1. Tente remover o número `4` do `set` `{1, 2, 3}` usando `remove()`. O que acontece?
    1. Tente remover o número `4` do `set` `{1, 2, 3}` usando `discard()`. O que acontece?
    1. Adicione os elementos `8, 9, 10` ao `set` `{4, 5, 6, 7}` e imprima o resultado.
    1. Remova todos os elementos de um `set` usando `clear()`.
    1. Verifique se o número `5` está presente no `set` `{1, 2, 3, 4, 5}`.
    1. Crie um `set` e adicione a string `"Python"` como um único elemento.
    1. Remova o último elemento do `set` `{10, 20, 30, 40, 50}` (use `pop()`) e imprima o resultado.
    1. Verifique se o caractere `"a"` está presente no `set` criado a partir da string `"alphabet"`.
1. Exercícios com Operações de Conjunto
    1. Crie dois `sets`, `A = {1, 2, 3}` e `B = {3, 4, 5}`, e calcule a união usando `union()`.
    1. Calcule a interseção dos `sets` `{10, 20, 30}` e `{20, 30, 40}`.
    1. Encontre a diferença entre os `sets` `{100, 200, 300}` e `{200, 300, 400}`.
    1. Crie dois `sets`, `A = {‘apple’, ‘banana’}` e `B = {‘banana’, ‘cherry’}`, e calcule a união.
    1. Encontre a interseção entre os `sets` `{‘a’, ‘b’, ‘c’}` e `{‘b’, ‘c’, ‘d’}`.
    1. Calcule a diferença entre os `sets` `{‘red’, ‘blue’, ‘green’}` e `{‘blue’, ‘yellow’}`.
    1. Crie dois `sets`, `A = {2, 4, 6, 8}` e `B = {1, 2, 3, 4}`, e encontre a interseção.
    1. Encontre a união dos `sets` `{5, 10, 15}` e `{15, 20, 25}`.
    1. Calcule a diferença entre os `sets` `{‘dog’, ‘cat’, ‘fish’}` e `{‘fish’, ‘bird’}`.
    1. Crie dois `sets`, `A = {‘x’, ‘y’, ‘z’}` e `B = {‘y’, ‘z’, ‘w’}`, e calcule a diferença.
1. Exercícios Mistos
    1. Verifique se o `set` `{1, 2, 3}` é subconjunto de `{1, 2, 3, 4, 5}`.
    1. Verifique se o `set` `{‘apple’, ‘banana’}` é subconjunto de `{‘apple’, ‘banana’, ‘cherry’}`.
    1. Verifique se `{1, 2}` e `{3, 4}` são conjuntos disjuntos.
    1. Crie um `set` a partir de uma string que contenha caracteres repetidos, como `"mississippi"`, e imprima os caracteres únicos.
    1. Crie um `set` a partir de uma lista com elementos duplicados e verifique se a quantidade de elementos no `set` é menor que na lista original.
    1. Combine dois `sets` usando o operador `|` (ou a operação `union()`).
    1. Encontre os elementos exclusivos de um `set` em comparação com outro usando a operação de diferença.
    1. Crie dois `sets` com elementos totalmente diferentes e verifique se a interseção é vazia.
    1. Verifique se um `set` é subconjunto de si mesmo.
    1. Tente adicionar um elemento já existente a um `set` e observe o comportamento.
1. Desafios
    1. Crie três `sets` diferentes e calcule a interseção de todos eles.
    1. Crie três `sets` diferentes e calcule a união de todos eles.
    1. Dado um `set` de números de 1 a 10, crie um segundo `set` com os números ímpares e calcule a diferença.
    1. Dado um `set` de palavras, crie um segundo `set` com palavras que começam com uma determinada letra e calcule a interseção.
    1. Crie dois `sets` com diferentes tipos de frutas e calcule a união e a diferença simétrica (usando o operador `^`).
    1. Verifique se a interseção de dois `sets` é vazia, ou seja, se eles são disjuntos.
    1. Dado um `set` com caracteres de uma string, adicione um novo caractere ao `set` e verifique se ele já existia.
    1. Crie um `set` a partir de uma lista de números e verifique quantos elementos únicos existem.
    1. Dado um `set` de letras, remova todas as vogais (se existirem).
    1. Crie um `set` a partir de uma frase e calcule a quantidade de letras distintas, ignorando espaços e pontuação.

</details>

## operadores do set

Os operadores `|`, `&`, `-` e `^` em Python são usados para realizar operações comuns de teoria dos conjuntos em objetos do tipo `set`.

### operador `|` (união)

O operador `|` é utilizado para realizar a **união** de dois conjuntos. A união de dois conjuntos resulta em um novo conjunto contendo todos os elementos que estão em qualquer um dos conjuntos ou em ambos.

```python
>>> set1 = {1, 2, 3}
>>> set2 = {3, 4, 5}
>>>
>>> resultado = set1 | set2
>>> print(resultado)
{1, 2, 3, 4, 5}
>>> |
```

**explicação :** a união entre `set1` e `set2` resulta em um conjunto que contém todos os elementos de ambos os conjuntos. Observe que elementos duplicados são incluídos apenas uma vez;

### operador `&` (interseção)

O operador `&` é utilizado para realizar a **interseção** de dois conjuntos. A interseção de dois conjuntos resulta em um novo conjunto contendo apenas os elementos que estão presentes em ambos os conjuntos.

```python
>>> set1 = {1, 2, 3}
>>> set2 = {3, 4, 5}
>>>
>>> resultado = set1 & set2
>>> print(resultado)
{3}
>>> |
```
**explicação :** a interseção entre `set1` e `set2` resulta em um conjunto que contém apenas o elemento `3`, que é o único presente em ambos os conjuntos;

### operador `-` (diferença)

O operador `-` é utilizado para realizar a **diferença** entre dois conjuntos. A diferença entre dois conjuntos resulta em um novo conjunto contendo os elementos que estão no primeiro conjunto, mas não no segundo.

```python
>>> set1 = {1, 2, 3}
>>> set2 = {3, 4, 5}
>>>
>>> resultado = set1 - set2
>>> print(resultado)
{1, 2}
>>> |
```
**explicação :** a diferença entre `set1` e `set2` resulta em um conjunto que contém os elementos `1` e `2`, que estão em `set1` mas não em `set2`;

### operador `^` (diferença simétrica)

O operador `^` é utilizado para realizar a **diferença simétrica** entre dois conjuntos. A diferença simétrica resulta em um novo conjunto contendo os elementos que estão em um dos conjuntos, mas não em ambos. Em outras palavras, ele exclui os elementos comuns.

```python
>>> set1 = {1, 2, 3}
>>> set2 = {3, 4, 5}
>>>
>>> resultado = set1 ^ set2
>>> print(resultado)
{1, 2, 4, 5}
>>> |
```
**explicação :** a diferença simétrica entre `set1` e `set2` resulta em um conjunto que contém os elementos `1`, `2`, `4` e `5`. Esses são os elementos que estão em apenas um dos conjuntos, mas não em ambos;

### atribuição composta dos operadores

Os operadores `|`, `&`, `-` e `^` em Python possuem versões com atribuição composta, que permitem modificar diretamente o conjunto à esquerda do operador.

#### `|=`

A União com Atribuição Composta combina o conjunto à esquerda com o conjunto à direita, e o resultado é armazenado de volta no conjunto à esquerda.

```python
>>> set1 = {1, 2, 3}
>>> set2 = {3, 4, 5}
>>>
>>> set1 |= set2
>>> print(set1)
{1, 2, 3, 4, 5}
>>> |
```

#### `&=`

A Interseção com Atribuição Composta mantém no conjunto à esquerda apenas os elementos que estão presentes também no conjunto à direita.

```python
>>> set1 = {1, 2, 3}
>>> set2 = {3, 4, 5}
>>>
>>> set1 &= set2
>>> print(set1)
{3}
>>> |
```

#### `-=`

A Diferença com Atribuição Compost remove do conjunto à esquerda todos os elementos que também estão presentes no conjunto à direita.

```python
>>> set1 = {1, 2, 3}
>>> set2 = {3, 4, 5}
>>>
>>> set1 -= set2
>>> print(set1)
{1, 2}
>>> |
```

#### `^=`

A Diferença Simétrica com Atribuição Composta atualiza o conjunto à esquerda com os elementos que estão em apenas um dos conjuntos, excluindo os elementos comuns.

```python
>>> set1 = {1, 2, 3}
>>> set2 = {3, 4, 5}
>>>
>>> set1 ^= set2
>>> print(set1)
{1, 2, 4, 5}
>>> |
```

## exercícios com operadores

<details>
<summary>Lista de Exercícios</summary>

1. **União Básica**: Crie dois conjuntos `set1 = {1, 2, 3}` e `set2 = {3, 4, 5}`. Utilize o operador `|` para encontrar a união dos dois conjuntos.
1. **Interseção Básica**: Crie dois conjuntos `set1 = {1, 2, 3}` e `set2 = {3, 4, 5}`. Utilize o operador `&` para encontrar a interseção dos dois conjuntos.
1. **Diferença Básica**: Crie dois conjuntos `set1 = {1, 2, 3}` e `set2 = {3, 4, 5}`. Utilize o operador `-` para encontrar a diferença entre `set1` e `set2`.
1. **Diferença Simétrica Básica**: Crie dois conjuntos `set1 = {1, 2, 3}` e `set2 = {3, 4, 5}`. Utilize o operador `^` para encontrar a diferença simétrica entre os dois conjuntos.
1. **União com Strings**: Crie dois conjuntos de strings: `set1 = {"apple", "banana", "cherry"}` e `set2 = {"banana", "date", "fig"}`. Utilize o operador `|` para unir os dois conjuntos.
1. **Interseção com Strings**: Usando os mesmos conjuntos do exercício anterior, utilize o operador `&` para encontrar as strings comuns entre `set1` e `set2`.
1. **Diferença com Strings**: Crie dois conjuntos de strings: `set1 = {"dog", "cat", "mouse"}` e `set2 = {"cat", "horse"}`. Utilize o operador `-` para encontrar os elementos que estão em `set1` mas não em `set2`.
1. **Diferença Simétrica com Strings**: Usando os conjuntos do exercício anterior, utilize o operador `^` para encontrar os elementos únicos em cada conjunto.
1. **Operação Combinada**: Crie três conjuntos `A = {1, 2, 3}`, `B = {3, 4, 5}` e `C = {5, 6, 7}`. Encontre a união dos conjuntos `A` e `B`, e depois calcule a diferença com o conjunto `C`.
1. **Interseção Vazia**: Crie dois conjuntos `set1 = {1, 2, 3}` e `set2 = {4, 5, 6}`. Verifique se a interseção entre eles é vazia.
1. **União com Conjuntos de Números Flutuantes**: Crie dois conjuntos de números flutuantes `set1 = {1.1, 2.2, 3.3}` e `set2 = {3.3, 4.4, 5.5}`. Utilize o operador `|` para unir os dois conjuntos.
1. **Interseção com Conjuntos de Números Flutuantes**: Usando os conjuntos do exercício anterior, utilize o operador `&` para encontrar os elementos comuns entre eles.
1. **Diferença entre Conjuntos Vários**: Crie três conjuntos `A = {1, 2, 3, 4}`, `B = {3, 4, 5, 6}` e `C = {5, 6, 7, 8}`. Encontre a diferença entre `A` e a união de `B` e `C`.
1. **Diferença Simétrica com Conjuntos Grandes**: Crie dois conjuntos `A` e `B` com 10 números inteiros aleatórios cada. Utilize o operador `^` para encontrar os elementos únicos em ambos os conjuntos.
1. **Operações Sequenciais**: Crie dois conjuntos `X = {10, 20, 30, 40}` e `Y = {30, 40, 50, 60}`. Primeiro, encontre a interseção entre `X` e `Y`, e depois subtraia essa interseção de `X`.
1. **Combinação de Operadores**: Crie três conjuntos `P = {2, 4, 6, 8}`, `Q = {4, 8, 12, 16}`, e `R = {8, 16, 24, 32}`. Calcule `(P | Q) & R`.
1. **Diferença com Listas Convertidas em Sets**: Converta as listas `list1 = [1, 2, 3, 4]` e `list2 = [3, 4, 5, 6]` em conjuntos, e depois encontre a diferença entre `set1` e `set2`.
1. **Diferença Simétrica de Sets Convertidos de Strings**: Converta as strings `str1 = "hello"` e `str2 = "world"` em conjuntos de caracteres, e utilize o operador `^` para encontrar a diferença simétrica entre os dois conjuntos.
1. **Verificação de Resultados**: Crie dois conjuntos `set1 = {1, 2, 3, 4}` e `set2 = {2, 4, 6, 8}`. Verifique se o resultado de `set1 ^ set2` é igual a `(set1 | set2) - (set1 & set2)`.
1. **União de Sets com Elementos Não Repetidos**: Crie dois conjuntos `set1 = {100, 200, 300}` e `set2 = {300, 400, 500}`. Verifique se a união dos conjuntos é igual a um conjunto criado manualmente `{100, 200, 300, 400, 500}`.

</details>
# tipos int e float

## operação de atribuição composta

A operação de atribuição composta no Python é uma maneira concisa de combinar uma operação aritmética ou lógica com a atribuição de valor a uma variável. Em vez de escrever a operação completa de forma explícita, é possível usar um operador de atribuição composto, que realiza a operação e, ao mesmo tempo, atribui o resultado à mesma variável.

A sintaxe geral para uma operação de atribuição composta é :

```python
variável operador= valor
```

Isso é equivalente a:
```python
variável = variável operador valor
```

### exemplos

Aqui estão alguns exemplos de operadores de atribuição compostos e como eles funcionam :

1. **Adição composta `+=`**
    ```python
    x = 5
    x += 3  # equivale a x = x + 3
    print(x)  # saída : 8
    ```

1. **Subtração composta `-=`**
    ```python
    x = 5
    x -= 2  # equivale a x = x - 2
    print(x)  # saída : 3
    ```

1. **Multiplicação composta `*=`**
    ```python
    x = 4
    x *= 3  # equivale a x = x * 3
    print(x)  # saída : 12
    ```

1. **Divisão composta `/=`**
    ```python
    x = 10
    x /= 2  # equivale a x = x / 2
    print(x)  # saída : 5.0
    ```

1. **Módulo composto `%=`**
    ```python
    x = 10
    x %= 3  # equivale a x = x % 3
    print(x)  # saída : 1
    ```

1. **Exponenciação composta `**=`**
    ```python
    x = 2
    x **= 3  # equivale a x = x ** 3
    print(x)  # saída : 8
    ```

1. **Divisão inteira composta `//=`**
    ```python
    x = 10
    x //= 3  # equivale a x = x // 3
    print(x)  # saída : 3
    ```

<!-- 1. **Operador bitwise AND composto `&=`**
    ```python
    x = 5  # 0b0101
    x &= 3  # 0b0011, equivale a x = x & 3
    print(x)  # saída : 1 (0b0001)
    ``` -->

<!-- 1. **Operador bitwise OR composto `|=`**
    ```python
    x = 5  # 0b0101
    x |= 2  # 0b0010, equivale a x = x | 2
    print(x)  # saída : 7 (0b0111)
    ``` -->

<!-- 1. **Operador bitwise XOR composto `^=`**
    ```python
    x = 5  # 0b0101
    x ^= 3  # 0b0011, equivale a x = x ^ 3
    print(x)  # saída : 6 (0b0110)
    ``` -->

### vantagens

- **código mais conciso** : reduz a repetição, tornando o código mais limpo e fácil de ler;
- **desempenho** : em algumas situações, operações compostas podem ser ligeiramente mais eficientes, embora a diferença geralmente seja mínima;
# tipos mutáveis e imutáveis

## tipos imutáveis

Os tipos **imutáveis** em Python são aqueles cujos valores não podem ser alterados após sua criação. Quando se altera um valor, o Python cria um novo objeto em vez de modificar o objeto existente. Isso tem implicações importantes para a maneira como se lida com variáveis e objetos no Python.

Os principais tipos imutáveis em Python são :

1. **números (inteiros e ponto flutuante)**
1. **strings (`str`)**
1. **tuplas (`tuple`)**
1. **frozensets (`frozenset`)**

### 1. números

Os tipos numéricos imutáveis em Python incluem inteiros (`int`), números de ponto flutuante (`float`), e números complexos (`complex`).

Exemplos :

```python
>>> x = 10  # inteiro
>>> y = 3.14  # ponto flutuante
>>> z = 1 + 2j  # número complexo
```

Se alterar o valor de uma variável numérica, um novo objeto é criado. O objeto antigo permanece inalterado, e a variável passa a referenciar o novo objeto.

```python
>>> x = 10
>>> x = 20
>>> # x agora referencia um novo objeto (20)
```

Qualquer operação que pareça alterar o valor de um número cria um novo objeto e não modifica o objeto original.

### 2. strings (`str`)

Strings são sequências imutáveis de caracteres. Elas são definidas usando aspas simples `'` ou duplas `"`.

Exemplo :

```python
>>> s = "Olá, Mundo!"
```

Operações como concatenação, repetição, ou substituição de caracteres criam novas strings em vez de alterar a string original.

```python
>>> s = "Olá"
>>> s = s + " Mundo"
>>> # cria uma nova string "Olá Mundo"
```

Strings não podem ser alteradas após a criação. Qualquer operação que pareça modificar a string resultará em uma nova string.

### 3. tuplas (`tuple`)

Tuplas são coleções ordenadas e imutáveis de elementos. São definidas usando parênteses `()` e os elementos são separados por vírgulas.

Exemplo :

```python
>>> t = (1, 2, 3, "quatro")
```

Não se pode alterar os elementos de uma tupla uma vez que ela é criada. Se precisar modificar uma tupla, terá que criar uma nova.

```python
>>> t = (1, 2, 3)
>>> # t[1] = 4  # isso resultaria em um erro
>>> t = (1, 4, 3)  # cria uma nova tupla
```

Qualquer tentativa de alterar os elementos da tupla ou sua estrutura resulta em um erro.

### 4. frozensets (`frozenset`)

Frozensets são conjuntos imutáveis. Ao contrário dos conjuntos normais, eles não permitem alterações após sua criação.

Exemplo

```python
>>> fs = frozenset([1, 2, 3, 4])
```

Não se pode adicionar, remover ou modificar elementos em um frozenset após sua criação. Qualquer tentativa de alteração resulta em um erro.

```python
>>> fs = frozenset([1, 2, 3])
>>> # fs.add(4)  # Isso resultaria em um erro
```

Frozensets são úteis quando se precisa de um conjunto cujos elementos não mudem ao longo do tempo e é importante que o conjunto possa ser usado como chave em um dicionário ou elemento em outro conjunto.

## tipos mutáveis

Em Python, um **tipo mutável** é um tipo de dado cujos valores podem ser alterados após sua criação. Diferente dos tipos imutáveis, onde qualquer alteração resulta na criação de um novo objeto, os tipos mutáveis permitem modificações diretas nos dados sem a necessidade de criar um novo objeto.

Os principais tipos mutáveis em Python são:

1. **listas (`list`)**
1. **dicionários (`dict`)**
1. **conjuntos (`set`)**

### 1. listas (`list`)

Listas são coleções ordenadas de elementos que podem ser de tipos variados. São definidas usando colchetes `[]` e os elementos são separados por vírgulas.

Exemplo :

```python
>>> minha_lista = [1, 2, 3, "quatro"]
```

Podese alterar um elemento específico da lista, por exemplo:

```python
>>> minha_lista[2] = "três"
```

Pode-se adicionar novos elementos com métodos como `append()` e `extend()`:

```python
>>> minha_lista.append(5)
>>> minha_lista.extend([6, 7])
```

Pode-se remover elementos com métodos como `remove()` e `pop()`:

```python
>>> minha_lista.remove("quatro")
>>> elemento = minha_lista.pop()
```

Alterar uma lista altera o próprio objeto lista, e todas as referências a essa lista verão as mudanças.

### 2. dicionários (`dict`)

Dicionários são coleções de pares chave-valor. São definidos usando chaves `{}` e os pares chave-valor são separados por vírgulas.

Exemplo :

```python
>>> meu_dict = {"nome": "Ana", "idade": 25}
```

Pode-se alterar o valor associado a uma chave existente:

```python
>>> meu_dict["idade"] = 26
```

Podese adicionar novos pares usando a chave:

```python
>>> meu_dict["cidade"] = "São Paulo"
```

Pode-se remover pares com `del` ou o método `pop()`:

```python
>>> del meu_dict["cidade"]
>>> idade = meu_dict.pop("idade")
```

Alterar um dicionário altera o próprio objeto dicionário. Todas as referências ao dicionário verão as mudanças.

### 3. conjuntos (`set`)

Conjuntos são coleções não ordenadas de elementos únicos. São definidos usando chaves `{}` e não permitem elementos duplicados.

Exemplo :

```python
>>> meu_set = {1, 2, 3}
```

Pode-se adicionar novos elementos com `add()`:

```python
>>> meu_set.add(4)
```

Pode-se remover elementos com `remove()` e `discard()`:

```python
>>> meu_set.remove(2)
>>> meu_set.discard(5)  # Não gera erro se o elemento não estiver presente
```

- **operações conjuntivas :** pode fazer operações como união, interseção e diferença:

```python
>>> outro_set = {3, 4, 5}
>>> uniao = meu_set.union(outro_set)
>>> intersecao = meu_set.intersection(outro_set)
>>> diferenca = meu_set.difference(outro_set)
```

Alterar um conjunto altera o próprio objeto conjunto. Todas as referências ao conjunto verão as mudanças.
Índice

1. [sintaxe](#sintaxe)
1. [caracteres especiais](#caracteres-especiais)
1. [string crua](#string-crua)
1. [string literal](#string-literal)
1. [exercícios - parte 1](#exercícios---parte-1)
1. [concatenando strings](#concatenando-strings)
1. [multiplicando strings](#multiplicando-strings)
1. [indexando strings](#indexando-strings)
1. [dividindo strings](#dividindo-strings)
1. [exercícios - parte 2](#exercícios---parte-2)
<details>
<summary>métodos da string</summary>

1. [str.upper()](#strupper)
1. [str.lower()](#strlower)
1. [str.capitalize()](#strcapitalize)
1. [str.title()](#strtitle)
1. [str.strip()](#strstrip)
1. [str.lstrip()](#strlstrip)
1. [str.rstrip()](#strrstrip)
1. [str.replace()](#strreplace)
1. [str.split()](#strsplit)
1. [str.join()](#strjoin)
1. [str.find()](#strfind)
1. [str.startswith()](#strstartswith)
1. [str.endswith()](#strendswith)
1. [str.isalpha()](#strisalpha)
1. [str.isdigit()](#strisdigit)
1. [str.isalnum()](#strisalnum)
1. [str.isspace()](#strisspace)
1. [str.isupper()](#strisupper)
1. [str.islower()](#strislower)
1. [str.zfill()](#strzfill)
1. [str.center()](#strcenter)
1. [str.ljust()](#strljust)
1. [str.rjust()](#strrjust)
1. [str.partition()](#strpartition)
1. [str.rpartition()](#strrpartition)

</details>

# tipo string

O Python pode manipular texto (representado pelo tipo `str`, também chamado de `strings`), bem como os números. Isso inclui caracteres `!`, palavras `coelho`, nomes `Paris`, frases `Eu te protejo.`, `Oba! :)` etc.. Eles podem ser colocados entre aspas simples `'...'` ou aspas duplas `"..."` com o mesmo resultado.

```python
>>> 'sou um texto'  # aspas simples
'sou um texto'
>>> "sou outro texto"  # aspas duplas
'sou outro texto'
>>> '1984'  # dígitos e números entre aspas também são strings
'1984'
```

## sintaxe

Para colocar aspas entre aspas, precisamos "escapá-la", precedendo-as com `\`. Alternativamente, podemos usar o outro tipo de aspas:

```python
>>> 'The Kids Aren\'t Alright'  # use \' para escapar as aspas simples...
"The Kids Aren't Alright"
>>> "The Kids Aren't Alright"  # ou use aspas duplas
"The Kids Aren't Alright"
>>>
>>> '"pois não", disse o garçom'
'"pois não", disse o garçom'
>>> "\"pois não\", disse o garçom"
'"pois não", disse o garçom'
>>> |
```

No shell do Python, a definição de string e a string de saída podem parecer diferentes. A função `print()` produz uma saída mais legível, omitindo as aspas delimitadoras e imprimindo caracteres de escape e especiais:
```python
>>> texto = 'linha um\nlinha dois'
>>> texto  # sem o print(), caracteres especiais são incluídos na string
'linha um\nlinha dois'
>>> print(texto)  # com o print, os caracteres especiais são interpretados
linha um
linha dois
>>>
```

## caracteres especiais

Os caracteres especiais são uma forma de mandar para a linguagem de programação comandos a serem executados de dentro da string :

- `\n` : é usado quando se quer criar uma nova linha na exibição do texto;
```python
>>> print('linha 1\nlinha 2\nlinha 3\nlinha 4\n')
linha 1
linha 2
linha 3
linha 4

>>> |
```
- `\t` : é usado quando se quer inserir uma tabulação no texto;
```python
>>> print('sem tabulação\n\tuma tabulação\n\t\tduas tabulações\n\t\t\ttrês tabulações')
sem tabulação
    uma tabulação
        duas tabulações
            três tabulações
>>> |
```

## string crua

Se não quiser que os caracteres precedidos por `\` sejam interpretados como caracteres especiais, pode-se usar strings `raw` ("crua" ou sem processamento de caracteres de escape) adicionando um r antes da primeira aspa ou então colocando duas `\\`:

```python
>>> print('C:\nemo')  # aqui \n indica nova linha!
C:
emo
>>> print(r'C:\nemo')  # note o r antes da aspa
C:\nemo
>>> print('c:\nemo\\nemo')  # repare no uso duplo da \\
c:
emo\nemo
>>> |
```

Há um aspecto sutil nas strings raw: uma string raw não pode terminar em um número ímpar de caracteres `\`.

```python
>>> print(r'C:\nemo\\')
C:\nemo\\
>>>
>>> print(r'C:\nemo\\\')
  File "<stdin>", line 1
    print(r'C:\nemo\\\')
          ^
SyntaxError: unterminated string literal (detected at line 1)

# mais exemplos
print('uma tabulação\\tdois')
print('C:\\usuario\\ted')
>>> |
```

## string literal

As strings literais podem abranger várias linhas. Uma maneira é usar as aspas triplas: `"""..."""` ou `'''...'''`. O fim das linhas é incluído automaticamente na string, mas é possível evitar isso adicionando uma `\` no final.
O seguinte exemplo:
```python
>>> print("""\
... Uso: alguma coisa [opcional]
...     -h                      Mostra esta mensagem.
...     -H hostname             Nome do host para conectar.
... """)
Uso: alguma coisa [opcional]
  -h              Mostra esta mensagem.
  -H hostname     Nome do host para conectar.

>>> |
```

```python
>>> print("""sou uma string
... dividida em apenas \
... duas linhas""")
sou uma string
dividida em apenas duas linhas
>>> |
```

## exercícios - parte 1

<details>
<summary>Lista de Exercícios</summary>

1. Exercícios Simples
    1. Crie uma string com seu nome e imprima-a.
    1. Crie uma string com uma citação famosa e imprima-a.
    1. Use aspas duplas para criar uma string e imprima-a.
    1. Use aspas simples para criar uma string e imprima-a.
    1. Crie uma string com aspas dentro dela, usando aspas duplas e simples, e imprima-a.
    1. Crie uma string que contenha uma nova linha (\n) e imprima-a.
    1. Crie uma string que contenha um tab (\t) e imprima-a.
    1. Crie uma string que contenha tanto \n quanto \t e imprima-a.
    1. Crie uma string que contenha barras invertidas (\\) e imprima-a.
    1. Crie uma string usando raw string (prefixo r) e imprima-a.
1. Exercícios de Nível Intermediário
    1. Crie uma string com várias linhas usando \n e imprima-a.
    1. Crie uma string com várias tabs usando \t e imprima-a.
    1. Crie uma string com um caminho de arquivo usando barras invertidas e imprima-a.
    1. Use raw string para criar um caminho de arquivo e imprima-a.
    1. Combine aspas duplas e simples em uma string e imprima-a.
    1. Crie uma string que contenha aspas simples escapadas e imprima-a.
    1. Crie uma string que contenha aspas duplas escapadas e imprima-a.
    1. Crie uma string com uma citação famosa usando raw string e imprima-a.
    1. Crie uma string que contenha um caractere de nova linha escapado (\\n) e imprima-a.
    1. Crie uma string que contenha um caractere de tab escapado (\\t) e imprima-a.
1. Exercícios Avançados
    1. Crie uma string longa usando múltiplas linhas e o caractere \n e imprima-a.
    1. Crie uma string longa usando múltiplas tabs e o caractere \t e imprima-a.
    1. Crie uma string com várias barras invertidas (\\\\) e imprima-a.
    1. Crie uma string que combine várias linhas, tabs e barras invertidas e imprima-a.
    1. Use raw string para criar uma string com várias linhas e tente imprimi-la.
    1. Use raw string para criar uma string com várias tabs e tente imprimí-la.
    1. Use raw string para criar uma string com várias barras invertidas e imprima-a.
    1. Combine aspas duplas, simples e barras invertidas em uma string e imprima-a.
    1. Crie uma string com uma citação famosa que contenha várias linhas e imprima-a.
    1. Crie uma string com um poema que contenha várias tabs e imprima-a.
1. Exercícios Complexos
    1. Crie uma string que represente uma linha de JSON e imprima-a.
    1. Crie uma string que represente uma linha de script HTML e imprima-a.
    1. Crie uma string que contenha CSS com várias linhas e imprima-a.
    1. Crie uma string que contenha código Python com várias linhas e imprima-a.
    1. Crie uma string com uma mensagem que use aspas duplas, simples, \n e \t, e imprima-a.
    1. Crie uma string que represente um caminho de rede e imprima-a.
    1. Crie uma string que contenha uma citação longa com várias linhas e tabs, e imprima-a.
    1. Use raw string para criar uma string com código Python e imprima-a.
    1. Use raw string para criar uma string com script HTML e imprima-a.
    1. Use raw string para criar uma string com CSS e imprima-a.
1. Exercícios Muito Complexos
    1. Crie uma string que contenha um bloco de código JSON com várias linhas e imprima-a.
    1. Crie uma string que contenha um bloco de código HTML com várias linhas e imprima-a.
    1. Crie uma string que contenha um bloco de código CSS com várias linhas e imprima-a.
    1. Crie uma string que contenha um bloco de código Python com várias linhas e imprima-a.
    1. Combine raw string com uma string que contenha um bloco de código Python e imprima-a.
        '''python
        texto = """
        valor = 10
        print(valor)
        """
        print(r'estou na raw string ',texto)
        '''
    1. Combine raw string com uma string que contenha um bloco de código HTML e imprima-a.
    1. Combine raw string com uma string que contenha um bloco de código CSS e imprima-a.
    1. Crie uma string que contenha um caminho de arquivo complexo e imprima-a.
    1. Crie uma string que combine várias técnicas de formatação (raw string, escapamento, \n, \t) e imprima-a.
    1. Crie uma string que contenha um script completo em qualquer linguagem de programação e imprima-a.

</details>

## concatenando strings

As strings podem ser concatenadas (coladas, "somadas") com o operador `+` ou então apenas deixando um espaço entre elas :
```python
>>> 'Py' + 'thon'
'Python'
>>> 'Arnold' + ' ' + 'Schwarzenegger'
'Arnold Schwarzenegger'
>>> 'Arnold' ' ' 'Schwarzenegger'
'Arnold Schwarzenegger'
>>> 'Arnold ' 'Schwarzenegger'
'Arnold Schwarzenegger'
>>> |
```

Concaternar strings com espaço pode ser útil para quebrar uma longa string e várias linhas :
```python
>>> texto = ('Coloque várias strings dentro de parênteses '
...          'para juntá-las em uma.')
>>> texto
'Coloque várias strings dentro de parênteses para juntá-las em uma.'
>>> |
```

Strings literais não podem ser concatenadas com variáveis dessa forma, mesmo elas também sendo strings.
Para isso funcionar, é necessário usar o operador `+`.

Veja exemplos :
```python
>>> # definindo as variáveis
>>> nome = 'Arnold'
>>> sobrenome = 'Schwarzenegger'
```
```python
>>> # mostrando os erros
>>> nome 'Schwarzenegger'
  File "<stdin>", line 1
    nome 'Schwarzenegger'
         ^^^^^^^^^^^^^^^^
SyntaxError: invalid syntax
>>>
>>> print('Arnold' sobrenome)
  File "<stdin>", line 1
    print('Arnold' sobrenome)
          ^^^^^^^^^^^^^^^^^^
SyntaxError: invalid syntax. Perhaps you forgot a comma?
>>>
>>> nome sobrenome
  File "<stdin>", line 1
    nome sobrenome
         ^^^^^^^^^
SyntaxError: invalid syntax
>>>
>>> print(nome sobrenome)
  File "<stdin>", line 1
    print(nome sobrenome)
          ^^^^^^^^^^^^^^
SyntaxError: invalid syntax. Perhaps you forgot a comma?
```
```python
>>> # mostrando como funciona
>>> nome + 'Schwarzenegger'
'ArnoldSchwarzenegger'
>>> print('Arnold' 'Schwarzenegger')
ArnoldSchwarzenegger
>>> print(nome + ' ' + sobrenome)
Arnold Schwarzenegger
>>> |
```

## multiplicando strings

Também é possível usar o operador de multiplicação `*` para manipular as string.

```python
>>> 5 * nome
'ArnoldArnoldArnoldArnoldArnold'
>>> print(25 * '=-' + '=')
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
>>> print(" + " * 20)
 +  +  +  +  +  +  +  +  +  +  +  +  +  +  +  +  +  +  +  +
>>> |
```

## combinando os operadores

É possível usar ambos os operadores de uma vez :
```python
>>> 3 * nome + ' ' +  sobrenome
'ArnoldArnoldArnold Schwarzenegger'
>>> |
```

## indexando strings

Uma string nada mais é do que uma sucessão de caracteres. Diferente dos números, onde o valor 2.147.483.648 corresponde a apenas um valor, uma palavra é composta por diversos caracteres. Por causa disso, é possível *indexar* uma string com o primeiro caractere iniciando em `zero`.

Veja abaixo :
```python
>>> sobrenome = 'Schwarzenegger'
>>> sobrenome[0]  # caractere na posição 0
'S'
>>> sobrenome[5]  # caractere na posição 5
'r'
```

Também é possível usar números negativos e começar a contagem da direita :
```python
>>> sobrenome[-1]
'r'
>>> sobrenome[-2]
'e'
>>> sobrenome[-7]
'e'
>>> |
```

Repare que, como -0 é a mesma coisa que 0, os índices negativos iniciam em `-1`.

## dividindo strings
Além de indexar, as strings também podem ser *divididas*. Enquanto indexar é usado para obter um caractere, dividir permite obter uma substring a partir da original.

Veja abaixo :
```python
>>> sobrenome[0:5]  # caracteres da posição 0 (incluída) até 5 (excluída)
'Schwa'
>>> sobrenome[5:8]  # caracteres da posição 5 (incluída) até 8 (excluída)
'rze'
>>> |
```

Dividir índices tem alguns padrões interessantes. Se o primeiro índice for omitido, o valor padrão é zero. Se o segundo índice é omitido, o tamanho da string é o valor padrão. Veja :
```python
>>> sobrenome[:6]  # caractere iniciado do início até a posição 6 (excluída)
'Schwar'
>>> sobrenome[8:]  # caracteres da posição 8 (incluída) até o final
'enegger'
>>> sobrenome[-3:]  # caracteres da terceira última posição (incluída) até o final
'ger'
>>> |
```

Repare que o índice inicial é sempre incluído e o último é sempre excluído. Isso é feito dessa maneira para que `sobrenome[:i] + sobrenome[i:]` seja **sempre** igual a `sobrenome` :
```python
>>> sobrenome[:6] + sobrenome[6:]
'Schwarzenegger'
>>>
>>> sobrenome[:9] + sobrenome[9:]
'Schwarzenegger'
>>> |
```

Uma forma de lembrar como a divisão de strings funciona é pensar nos índices como ponteiros entre os caracteres, com a margem esquerda so primeiro caractere iniciando em 0. E a margem da direita do último caractere da string de tamanho *n* tem o índice *n*.

Veja um exemplo :
```
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  | S | c | h | w | a | r | z | e | n | e | g | g | e | r |
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14
-14 -13 -12 -11 -10  -9  -8  -7  -6  -5  -4  -3  -2  -1
```
A primeira linha de números mostra a posição dos índices 0..14 da string. A segunda linha mostra os índices negativos correspondentes. A divisão de `i` a `j` consiste em todos os caracteres entre as margens marcadas com `i` e `j`, respectivamente.

Tentar acessar um índice maior que a string irá levantar um erro, mas se tentar acessar um índice da divisão maior que o tamanho da string, não acontece o erro :
```python
>>> sobrenome = 'Schwarzenegger'
>>> sobrenome[42]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: string index out of range
>>> sobrenome[6:42]
'zenegger'
>>> sobrenome[42:]
''
>>> |
```

## exercícios - parte 2

<details>
    <summary>Lista de Exercícios</summary>

1. Exercícios Simples
    1. Concatene as strings "Olá " e "Mundo".
    1. Concatene as strings "Python" e "Programação".
    1. Multiplique a string "Olá " por 3.
    1. Acesse o primeiro caractere da string "Olá ".
    1. Acesse o último caractere da string "Mundo".
    1. Concatene as strings "Py" e "thon".
    1. Concatene as strings "Senac " e "Tech".
    1. Multiplique a string "Python" por 2.
    1. Acesse o segundo caractere da string "Django".
    1. Acesse o penúltimo caractere da string "Desenvolvimento Web".
1. Exercícios de Nível Intermediário
    1. Concatene as strings "Aprendizado de" e "Máquina".
    1. Multiplique a string "Dados" por 4.
    1. Acesse o terceiro caractere da string "Inteligência".
    1. Acesse o antepenúltimo caractere da string "Artificial".
    1. Concatene as strings "Big" e "Data" e acesse o quinto caractere.
    1. Concatene as strings "Deep" e "Learning".
    1. Multiplique a string "Neural" por 3.
    1. Acesse o quarto caractere da string "Networks".
    1. Acesse o primeiro caractere da string concatenada "LinguagemNatural".
    1. Acesse o último caractere da string concatenada "LinguagemNatural".
1. Exercícios Avançados
    1. Concatene as strings "Olá " e " " e "Mundo".
    1. Acesse o quinto caractere da string "Inteligência Artificial".
    1. Multiplique a string "Big" por 5 e acesse o terceiro caractere.
    1. Concatene as strings "Deep" e " " e "Learning".
    1. Acesse o primeiro caractere da string "Neural" multiplicada por 3.
    1. Acesse o terceiro caractere da string concatenada "Ciência de Dados".
    1. Concatene as strings "Senac" e " " e "Tech" e acesse o último caractere.
    1. Multiplique a string "Máquina" por 2 e acesse o décimo caractere.
    1. Acesse o segundo caractere da string "Aprendizagem Profunda".
    1. Concatene as strings "Linguagem" e "Natural" e acesse o sexto caractere.
1. Exercícios Complexos
    1. Acesse o primeiro e último caractere da string "Programando em Python".
    1. Multiplique a string "Python 3.12" por 4 e acesse o oitavo caractere.
    1. Concatene as strings "Aprendizado" e " " e "Máquina" e acesse o décimo segundo caractere.
    1. Acesse o penúltimo caractere da string "Inteligência Artificial".
    1. Multiplique a string "Aprendizagem Profunda" por 2 e acesse o vigésimo caractere.
    1. Acesse o quinto caractere da string concatenada "BigData".
    1. Concatene as strings "Redes" e " " e "Neurais" e acesse o décimo quinto caractere.
    1. Multiplique a string "LinguagemNatural" por 3 e acesse o vigésimo terceiro caractere.
    1. Acesse o segundo caractere da string "Ciência de Dados".
    1. Concatene as strings "Olá " e "Mundo" e acesse o sexto caractere.
1. Exercícios Muito Complexos
    1. Acesse o primeiro e último caractere da string concatenada "Inteligência Artificial".
    1. Multiplique a string "Linguagem de Progamação Python" por 6 e acesse o trigésimo segundo caractere.
    1. Concatene as strings "Senac Tech" e "Escola de Tecnologia" e acesse o décimo nono caractere.
    1. Acesse o penúltimo caractere da string "Aprendizado Profundo e Redes Neurais".
    1. Multiplique a string "BigData" por 5 e acesse o quadragésimo quinto caractere.
    1. Concatene as strings "Ciência" e "de Dados" e acesse o décimo segundo caractere.
    1. Multiplique a string "Redes Neurais" por 3 e acesse o vigésimo quinto caractere.
    1. Acesse o terceiro caractere da string concatenada "Processamento de Linguagem Natural".
    1. Concatene as strings "Olá " e " " e "Mundo" e acesse o décimo quinto caractere.
    1. Acesse o segundo e último caractere da string "Inteligência Artificial" multiplicada por 2.

</details>

## métodos das strings

As strings em Python são sequências imutáveis de caracteres que possuem vários métodos embutidos, os quais permitem realizar uma ampla variedade de operações.

### `str.upper()`

O método `upper()` converte todos os caracteres alfabéticos de uma string para maiúsculas. Ele não afeta números, espaços em branco ou caracteres especiais.

```python
# Exemplo básico
texto = "hello world"
print(texto.upper())  # saída : "HELLO WORLD"

# Mistura de letras maiúsculas e minúsculas
texto = "Python is Fun!"
print(texto.upper())  # saída : "PYTHON IS FUN!"

# String com números e caracteres especiais
texto = "Python 3.12!"
print(texto.upper())  # saída : "PYTHON 3.12!"
```

### `str.lower()`

O método `lower()` converte todos os caracteres alfabéticos de uma string para minúsculas. Assim como `upper()`, ele não altera números, espaços em branco ou caracteres especiais.

```python
# Exemplo básico
texto = "HELLO WORLD"
print(texto.lower())  # saída : "hello world"

# Mistura de letras maiúsculas e minúsculas
texto = "Python Is Fun!"
print(texto.lower())  # saída : "python is fun!"

# String com números e caracteres especiais
texto = "Python 3.12!"
print(texto.lower())  # saída : "python 3.12!"
```

### `str.capitalize()`

O método `capitalize()` converte o primeiro caractere da string para maiúscula e todos os outros caracteres alfabéticos para minúscula. Se o primeiro caractere já for maiúsculo ou não for uma letra, ele permanece inalterado.

```python
# Exemplo básico
texto = "hello world"
print(texto.capitalize())  # saída : "Hello world"

# Primeira letra maiúscula, mas as demais já estão maiúsculas
texto = "HELLO WORLD"
print(texto.capitalize())  # saída : "Hello world"

# String começando com número
texto = "123 python"
print(texto.capitalize())  # saída : "123 python"
```

### `str.title()`

O método `title()` converte o primeiro caractere de cada palavra na string para maiúscula e o restante para minúscula. Este método considera qualquer caractere não alfabético (como espaços ou pontuação) como delimitador de palavras.

```python
# Exemplo básico
texto = "hello world"
print(texto.title())  # saída : "Hello World"

# Mistura de maiúsculas e minúsculas
texto = "python is FUN!"
print(texto.title())  # saída : "Python Is Fun!"

# String com caracteres especiais
texto = "welcome to python's world!"
print(texto.title())  # saída : "Welcome To Python'S World!"
```

### `str.strip()`

O método `strip()` remove os espaços em branco do início e do final da string. Além dos espaços em branco, você pode especificar caracteres adicionais a serem removidos.

```python
# Exemplo básico
texto = "   hello world   "
print(texto.strip())  # saída : "hello world"

# Removendo caracteres específicos
texto = "***hello world***"
print(texto.strip('*'))  # saída : "hello world"

# Removendo múltiplos caracteres específicos
texto = "!!!hello world###"
print(texto.strip('!#'))  # saída : "hello world"
```

### `str.lstrip()`

O método `lstrip()` remove os espaços em branco do início da string (lado esquerdo). Ele também pode remover caracteres específicos se forem fornecidos.

```python
# Exemplo básico
texto = "   hello world   "
print(texto.lstrip())  # saída : "hello world   "

# Removendo caracteres específicos
texto = "***hello world***"
print(texto.lstrip('*'))  # saída : "hello world***"

# Removendo múltiplos caracteres específicos
texto = "!!!hello world###"
print(texto.lstrip('!#'))  # saída : "hello world###"
```

### `str.rstrip()`

O método `rstrip()` remove os espaços em branco do final da string (lado direito). Ele também pode remover caracteres específicos se forem fornecidos.

```python
# Exemplo básico
texto = "   hello world   "
print(texto.rstrip())  # saída : "   hello world"

# Removendo caracteres específicos
texto = "***hello world***"
print(texto.rstrip('*'))  # saída : "***hello world"

# Removendo múltiplos caracteres específicos
texto = "!!!hello world###"
print(texto.rstrip('!#'))  # saída : "!!!hello world"
```

### `str.replace()`

O método `replace(old, new[, count])` substitui todas as ocorrências de uma substring por outra dentro da string. Se o argumento `count` for fornecido, ele limitará o número de substituições.

```python
# Substituindo todas as ocorrências
texto = "hello world"
print(texto.replace("world", "Python"))  # saída : "hello Python"

# Limitando o número de substituições
texto = "banana"
print(texto.replace("a", "o", 2))  # saída : "bonona"

# Substituindo uma sequência de caracteres por outra
texto = "abra kadabra"
print(texto.replace("abra", "magic"))  # saída : "magic kadmagic"
```

### `str.split()`

O método `split(separator[, maxsplit])` divide uma string em uma lista de substrings com base em um separador específico. Se `separator` não for especificado, espaços em branco serão usados por padrão. O argumento `maxsplit` limita o número de divisões.

```python
# Exemplo básico com separador padrão (espaço em branco)
texto = "hello world python"
print(texto.split())  # saída : ['hello', 'world', 'python']

# Dividindo com um separador específico
texto = "hello,world,python"
print(texto.split(','))  # saída : ['hello', 'world', 'python']

# Limitando o número de divisões
print(texto.split(',', 1))  # saída : ['hello', 'world,python']

# Dividindo com múltiplos espaços
texto = "hello   world   python"
print(texto.split())  # saída : ['hello', 'world', 'python']
```

### `str.join()`

O método `join(iterable)` combina elementos de um iterável (como listas ou tuplas) em uma única string, usando a string original como separador. Este método é frequentemente usado para converter listas de strings em uma única string.

```python
# Exemplo básico com espaço como separador
lista = ['hello', 'world', 'python']
print(' '.join(lista))  # saída : "hello world python"

# Usando outro separador
print(','.join(lista))  # saída : "hello,world,python"

# Usando uma string vazia como separador
print(''.join(lista))  # saída : "helloworldpython"

# Unindo elementos de uma lista de números (convertidos para strings)
numeros = ['1', '2', '3', '4']
print('-'.join(numeros))  # saída : "1-2-3-4"
```

### `str.find()`

O método `find(sub[, start[, end]])` retorna o índice da primeira ocorrência da substring `sub` na string. Se a substring não for encontrada, ele retorna `-1`. Os parâmetros `start` e `end` são opcionais e podem limitar a busca a um intervalo específico.

```python
# Encontrando a primeira ocorrência
texto = "hello world"
print(texto.find('world'))  # saída : 6

# Buscando a partir de um índice específico
print(texto.find('l', 4))  # saída : 9

# Quando a substring não é encontrada
print(texto.find('Python'))  # saída : -1

# Buscando em um intervalo específico
texto = "abracadabra"
print(texto.find('abra', 1, 7))  # saída : 7
```

### `str.rfind()`

O método `rfind(sub[, start[, end]])` é similar ao `find()`, mas busca pela última ocorrência da substring `sub` na string. Se a substring não for encontrada, ele retorna `-1`. Os parâmetros `start` e `end` são opcionais.

```python
# Encontrando a última ocorrência
texto = "abracadabra"
print(texto.rfind('abra'))  # saída : 7

# Buscando a partir de um índice específico
print(texto.rfind('a', 0, 5))  # saída : 3

# Quando a substring não é encontrada
print(texto.rfind('Python'))  # saída : -1

# Buscando em um intervalo específico
print(texto.rfind('bra', 2, 7))  # saída : -1
```

### `str.startswith()`

O método `startswith(prefix[, start[, end]])` verifica se a string começa com a substring `prefix`. Ele retorna `True` se a string começar com o prefixo e `False` caso contrário. Os parâmetros `start` e `end` podem limitar a verificação a um intervalo específico.

```python
# Verificando se começa com determinado prefixo
texto = "hello world"
print(texto.startswith('hello'))  # saída : True

# Verificando com um intervalo específico
print(texto.startswith('world', 6))  # saída : True

# Quando não começa com o prefixo
print(texto.startswith('Python'))  # saída : False

# Verificando com múltiplos prefixos
print(texto.startswith(('hello', 'Hi')))  # saída : True
```

### `str.endswith()`

O método `endswith(suffix[, start[, end]])` verifica se a string termina com a substring `suffix`. Ele retorna `True` se a string terminar com o sufixo e `False` caso contrário. Os parâmetros `start` e `end` podem limitar a verificação a um intervalo específico.

```python
# Verificando se termina com determinado sufixo
texto = "hello world"
print(texto.endswith('world'))  # saída : True

# Verificando com um intervalo específico
print(texto.endswith('hello', 0, 5))  # saída : True

# Quando não termina com o sufixo
print(texto.endswith('Python'))  # saída : False

# Verificando com múltiplos sufixos
print(texto.endswith(('world', 'Python')))  # saída : True
```

### `str.isalpha()`

O método `isalpha()` retorna `True` se todos os caracteres da string forem letras do alfabeto e a string não estiver vazia. Se houver números, espaços ou caracteres especiais, ele retorna `False`.

```python
# Todos os caracteres são letras
texto = "hello"
print(texto.isalpha())  # saída : True

# Contém números
texto = "hello123"
print(texto.isalpha())  # saída : False

# Contém espaços
texto = "hello world"
print(texto.isalpha())  # saída : False

# String vazia
texto = ""
print(texto.isalpha())  # saída : False
```

### `str.isdigit()`

O método `isdigit()` retorna `True` se todos os caracteres da string forem dígitos (0-9) e a string não estiver vazia. Se houver letras, espaços ou caracteres especiais, ele retorna `False`.

```python
# Todos os caracteres são dígitos
texto = "123456"
print(texto.isdigit())  # saída : True

# Contém letras
texto = "123abc"
print(texto.isdigit())  # saída : False

# Contém espaços
texto = "123 456"
print(texto.isdigit())  # saída : False

# String vazia
texto = ""
print(texto.isdigit())  # saída : False
```

### `str.isalnum()`

O método `isalnum()` retorna `True` se todos os caracteres da string forem letras ou dígitos e a string não estiver vazia. Se houver espaços ou caracteres especiais, ele retorna `False`.

```python
# Todos os caracteres são alfanuméricos
texto = "hello123"
print(texto.isalnum())  # saída : True

# Contém espaço
texto = "hello 123"
print(texto.isalnum())  # saída : False

# Contém caracteres especiais
texto = "hello@123"
print(texto.isalnum())  # saída : False

# String vazia
texto = ""
print(texto.isalnum())  # saída : False
```

### `str.isspace()`

O método `isspace()` retorna `True` se todos os caracteres da string forem espaços em branco (incluindo tabulações, quebras de linha, etc.) e a string não estiver vazia. Se houver qualquer outro caractere, ele retorna `False`.

```python
# Todos os caracteres são espaços em branco
texto = "   "
print(texto.isspace())  # saída : True

# Contém um caractere não branco
texto = "   a"
print(texto.isspace())  # saída : False

# String com quebra de linha
texto = "\n\t"
print(texto.isspace())  # saída : True

# String vazia
texto = ""
print(texto.isspace())  # saída : False
```

### `str.isupper()`

O método `isupper()` retorna `True` se todos os caracteres alfabéticos na string forem maiúsculos. Se houver caracteres minúsculos ou a string estiver vazia, ele retorna `False`.

```python
# Todos os caracteres alfabéticos são maiúsculos
texto = "HELLO"
print(texto.isupper())  # saída : True

# Contém caracteres minúsculos
texto = "Hello"
print(texto.isupper())  # saída : False

# String com números e maiúsculas
texto = "123 HELLO"
print(texto.isupper())  # saída : True

# String vazia
texto = ""
print(texto.isupper())  # saída : False
```

### `str.islower()`

O método `islower()` retorna `True` se todos os caracteres alfabéticos na string forem minúsculos. Se houver caracteres maiúsculos ou a string estiver vazia, ele retorna `False`.

```python
# Todos os caracteres alfabéticos são minúsculos
texto = "hello"
print(texto.islower())  # saída : True

# Contém caracteres maiúsculos
texto = "Hello"
print(texto.islower())  # saída : False

# String com números e minúsculas
texto = "123 hello"
print(texto.islower())  # saída : True

# String vazia
texto = ""
print(texto.islower())  # saída : False
```

### `str.zfill()`

O método `zfill(width)` retorna uma cópia da string original preenchida com zeros à esquerda para alcançar um determinado comprimento (`width`). Se a string for maior ou igual ao comprimento especificado, ela será retornada sem alterações.

```python
# Preenchendo com zeros
texto = "42"
print(texto.zfill(5))  # saída : "00042"

# String já maior que o comprimento especificado
texto = "12345"
print(texto.zfill(3))  # saída : "12345"

# Aplicando em uma string negativa
texto = "-42"
print(texto.zfill(5))  # saída : "-0042"

# Aplicando em uma string de caracteres
texto = "abc"
print(texto.zfill(5))  # saída : "00abc"
```

### `str.center()`

O método `center(width[, fillchar])` retorna uma nova string de comprimento `width`, onde a string original é centralizada. Se o `fillchar` for fornecido, ele será usado para preencher os espaços em volta; caso contrário, o espaço será usado.

```python
# Centralizando com espaços
texto = "hello"
print(texto.center(10))  # saída : "  hello   "

# Centralizando com um caractere de preenchimento
print(texto.center(10, '*'))  # saída : "**hello***"

# Comprimento menor que a string original
print(texto.center(4))  # saída : "hello"
```

### `str.ljust()`

O método `ljust(width[, fillchar])` retorna uma nova string de comprimento `width`, onde a string original é justificada à esquerda. Se o `fillchar` for fornecido, ele será usado para preencher o espaço à direita; caso contrário, o espaço será usado.

```python
# Justificando à esquerda com espaços
texto = "hello"
print(texto.ljust(10))  # saída : "hello     "

# Justificando à esquerda com um caractere de preenchimento
print(texto.ljust(10, '-'))  # saída : "hello-----"

# Comprimento menor que a string original
print(texto.ljust(4))  # saída : "hello"
```

### `str.rjust()`

O método `rjust()` retorna uma nova string de comprimento `width`, onde a string original é justificada à direita. Se o `fillchar` for fornecido, ele será usado para preencher o espaço à esquerda; caso contrário, o espaço será usado.

```python
# Justificando à direita com espaços
texto = "hello"
print(texto.rjust(10))  # saída : "     hello"

# Justificando à direita com um caractere de preenchimento
print(texto.rjust(10, '-'))  # saída : "-----hello"

# Comprimento menor que a string original
print(texto.rjust(4))  # saída : "hello"
```

### `str.partition()`

O método `partition(sep)` divide a string em uma tupla de três elementos: a parte antes do separador `sep`, o próprio separador, e a parte após o separador. Se o separador não for encontrado, a tupla conterá a string original e duas strings vazias.

```python
# Separando com um delimitador presente
texto = "hello world python"
print(texto.partition('world'))  # saída : ('hello ', 'world', ' python')

# Separando com um delimitador ausente
print(texto.partition('Python'))  # saída : ('hello world python', '', '')

# Separando no início da string
print(texto.partition('hello'))  # saída : ('', 'hello', ' world python')
```

### `str.rpartition()`

O método `rpartition(sep)` é similar ao `partition()`, mas a divisão ocorre na última ocorrência do separador `sep`.

```python
# Separando com um delimitador presente
texto = "hello world world"
print(texto.rpartition('world'))  # saída : ('hello world ', 'world', '')

# Separando com um delimitador ausente
print(texto.rpartition('Python'))  # saída : ('', '', 'hello world world')

# Separando no início da string
texto = "hello world"
print(texto.rpartition('hello'))  # saída : ('', 'hello', ' world')
```

## execícios

<details>
<summary>Lista de Exercícios</summary>

### 1. `str.upper()`
1. Crie uma variável com uma frase e converta-a para letras maiúsculas usando `str.upper()`.
2. Receba uma string do usuário e exiba-a totalmente em maiúsculas.
3. Converta o nome de uma cidade para maiúsculas e exiba-o.
4. Converta a palavra "python" para maiúsculas e exiba o resultado.
5. Crie uma lista com várias palavras e converta cada uma para maiúsculas, exibindo o resultado.
6. Receba uma frase do usuário e converta apenas a primeira palavra para maiúsculas.
7. Armazene uma mensagem em uma variável e exiba-a em maiúsculas.
8. Receba o nome de um filme do usuário e exiba-o em maiúsculas.
    ```python
    nome_filme = input('digite o nome de um filme : ')

    print(nome_filme.upper())
    ```
9. Converta o título de um livro para maiúsculas e exiba-o.

### 2. `str.lower()`
1. Crie uma variável com uma frase e converta-a para letras minúsculas usando `str.lower()`.
2. Receba uma string do usuário e exiba-a totalmente em minúsculas.
3. Converta o nome de uma cidade para minúsculas e exiba-o.
4. Converta a palavra "PYTHON" para minúsculas e exiba o resultado.
5. Crie uma lista com várias palavras e converta cada uma para minúsculas, exibindo o resultado.
    ```python
    palavras = ['carro', 'Moto', 'Jacarezinho', 'AVIAO']

    i = 0

    while i < len(palavras):
        print(palavras[i].lower())
        i = i + 1
    ```
6. Receba uma frase do usuário e converta apenas a primeira palavra para minúsculas.
    ```python
    frase = input('digite uma frase qualquer : ')

    # valida se recebeu algo
    if frase:
        lista = frase.split(' ')
        lista[0] = lista[0].upper()
        print(' '.join(lista))
    else:
        print('digite algo na proxima vez')
    ```
7. Armazene uma mensagem em uma variável e exiba-a em minúsculas.
8. Receba o nome de um filme do usuário e exiba-o em minúsculas.
9. Converta o título de um livro para minúsculas e exiba-o.

### 3. `str.capitalize()`
1. Crie uma variável com uma frase em letras minúsculas e use `str.capitalize()` para capitalizar a primeira letra.
2. Receba uma string do usuário e exiba-a com a primeira letra em maiúscula.
3. Converta a palavra "python" para "Python" usando `str.capitalize()`.
4. Crie uma lista com várias palavras e capitalize a primeira letra de cada uma, exibindo o resultado.
5. Receba uma frase do usuário e capitalize apenas a primeira palavra.
    ```python
    frase = input('digite uma frase : ')
    lista = frase.split(' ')

    lista[0] = lista[0].capitalize()

    frase = ' '.join(lista)

    print(frase)

    ```
6. Armazene uma mensagem em uma variável e exiba-a com a primeira letra em maiúscula.
7. Receba o nome de um filme do usuário e exiba-o com a primeira letra em maiúscula.
8. Capitalize o título de um livro e exiba-o.
9. Receba o nome de uma cidade e capitalize a primeira letra.

### 4. `str.title()`
1. Crie uma variável com uma frase e use `str.title()` para capitalizar a primeira letra de cada palavra.
2. Receba uma string do usuário e exiba-a com a primeira letra de cada palavra em maiúscula.
3. Converta a frase "learning python is fun" para "Learning Python Is Fun" usando `str.title()`.
4. Crie uma lista de frases e aplique `str.title()` em cada uma, exibindo o resultado.
5. Receba uma frase do usuário e capitalize a primeira letra de cada palavra.
6. Armazene uma frase em uma variável e exiba-a com `str.title()`.
    ```python
    frase = 'eu sou uma grade frase'
    print(frase.title())

    ```
7. Receba o título de um filme e converta-o para `title case`.
8. Capitalize as palavras de um título de livro e exiba-o.
9. Receba uma frase e exiba-a com cada palavra iniciada com letra maiúscula.

### 5. `str.strip()`
1. Crie uma variável com uma string contendo espaços em branco no início e no final. Use `str.strip()` para removê-los.
2. Receba uma string do usuário com espaços extras e exiba-a sem esses espaços.
3. Remova espaços em branco de uma frase armazenada em uma variável.
4. Receba uma string de texto com espaços e pontuação extra, e use `str.strip()` para removê-los.
5. Crie uma lista de strings com espaços em branco e remova-os usando `str.strip()`.
6. Receba uma string com caracteres específicos no início e no fim e remova-os usando `str.strip()`.
7. Armazene uma frase com espaços e exiba-a sem os espaços no início e no final.
8. Receba uma string de texto e remova qualquer pontuação extra no início e no fim.
9. Receba uma frase do usuário e remova todos os espaços extras e caracteres especiais do início e fim.
    ```python
    frase = input('digite uma frase : ')

    frase = frase.strip()

    bichados = '!@#$%&*?'
    i = 0
    while i < len(bichados):
        frase = frase.strip(bichados[i])
        i = i + 1

    print(frase)
    ```

### 6. `str.lstrip()`
1. Crie uma variável com uma string contendo espaços em branco no início. Use `str.lstrip()` para removê-los.
2. Receba uma string do usuário com espaços extras no início e exiba-a sem esses espaços.
3. Remova espaços em branco do início de uma frase armazenada em uma variável.
4. Receba uma string de texto com espaços extras no início e use `str.lstrip()` para removê-los.
5. Crie uma lista de strings com espaços em branco no início e remova-os usando `str.lstrip()`.
6. Receba uma string com caracteres específicos no início e remova-os usando `str.lstrip()`.
7. Armazene uma frase com espaços no início e exiba-a sem esses espaços.
8. Receba uma string de texto e remova qualquer pontuação extra no início.
9. Receba uma frase do usuário e remova todos os espaços extras e caracteres especiais do início.

### 7. `str.rstrip()`
1. Crie uma variável com uma string contendo espaços em branco no final. Use `str.rstrip()` para removê-los.
2. Receba uma string do usuário com espaços extras no final e exiba-a sem esses espaços.
3. Remova espaços em branco do final de uma frase armazenada em uma variável.
4. Receba uma string de texto com espaços extras no final e use `str.rstrip()` para removê-los.
5. Crie uma lista de strings com espaços em branco no final e remova-os usando `str.rstrip()`.
6. Receba uma string com caracteres específicos no final e remova-os usando `str.rstrip()`.
7. Armazene uma frase com espaços no final e exiba-a sem esses espaços.
8. Receba uma string de texto e remova qualquer pontuação extra no final.
9. Receba uma frase do usuário e remova todos os espaços extras e caracteres especiais do final.

### 8. `str.replace(old, new[, count])`
1. Crie uma string e substitua todas as ocorrências de "a" por "o" usando `str.replace()`.
2. Receba uma frase do usuário e substitua todas as ocorrências de uma palavra específica por outra.
3. Substitua todos os espaços em uma string por hífens usando `str.replace()`.
4. Crie uma lista de frases e substitua uma palavra específica em todas elas usando `str.replace()`.
5. Receba uma string e substitua todas as vírgulas por pontos.
6. Substitua todas as ocorrências da palavra "Python" por "programação" em uma string.
7. Receba uma frase e substitua apenas as primeiras 3 ocorrências de uma palavra específica.
8. Crie uma string com várias ocorrências de uma palavra e substitua-a por outra, limitando o número de substituições.
9. Substitua todos os números em uma string por "#" usando `str.replace()`.
    ```python
    frase = 'sou uma 123 grande 123 frase com 1287 diversos nume1230os'
    print(frase)

    i = 0

    while i  < 10:
        frase = frase.replace(str(i),'#')
        i = i + 1

    print(frase)
    ```
10. Receba uma frase do usuário e substitua todas as ocorrências de uma letra específica, limitando o número de substituições.

### 9. `str.split(separator[, maxsplit])`
1. Crie uma string com várias palavras separadas por espaços e divida-a em uma lista de palavras usando `str.split()`.
2. Receba uma frase do usuário e divida-a em palavras usando espaços como separador.
3. Divida uma frase em uma lista de palavras usando vírgulas como separador.
4. Crie uma lista de frases e divida cada uma delas em palavras usando `str.split()`.
5. Receba uma string e divida-a em uma lista, limitando o número de divisões para 3.
6. Divida uma frase em palavras usando um caractere específico como separador.
7. Crie uma string com números separados por vírgulas e divida-a em uma lista de números.
    ```python
    texto = '33,121,11234,0981234,88282'
    print(texto)

    lista = texto.split(',')
    print(lista)

    i = 0
    while i < len(lista):
        lista[i] = int(lista[i])
        i = i + 1
    print(lista)
    ```
8. Receba uma frase do usuário e divida-a em palavras, limitando o número de divisões para 2.
9. Divida uma string em partes, usando espaços como separador e limitando o número de divisões.
10. Receba uma frase e divida-a em palavras usando um separador específico, limitando o número de divisões.

### 10. `str.join(iterable)`
1. Crie uma lista de palavras e una-as em uma única string, separando-as por espaços usando `str.join()`.
2. Receba uma lista de palavras do usuário e una-as em uma única string com hífens como separador.
3. Una os elementos de uma lista de números em uma string, separando-os por vírgulas.
4. Crie uma lista de frases e una-as em uma única string, separando-as por espaços.
5. Receba uma lista de palavras e una-as em uma string com um caractere específico como separador.
6. Una os elementos de uma lista de palavras em uma string, separando-os por " - ".
7. Receba uma lista de nomes e una-os em uma string com vírgulas como separador.
    ```python
    lista = []

    count = 5
    while count > 0:
        nome = input('digite um nome : ')
        lista.append(nome)
        count = count - 1

    print(lista)
    texto = ','.join(lista)
    print(texto)
    ```
8. Crie uma lista de palavras e una-as em uma string, separando-as por " | ".
9. Receba uma lista de frases e una-as em uma única string com pontos finais entre elas.
10. Crie uma lista de números e una-os em uma string com espaços como separador.

### 11. `str.find(sub[, start[, end]])`
1. Crie uma string e encontre a posição da primeira ocorrência de uma letra específica usando `str.find()`.
2. Receba uma frase do usuário e encontre a posição da primeira ocorrência de uma palavra específica.
3. Encontre a posição da primeira ocorrência de "Python" em uma string.
4. Crie uma lista de frases e encontre a posição de uma palavra específica em cada uma delas usando `str.find()`.
5. Receba uma string e encontre a posição da primeira ocorrência de uma letra específica, começando a busca em um índice específico.
6. Encontre a posição da primeira ocorrência de um número em uma string.
7. Receba uma frase e encontre a posição da primeira ocorrência de uma palavra específica, dentro de um intervalo específico.
8. Crie uma string e encontre a posição da primeira ocorrência de uma letra específica, buscando apenas em uma parte da string.
9. Receba uma frase do usuário e encontre a posição da primeira ocorrência de um caractere específico.
10. Encontre a posição da primeira ocorrência de uma palavra em uma string, começando a busca em um índice específico.

### 12. `str.rfind(sub[, start[, end]])`
1. Crie uma string e encontre a posição da última ocorrência de uma letra específica usando `str.rfind()`.
2. Receba uma frase do usuário e encontre a posição da última ocorrência de uma palavra específica.
3. Encontre a posição da última ocorrência de "Python" em uma string.
4. Crie uma lista de frases e encontre a posição da última ocorrência de uma palavra específica em cada uma delas usando `str.rfind()`.
5. Receba uma string e encontre a posição da última ocorrência de uma letra específica, começando a busca em um índice específico.
6. Encontre a posição da última ocorrência de um número em uma string.
7. Receba uma frase e encontre a posição da última ocorrência de uma palavra específica, dentro de um intervalo específico.
8. Crie uma string e encontre a posição da última ocorrência de uma letra específica, buscando apenas em uma parte da string.
9. Receba uma frase do usuário e encontre a posição da última ocorrência de um caractere específico.
10. Encontre a posição da última ocorrência de uma palavra em uma string, começando a busca em um índice específico.

### 13. `str.startswith(prefix[, start[, end]])`
1. Crie uma string e verifique se ela começa com uma letra específica usando `str.startswith()`.
2. Receba uma frase do usuário e verifique se ela começa com uma palavra específica.
3. Verifique se a string "Python is awesome" começa com a palavra "Python".
4. Crie uma lista de frases e verifique se cada uma começa com uma palavra específica usando `str.startswith()`.
5. Receba uma string e verifique se ela começa com uma letra específica, começando a verificação em um índice específico.
6. Verifique se uma string começa com um número específico.
7. Receba uma frase e verifique se ela começa com uma palavra específica, dentro de um intervalo específico.
8. Crie uma string e verifique se ela começa com uma letra específica, buscando apenas em uma parte da string.
9. Receba uma frase do usuário e verifique se ela começa com um caractere específico.
10. Verifique se uma string começa com uma palavra específica, começando a verificação em um índice específico.

### 14. `str.endswith(suffix[, start[, end]])`
1. Crie uma string e verifique se ela termina com uma letra específica usando `str.endswith()`.
2. Receba uma frase do usuário e verifique se ela termina com uma palavra específica.
3. Verifique se a string "Python is awesome" termina com a palavra "awesome".
4. Crie uma lista de frases e verifique se cada uma termina com uma palavra específica usando `str.endswith()`.
5. Receba uma string e verifique se ela termina com uma letra específica, começando a verificação em um índice específico.
6. Verifique se uma string termina com um número específico.
7. Receba uma frase e verifique se ela termina com uma palavra específica, dentro de um intervalo específico.
8. Crie uma string e verifique se ela termina com uma letra específica, buscando apenas em uma parte da string.
9. Receba uma frase do usuário e verifique se ela termina com um caractere específico.
10. Verifique se uma string termina com uma palavra específica, começando a verificação em um índice específico.

### 15. `str.isalpha()`
1. Crie uma string contendo apenas letras e verifique se `str.isalpha()` retorna `True`.
2. Receba uma string do usuário e verifique se ela contém apenas letras.
3. Verifique se a string "Python3" contém apenas letras usando `str.isalpha()`.
4. Crie uma lista de palavras e verifique se cada uma delas contém apenas letras.
5. Receba uma string e verifique se ela contém apenas letras, sem espaços ou caracteres especiais.
    ```python
    >>> texto = input('Digite um texto qualquer : ')
    Digite um texto qualquer : aqui tem um texto qualquer
    >>> texto
    'aqui tem um texto qualquer'
    >>>
    >>> if texto.isalpha():
    ...     print('o conteúdo dessa variável só tem caracteres alfabéticos')
    ... else:
    ...     print('essa string tem outras coisas além dos caracteres alfabéticos')
    ...
    essa string tem outras coisas além dos caracteres alfabéticos
    >>> |
    ```
6. Verifique se uma string composta por várias palavras contém apenas letras.
7. Receba uma frase do usuário e verifique se todas as palavras contêm apenas letras.
8. Verifique se uma string que contém um nome completo tem apenas letras.
9. Receba uma palavra do usuário e verifique se ela contém apenas letras, sem números ou símbolos.

### 16. `str.isdigit()`
1. Crie uma string contendo apenas números e verifique se `str.isdigit()` retorna `True`.
2. Receba uma string do usuário e verifique se ela contém apenas números.
3. Verifique se a string "12345" contém apenas números usando `str.isdigit()`.
4. Crie uma lista de strings e verifique se cada uma delas contém apenas números.
5. Receba uma string e verifique se ela contém apenas números, sem espaços ou caracteres especiais.
6. Verifique se uma string composta por um número de telefone contém apenas números.
7. Receba uma string do usuário e verifique se ela é um código postal válido (apenas números).
8. Verifique se uma string que contém a idade de uma pessoa tem apenas números.
9. Receba uma string do usuário e verifique se ela contém apenas números, sem letras ou símbolos.

### 17. `str.isalnum()`
1. Crie uma string contendo apenas letras e números e verifique se `str.isalnum()` retorna `True`.
2. Receba uma string do usuário e verifique se ela contém apenas letras e números.
3. Verifique se a string "Python3" contém apenas letras e números usando `str.isalnum()`.
4. Crie uma lista de strings e verifique se cada uma delas contém apenas letras e números.
5. Receba uma string e verifique se ela contém apenas letras e números, sem espaços ou caracteres especiais.
6. Verifique se uma string composta por um nome de usuário contém apenas letras e números.
7. Receba uma string do usuário e verifique se ela contém apenas letras e números, sem símbolos.
8. Verifique se uma string que contém uma senha tem apenas letras e números.
9. Receba uma string do usuário e verifique se ela contém apenas letras e números, sem espaços.

### 18. `str.isspace()`
1. Crie uma string contendo apenas espaços em branco e verifique se `str.isspace()` retorna `True`.
2. Receba uma string do usuário e verifique se ela contém apenas espaços.
3. Verifique se uma string composta por tabulações e espaços contém apenas espaços usando `str.isspace()`.
4. Crie uma lista de strings e verifique se cada uma delas contém apenas espaços.
5. Receba uma string e verifique se ela contém apenas espaços, sem letras ou números.
6. Verifique se uma string que aparenta estar vazia contém apenas espaços.
7. Receba uma string do usuário e verifique se ela contém apenas tabulações e espaços.
8. Verifique se uma string que contém múltiplos espaços consecutivos contém apenas espaços.
9. Receba uma string do usuário e verifique se ela contém apenas espaços, sem outros caracteres.

### 19. `str.isupper()`
1. Crie uma string em maiúsculas e verifique se `str.isupper()` retorna `True`.
2. Receba uma string do usuário e verifique se ela está totalmente em maiúsculas.
3. Verifique se a string "PYTHON" está totalmente em maiúsculas usando `str.isupper()`.
4. Crie uma lista de palavras e verifique se cada uma delas está em maiúsculas.
5. Receba uma string e verifique se ela está em maiúsculas, sem letras minúsculas.
6. Verifique se uma string que contém uma frase está toda em maiúsculas.
7. Receba uma string do usuário e verifique se ela contém apenas letras maiúsculas.
8. Verifique se uma string que contém o nome de uma cidade está em maiúsculas.
9. Receba uma string do usuário e verifique se ela está completamente em maiúsculas, sem caracteres minúsculos.

### 20. `str.islower()`
1. Crie uma string em minúsculas e verifique se `str.islower()` retorna `True`.
2. Receba uma string do usuário e verifique se ela está totalmente em minúsculas.
3. Verifique se a string "python" está totalmente em minúsculas usando `str.islower()`.
4. Crie uma lista de palavras e verifique se cada uma delas está em minúsculas.
5. Receba uma string e verifique se ela está em minúsculas, sem letras maiúsculas.
6. Verifique se uma string que contém uma frase está toda em minúsculas.
7. Receba uma string do usuário e verifique se ela contém apenas letras minúsculas.
8. Verifique se uma string que contém o nome de uma cidade está em minúsculas.
9. Receba uma string do usuário e verifique se ela está completamente em minúsculas, sem caracteres maiúsculos.

### 21. `str.zfill(width)`
1. Crie uma string numérica e use `str.zfill()` para preenchê-la com zeros à esquerda, completando um total de 10 caracteres.
2. Receba um número do usuário e complete-o com zeros à esquerda, usando `str.zfill()` para ter 8 dígitos.
3. Preencha um número de telefone com zeros à esquerda até ter um total de 12 caracteres.
4. Crie uma lista de números e preencha cada um com zeros à esquerda, até atingir 6 dígitos.
5. Receba uma string numérica do usuário e complete-a com zeros à esquerda para um total de 5 dígitos.
6. Use `str.zfill()` para garantir que um número de pedido tenha exatamente 10 dígitos, preenchendo com zeros à esquerda se necessário.
7. Receba um código postal e preencha-o com zeros à esquerda até ter 7 dígitos.
8. Preencha um número de série com zeros à esquerda até atingir 15 caracteres.
9. Receba um código de produto e complete-o com zeros à esquerda até ter 10 caracteres.

### 22. `str.center(width[, fillchar])`
1. Crie uma string e centralize-a em uma largura de 20 caracteres, preenchendo os espaços com traços (-).
    ```python
    >>> nome = 'Arnold'
    >>> nome = nome.center(20,'-')
    >>> print(nome)
    -------Arnold-------
    ```
2. Receba uma palavra do usuário e centralize-a em uma largura de 30 caracteres, usando asteriscos como preenchimento.
3. Centralize a frase "Python Rocks!" em uma largura de 40 caracteres, preenchendo os espaços com pontos (.).
4. Crie uma lista de palavras e centralize cada uma delas em uma largura de 15 caracteres, usando traços como preenchimento.
5. Receba uma string e centralize-a em uma largura de 25 caracteres, preenchendo os espaços com espaços em branco.
6. Use `str.center()` para centralizar um título de 10 caracteres em uma largura de 20, preenchendo com hífens (-).
7. Receba uma palavra do usuário e centralize-a em uma largura de 50 caracteres, preenchendo os espaços com iguais (=).
8. Centralize uma frase em uma largura de 60 caracteres, preenchendo os espaços com traços duplos (==).
9. Receba um título do usuário e centralize-o em uma largura de 35 caracteres, preenchendo os espaços com pontos de exclamação (!).

### 23. `str.ljust(width[, fillchar])`
1. Crie uma string e alinhe-a à esquerda em uma largura de 20 caracteres, preenchendo os espaços com traços (-).
2. Receba uma palavra do usuário e alinhe-a à esquerda em uma largura de 30 caracteres, usando asteriscos (*) como preenchimento.
3. Alinhe a frase "Python Rocks!" à esquerda em uma largura de 40 caracteres, preenchendo os espaços com pontos (.).
4. Crie uma lista de palavras e alinhe cada uma delas à esquerda em uma largura de 15 caracteres, usando traços como preenchimento.
5. Receba uma string e alinhe-a à esquerda em uma largura de 25 caracteres, preenchendo os espaços com espaços em branco.
6. Use `str.ljust()` para alinhar um título de 10 caracteres à esquerda em uma largura de 20, preenchendo com hífens (-).
7. Receba uma palavra do usuário e alinhe-a à esquerda em uma largura de 50 caracteres, preenchendo os espaços com iguais (=).
8. Alinhe uma frase à esquerda em uma largura de 60 caracteres, preenchendo os espaços com traços duplos (==).
9. Receba um título do usuário e alinhe-o à esquerda em uma largura de 35 caracteres, preenchendo os espaços com pontos de exclamação (!).

### 24. `str.rjust(width[, fillchar])`
1. Crie uma string e alinhe-a à direita em uma largura de 20 caracteres, preenchendo os espaços com traços (-).
2. Receba uma palavra do usuário e alinhe-a à direita em uma largura de 30 caracteres, usando asteriscos (*) como preenchimento.
3. Alinhe a frase "Python Rocks!" à direita em uma largura de 40 caracteres, preenchendo os espaços com pontos (.).
4. Crie uma lista de palavras e alinhe cada uma delas à direita em uma largura de 15 caracteres, usando traços como preenchimento.
5. Receba uma string e alinhe-a à direita em uma largura de 25 caracteres, preenchendo os espaços com espaços em branco.
6. Use `str.rjust()` para alinhar um título de 10 caracteres à direita em uma largura de 20, preenchendo com hífens (-).
7. Receba uma palavra do usuário e alinhe-a à direita em uma largura de 50 caracteres, preenchendo os espaços com iguais (=).
8. Alinhe uma frase à direita em uma largura de 60 caracteres, preenchendo os espaços com traços duplos (==).
9. Receba um título do usuário e alinhe-o à direita em uma largura de 35 caracteres, preenchendo os espaços com pontos de exclamação (!).

### 25. `str.partition(sep)`
1. Crie uma string contendo uma frase e separe-a em três partes usando `str.partition()`, com o separador sendo um espaço.
2. Receba uma frase do usuário e use `str.partition()` para separar a primeira palavra do restante.
3. Use `str.partition()` para dividir uma string em três partes, com o separador sendo uma vírgula.
4. Crie uma lista de frases e use `str.partition()` em cada uma para separar a primeira palavra do restante.
5. Receba uma string e use `str.partition()` para dividir a string em três partes, usando um hífen como separador.
6. Use `str.partition()` para separar uma frase em três partes, com o separador sendo o primeiro espaço encontrado.
7. Crie uma string com múltiplas palavras e use `str.partition()` para dividir a string na primeira ocorrência de uma palavra específica.
8. Receba uma string do usuário e use `str.partition()` para separar a string em três partes, usando um ponto final como separador.
9. Use `str.partition()` para dividir uma string de números em três partes, com o separador sendo um ponto (.)
10. Receba uma frase do usuário e use `str.partition()` para separar a frase na primeira ocorrência de uma palavra específica.

</details>
# tipo tupla

As **tuplas** (ou *tuples* em inglês) são um tipo de dado em Python que representam uma coleção ordenada de elementos. Assim como as listas, as tuplas podem armazenar múltiplos itens em uma única variável. No entanto, diferentemente das listas, as tuplas são **imutáveis**, ou seja, uma vez criadas, seus valores não podem ser alterados.

## características

1. **imutabilidade** : depois que uma tupla é criada, não é possível modificar, adicionar ou remover elementos dela. isso garante que o conteúdo da tupla permaneça constante ao longo do tempo;

2. **ordenadas** : as tuplas mantêm a ordem dos elementos. isso significa que, ao acessar os elementos de uma tupla, eles sempre serão obtidos na mesma ordem em que foram definidos;

3. **armazenamento de diferentes tipos de dados** : uma tupla pode conter itens de diferentes tipos de dados, como inteiros, floats, strings, listas, outras tuplas, etc;

4. **indexação e fatiamento** : assim como as listas, os elementos de uma tupla podem ser acessados usando índices, e é possível fatiar uma tupla para acessar subconjuntos de seus elementos;

## criando tuplas

Tuplas são criadas colocando-se os elementos separados por vírgulas dentro de parênteses `()`.

```python
>>> # exemplo de uma tupla com diferentes tipos de dados
>>> tupla_exemplo = (1, "Python", 3.14, [10, 20, 30], (40, 50, 60))
>>>
>>> print(tupla_exemplo)
(1, 'Python', 3.14, [10, 20, 30], (40, 50, 60))
>>> |
```

Neste exemplo, `tupla_exemplo` é uma tupla que contém:
- um número inteiro (`1`)
- uma string (`"Python"`)
- um número float (`3.14`)
- uma lista (`[10, 20, 30]`)
- outra tupla (`(40, 50, 60)`)

## acessando elementos de uma tupla

Os elementos de uma tupla podem ser acessados por meio de seus índices, que começam em `0` para o primeiro elemento, `1` para o segundo, e assim por diante.

```python
>>> # acessando elementos individuais
>>> primeiro_elemento = tupla_exemplo[0]
>>> segundo_elemento = tupla_exemplo[1]
>>>
>>> print(primeiro_elemento)
1
>>> print(segundo_elemento)
Python
>>> |
```

## fatiamento (slicing)

É possível obter sub-tuplas de uma tupla usando a notação de fatiamento (slicing).

```python
>>> # fatiamento básico
>>> sub_tupla = tupla_exemplo[1:4]
>>>
>>> print(sub_tupla)
('Python', 3.14, [10, 20, 30])
>>> |
```

Neste exemplo, `tupla_exemplo[1:4]` retorna uma sub-tupla que inclui os elementos do índice `1` ao `3` (o índice final `4` não é incluído).

## tuplas com um único elemento

Para criar uma tupla com apenas um elemento, é necessário adicionar uma vírgula após o elemento dentro dos parênteses, caso contrário, Python interpretará os parênteses como um agrupamento de expressões.

```python
>>> # Tupla com um único elemento
>>> tupla_unica = (42,)
>>>
>>> print(type(tupla_unica))
<class 'tuple'>
>>> |
```

Sem a vírgula, Python consideraria `tupla_unica` como um número inteiro e não como uma tupla.

## imutabilidade

Uma das principais diferenças entre tuplas e listas é que as tuplas são imutáveis. Isso significa que, depois de criada, uma tupla não pode ser modificada. Não é possível alterar, adicionar ou remover elementos de uma tupla.

```python
>>> # tentando alterar um elemento da tupla
>>> try:
>>>     tupla_exemplo[0] = 100
>>> except TypeError as e:
>>>     print(e)
'tuple' object does not support item assignment
>>> |
```

## usos comuns das tuplas

1. **agrupamento de dados** : tuplas são frequentemente usadas para agrupar dados que logicamente pertencem juntos, como coordenadas `(x, y)` ou informações de contato;

1. **retorno de múltiplos valores de funções** : as funções em python podem retornar múltiplos valores encapsulados em uma tupla;
    ```python
    >>> def dividir_e_resto(dividendo, divisor):
    >>>     quociente = dividendo // divisor
    >>>     resto = dividendo % divisor
    >>>     return quociente, resto
    >>>
    >>> resultado = dividir_e_resto(10, 3)
    >>> print(resultado)
    (3, 1)
    >>> |
    ```
    Neste exemplo, a função `dividir_e_resto` retorna uma tupla com o quociente e o resto da divisão.

1. **tuplas aninhadas**: tuplas podem conter outras tuplas como elementos, criando uma estrutura aninhada;
    ```python
    >>> tupla_aninhada = (1, (2, 3), (4, (5, 6)))
    >>>
    >>> print(tupla_aninhada)  # Saída: (1, (2, 3), (4, (5, 6)))
    ```

4. **chaves imutáveis em dicionários**: tuplas podem ser usadas como chaves em dicionários porque são imutáveis.
    ```python
    >>> coordenadas = {}
    >>> coordenadas[(10, 20)] = "Ponto A"
    >>> coordenadas[(30, 40)] = "Ponto B"
    >>>
    >>> print(coordenadas)
    {(10, 20): 'Ponto A', (30, 40): 'Ponto B'}
    >>> |
    ```

### métodos e funções úteis para tuplas

Embora as tuplas sejam imutáveis, Python oferece algumas funções e métodos que podem ser usados com elas:

- **`len(tupla)`** : retorna o número de elementos na tupla;
- **`min(tupla)` e `max(tupla)`** : retornam o menor e o maior elemento da tupla, respectivamente;
- **`tupla.index(valor)`** : retorna o índice do primeiro elemento com o valor especificado;
- **`tupla.count(valor)`** : retorna o número de vezes que o valor aparece na tupla;

```python
>>> numeros = (3, 2, 8, 6, 2, 7)
>>>
>>> print(len(numeros))
5
>>> print(min(numeros))
2
>>> print(max(numeros))
8
>>> print(numeros.index(2))
1
>>> print(numeros.count(2))
2
```

### convertendo entre listas e tuplas

É possível converter uma lista em uma tupla e vice-versa usando as funções `tuple()` e `list()`.

```python
>>> lista = [1, 2, 3]
>>> tupla_convertida = tuple(lista)
>>> print(tupla_convertida)
(1, 2, 3)
>>>
>>> tupla = (4, 5, 6)
>>> lista_convertida = list(tupla)
>>> print(lista_convertida)
[4, 5, 6]
>>> |
```

## exercícios

<details>
<summary>Lista de Exercícios</summary>

1. nível simples
    1. **Acessando Elementos**: Crie uma tupla com 5 números inteiros. Escreva um loop `for` que percorra a tupla e imprima cada elemento.
    1. **Índices e Elementos**: Crie uma tupla com 4 strings. Escreva um loop `while` que percorra a tupla e imprima o índice e o valor de cada elemento.
    1. **Verificação de Presença**: Crie uma tupla com alguns números. Escreva um loop `for` que verifica se o número 7 está presente na tupla e, se estiver, imprima "Número encontrado".
    1. **Contando Elementos**: Crie uma tupla com 6 números inteiros. Use um loop `for` para contar quantos números na tupla são maiores que 10.
    1. **Tupla de Tuplas**: Crie uma tupla contendo outras tuplas dentro dela. Escreva um loop `for` que percorra cada sub-tupla e imprima seus elementos.
1. nível intermediário
    1. **Comparando Tuplas**: Crie duas tuplas de números inteiros. Escreva um loop `while` que compare elemento por elemento as duas tuplas e imprima qual tupla tem o maior número naquele índice.
    1. **Soma de Elementos**: Crie uma tupla com 5 números inteiros. Use um loop `for` para calcular e imprimir a soma de todos os elementos da tupla.
    1. **Verificação de Índices**: Crie uma tupla com 8 elementos. Use um loop `while` para verificar se o terceiro e o sexto elementos são iguais. Imprima "Iguais" ou "Diferentes" conforme o caso.
    1. **Busca em Tupla**: Crie uma tupla com 6 strings. Escreva um loop `for` que percorra a tupla e, se encontrar a string "Python", imprima "Linguagem encontrada!" e pare o loop.
    1. **Filtros com If**: Crie uma tupla de números inteiros. Escreva um loop `for` que percorra a tupla e imprima apenas os números pares.
1. nível avançado
    1. **Tuplas com Condicionais**: Crie uma tupla com 5 números inteiros. Escreva um loop `for` que verifique se cada número é maior que 10. Se for, imprima "Maior que 10", caso contrário, imprima "Menor ou igual a 10".
    1. **Contagem de Itens**: Crie uma tupla com vários números, alguns deles repetidos. Escreva um loop `while` que percorra a tupla e conte quantas vezes o número 3 aparece.
    1. **Tupla de Strings**: Crie uma tupla de strings. Escreva um loop `for` que percorra a tupla e, para cada string, verifique se ela começa com a letra "A". Se sim, imprima "Começa com A".
    1. **Busca com Condicional**: Crie uma tupla com números inteiros. Escreva um loop `while` que percorra a tupla e verifique se há algum número negativo. Se encontrar, imprima "Número negativo encontrado" e termine o loop.
    1. **Verificação de Maior Número**: Crie uma tupla com 5 números. Escreva um loop `for` que encontre e imprima o maior número da tupla.
1. nível complexo
    1. **Comparando Duas Tuplas**: Crie duas tuplas de números. Escreva um loop `while` que percorra ambas as tuplas e imprima qual número é maior em cada índice correspondente.
    1. **Tuplas Aninhadas**: Crie uma tupla que contenha outras tuplas dentro. Escreva um loop `for` que percorra cada sub-tupla e verifique se o primeiro elemento é maior que o segundo. Imprima "Sim" ou "Não" conforme o caso.
    1. **Verificação de Todos os Elementos**: Crie uma tupla de números inteiros. Escreva um loop `for` que verifique se todos os elementos são positivos. Se algum número for negativo, imprima "Número negativo encontrado" e interrompa o loop.
    1. **Tuplas e Condicionais**: Crie uma tupla com números e escreva um loop `while` que percorra a tupla. Se o número for maior que 20, multiplique-o por 2 e imprima o resultado.
    1. **Acessando Sub-Tuplas**: Crie uma tupla de 3 sub-tuplas, cada uma contendo 2 números. Escreva um loop `for` que percorra cada sub-tupla e some os números de cada uma, imprimindo o resultado.
1. nível muito complexo
    1. **Comparação de Listas e Tuplas**: Crie uma lista e uma tupla com números inteiros. Escreva um loop `for` que percorra ambos e imprima qual estrutura tem o maior número em cada índice correspondente.
    1. **Filtragem em Tuplas**: Crie uma tupla com vários números. Escreva um loop `while` que percorra a tupla e crie uma nova tupla contendo apenas os números pares.
    1. **Tupla e Contador**: Crie uma tupla de números inteiros. Escreva um loop `for` que percorra a tupla e use um contador para contar quantos números são maiores que 15.
    1. **Análise de Dados**: Crie uma tupla com temperaturas registradas durante uma semana. Escreva um loop `while` que percorra a tupla e identifique quantos dias tiveram temperatura acima de 30 graus.
    1. **Tuplas e Índices**: Crie uma tupla de números. Escreva um loop `for` que percorra a tupla e imprima apenas os números que estão em índices pares.
    1. **Busca de Substrings**: Crie uma tupla de strings. Escreva um loop `for` que percorra a tupla e imprima apenas as strings que contêm a substring "py".
    1. **Verificação de Múltiplos de 5**: Crie uma tupla com números inteiros. Escreva um loop `while` que percorra a tupla e verifique se cada número é múltiplo de 5. Imprima "Múltiplo de 5" ou "Não é múltiplo de 5" conforme o caso.
    1. **Contagem de Vogais**: Crie uma tupla de strings. Escreva um loop `for` que percorra cada string na tupla e conte quantas vogais há em cada uma, imprimindo o resultado.
    1. **Tupla de Pares e Ímpares**: Crie uma tupla de números. Escreva um loop `while` que percorra a tupla e crie duas novas tuplas, uma contendo apenas os números pares e outra contendo apenas os ímpares.
    1. **Comparação de Sub-Tuplas**: Crie uma tupla de sub-tuplas, onde cada sub-tupla contém dois números. Escreva um loop `for` que percorra cada sub-tupla e verifique se a soma dos dois números é maior que 10. Imprima "Sim" ou "Não" conforme o caso.

</details>
# Avaliação

<details>
<summary>solicitante</summary>

<img
    src="https://e7.pngegg.com/pngimages/536/147/png-clipart-logo-harry-potter-and-the-cursed-child-hogwarts-james-potter-fictional-universe-of-harry-potter-harry-potter-logo-magic-thumbnail.png"
    alt="escudo hogwarts"
    width="65%">

Sua equipe foi contratada pela Escola de Magia e Bruxaria de Hogwarts para criar uma série de Algoritmos, já que eles não possuem experiência em programas.

Como a escola não tem experiência com computadores, apenas uma máquina foi adquirida e ela ainda estava amaldiçoada. Essa maldição fez com que apenas duas pessoas pudessem estar próximas sem desligar e apenas um poder usar. Para que a equipe seja bem avaliada, todos os integrantes tem que desenvolver os códigos. Então, para isso, haverá um revezamento no uso da máquina.

Eis as regras :
- apenas um aluno de cada vez poderá usar o teclado;
- um segundo aluno sentará ao lado e pode opinar sobre o código, mas não pode tocar no teclado ou mouse;
- após 60 segundos, o aluno do teclado irá para o fundo da sala para junto do resto da turma e o aluno papagaio sentará na cadeira do teclado;
- um aluno do fundo da sala sentará na posição de papagaio;
- os alunos do fundo da sala, podem usar um computador para testes e buscar material;
- a ordem de uso da máquina será definida em um sorteio no começo e deverá ser mantida até o final;

</details>

## desafio 1

<details>
<summary>detalhes</summary>

A professora Minerva recebeu vocês na entrada de Hogwarts. Ela os encaminhou até um computador velho e amarelado, com um monitor de tubo. Como ela ainda não conhece as capacidade da equipe, ela gostaria de testar todos antes que outros professores façam suas solicitações.

Então, ela pediu os seguintes algoritmos :
- um programa que peça um número inteiro positivo e some todos os valores de zero até o número informado;
- um programa que peça dois números inteiros distintos e depois some todos os números no intervalo especificado;
- um programa que peça dez números inteiros, depois peça um novo número inteiro e verifique se ele já foi digitado anteriormente;

</details>

## desafio 2

<details>
<summary>detalhes</summary>

Após o teste, a professora Minerva ficou muito satisfeita.

Vocês desmontaram o computador e a seguiram até a Estufa. Lá, encontraram a professora Sprout, da aula de Herbologia. Vocês se instalaram em um canto e aguardaram.

O local possuia muitas plantas, de diferentes espécies. Então, ela quer um programa para calcular a taxa de crescimento de duas plantas. Ela possui uma Mandrágora que tem 0.50m e cresce 2cm por ano e um Visgo do Diabo que tem 0.10m e cresce 3cm por ano.

Ela gostaria que vocês construissem um algoritmo que calculasse e mostrasse quantos anos serão necessários para que o Visgo do Diabo seja maior que a Mandrágora.

</details>

## desafio 3

<details>
<summary>detalhes</summary>

Depois de deixarem a professora Sprout muito satisfeita, vocês foram encaminhados, ainda pela professora Minerva, até as masmorras. Lá, eram esperados pelo professor Snape, da Aula de Poções. Ele está muito irritado que vários alunos do outro lado do oceano não sabem converter corretamente as escalas de temperatura, fazendo que caldeirões explodam durante suas as aulas. Então, sem floreios, ele vai logo dizendo o que quer.

Ele quer que sua equipe crie um programa que realize as conversões da tabela abaixo :

<img
    src="https://www.infoescola.com/wp-content/uploads/2010/01/conversao-de-escalas-termometricas-tabela.jpg"
    alt="imagem dos elementos da divisão"
    width="65%">

O que ele espera do programa : um aluno irá digitar que conversão gostaria de realizar. Uma vez escolhida, seu programa deverá receber como entrada um valor numérico do tipo **float** e mostrar uma mensagem informando a temperatura em uma escala e seu valor correspondente na escala a ser convertida.

</details>

## desafio 4

<details>
<summary>detalhes</summary>

Após finalmente sair da masmorra fechada e claustrofóbica e deixar para trás um professor muito carrancudo, vocês foram encaminhados pela professora Minerva até a Madame Hooch, da Turma de Voo no campo de Quadribol. Ela gostaria de um programa para calcular os pontos de uma partida. Cada gol vale dez pontos e a captura do pomo de ouro vale cento e cinquenta pontos.

Ela quer que desenvolvam um programa que seja usado durante uma partida de Quadribol.

O que ele deverá fazer :
- especificar as duas casas que irão disputar a partida :
    - Grifinória, Lufa-Lufa, Corvinal ou Sonserina;
- guardar a pontuação na ordem de marcação que acontecer durante o jogo;
- quando o pomo for capturado, especificar a casa que o capturou;
- mostrar o placar final da partida indicando a casa vencedora;

</details>

## desafio final

<details>
<summary>detalhes</summary>

Uma vez terminado, vocês desmontam novamente o computador e seguiram a professora Minerva de volta ao castelo. Uma vez lá dentro, vocês foram encaminhados para a sala do diretor Albus Dumbledore.

Ele gostaria que criem um algoritmo para calcular a média de um aluno de alguma disciplina da escola.

As notas são passadas usando letras, mas cada uma tem uma pontuação específica, conforme a tabela abaixo :

| nota | valor numérico || nota | valor numérico || nota | valor numérico |
| :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: |
| A+ | 10.0 || A | 9.7 || A- | 9.3 |
| B+ | 8.9 || B | 8.4 || B- | 7.9 |
| C+ | 7.4 || C | 6.9 || C- | 6.4 |
| D+ | 5.9 || D | 3.9 || D- | 2.0 |
| F  | 0.0 |

Ele quer que vocês criem um programa que peça o nome do aluno, sua casa, uma disciplina da lista (Transfiguração, Herbologia, Poções, Astronomia, Defesa Contra as Artes das Trevas e Trato das Criaturas Mágicas) e 5 notas do aluno (A, B-, etc). Depois, calcule sua média.

Se a média for maior ou igual 9.5, exiba a mensagem "Nível Auror". Se a média for menor que 9.5 e maior que 8.4, exiba a mensagem "Ótimo". Média menor que 8.5 e maior que 7.4, "Excede Expectativas". Média menor que 7.4 e maior que 5.9, "Aceitável". Média menor que 6.0 e e maior que 3.9, "Péssimo (Recuperação)". Média menor que 4.0 e maior que 1.9, "Deplorável". Média menor que 2.0, "Trasgo".

Por fim, exiba o nome do aluno, a sua casa, a disciplina, sua lista de suas notas, a média atingida e a respectiva mensagem.

</details>



# avaliacao.md

# avaliação

## validando cpf

O CPF, ou Cadastro de Pessoas Físicas, é um documento emitido pela Receita Federal do Brasil que serve para identificar os contribuintes brasileiros, tanto residentes no país quanto no exterior. Ele é essencial para diversas atividades, como abrir contas bancárias, declarar imposto de renda, realizar compras a crédito, entre outras.

O CPF é composto por 11 dígitos numéricos, geralmente formatados como `XXX.XXX.XXX-YY`, onde `XXX.XXX.XXX` são os números do CPF propriamente ditos e `YY` são os dígitos verificadores, usados para validar a autenticidade do número.

O algoritmo de validação do CPF calcula o primeiro dígito verificador a partir dos 9 primeiros dígitos do CPF, e em seguida, calcula o segundo dígito verificador a partir dos 9 (nove) primeiros dígitos do CPF, mais o primeiro dígito, obtido na primeira parte.

Para explicar bem o processo de validação, vai ser usado como exemplo o CPF fictício, mas válido : `111.444.777-35`.

## cálculo dos dígitos

### cálculo do primeiro dígito

Para validar um CPF, é preciso começar com o calculo do primeiro dígito verificador. Para isso, é preciso separar os 9 primeiros dígitos do CPF (111444777) e multiplicar cada um dos números, da esquerda para a direita por números decrescentes a partir do 10.

Veja a tabela abaixo :

> | Dígito CPF|| Multiplicador|| Resultado |
> | :----: | :----: | :----: | :----: | :----: |
> ||||||
> | `1` | * | `10` | = | `10` |
> | `1` | * | `9` | = | `9` |
> | `1` | * | `8` | = | `8` |
> | `4` | * | `7` | = | `28` |
> | `4` | * | `6` | = | `24` |
> | `4` | * | `5` | = | `20` |
> | `7` | * | `4` | = | `28` |
> | `7` | * | `3` | = | `21` |
> | `7` | * | `2` | = | `14` |
> ||||||

Cada dígito do CPF é multiplicado pelo respectivo número. Depois todos os resultados são somados :

> `10` + `9` + `8` + `28` + `24` + `20` + `28` + `21` + `14` = `162`

A partir do resultado obtido na soma, é realizada uma divisão por `11`. Esse cálculo irá gerar um quociente e um resto inteiros. Então, dividir `162` por `11` irá gerar um quociente igual a `14` e um resto igual `8`.

A partir desse resultado, é feita a seguinte avaliação :
- se o resto da divisão for `menor que 2`, então o primeiro dígito é igual a `zero`;
- se o resto da divisão for `maior ou igual a 2`, então o dígito verificador é igual a `11 menos o resto da divisão`;

No exemplo, o resto obitido foi oito, logo o primeiro dígito verificador é o onze menor o resto :

> `11 - 8 = 3`

O primeiro dígito verificador é `3`.

### cálculo do segundo dígito

Para calcular o segundo dígito, é necessário já saber qual é o primeiro digito calculado. O mesmo processo de multiplicação e soma terá que ser realizado, mas dessa vez é incluído o recém calculado primeiro dígito verificador ao final. E, em vez de iniciar a multiplicação em 10 e decrescer até o 2, é iniciado em `11` e decrescendo ainda até o 2.

Veja a tabela abaixo :

> | Dígito CPF|| Multiplicador|| Resultado |
> | :----: | :----: | :----: | :----: | :----: |
> ||||||
> | `1` | * | `11` | = | `11` |
> | `1` | * | `10` | = | `10` |
> | `1` | * | `9` | = | `9` |
> | `4` | * | `8` | = | `32` |
> | `4` | * | `7` | = | `28` |
> | `4` | * | `6` | = | `24` |
> | `7` | * | `5` | = | `35` |
> | `7` | * | `4` | = | `28` |
> | `7` | * | `3` | = | `21` |
> | `3` | * | `2` | = | `6` |
> ||||||

Novamente é efetuada a soma dos resultados da multiplicação :

> `11` + `10` + `9` + `32` + `28` + `24` + `35` + `28` + `21` + `6` = `204`

E novamente o total do somatório é dividido por onze para obter o quociente `18` e o resto `6` da divisão.

Uma vez conhecidos o resto e o quociente, o mesmo teste do resto é realizado :
- se o resto da divisão for `menor que 2`, então o segundo dígito é igual a `zero`;
- se o resto da divisão for `maior ou igual a 2`, então o dígito verificador é igual a `11 menos o resto da divisão`;

No exemplo, subtraindo 11 do resto resultará em :

> `11 - 6 = 5`

Logo, `5` é o segundo dígito verificador.

### validando os dígitos

Agora que ambos os dígitos são conhecidos (`3` e `5`), é possível validar o CPF.

Para isso, é necessário comparar os dígitos primeiro e segundo encontrados com o CPF a ser validado, o `111.444.777-35` deste exemplo. Se o primeiro dígito for igual ao penúltimo número do CPF e o segundo dígito for igual ao último número do CPF, então ele é válido. Se qualquer um deles for diferente, então o CPF é inválido.

Por exemplo :
- 111.444.777-35 é válido;
- 111.444.777-36 é inválido;
- 111.444.777-45 é inválido;

## cpfs sempre inválidos

Embora a validação funcione para todos os CPFs no formato esperado, alguns CPFs bem específicos são considerados **sempre** inválidos

São aqueles com dígitos repetidos, isto é, é composto de apenas um dígito repetido 11 vezes. Por exemplo :
- `111.111.111-11`
- `222.222.222-22`
- `333.333.333-33`,
- etc

Então, seu algoritmo deverá ignorar os CPFs com o padrão acima e avisar ao usuário de sua invalidade.

## entrada de dados

É muito importante para um validador de CPF ser capaz de receber o CPF do usuário e então retornar uma forma de aviso quando à sua validade.

Então,seu programa deverá pedir **vários** CPFs ao usuário.

Os formatos possíveis para um CPF digitado podem ser `XXX.XXX.XXX-YY`, `XXXXXXXXXYY`, `XXX.XXX.XXXYY`, etc. Não podem ser aceitos caracteres alfanuméricos e caracteres especiais, com exceção do ponto `.` e do traço `-`. Para interromper a digitação dos CPFs o usuário precisará digitar `sair` em vez de um CPF.

Após receber o CPF, seu programa deverá mostrar se o que foi digitado é válido ou inválido.

Alguns exemplos de mensagens :
- *O CPF digitato está em um formato inválido*;
- *Não digite letras no CPF*;
- *O CPF <cpf_digitado> é inválido!*, se ao menos um dos dígitos verificadores forem diferentes dos dois últimos números do CPF;
- *O CPF <cpf_digitado> é válido!*, se ambos os dígitos verificadores forem iguais dos dois últimos números do CPF;

O campo <cpf_digitado> deverá estar no formato `XXX.XXX.XXX-YY`, independente de como ele foi digitado pelo usuário.

## mensagens

Crie mensagens de boas vindas, encerramento e notificando se o CPF foi validado corretamente ou incorretamente.

## otimização

Use funções para otimizar seu programa.

Embora o código da soma dos dígitos do CPF e da validação dos dígitos verificadores possa ser feito em uma função cada, isso não será obrigatório para seu programa. Crie funções para deixar seu programa organizado e mais eficiente.

Seu programa deverá, **por hora**, possuir ao menos 4 funções.

## módulos

Para melhor organização do software, organize seu programa em ao menos 2 módulos. Um deles conterá as funções e variáveis de seu programa e o outro será o módulo principal, que ficará responsável pela execução do programa, chamado de `main.py`. Ele irá realizar o `import` do módulo auxiliar.

## testes

Para que um programa funcione corretamente, é necessário que haja uma bateria de testes. Para isso, o uso da variável `__name__` dentro de um módulo é imprescindível.

Crie uma lista de testes com diversos CPFs inválidos e válido para serem realizados quando o módulo auxiliar for chamado diretamente. Realize testes com todas as funções do seu código. Exiba mensagens informando quando o teste ocorrer conforme o esperado e quando acontece um erro imprevisto.

## tratando erros

Acontece muito de ocorrer uma interrupção da execução do programa por culpa de um erro imprevisto. Para evitar isso, use os comandos `try` e `except` para evitar que a execução seja interrompida.

Seu programa deverá executar e jamais ser interrompido por um erro inesperado. Use exceções **`específicas`** para bloquear as interrupções.

## arquivos

Arquivos são uma forma eficiente de armazenar informações por tempo indeterminado. Por conta disso, é necessário que sejam criados registros das tentativas de validação do CPF. Ambos deverão ser cumulativos, isto é, a cada execução do programa os novos registros devem ser adicionados ao final deles.

Seu programa deverá ter dois arquivos distintos.
- `erros.log` : o arquivo será responsável por armazenar a data e hora exatos do pedido de validação, o CPF digitado pelo usuário e uma mensagem sucinta informando o motido dele ter sido invalidado, conforme o exemplo;

    exemplos :
    ```log
    [16/08/2024 18:55:34.123456] asdf : caracter inválido
    [19/08/2024 18:21:34.123456] 111.444.777-315 : tamanho inválido
    [20/08/2024 19:32:34.123456] 123.456.799-87 : 1º dígito inválido
    [20/08/2024 07:44:34.123456] 111.444777-15 : 1º dígito inválido
    [21/08/2024 10:01:34.123456] 111.444.777-36 : 2º dígito inválido
    [22/08/2024 00:12:34.123456] 111.111.111-11 : dígitos repetidos
    ```

- `validos.json` : o arquivo será responsável por armazenar a data e hora exatos do pedido de validação, armazenar os CPFs validados e que tiveram seus dois dígitos verificados e aprovados, conforme o exemplo;

    exemplo :
    ```json
    {
        [
            {"data":"16/08/2024","hora":"07:44:34.123456","cpf_digitado": "111444.777-35","digito_1": 3,"digito_2": 5,"cpf_formatado": "111.444.777-35"},
            {"data":"30/08/2024","hora":"18:21:34.123456","cpf_digitado": "111.444.777-35","digito_1": 3,"digito_2": 5,  "cpf_formatado": "111.444.777-35"},
            {"data":"31/08/2024","hora":"18:42:34.123456","cpf_digitado": "11144477735","digito_1": 3,"digito_2": 5,"cpf_formatado": "111.444.777-35"}
        ]
    }
    ```

## classes

É muito importante organizar o código em classes.

Para isso, seu programa deverá possuir ao menos duas classes :
- a classe `Cpf` deverá ser responsável por guardar o CPF digitado pelo usuário, realizar as validações dos dígitos verificadores, retornar quando estivar válido / inválido;
- a classe `Arquivo` deverá ser responsável por receber as mensagens e salvá-las ou no arquivo `erros.log` ou no arquivo `validos.json`;
- todas funções criadas envolvendo o CPF deverão ser adaptadas para serem usadas através dos objetos da classe `Cpf`, enquanto que todas as funções criadas envolvendo a manipulação de arquivos deverão ser adaptadas para serem usadas através de objetos da classe `Arquivo`;

Seu módulo principal, o módulo `main.py`, deverá receber o CPF ditado e torná-lo uma instância da classe `Cpf`, para só então realizar todas as validações e verificações.

## o que usar

> [!CAUTION]
> Apenas os conteúdos vistos em aula (que estão neste repositório) são permitidos para a realização do código.
> Se algum material fora deste repositório for usado, ***`TODO`*** o código será invalidado e o aluno estará sugeito à **recuperação**.

## checklist

Abaixo há uma lista de todos os pontos que devem ser realizados.
Lista essa que irá aumentar quando novos conteúdos forem apresentados em aula.

Lista :

Parte 1
- [ ] receber um CPF do usuário;
- [ ] validar o CPF digitado (só pode possuir números, pontos e traço);
- [ ] mostrar uma mensagem informando se o CPF está em formato inválido;
- [ ] encontrar o primeiro dígito verificador;
- [ ] usar o primeiro dígito encontrado para o cálculo do segundo dígito verificador;
- [ ] encontrar o segundo dígito verificador;
- [ ] comparar os dois dígitos encontrados com os dois últimos números do CPF;
- [ ] mostrar o CPF digitado no formato XXX.XXX.XXX-YY;
- [ ] mostrar uma mensagem informando se o CPF digitado é válido ou inválido;

Parte 2
- [ ] receber diversos CPFs do usuário sem interromper o programa;
- [ ] rejeitar CPFs com dígitos iguais;

Parte 3
- [ ] mensagem de boas vindas;
- [ ] função para receber e validar o CPF;
- [ ] função para calcular a soma dos dígitos verificadores (uma função para ambas as somas);
- [ ] função para realizar os testes dos dígitos verificadores (uma função para ambos os testes);
- [ ] mensagem ao finalizar;

Parte 4
- [ ] organização do código em pelo menos dois módulos;
- [ ] um módulo será de auxiliar, onde terá as funções e variáveis;
- [ ] o outro será o principal e deverá ser chamado de `main.py`, onde o programa será executado;

Parte 5
- [ ] use da variável `__name__` para casos de teste nos módulos auxiliares;
- [ ] uso dos blocos `try` e `except`;
- [ ] criação e armazenamento dos CPFs inválidos em `erros.log`;
- [ ] criação e armazenamento dos CPFs válidos em `validos.json`;

Parte 6
- [ ] crie a classe `Cpf`;
- [ ] crie a classe `Arquivo`;
- [ ] use ambas as classes para instanciar objetos a partir do módulo `main.py`;
- [ ] adicione a data e hora em cada validação do CPF com o módulo `datetime`;


# cast.md

Índice Cast

1. [o que é cast](#o-que-é-cast)
1. [funções de conversão](#funções-de-conversões)
1. [detalhes importantes](#detalhes-importantes)
1. [lista de exercícios](#lista-de-exercícios)

# cast

## o que é cast

Em programação, **cast** ou **casting** refere-se à conversão de uma variável de um tipo de dado para outro. No Python, isso é feito utlizando funções de conversão de tipo. Por exemplo, pode-se converter um número em uma string, uma string em um número.

## funções de conversões

Abaixo, há uma lista de conversão de algum dos tipo do Python :

* `int()` : converte para um número inteiro;
* `float()` : converte para um número de ponto flutuante;
* `str()` : converte para uma string;
* `bool()` : converte para um valor booleano;

Veja alguns exemplos :

```python
# convertendo string para inteiro
numero = int('123')
print(numero)  # saída : 123

# convertendo float para inteiro
numero = int(3.14159265)
print(numero)  # saida : 3

# convertendo boolean para inteiro
numero = int(True)
print(numero)  # saida : 1

# convertendo string para float
numero = float('3.1415')
print(numero)  # saída : 3.1415

# convertendo inteiro para float
numero = float(42)
print(numero)  # saida : 42.0

# convertendo boolean para float
numero = float(True)
print(numero)  # saida : 1.0

# convertendo inteiro para string
texto = str(42)
print(texto)  # saída : "42"

# convertendo float para string
texto = str(3.1415)
print(texto)  # saida : "3.1415"

# convertendo boolean para string
texto = str(True)
print(texto)  # saida : "True"

# convertendo inteiro para boolean
texto = bool(42)
print(texto)  # saída : True

# convertendo float para boolean
texto = bool(0.0)
print(texto)  # saida : False

# convertendo string para boolean
texto = bool('Arnold')
print(texto)  # saida : True

# convertendo string para boolean
texto = bool('')
print(texto)  # saida : False
```

## detalhes importantes

Alguns detalhes importantes sobre a conversão de um tipo de variável em outra :

1. `ìnt()` : converte uma string ou float para um inteiro, mas se a string não representar um número inteiro válido, irá levantar um erro;
1. `float()` : converte uma string ou um inteiro para um float e, assim como o inteiro, se a string não representar um número válido, irá levantar um erro;
1. `str()` : converte qualquer tipo de dado para uma string;
1. `bool()` : converte qualquer tipo de dado para booleano. Valores como `0`, `0.0`,`''` (uma string vazia), `[]` (uma lista vazia), `()` (uma tupla vazia), `{}` (um dicionário vazio) são convertidos para `False`, enquanto que qualquer outro valor é convertido para `True`.

## lista de exercícios

<details>
<summary>Lista de Exercícios</summary>

1. Converting to Integer (int())
    1. Converta a string "1234" para um inteiro.
    1. Converta a string "56" para um inteiro.
    1. Converta o float 98.76 para um inteiro.
    1. Converta a string "0" para um inteiro.
    1. Converta o float 0.0 para um inteiro.
    1. Converta a string "200" para um inteiro.
    1. Converta o float 150.99 para um inteiro.
    1. Converta a string "-123" para um inteiro.
    1. Converta a string "999" para um inteiro.
    1. Converta o float -45.67 para um inteiro.
1. Converting to Float (float())
    1. Converta a string "123.45" para um float.
    1. Converta a string "56.78" para um float.
    1. Converta o inteiro 100 para um float.
    1. Converta a string "0" para um float.
    1. Converta o inteiro 0 para um float.
    1. Converta a string "250.75" para um float.
    1. Converta o inteiro 45 para um float.
    1. Converta a string "-987.65" para um float.
    1. Converta a string "3.14159" para um float.
    1. Converta o inteiro -200 para um float.
1. Converting to String (str())
    1. Converta o inteiro 1234 para uma string.
    1. Converta o float 56.78 para uma string.
    1. Converta o inteiro 0 para uma string.
    1. Converta o float 0.0 para uma string.
    1. Converta o inteiro 789 para uma string.
    1. Converta o float 12.34 para uma string.
    1. Converta o inteiro -123 para uma string.
    1. Converta o float -56.78 para uma string.
    1. Converta o booleano True para uma string.
    1. Converta o booleano False para uma string.
1. Converting to Boolean (bool())
    1. Converta a string "True" para um booleano.
    1. Converta a string "False" para um booleano.
    1. Converta a string "" (string vazia) para um booleano.
    1. Converta o inteiro 0 para um booleano.
    1. Converta o inteiro 1 para um booleano.
    1. Converta o float 0.0 para um booleano.
    1. Converta o float 3.14 para um booleano.
    1. Converta a string "Hello" para um booleano.
    1. Converta a string "0" para um booleano.
    1. Converta a string " " (espaço) para um booleano.

</details>



# comandos-built-in.md

Índice

1. [`in`](#in)
1. [exercícios `in`](#exercicios-in)
1. [`del`](#del)
1. [exercícios `del`](#exercicios-del)
1. [`pass`](#pass)
1. [`break`](#break)
1. [`continue`](#continue)
1. [`break` e `continue`](#break-e-continue)
1. [exercícios `break` e `continue`](#exercícios-break-e-continue)
1. [`assert`](#assert)
1. [exercícios `assert`](#exercicios-assert)
1. [`yield`](#yield)
1. [exercícios `yield`](#exercícios-yield)

# comandos built-in

Comandos built-in do Python são funções e tipos de dados que estão disponíveis diretamente na linguagem, sem a necessidade de importar módulos adicionais. Eles fazem parte da biblioteca padrão e oferecem funcionalidades básicas essenciais para a programação.

## `in`

O comando `in` do Python é um operador que verifica a existência de um elemento em uma coleção de elementos, como listas, strings, tuplas, dicionários, sets, etc. Ele retorna um valor booleano: `True` se o elemento estiver presente na coleção e `False` caso contrário.

```python
# sintaxe básica
elemento in coleção
```

- `elemento` : é o item que você deseja verificar se está presente na coleção;
- `coleção` : é a estrutura de dados onde a verificação será feita;

### exemplos

#### `in` em strings

Quando usado com strings, o `in` verifica se uma substring está presente na string.

```python
>>> mensagem = "Olá, mundo!"
>>>
>>> print('Olá' in mensagem)
True
>>> print('mundo' in mensagem)
True
>>> print('Python' in mensagem)
False
>>> |
```

- aqui, `Olá` e `mundo` são substrings de `mensagem`, então o resultado é `True`;
- `Python` não é uma substring de `mensagem`, resultando em `False`;

#### `in` em listas

Em listas, o `in` verifica se o item existe em qualquer posição da lista.

```python
>>> frutas = ['maçã', 'banana', 'laranja']
>>>
>>> print('banana' in frutas)
True
>>> print('uva' in frutas)
False
>>> |
```

- no primeiro caso, `banana` está na lista `frutas`, então o resultado é `True`;
- no segundo caso, `uva` não está na lista, então o resultado é `False`;

#### `in` em tuplas

O funcionamento é semelhante ao das listas.

```python
>>> numeros = (1, 2, 3, 4)
>>>
>>> print(3 in numeros)
True
>>> print(5 in numeros)
False
>>> |
```

- `3` está na tupla `numeros`, então o resultado é `True`;
- `5` não está na tupla, resultando em `False`;

#### `in` em dicionários

Quando aplicado a dicionários, o `in` verifica a presença de uma chave, e não do valor associado a ela.

```python
>>> aluno = {'nome': 'Ana', 'idade': 21, 'curso': 'Engenharia'}
>>>
>>> print('nome' in aluno)
True
>>> print('Ana' in aluno)
False
>>> |
```

- `nome` é uma chave no dicionário `aluno`, portanto o resultado é `True`;
- `Ana` não é uma chave, é um valor, então o resultado é `False`;

#### `in` em sets

Em sets, o `in` verifica a presença de um elemento específico.

```python
>>> cores = {'vermelho', 'verde', 'azul'}
>>> print('verde' in cores)
True
>>> print('amarelo' in cores)
False
>>> |
```

- `verde` está no set `cores`, então o resultado é `True`;
- `amarelo` não está, resultando em `False`

### operador `not in`

O operador `not in` é o inverso de `in`. Ele verifica se o elemento **não** está presente na coleção.

```python
>>> frutas = ['maçã', 'banana', 'laranja']
>>> print('uva' not in frutas)
True
>>> print('banana' not in frutas)
False
>>> |
```

- no primeiro caso, `uva` não está na lista `frutas`, então o resultado é `True`;
- no segundo caso, `banana` está na lista, então o resultado é `False`;

## exercícios `in`

<details>
<summary>Lista de Exercícios</summary>

1. exercícios com strings
    1. Verifique se a substring `"Python"` está presente na string `"Eu estou aprendendo Python"` e imprima o resultado.
    1. Verifique se a letra `"a"` está presente na string `"Hello, World!"` e imprima o resultado.
    1. Crie uma string `"abcdefg"` e verifique se a letra `"h"` está presente nela. Imprima `True` ou `False`.
    1. Dada a string `"Programação"`, verifique se a substring `"ção"` está presente. Imprima o resultado.
    1. Verifique se a palavra `"code"` está na frase `"Escrever código é divertido"`. Imprima o resultado.
1. exercícios com listas
    1. Crie uma lista `["maçã", "banana", "laranja"]`. Verifique se `"banana"` está presente na lista e imprima o resultado.
    1. Dada a lista `[10, 20, 30, 40, 50]`, verifique se o número `25` está na lista e imprima `True` ou `False`.
    1. Crie uma lista de nomes `["Ana", "Beatriz", "Carlos"]`. Verifique se o nome `"Daniel"` está na lista e imprima o resultado.
    1. Dada a lista `["cachorro", "gato", "peixe"]`, verifique se `"passarinho"` está presente na lista e imprima o resultado.
    1. Crie uma lista vazia e verifique se o número `0` está presente nela. Imprima o resultado.
1. exercícios com tuplas
    1. Crie uma tupla `(1, 2, 3, 4, 5)` e verifique se o número `3` está presente. Imprima o resultado.
    1. Dada a tupla `("a", "b", "c", "d")`, verifique se a letra `"e"` está presente na tupla e imprima `True` ou `False`.
    1. Crie uma tupla com as cores `("vermelho", "verde", "azul")`. Verifique se a cor `"amarelo"` está na tupla e imprima o resultado.
    1. Verifique se o número `100` está na tupla `(10, 20, 30, 40, 50)` e imprima o resultado.
    1. Dada a tupla `(7, 14, 21, 28)`, verifique se o número `14` está presente e imprima o resultado.
1. exercícios com sets
    1. Crie um set `{"maçã", "banana", "uva"}` e verifique se `"laranja"` está presente no set. Imprima o resultado.
    1. Dado o set `{1, 3, 5, 7}`, verifique se o número `5` está presente e imprima `True` ou `False`.
    1. Verifique se o elemento `"Python"` está presente no set `{"Java", "C++", "Python", "JavaScript"}` e imprima o resultado.
    1. Crie um set com números `{2, 4, 6, 8}` e verifique se o número `10` está no set. Imprima o resultado.
    1. Dado o set `{"cachorro", "gato", "coelho"}`, verifique se o animal `"cavalo"` está presente e imprima `True` ou `False`.
1. exercícios com dicionários
    1. Crie um dicionário `aluno = {"nome": "João", "idade": 20, "curso": "Engenharia"}`. Verifique se a chave `"idade"` está presente no dicionário e imprima o resultado.
    1. Dado o dicionário `cidades = {"SP": "São Paulo", "RJ": "Rio de Janeiro", "MG": "Belo Horizonte"}`, verifique se a chave `"BA"` está no dicionário e imprima `True` ou `False`.
    1. Crie um dicionário `carro = {"marca": "Toyota", "modelo": "Corolla", "ano": 2020}`. Verifique se a chave `"cor"` está presente no dicionário e imprima o resultado.
    1. Dado o dicionário `estoque = {"caneta": 100, "caderno": 50, "borracha": 30}`, verifique se a chave `"lápis"` está presente no dicionário e imprima o resultado.
    1. Crie um dicionário `pessoa = {"nome": "Ana", "altura": 1.70, "peso": 65}`. Verifique se a chave `"idade"` está presente no dicionário e imprima `True` ou `False`.

</details>

## `del`

O comando `del` do Python é uma instrução usada para remover variáveis, elementos de uma lista, chave-valor de um dicionário, ou até mesmo fatias de listas e elementos em outros tipos de coleção. A instrução `del` também pode ser usada para deletar uma variável inteira da memória, tornando-a indisponível para uso posterior.

```python
# sintaxe básica
del objeto
```

- `objeto` : pode ser uma variável, um elemento de uma coleção, uma fatia de uma lista, ou uma chave de um dicionário;

### exemplos

#### deletando variáveis

É possível usar `del` para remover uma variável completamente, liberando o espaço de memória que ela estava ocupando.

```python
>>> x = 10
>>> print(x)
10
>>>
>>> del x
>>>
>>> print(x)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'x' is not defined
>>> |
```

- depois de `del x`, a variável `x` deixa de existir, e qualquer tentativa de acessá-la resultará em um erro;

#### deletando elementos de uma lista

O comando `del` pode ser usado para remover um elemento específico de uma lista, identificando-o pelo índice.

```python
>>> frutas = ['maçã', 'banana', 'laranja', 'uva']
>>>
>>> print(frutas)
['maçã', 'banana', 'laranja', 'uva']
>>>
>>> del frutas[1]
>>>
>>> print(frutas)
['maçã', 'laranja', 'uva']
>>> |
```

- aqui, `del frutas[1]` remove a `banana` da lista, que estava no índice `1`;

#### deletando fatias de uma lista

É possível usar `del` para remover uma fatia (slice) de elementos de uma lista.

```python
>>> numeros = list(range(1,7,1))
>>> print(numeros)
[1, 2, 3, 4, 5, 6]
>>>
>>> del numeros[2:5]
>>>
>>> print(numeros)
[1, 2, 6]
>>> |
```

- `del numeros[2:5]` remove os elementos nos índices `2`, `3` e `4` da lista original, que correspondem aos números `3`, `4` e `5`;

#### deletando chaves de um dicionário

No caso de dicionários, `del` é usado para remover um par chave-valor.

```python
>>> aluno = {'nome': 'Ana', 'idade': 21, 'curso': 'Engenharia'}
>>> print(aluno)
{'nome': 'Ana', 'idade': 21, 'curso': 'Engenharia'}
>>>
>>> del aluno['idade']
>>>
>>> print(aluno)
{'nome': 'Ana', 'curso': 'Engenharia'}
>>> |
```

- `del aluno['idade']` remove a chave `idade` e o valor associado a ela do dicionário;

#### deletando elementos de um set

Embora não se possa acessar diretamente um elemento em um set pelo índice (devido à natureza não ordenada dos sets), é possível deletar um set inteiro usando `del`.

```python
>>> cores = {'vermelho', 'verde', 'azul'}
>>> print(cores)
{'vermelho', 'azul', 'verde'}
>>>
>>> del cores
>>> print(cores)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'cores' is not defined
>>> |
```

- aqui, `del cores` remove completamente o set `cores` da memória;

### considerações adicionais

- **deletando múltiplas variáveis** : é possível deletar várias variáveis ao mesmo tempo, separando-as por vírgulas;
    ```python
    >>> a = 10
    >>> b = 20
    >>> c = 30
    >>>
    >>> del a, c
    >>>
    >>> print(a)
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    NameError: name 'a' is not defined
    >>>
    >>> print(b)
    20
    >>>
    >>> print(c)
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    NameError: name 'c' is not defined
    >>> |
    ```

- **deletando referências a objetos** : quando se deleta uma variável que se refere a um objeto, como uma lista ou um dicionário, e não há mais referências a esse objeto, ele é removido da memória pelo garbage collector do python;

- **uso em loops e funções** : é possível usar `del` dentro de loops e funções para remover elementos dinamicamente à medida que o programa é executado;

## exercícios `del`

<details>
<summary>Lista de Exercícios</summary>

1. exercícios com variáveis numéricas e strings
    1. Crie uma variável `x = 10`. Use `del` para deletar a variável `x`. Tente imprimir `x` e observe o que acontece.
    1. Defina duas variáveis `a = 5` e `b = 10`. Use `del` para deletar ambas as variáveis. Tente imprimir `a` e `b`.
    1. Crie uma string `frase = "Olá, Mundo!"`. Use `del` para deletar a variável `frase`. Tente imprimir `frase` e observe o resultado.
    1. Defina uma variável `nome = "Maria"`. Use `del` para deletar a variável. Tente acessar `nome` após deletá-la.
    1. Crie três variáveis: `num1 = 3`, `num2 = 6`, e `num3 = 9`. Use `del` para deletar `num1` e `num2`. Tente imprimir todas as três variáveis.
1. exercícios com listas
    1. Crie uma lista `numeros = [1, 2, 3, 4, 5]`. Use `del` para deletar o terceiro elemento da lista. Imprima a lista resultante.
    1. Defina uma lista `frutas = ["maçã", "banana", "laranja"]`. Use `del` para deletar o último item da lista. Imprima a lista.
    1. Crie uma lista `cores = ["vermelho", "azul", "verde", "amarelo"]`. Use `del` para deletar os elementos no índice 1 e 2. Imprima a lista resultante.
    1. Crie uma lista `alfabeto = ["a", "b", "c", "d", "e", "f"]`. Use `del` para deletar os primeiros dois elementos da lista. Imprima a lista.
    1. Defina uma lista `itens = ["caneta", "caderno", "borracha"]`. Use `del` para deletar a lista inteira. Tente imprimir `itens` e observe o que acontece.
    1. Crie uma lista `numeros = [10, 20, 30, 40, 50]`. Use `del` para deletar o elemento no índice `4`. Imprima a lista resultante.
    1. Dada a lista `animais = ["cachorro", "gato", "passarinho", "peixe"]`, use `del` para deletar o segundo e o terceiro elementos. Imprima a lista.
    1. Crie uma lista `dias = ["segunda", "terça", "quarta", "quinta", "sexta"]`. Use `del` para deletar os três últimos elementos. Imprima a lista.
    1. Crie uma lista `meses = ["janeiro", "fevereiro", "março", "abril"]`. Use `del` para deletar o primeiro elemento da lista. Imprima a lista.
    1. Defina uma lista `numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9]`. Use `del` para deletar os elementos nos índices 0 a 4 (inclusive). Imprima a lista resultante.
1. exercícios com tuplas
    1. Crie uma tupla `pares = (2, 4, 6, 8, 10)`. Use `del` para deletar a tupla inteira. Tente imprimir `pares`.
    1. Crie uma tupla `letras = ("a", "b", "c", "d")`. Use `del` para deletar a tupla inteira. Tente acessar `letras` e observe o resultado.
    1. Defina uma tupla `numeros = (1, 2, 3, 4, 5)`. Use `del` para deletar a variável `numeros`. Tente imprimir `numeros`.
1. exercícios com sets
    1. Crie um set `vogais = {"a", "e", "i", "o", "u"}`. Use `del` para deletar o set inteiro. Tente acessar `vogais`.
    1. Defina um set `numeros = {1, 2, 3, 4, 5}`. Use `del` para deletar o set. Tente imprimir `numeros`.
    1. Crie um set `cores = {"vermelho", "verde", "azul"}`. Use `del` para deletar o set. Verifique o que acontece ao tentar acessar `cores`.
1. exercícios com dicionários
    1. Crie um dicionário `aluno = {"nome": "João", "idade": 20, "curso": "Matemática"}`. Use `del` para deletar a chave `"idade"`. Imprima o dicionário resultante.
    1. Defina um dicionário `produto = {"nome": "caneta", "preço": 1.50, "estoque": 100}`. Use `del` para deletar a chave `"preço"`. Imprima o dicionário.
    1. Crie um dicionário `contato = {"nome": "Maria", "telefone": "1234-5678", "email": "maria@gmail.com"}`. Use `del` para deletar a chave `"telefone"`. Imprima o dicionário.
    1. Dado o dicionário `carro = {"marca": "Ford", "modelo": "Mustang", "ano": 1969}`, use `del` para deletar a chave `"ano"`. Imprima o dicionário resultante.

</details>

## `pass`

O comando `pass` em Python é uma instrução nula; quando é executado, nada acontece. Ele é utilizado em situações onde uma declaração é necessária sintaticamente, mas onde nenhum código precisa ser executado.

### formas de uso

1. **estrutura de código em desenvolvimento** : durante o desenvolvimento, pode ser usado para estruturar funções, classes ou blocos condicionais que ainda não foram implementados, mas deseja evitar erros de sintaxe. O `pass` é uma forma de “marcar” esses locais, sem precisar escrever o código definitivo imediatamente.
    ```python
    >>> def minha_funcao():
    >>>     pass  # vai ser implementado depois
    >>>
    >>> class MinhaClasse:
    >>>     pass  # classe em desenvolvimento
    >>>
    >>> if condicao:
    >>>     pass  # Ainda não sei o que fazer aqui
    ```

1. **blocos de código condicional**: em certos casos, pode ser necessário ter uma condicional que não faz nada, por exemplo, ao tratar um caso onde nenhuma ação é necessária.
    ```python
    >>> for item in minha_lista:
    >>>     if item == "pular":
    >>>         pass  # não faço nada para 'pular'
    >>>     else:
    >>>         print(item)
    ```

1. **estruturas de controle sem implementação imediata**: o `pass` é útil em loops, funções ou outras estruturas de controle onde ainda não se sabe qual será a lógica final, mas quer estruturar o código de forma que ele seja executável.
    ```python
    >>> while True:
    >>>     pass  # loop infinito em desenvolvimento, sem lógica definida
    ```

### exemplos

1. classe em desenvolvimento
    ```python
    >>> class Animal:
    >>>     pass  # classe animal a ser definida depois
    >>>
    >>> # não gera erro e a classe pode ser instanciada
    >>> cachorro = Animal()
    ```

1. função em desenvolvimento
    ```python
    >>> def funcao_complexa():
    >>>     pass  # lógica a ser implementada depois
    >>>
    >>> # função chamada, mas sem erros
    >>> funcao_complexa()
    ```

1. estrutura condicional
    ```python
    >>> x = 10
    >>>
    >>> if x > 0:
    >>>     pass  # sem ação específica para números positivos
    >>> else:
    >>>     print("Número não positivo")
    ```

### observações

- **evitar uso excessivo** : o `pass` é útil para o desenvolvimento inicial ou para marcar futuras implementações, mas em um código final, ele deve ser removido ou substituído por código funcional.

- **leitura do código** : o uso de `pass` pode indicar a necessidade de implementação futura, mas em código de produção, deixar blocos de código com `pass` pode sugerir funcionalidades incompletas ou mal implementadas.

### conclusão

O `pass` é uma ferramenta essencial em Python para a criação de esboços de código e para manter a estrutura do código correta durante o desenvolvimento. Ele garante que seja possível continuar a desenvolver outras partes do código sem ser interrompido por erros de sintaxe.


## `break`

O comando `break` em Python é utilizado dentro de loops (`for` e `while`) para interromper o loop imediatamente. Quando o Python encontra um `break`, ele sai do loop, ignorando todas as iterações restantes, e a execução do código continua após o bloco do loop.

Quando o comando `break` é executado dentro de um loop, ele interrompe o loop inteiro, não importa em qual ponto da iteração o `break` esteja. Isso é útil quando é preciso sair de um loop antes que ele termine todas as iterações, com base em uma condição específica.

```python
>>> # estrutura básica
>>> for item in sequencia:
>>>     if condicao:
>>>         break  # sai do loop completamente
>>>     # código que é executado até que o break seja chamado
```

### exemplos

1. interrompendo um loop ao encontrar um valor específico : vamos supor que tenha uma lista de números e queira parar a iteração assim que encontrar o número 5 :
    ```python
    >>> numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    >>>
    >>> for numero in numeros:
    >>>     if numero == 5:
    >>>         break  # interrompe o loop quando o número 5 é encontrado
    >>>     print(numero)
    1
    2
    3
    4
    >>> |
    ```
    Neste exemplo, o loop é interrompido assim que o número 5 é encontrado, e o Python sai do loop, ignorando os números restantes na lista.

1. encontrando um item em uma lista : pode usar o `break` para interromper a busca em uma lista assim que encontrar um item específico :
    ```python
    >>> frutas = ["maçã", "banana", "laranja", "abacaxi", "uva"]
    >>>
    >>> for fruta in frutas:
    >>>     print(f"Verificando {fruta}")
    >>>     if fruta == "laranja":
    >>>         print("Laranja encontrada, interrompendo a busca.")
    >>>         break  # Para a busca quando a laranja é encontrada
    Verificando maçã
    Verificando banana
    Verificando laranja
    Laranja encontrada, interrompendo a busca.
    >>> |
    ```
    Aqui, o loop para de executar assim que encontra "laranja", evitando verificar as frutas restantes.

1. interrompendo um loop infinito : um `break` é frequentemente usado para sair de um loop infinito quando uma certa condição é atendida :
    ```python
    >>> i = 1
    >>>
    >>> while True:
    >>>     print(i)
    >>>     if i == 10:
    >>>         break  # Interrompe o loop infinito quando i é igual a 10
    >>>     i += 1
    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    >>> |
    ```
    Neste exemplo, o loop `while` é infinito (`while True:`), mas o comando `break` faz com que o loop seja interrompido quando `i` atinge o valor 10.

### quando usar `break`

1. **interromper a busca** : quando está procurando por algo em uma lista ou sequência e deseja parar a busca assim que encontrar o que precisa;

1. **sair de loops infinitos** : em loops `while` que podem, teoricamente, rodar para sempre, o `break` pode ser usado para sair do loop quando uma condição específica é atingida;

1. **prevenir iterações desnecessárias** : se sabe que não precisa continuar o loop após encontrar um certo valor, o `break` pode melhorar a eficiência do código;

### conclusão

O `break` é uma ferramenta essencial para controle de fluxo em loops. Ele permite que você saia de loops imediatamente quando uma condição específica é atendida, evitando iterações desnecessárias e melhorando a eficiência do seu código.


## `continue`

O comando `continue` em Python é utilizado dentro de loops (`for` e `while`) para pular a iteração atual e passar para a próxima iteração do loop. Ele é útil quando se deseja ignorar o restante do código no bloco do loop para certas condições, sem interromper o loop completamente.

Quando o Python encontra o comando `continue` dentro de um loop, ele interrompe a execução do código restante na iteração atual e imediatamente volta ao início do loop, verificando a condição do loop novamente. Se a condição for verdadeira, uma nova iteração começa.

```python
>>> # estrurua básica
>>> for item in sequencia:
>>>     if condicao:
>>>         continue  # pula o resto do código no loop e vai para a próxima iteração
>>>     # código que será ignorado se a condição for verdadeira
```

### exemplos

1. pular números pares : vamos supor que se queira iterar por uma lista de números e imprimir apenas os números ímpares:
    ```python
    >>> numeros = list(range(1,11))
    >>>
    >>> for numero in numeros:
    >>>     if numero % 2 == 0:  # verifica se o número é par
    >>>          continue  # pula a iteração se o número for par
    >>>     print(numero)
    1
    3
    5
    7
    9
    >>> |
    ```
    Neste exemplo, o comando `continue` faz com que o loop pule a impressão dos números pares.

1. ignorar palavras específicas : pode usar `continue` para ignorar palavras específicas em uma lista de palavras :
    ```python
    >>> palavras = ["maçã", "banana", "laranja", "abacaxi", "uva"]
    >>>
    >>> for palavra in palavras:
    >>>     if palavra == "laranja":
    >>>         continue  # ignora a palavra "laranja"
    >>>     print(palavra)
    maçã
    banana
    abacaxi
    uva
    >>> |
    ```
    Aqui, a palavra "laranja" é ignorada e não é impressa.

1. contando iterações válidas : em um loop `while`, o `continue` pode ser usado para ignorar certos valores e continuar a contagem ou execução das iterações :
    ```python
    >>> i = 0
    >>> while i < 10:
    >>>     i += 1
    >>>     if i % 2 == 0:  # se i for par, pula para a próxima iteração
    >>>         continue
    >>>     print(i)
    1
    3
    5
    7
    9
    ```
    Neste exemplo, `continue` faz com que os números pares sejam pulados no loop `while`.

### quando usar `continue`

1. **filtragem de dados**: quando se deseja processar apenas certos itens de uma lista ou sequência e ignorar outros com base em uma condição específica;

2. **ignorar erros**: pode ser usado para pular uma iteração se uma operação específica falhar (por exemplo, um cálculo que pode causar uma exceção);

3. **simplificar estruturas de controle**: em vez de usar `else` ou aninhar múltiplas condições, `continue` pode simplificar o código, especialmente quando a lógica principal deve ser executada apenas para alguns casos;

### conclusão

O `continue` é uma ferramenta poderosa em Python para controle de fluxo dentro de loops. Ele permite que pular certas iterações com base em condições específicas, tornando o código mais flexível e legível.


## `break` e `continue`

Os comandos `break` e `continue` são ambos utilizados para controlar o fluxo de execução dentro de loops em Python. Embora possam ser usados de forma independente, existem situações em que é útil combiná-los dentro do mesmo loop para criar lógica mais complexa.

Quando combinado `break` e `continue` em um loop, por exemplo, é possível criar uma lógica em que determinadas condições pulem a iteração atual, enquanto outras condições interrompem completamente o loop.

### exemplos

1. filtragem e interrupção de processamento : suponha que tenha uma lista de números e queira processar apenas os números ímpares. Se um número for maior que 15, quer interromper o processamento completamente.
    ```python
    >>> numeros = [3, 7, 2, 9, 12, 17, 19, 6, 11]
    >>>
    >>> for numero in numeros:
    >>>     if numero % 2 == 0:  # se o número for par
    >>>         continue  # pula para a próxima iteração, ignorando o número par
    >>>
    >>>     if numero > 15:  # se o número for maior que 15
    >>>         print("Número maior que 15 encontrado. Interrompendo.")
    >>>         break  # interrompe o loop completamente
    >>>
    >>>     print(f"Processando número ímpar: {numero}")
    >>> Processando número ímpar: 3
    >>> Processando número ímpar: 7
    >>> Processando número ímpar: 9
    >>> Número maior que 15 encontrado. Interrompendo.
    >>> |
    ```
    Neste exemplo:
    - O `continue` é usado para pular números pares, ignorando-os;
    - O `break` é usado para interromper o loop assim que um número maior que 15 é encontrado;

1. looping com condições múltiplas : considere uma situação em que se precisa iterar sobre uma lista de números, mas deseja:
    1. Ignorar números negativos (`continue`);
    1. Interromper o loop ao encontrar um número que é um múltiplo de 7 (`break`);
    ```python
    >>> numeros = [5, -3, 10, 6, -1, 14, 12, -8, 20]
    >>>
    >>> for numero in numeros:
    >>>     if numero < 0:  # ignora números negativos
    >>>         continue  # pula para a próxima iteração
    >>>
    >>>     if numero % 7 == 0:  # encontra o primeiro múltiplo de 7
    >>>         print(f"Número múltiplo de 7 encontrado: {numero}. Interrompendo o loop.")
    >>>         break  # interrompe o loop ao encontrar múltiplo de 7
    >>>
    >>>     print(f"Processando número: {numero}")
    >>> Processando número: 5
    >>> Processando número: 10
    >>> Processando número: 6
    >>> Número múltiplo de 7 encontrado: 14. Interrompendo o loop.
    >>> |
    ```
    Neste exemplo:
    - O `continue` é utilizado para pular números negativos.
    - O `break` é utilizado para interromper o loop assim que um múltiplo de 7 é encontrado.

1. verificando condições em uma lista de strings : imagine que está processando uma lista de palavras e:
    1. Deseja pular qualquer palavra que comece com a letra "a" (`continue`);
    1. Quer interromper completamente o loop se encontrar a palavra "parar" (`break`);
    ```python
    >>> palavras = ["maçã", "banana", "abacate", "uva", "parar", "laranja"]
    >>>
    >>> for palavra in palavras:
    >>>     if palavra.startswith("a"):  # Ignora palavras que começam com "a"
    >>>         continue  # Pula para a próxima iteração
    >>>
    >>>     if palavra == "parar":  # Interrompe o loop se encontrar "parar"
    >>>         print("Palavra 'parar' encontrada. Interrompendo o loop.")
    >>>         break  # Interrompe o loop
    >>>
    >>>     print(f"Processando palavra: {palavra}")
    >>> Processando palavra: banana
    >>> Processando palavra: uva
    >>> Palavra 'parar' encontrada. Interrompendo o loop.
    >>> |
    ```
    Neste exemplo:
    - O `continue` ignora palavras que começam com a letra "a";
    - O `break` interrompe o loop ao encontrar a palavra "parar";

### considerações importantes

- **ordem importa**: a ordem que se coloca `continue` e `break` dentro do loop é crucial, pois determinará a lógica do fluxo de execução;
- **leitura do código**: usar `continue` e `break` no mesmo loop pode tornar o código mais difícil de ler, então é importante usar comentários claros ou refatorar o código para que a lógica seja intuitiva;

### conclusão

Combinar `break` e `continue` em um loop Python permite um controle granular sobre o fluxo de execução, permitindo que se pule iterações específicas enquanto também fornece uma maneira de sair completamente do loop quando certas condições são atendidas. Usados juntos, esses comandos podem tornar o código mais eficiente e focado, dependendo das necessidades da aplicação.

## exercícios `break` e `continue`

<details>
<summary>Lista de Exercícios</summary>

### `break`

1. **Interrupção em Lista de Números**: Crie um loop `for` que percorra uma lista de números de 1 a 10. Use `break` para interromper o loop quando o número 5 for encontrado.
1. **Busca em String**: Escreva um loop `for` que percorra uma string. Use `break` para parar o loop assim que a letra "a" for encontrada e imprima as letras anteriores.
1. **Loop com Condição**: Crie um loop `while` que incrementa uma variável `x` começando em 0. Use `break` para parar o loop quando `x` for igual a 10.
    ```python
    x = 0

    # while x < 20:
    while True:
        if x == 10:
            break
        x = x + 1

    print(f'saindo do while com {x = }')
    ```
1. **Interrupção em Lista de Strings**: Escreva um loop `for` que percorra uma lista de strings. Use `break` para sair do loop assim que encontrar uma string vazia.
1. **Número Múltiplo**: Crie um loop `for` que percorra uma lista de números. Use `break` para interromper o loop assim que encontrar um número divisível por 7.
1. **Interromper com Condicional**: Crie um loop `while` que soma números inteiros a partir de 1. Use `break` para sair do loop assim que a soma ultrapassar 50.
1. **Busca de Palavras**: Escreva um loop `for` que percorra uma lista de palavras. Use `break` para interromper o loop se encontrar uma palavra que começa com "Z".
1. **Busca em String**: Crie um loop `while` que percorra uma string caractere por caractere. Use `break` para parar o loop se encontrar um dígito numérico.
1. **Interrupção em Sublista**: Escreva um loop `for` que percorra uma lista de listas. Use `break` para sair do loop principal se encontrar uma sublista que contém um valor negativo.
1. **Interromper com Condição Complexa**: Crie um loop `for` que percorra uma lista de números e use `break` para sair do loop se encontrar um número maior que 100 ou menor que -100.
1. **Interrupção Condicional**: Crie um loop `while` que percorra os caracteres de uma string. Use `break` se encontrar duas vogais consecutivas e imprima o que foi lido até esse ponto.
1. **Busca de Substring**: Escreva um loop `for` que percorra uma lista de strings. Use `break` se encontrar uma string que contenha a substring "python".
1. **Parada em Número Específico**: Crie um loop `while` que gera números aleatórios entre 1 e 100. Use `break` para sair do loop quando um número específico (por exemplo, 42) for gerado.
1. **Interromper em Condição Composta**: Escreva um loop `for` que percorra uma lista de números. Use `break` para sair do loop se encontrar um número negativo seguido de um positivo.
1. **Interromper após Concatenar**: Crie um loop `for` que percorra uma lista de strings e as concatene em uma única string. Use `break` quando o comprimento total da string concatenada ultrapassar 50 caracteres.
1. **Interromper em Sequência**: Escreva um loop `for` que percorra uma lista de números. Use `break` se encontrar uma sequência de três números ímpares consecutivos.
1. **Interromper em Condição de Soma**: Crie um loop `while` que adicione números de uma lista a uma variável soma. Use `break` para interromper a adição se a soma exceder um valor limite (por exemplo, 100).
1. **Interrupção em String**: Escreva um loop `for` que percorra uma string caractere por caractere. Use `break` se encontrar uma combinação específica de caracteres (por exemplo, "ab").
1. **Parada em Condição Composta**: Crie um loop `for` que percorra uma lista de números. Use `break` para sair do loop se encontrar um número maior que 50 seguido de um número menor que 10.
1. **Interrupção em Verificação de Substring**: Escreva um loop `while` que verifique se uma substring existe em uma string. Use `break` para sair do loop quando encontrar a substring "stop".

### `continue`

1. **Lista de Números**: Crie um loop `for` que percorra uma lista de números de 1 a 10. Use `continue` para pular os números pares e imprima os ímpares.
1. **String com Vogais**: Escreva um loop `for` que percorra uma string. Use `continue` para pular as vogais e imprima as consoantes.
1. **Números Negativos**: Crie um loop `while` que diminua o valor de uma variável `x` a partir de 10. Use `continue` se `x` for negativo e imprima o restante.
1. **Strings com Espaços**: Escreva um loop `for` que percorra uma lista de strings. Use `continue` para pular as strings que contêm espaços e imprima as demais.
1. **Divisíveis por 3**: Crie um loop `for` que percorra uma lista de números. Use `continue` para pular os números divisíveis por 3 e imprima os outros.
1. **Índices Pares**: Escreva um loop `for` que percorra uma lista de palavras e seus índices. Use `continue` para pular as palavras nos índices pares e imprima as outras.
1. **Contagem Regressiva**: Crie um loop `while` que conta de 20 até 0. Use `continue` para pular os números ímpares e imprima os pares.
1. **Nomes Longos**: Escreva um loop `for` que percorra uma lista de nomes. Use `continue` para pular os nomes com mais de 5 caracteres e imprima os menores.
1. **String com Dígitos**: Crie um loop `for` que percorra uma string. Use `continue` para pular os caracteres que são dígitos e imprima os demais.
1. **Listas Vazias**: Escreva um loop `for` que percorra uma lista de listas. Use `continue` para pular listas vazias e imprima as outras.
1. **Soma de Números**: Crie um loop `for` que percorra uma lista de números e calcule a soma deles. Use `continue` para ignorar os números negativos.
1. **String Alternada**: Escreva um loop `for` que percorra uma string e use `continue` para pular os caracteres nas posições ímpares. Imprima apenas os caracteres nas posições pares.
1. **Números Primos**: Crie um loop `while` que verifica números de 2 a 50. Use `continue` para pular números que não são primos e imprima apenas os primos.
1. **Palavras Compostas**: Escreva um loop `for` que percorra uma lista de palavras. Use `continue` para pular palavras que contêm mais de uma vogal e imprima as demais.
1. **Listas com Zeros**: Crie um loop `for` que percorra uma lista de listas de números. Use `continue` para pular listas que contenham o número 0 e imprima as outras listas.
1. **Comparação de Strings**: Escreva um loop `for` que percorra duas listas de strings de tamanho igual. Use `continue` para pular a comparação se as strings não tiverem o mesmo comprimento.
1. **Nomes e Idades**: Crie um loop `for` que percorra duas listas (nomes e idades). Use `continue` para pular a impressão se a idade for menor que 18 e imprima apenas os nomes das pessoas maiores de idade.
1. **Soma de Dígitos**: Escreva um loop `while` que receba uma string de números. Use `continue` para pular caracteres que não são dígitos e calcule a soma dos dígitos.
1. **Filtros em Listas**: Crie um loop `for` que percorra uma lista de números. Use `continue` para ignorar números que são múltiplos de 5 e imprima os restantes.
1. **String Invertida**: Escreva um loop `for` que percorra uma string de trás para frente. Use `continue` para pular os caracteres nas posições ímpares e imprima apenas os caracteres nas posições pares.

### `break` e `continue`

1. **Interrupção com Condição**: Crie um loop `for` que percorra uma lista de números de 1 a 10. Use `continue` para pular números pares e `break` para sair do loop quando encontrar o número 7.
2. **Busca em String**: Escreva um loop `for` que percorra uma string. Use `continue` para pular os espaços em branco e `break` para sair do loop quando encontrar a letra "z".
3. **Loop com Condição**: Crie um loop `while` que incrementa uma variável `x` a partir de 0. Use `continue` para pular os números divisíveis por 3 e `break` para parar o loop quando `x` atingir 15.
4. **Lista de Strings**: Escreva um loop `for` que percorra uma lista de strings. Use `continue` para pular as strings que contêm o caractere "a" e `break` para sair do loop ao encontrar uma string com mais de 5 caracteres.
5. **Interrupção Condicional**: Crie um loop `for` que percorra uma lista de números. Use `continue` para pular números negativos e `break` para sair do loop ao encontrar um número maior que 50.
6. **Filtro de Números**: Crie um loop `while` que gera números aleatórios entre 1 e 50. Use `continue` para pular números menores que 10 e `break` para parar o loop quando um número maior que 40 for gerado.
7. **Verificação de String**: Escreva um loop `for` que percorra uma lista de strings. Use `continue` para pular strings que não começam com a letra "P" e `break` para sair do loop ao encontrar uma string que começa com "Python".
8. **Interrupção Condicional em String**: Crie um loop `while` que percorra uma string caractere por caractere. Use `continue` para pular vogais e `break` para sair do loop ao encontrar a letra "e".
9. **Filtragem em Sublistas**: Escreva um loop `for` que percorra uma lista de listas de números. Use `continue` para pular sublistas vazias e `break` para sair do loop ao encontrar uma sublista contendo um número negativo.
10. **Condicionais Múltiplas**: Crie um loop `for` que percorra uma lista de números. Use `continue` para pular números divisíveis por 2 ou 5 e `break` para sair do loop ao encontrar um número maior que 30.
11. **Verificação de Consoantes**: Crie um loop `while` que percorre uma string. Use `continue` para pular caracteres que são vogais e `break` para parar o loop ao encontrar uma consoante específica (por exemplo, "r").
12. **Busca em Lista**: Escreva um loop `for` que percorra uma lista de números. Use `continue` para pular números ímpares e `break` para sair do loop ao encontrar um número divisível por 4.
13. **Interrupção Condicional em Nomes**: Crie um loop `for` que percorra uma lista de nomes. Use `continue` para pular nomes com menos de 4 letras e `break` para sair do loop ao encontrar um nome começando com "A".
14. **Substituição em String**: Escreva um loop `while` que percorra uma string caractere por caractere. Use `continue` para pular caracteres que não são letras e `break` para sair do loop ao encontrar um espaço.
15. **Filtro de Listas**: Crie um loop `for` que percorra uma lista de listas de números. Use `continue` para pular listas que não contêm números maiores que 10 e `break` para sair do loop ao encontrar uma lista com mais de 3 números.
16. **Filtro de Substring**: Escreva um loop `for` que percorra uma lista de strings. Use `continue` para pular strings que não contêm a letra "x" e `break` para sair do loop ao encontrar uma string com mais de 8 caracteres.
17. **Verificação de Números**: Crie um loop `while` que percorra uma lista de números de 1 a 100. Use `continue` para pular números que não são primos e `break` para sair do loop ao encontrar um número primo maior que 50.
18. **Busca em String**: Escreva um loop `for` que percorra uma string. Use `continue` para pular os caracteres que não são dígitos e `break` para sair do loop ao encontrar dois dígitos consecutivos.
19. **Filtro em Listas**: Crie um loop `for` que percorra uma lista de listas de números. Use `continue` para pular listas que contêm números negativos e `break` para sair do loop ao encontrar uma lista com apenas números positivos.
20. **Verificação de Caracteres**: Escreva um loop `while` que percorra uma string. Use `continue` para pular os caracteres que não são letras maiúsculas e `break` para sair do loop ao encontrar três letras maiúsculas consecutivas.

</details>

## `assert`

O comando `assert` no Python é utilizado para realizar verificações (ou *assertions*) em um programa. Ele é geralmente utilizado durante o desenvolvimento para garantir que certas condições lógicas sejam verdadeiras. Se a condição que está sendo verificada pelo `assert` for falsa, uma exceção do tipo `AssertionError` será levantada, interrompendo a execução do programa. Caso a condição seja verdadeira, o programa continua a ser executado normalmente.

A sintaxe básica do `assert` é:

```python
assert <condição>, <mensagem opcional>
```

- `<condição>` : uma expressão que será avaliada. Se ela for avaliada como `True`, o `assert` não faz nada e a execução do programa continua. Se for `False`, um `AssertionError` será levantado;
- `<mensagem opcional>` : uma mensagem que será exibida juntamente com o `AssertionError`, explicando o motivo do erro. Ela é opcional, mas útil para ajudar a entender o que deu errado;

- **Exemplo**

```python
x = 5
assert x > 0, "x deve ser maior que zero"
```

Neste exemplo, o programa continua normalmente, já que `x > 0` é `True`. No entanto, se `x` fosse um número menor ou igual a zero, o Python levantaria um `AssertionError` com a mensagem "x deve ser maior que zero".

### como funciona

Quando o comando `assert` é executado, ele faz o seguinte :

1. Avalia a expressão condicional;
1. Se a condição for `True`, o programa segue normalmente;
1. Se a condição for `False`, um `AssertionError` é lançado, e a execução do programa é interrompida a menos que a exceção seja tratada por um bloco `try-except`;

- **Exemplo**

```python
def divide(a, b):
    assert b != 0, "O divisor não pode ser zero."
    return a / b

print(divide(10, 2))  # saída: 5.0
print(divide(10, 0))  # lança um AssertionError com a mensagem: "O divisor não pode ser zero."
```

### por que usar

1. **Verificação durante o desenvolvimento** : o `assert` é útil para verificar suposições que o programador faz enquanto desenvolve o código. Se uma suposição falhar, o `AssertionError` ajuda a detectar o erro rapidamente;

1. **Depuração e testes** : durante o desenvolvimento ou testes, você pode usar o `assert` para verificar o comportamento esperado de funções ou trechos de código. Ele serve como uma medida de segurança para garantir que certas condições lógicas sejam sempre verdadeiras;

1. **Evitar erros lógicos** : ele ajuda a capturar erros lógicos ou situações inesperadas antes que eles causem maiores problemas no código;

### quando não usar

1. **Validação de entrada do usuário** : o `assert` não deve ser usado para validar entradas de usuários ou para condições que devem ser tratadas em tempo de execução. Isso ocorre porque, se o código for executado com otimizações (com a flag `-O`), os `assert` são removidos e não executados, o que poderia deixar o programa vulnerável;

1. **Verificações críticas de runtime** : se a verificação for fundamental para a segurança ou estabilidade do código, como garantir que um arquivo existe antes de ser lido, deve-se usar um bloco `if-else` e lançar exceções adequadas, em vez de confiar no `assert`;

Exemplo de uso inadequado para validar entradas :

```python
def validar_idade(idade):
    assert idade >= 18, "Idade deve ser maior ou igual a 18."
```

Neste caso, o `assert` não é a melhor escolha para validar a idade do usuário, pois se o programa for executado com a otimização (usando `python -O`), o `assert` não será executado, deixando o código vulnerável. O correto seria:

```python
def validar_idade(idade):
    if idade < 18:
        raise ValueError("Idade deve ser maior ou igual a 18.")
```

### como é tratado

Quando o Python é executado com a flag `-O` (modo otimizado), todas as instruções `assert` são ignoradas. Isso significa que elas não serão executadas e não terão impacto no programa. Portanto, o `assert` é útil durante o desenvolvimento, mas não deve ser confiado em ambientes de produção.

### exemplo de como o `assert` funciona com `-O`

Normalmente:

```python
x = 5
assert x == 10, "x deve ser igual a 10"
```

Isso lançaria um `AssertionError` com a mensagem "x deve ser igual a 10". No entanto, se o código for executado com a otimização (`python -O script.py`), o `assert` é removido, e o programa continua sem levantar erro.

### exemplo prático

Imagine que se está criando uma função para verificar se uma lista está ordenada. Durante o desenvolvimento, pode-se usar `assert` para garantir que a lista seja corretamente ordenada.

```python
def verificar_ordenacao(lista):
    for i in range(len(lista) - 1):
        assert lista[i] <= lista[i + 1], "A lista não está ordenada."
    return True

# Testando
verificar_ordenacao([1, 2, 3, 4])  # Não levanta erro
verificar_ordenacao([1, 3, 2, 4])  # Lança AssertionError: "A lista não está ordenada."
```

### exemplos de usos corretos e incorretos

#### em funções

- **uso correto para verificar pré-condições**

Pode-se usar o `assert` para garantir que uma função receba os parâmetros corretos:

```python
def calcular_raiz_quadrada(x):
    assert x >= 0, "O número deve ser maior ou igual a zero"
    return x ** 0.5

print(calcular_raiz_quadrada(9))  # Saída: 3.0
print(calcular_raiz_quadrada(-1))  # Lança AssertionError: "O número deve ser maior ou igual a zero"
```

Aqui, o `assert` garante que a função não tente calcular a raiz quadrada de um número negativo, o que não faz sentido matematicamente.

- **uso incorreto para validação de parâmetros de entrada**

Se estiver validando parâmetros de entrada de usuários, o `assert` não é a melhor escolha, já que pode ser desativado no modo otimizado.

```python
def verificar_idade(idade):
    assert idade >= 18, "Idade inválida para este serviço"

# Não recomendado para validação de dados de entrada.
```

Em vez disso, deve-se usar um `if` e levantar uma exceção apropriada, como `ValueError`:

```python
def verificar_idade(idade):
    if idade < 18:
        raise ValueError("Idade inválida para este serviço")
```

#### em loops

- **verificando a consistência de dados em um loop**

Pode-se usar `assert` para garantir que um valor seja crescente ao longo de um loop:

```python
def verificar_ordenacao(lista):
    for i in range(len(lista) - 1):
        assert lista[i] <= lista[i + 1], f"Lista não está ordenada: {lista[i]} > {lista[i+1]}"

verificar_ordenacao([1, 2, 3, 4])  # Não gera erro
verificar_ordenacao([1, 3, 2, 4])  # Lança AssertionError: "Lista não está ordenada: 3 > 2"
```

Aqui, o `assert` garante que a lista está ordenada enquanto percorre o loop. Se houver um erro, ele interrompe o programa e informa onde a ordem foi quebrada.

- **uso incorreto no lugar de um controle de fluxo normal**

Não é uma boa prática usar `assert` para substituir controles de fluxo como `break` ou `return` em loops.

```python
def buscar_valor(lista, valor):
    for item in lista:
        assert item != valor, "Valor encontrado!"  # NÃO recomendado
```

Em vez disso, o correto seria:

```python
def buscar_valor(lista, valor):
    for item in lista:
        if item == valor:
            return True
    return False
```

#### em condicionais

- **verificando uma condição lógica crítica**

```python
def dividir(a, b):
    assert b != 0, "Divisor não pode ser zero!"
    return a / b

print(dividir(10, 2))  # Saída: 5.0
print(dividir(10, 0))  # Lança AssertionError: "Divisor não pode ser zero!"
```

Aqui, o `assert` é utilizado para garantir que não haja uma tentativa de divisão por zero.

- **não usar `assert` para controle de erro crítico**

```python
def verificar_positivo(numero):
    assert numero > 0, "Número deve ser positivo!"
    # Não recomendado, pois no modo otimizado pode ser ignorado
```

Para algo crítico, como validar entradas, use estruturas de controle normais:

```python
def verificar_positivo(numero):
    if numero <= 0:
        raise ValueError("Número deve ser positivo!")
```

<!--
#### em classes

- **garantindo consistência de atributos em uma classe**

O `assert` pode ser usado para garantir que os atributos de uma classe estejam corretos após a inicialização:

```python
class Retangulo:
    def __init__(self, largura, altura):
        assert largura > 0 and altura > 0, "Largura e altura devem ser maiores que zero"
        self.largura = largura
        self.altura = altura

    def area(self):
        return self.largura * self.altura

r = Retangulo(5, 10)  # Funciona normalmente
r = Retangulo(-5, 10)  # Lança AssertionError: "Largura e altura devem ser maiores que zero"
```

Aqui, o `assert` garante que nenhum retângulo seja criado com dimensões inválidas.

- **não usar `assert` para validação de dados do usuário ao criar objetos**

Novamente, se os dados estão vindo de uma fonte externa (usuário, por exemplo), não é recomendado usar `assert`:

```python
class Retangulo:
    def __init__(self, largura, altura):
        assert largura > 0, "Largura inválida!"  # Não recomendado para entrada de dados
```

O correto seria usar verificações explícitas e lançar exceções adequadas:

```python
class Retangulo:
    def __init__(self, largura, altura):
        if largura <= 0 or altura <= 0:
            raise ValueError("Largura e altura devem ser maiores que zero")
```
-->

#### em módulos e importações

- **verificando importações**

O `assert` pode ser usado para garantir que módulos importantes sejam importados corretamente:

```python
try:
    import numpy as np
except ImportError:
    np = None

assert np is not None, "Módulo numpy não está instalado"
```

Aqui, o `assert` assegura que o módulo `numpy` está disponível antes de continuar a execução do programa.

#### em testes

- **testes automatizados**

O `assert` é muito útil em testes automatizados, para garantir que uma função retorne os valores esperados:

```python
def somar(a, b):
    return a + b

# testes
assert somar(2, 3) == 5, "A soma de 2 e 3 deve ser 5"
assert somar(-1, 1) == 0, "A soma de -1 e 1 deve ser 0"
```

Esses testes ajudam a garantir que o comportamento da função está correto. Se algo falhar, o `AssertionError` informará o erro.

- **uso incorreto para lidar com erros esperados**

Se está verificando se uma função lança uma exceção, o `assert` pode não ser a melhor escolha. Por exemplo:

```python
def dividir(a, b):
    return a / b

try:
    dividir(10, 0)
except ZeroDivisionError:
    pass
else:
    assert False, "Deveria ter levantado ZeroDivisionError"
```

Aqui, a maneira correta seria utilizar um framework de testes como `unittest` ou `pytest`, que têm funcionalidades adequadas para verificar exceções.

### resumo

**Quando usar `assert`:**
- Para verificar suposições durante o desenvolvimento (não em produção).
- Para garantir a consistência de dados e condições lógicas internas.
- Em testes automatizados, onde se deseja garantir que determinadas condições sejam verdadeiras.

**Quando não usar `assert`:**
- Para validar entradas do usuário ou outras condições que devem ser garantidas em produção.
- Para substituir controles de fluxo ou verificar erros críticos.
- Em verificações que podem afetar a segurança ou integridade de um sistema, especialmente porque `assert` é desabilitado no modo otimizado (`-O`).

## exercícios `assert`

<details>
<summary>Lista de Exercícios</summary>

1. **Verificando valores**: Escreva um código que recebe um número `x` e usa `assert` para garantir que `x` seja positivo.
1. **Divisão por zero**: Crie uma função `dividir(a, b)` que divide `a` por `b` e usa `assert` para garantir que `b` não seja zero.
1. **Comprimento da string**: Escreva um código que recebe uma string `s` e usa `assert` para garantir que a string tenha pelo menos 5 caracteres.
1. **Lista vazia**: Crie uma função que verifica se uma lista `lst` está vazia e, se sim, lança uma exceção usando `assert`.
1. **Soma de números positivos**: Escreva uma função `soma_positivos(a, b)` que soma dois números e usa `assert` para garantir que ambos sejam positivos.
1. **Raiz quadrada de número positivo**: Crie uma função `raiz_quadrada(x)` que calcula a raiz quadrada de um número. Use `assert` para garantir que `x` é positivo.
1. **Maior que zero em loop**: Escreva uma função que percorra uma lista de números e use `assert` para garantir que todos os números sejam maiores que zero.
1. **Garantindo a ordem de uma lista**: Crie uma função `verificar_ordenacao(lista)` que usa `assert` para garantir que todos os elementos da lista estão em ordem crescente.
1. **Validação de ano**: Escreva uma função que receba um ano e use `assert` para garantir que o ano seja maior que 0.
1. **Fatorial de um número**: Crie uma função `fatorial(n)` que calcula o fatorial de `n` e usa `assert` para garantir que `n` seja maior ou igual a zero.
1. **Média de notas**: Escreva uma função que recebe uma lista de notas e usa `assert` para garantir que todas as notas estão entre 0 e 10.
1. **Índice válido em lista**: Escreva uma função que usa `assert` para garantir que um índice fornecido está dentro dos limites de uma lista.
1. **Número ímpar**: Escreva uma função que recebe um número e usa `assert` para garantir que o número é ímpar.
1. **Verificando a soma de uma lista**: Crie uma função que recebe uma lista de números e usa `assert` para garantir que a soma de todos os elementos da lista é maior que 100.
1. **Verificando divisibilidade**: Escreva uma função que recebe dois números e usa `assert` para garantir que o primeiro número é divisível pelo segundo.
1. **Todos pares**: Escreva uma função que percorre uma lista e usa `assert` para garantir que todos os números são pares.
1. **Número dentro de intervalo**: Crie uma função que recebe um número e usa `assert` para garantir que o número está no intervalo entre 10 e 20.
1. **Tamanho da lista**: Escreva uma função que usa `assert` para garantir que uma lista tenha pelo menos 3 elementos.
1. **Soma de inteiros**: Escreva uma função que recebe dois valores e usa `assert` para garantir que ambos são inteiros antes de somá-los.
1. **Divisão de números pares**: Escreva uma função que recebe dois números e usa `assert` para garantir que ambos são pares antes de realizar a divisão.
1. **Verificação de senha**: Crie uma função `verificar_senha(senha)` que usa `assert` para garantir que a senha tenha pelo menos 8 caracteres.
1. **Números diferentes**: Escreva uma função que recebe dois números e usa `assert` para garantir que eles são diferentes.
1. **Palavra com letra específica**: Escreva uma função que usa `assert` para garantir que uma string contém a letra 'a' pelo menos uma vez.
1. **Lista de strings não vazias**: Crie uma função que percorra uma lista de strings e use `assert` para garantir que nenhuma das strings é vazia.
1. **Produto de lista não zero**: Escreva uma função que percorra uma lista de números e usa `assert` para garantir que o produto de todos os números não seja zero.
1. **Números na sequência**: Crie uma função que recebe uma lista de números e usa `assert` para garantir que a sequência dos números seja crescente ou decrescente.
1. **Valores maiores que 10**: Escreva uma função que usa `assert` para garantir que todos os valores em uma lista são maiores que 10.
1. **Verificação de vogais**: Escreva uma função que usa `assert` para garantir que uma string contém pelo menos uma vogal.
1. **Intervalo fechado**: Crie uma função que recebe dois números e usa `assert` para garantir que o segundo número é maior que o primeiro.
1. **Verificando múltiplos de 3**: Escreva uma função que percorra uma lista de números e use `assert` para garantir que todos os números são múltiplos de 3.

</details>

## `yield`

O comando `yield` no Python é uma palavra-chave que transforma uma função comum em um gerador. Um gerador é uma função que produz uma sequência de valores ao invés de retornar todos os valores de uma vez como faz a função `return`. Em vez disso, a função com `yield` "pausa" sua execução e retorna um valor temporário a cada chamada. Quando a função é chamada novamente, a execução continua de onde parou, até atingir o fim da função ou encontrar outro `yield`.

### como funciona

O `yield` permite que uma função retorne valores de forma incremental sem perder o estado intermediário entre as iterações. Cada vez que o `yield` é chamado, a função é interrompida e o controle é passado de volta para o chamador. Quando o chamador pede o próximo valor (geralmente por meio de um loop ou da função `next()`), a função continua sua execução exatamente de onde parou.

**Exemplo**

```python
def contador(limit):
    n = 0
    while n < limit:
        yield n  # Pausa e retorna o valor atual de n
        n += 1

# Usando o gerador
for num in contador(5):
    print(num)
```
**Saída**

```
0
1
2
3
4
```

Nesse exemplo, a função contador gera números de 0 até limit - 1. Cada vez que a função encontra o `yield`, ela pausa e retorna o valor atual de `n`. Quando a função é chamada de novo, a execução continua do ponto em que foi interrompida, incrementando o valor de `n`.

### `yield` vs `return`

- `return` finaliza a execução da função e retorna um valor (ou vários valores de uma vez em uma lista, tupla, etc.). Uma vez que uma função retorna, ela perde seu estado;
- `yield` pausa a execução da função e lembra do estado atual, podendo ser retomada a partir desse ponto;

**Exemplo com `return`**

```python
def retorna_lista():
    return [0, 1, 2, 3, 4]

for num in retorna_lista():
    print(num)
```

Neste caso, a função `retorna_lista` retorna todos os valores de uma vez, o que pode ser ineficiente se a lista for muito grande.

**Exemplo com `yield`**

```python
def gera_numeros():
    for i in range(5):
        yield i

for num in gera_numeros():
    print(num)
```

Aqui, os valores são gerados um de cada vez, economizando memória.

### para que serve

O `yield` é útil quando se deseja criar iteradores personalizados ou quando quer lidar com grandes volumes de dados sem carregar tudo na memória de uma vez. Ele permite:

- **eficiência de memória** : ao gerar grandes volumes de dados, como números em sequência ou linhas de um arquivo muito grande, o `yield` permite trabalhar com esses dados aos poucos, sem precisar carregá-los todos na memória;

- **manutenção de estado** : o `yield` mantém o estado interno da função entre as execuções, possibilitando a criação de iteradores personalizados sem precisar de variáveis externas;

**Exemplo de leitura de um arquivo grande**

```python
def ler_arquivo_em_pedacos(arquivo, tamanho_bloco):
    with open(arquivo, 'r') as f:
        while True:
            bloco = f.read(tamanho_bloco)
            if not bloco:
                break
            yield bloco

# usando o gerador
for bloco in ler_arquivo_em_pedacos('arquivo_grande.txt', 1024):
    print(bloco)
```

Aqui, em vez de ler o arquivo inteiro de uma vez (o que pode ser inviável para arquivos grandes), ele lê pedaços de 1024 bytes e vai processando bloco por bloco.

### vantagens

- **eficiência de memória** : como o `yield` retorna um valor por vez, ele não precisa armazenar todos os valores na memória. Isso é particularmente útil ao trabalhar com grandes coleções de dados ou streams de dados contínuos.

- **código mais limpo** : facilita a criação de iteradores personalizados sem precisar implementar manualmente o protocolo de iterador (usando `__iter__()` e `__next__()`).

- **lazy evaluation** : o `yield` gera valores sob demanda, o que pode evitar o cálculo desnecessário de valores futuros que talvez nunca sejam usados;

### desvantagens

- **dificuldade de depuração** : como o `yield` pausa a execução da função e mantém o estado, o fluxo de execução pode ser mais difícil de seguir e depurar, especialmente em casos complexos;

- **fica limitado ao contexto** : como o `yield` mantém o estado da função, não pode ser usado diretamente em situações onde se precisa de todos os resultados ao mesmo tempo (como enviar dados para uma API que requer tudo de uma vez);

- **perda de flexibilidade** : uma função com `yield` não pode retornar valores diretamente como uma função normal com `return`; portanto, ela só pode ser usada dentro do contexto de iteração';

**Exemplo de uso incorreto**

```python
def minha_funcao():
    if True:
        yield 1
    return 2

# Tentando usar o gerador
print(list(minha_funcao()))
```

**Saída**

```
1
```

Aqui, `return` 2 é ignorado, pois a função foi transformada em um gerador. O `yield` transforma a função em um gerador, então o `return` no meio de uma função com `yield` só termina o gerador (e não retorna o valor 2).

### como não usar

- não use `yield` se precisa de todos os resultados imediatamente. Nesse caso, é mais apropriado usar `return` com uma lista ou outro tipo de coleção;
- não tente usar `yield` em contextos onde os valores gerados precisam ser reutilizados várias vezes. O gerador é consumido uma vez e não pode ser resetado automaticamente;

**Exemplo sequência Fibonacci com `yield`**

```python
def fibonacci():
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b

# Usando o gerador Fibonacci
fib_gen = fibonacci()
for _ in range(10):
    print(next(fib_gen))
```

**Saída**

```
0
1
1
2
3
5
8
13
21
34
```

Aqui, foi criado um gerador infinito que gera a sequência de Fibonacci, e o código que o consome pode decidir quantos valores ele quer, sem gerar a sequência inteira de uma vez;

## exercícios `yield`

<details>
<summary>Lista de Exercícios</summary>

1. Exercícios Básicos:
    1. **Contador Simples** : Crie uma função geradora chamada `meu_contador` que usa `yield` para contar de 0 até 9.
    1. **Intervalo de Números** : Modifique o exercício anterior para aceitar dois parâmetros (`inicio` e `fim`) e gerar números de `inicio` até `fim-1`.
    1. **Pares e Ímpares** : Crie um gerador chamado `pares_ate` que gere números pares até um número fornecido como argumento.
    1. **Letras do Alfabeto** : Crie uma função geradora chamada `alfabeto` que gere as letras de 'a' até 'z' usando o `yield`.
    1. **Sequência Fibonacci** : Escreva uma função geradora chamada `fibonacci` que gere a sequência de Fibonacci até um limite fornecido.
1. Exercícios Intermediários:
    1. **Quadrados Perfeitos** : Crie um gerador que gere os quadrados perfeitos (1, 4, 9, 16, etc.) até um número limite.
    1. **Gerador de Potências de 2** : Escreva uma função que gera potências de 2 até uma potência máxima especificada como argumento.
    1. **Gerador de Fatorial** : Escreva um gerador que calcule o fatorial de números de 1 a n (onde n é passado como argumento).
    1. **Número Primo** : Crie uma função geradora chamada `primos` que gere números primos até um valor limite fornecido.
    1. **Múltiplos de 3 e 5** : Crie um gerador que retorna números múltiplos de 3 e 5 até um valor limite.
1. Exercícios Avançados:
    1. **Gerador de Strings** : Escreva um gerador chamado `gerador_strings` que receba uma lista de strings e retorne uma string por vez até a lista estar vazia.
    1. **Caminhar por Lista** : Crie um gerador que receba uma lista e produza os elementos dessa lista um por vez, permitindo pausar e retomar o processo.
    1. **Gerador de Data** : Escreva um gerador que, dado um intervalo de datas (por exemplo, de '2024-01-01' a '2024-01-10'), gere cada data do intervalo.
    1. **Leitura em Blocos** : Escreva um gerador que leia um arquivo de texto em blocos de 1024 bytes e retorne o conteúdo de cada bloco até o fim do arquivo.
1. Exercícios de Aplicação:
    1. **Números Aleatórios** : Escreva um gerador que gere números aleatórios dentro de um intervalo definido e limite o número de números gerados.
    1. **Texto em Palavras** : Escreva um gerador que receba um texto e retorne uma palavra de cada vez.
    1. **Caminhada Aleatória (Random Walk)** : Crie um gerador que simule uma caminhada aleatória unidimensional (por exemplo, +1 ou -1 a cada passo) e gere a posição atual a cada iteração.
    1. **Iterador Personalizado** : Crie um gerador que receba uma lista de números e retorne o dobro de cada número a cada iteração.
    1. **Caminho de Arquivos** : Escreva um gerador que percorra um diretório e retorne o caminho completo de cada arquivo encontrado.

</details>


# comandos-from-import-as.md

Índice

1. [comando import](#comando-import)
1. [comandos from e as](#comandos-from-e-as)
1. [comparando as abordagens](#comparando-as-abordagens)
1. [exemplo completo](#exemplo-completo)
1. [exercícios](#execícios)

# comandos `from` `import` `as`

## comando `import`

O comando `import` em Python é usado para incluir funcionalidades de outros módulos (arquivos `.py`) em um script, permitindo a reutilização de código. Um módulo em Python é simplesmente um arquivo contendo definições e instruções Python, como funções, classes e variáveis. Ao usar `import`, é possível acessar essas definições de um módulo dentro de outro.

### estrutura básica do `import`

A sintaxe básica do comando `import` é :

```python
>>> import nome_do_modulo
```

Aqui, `nome_do_modulo` é o nome do arquivo `.py` sem a extensão. Por exemplo, se tiver um arquivo chamado `meu_modulo.py`, poderá importá-lo em outro arquivo Python com :

```python
>>> import meu_modulo
```

### como funciona o `import`

Quando um módulo é importado :

1. **localização do módulo** : o python verifica se o módulo está presente no local de trabalho atual ou nos diretórios especificados na variável `sys.path`;
2. **execução do código** : todo o código no módulo importado é executado uma vez no momento do import. Se o módulo contém funções ou classes, elas são definidas e prontas para uso no script que fez o import;
3. **criação de um namespace** : um namespace separado é criado para o módulo, o que significa que os nomes definidos no módulo não entram em conflito com os nomes no script importador;

### acessando componentes do módulo

Depois de importar um módulo, é possível acessar as funções, variáveis e outros componentes usando a notação de ponto (`.`).

- exemplo 1 : acessando funções e variáveis

Suponha que tenha um arquivo `meu_modulo.py` com o seguinte conteúdo :

```python
# meu_modulo.py

def saudacao():
    return "Olá, bem-vindo ao meu módulo!"

mensagem = "Este é um exemplo de módulo."
```

Agora, em outro arquivo Python `main.py`, pode-se fazer o seguinte :

```python
# main.py
import meu_modulo

# chamando a função saudacao() do módulo
print(f'{meu_modulo.saudacao() = }')

# acessa a variável mensagem do módulo
print(f'{meu_modulo.mensagem = }')
```

O código acima irá mostrar :

```
Olá, bem-vindo ao meu módulo!
Este é um exemplo de módulo.
```

### importando vários módulos

Pode-se importar múltiplos módulos em um único arquivo Python. Eles podem ser módulos que você criou ou módulos padrão do Python. Cada módulo importado será acessível pelo seu próprio namespace.

- exemplo 2 : importando múltiplos módulos

```python
# main.py
import meu_modulo
import outro_modulo

print(f'{meu_modulo.saudacao() = }')
print(f'{outro_modulo.outra_funcao() = }')
```

### importar módulos repetidamente

Uma vez que um módulo é importado, ele não é reexecutado se for importado novamente no mesmo programa, a menos que o programa seja reiniciado. Isso significa que o código do módulo será executado apenas na primeira vez que o `import` for chamado.

### organização do código com módulos

O uso do `import` é fundamental para organizar o código em partes menores e mais gerenciáveis. Em vez de ter um único arquivo grande, pode-se dividir funcionalidades em diferentes módulos, importando-os conforme necessário. Isso facilita a manutenção e o reuso de código.

- exemplo 3 : organização com módulos

Considere um projeto com três módulos: `matematica.py`, `mensagens.py` e `main.py`.

**arquivo : `matematica.py`**

```python
# matematica.py

def soma(a, b):
    return a + b

def subtracao(a, b):
    return a - b
```

**arquivo : `mensagens.py`**

```python
# mensagens.py

def boas_vindas():
    return "Bem-vindo ao sistema!"

def despedida():
    return "Obrigado por usar o sistema!"
```

**arquivo : `main.py`**

```python
import matematica
import mensagens

print(mensagens.boas_vindas())
resultado = matematica.soma(10, 5)
print(f'A soma é : {resultado}')
print(mensagens.despedida())
```

**saída esperada :**

```
Bem-vindo ao sistema!
A soma é : 15
Obrigado por usar o sistema!
```

## comandos `from` e `as`

O Python oferece várias maneiras de importar funcionalidades de outros módulos. Além do simples `import`, já discutido acima, é possível usar `from ... import`, `import ... as`, e `from ... import ... as` para gerenciar como as funções e variáveis são importadas e acessadas em seu código.

### `from ... import`

O comando `from ... import` é usado quando se deseja importar funções, classes ou variáveis específicas de um módulo, ao invés de importar todo o módulo. Isso é útil quando se quer evitar a importação de todo o conteúdo do módulo, especialmente se apenas precisa de alguns itens.

Veja a sintaxe :

```python
from nome_do_modulo import nome1, nome2, ...
```

Aqui, `nome_do_modulo` é o nome do módulo que se está importando, e `nome1`, `nome2`, etc., são os nomes das funções, variáveis ou classes que se deseja importar.

- exemplo 1 : importando funções específicas

Vamos supor que tenha um módulo chamado `matematica.py` com o seguinte conteúdo :

```python
# matematica.py

def soma(a, b):
    return a + b

def subtracao(a, b):
    return a - b

PI = 3.14159
```

Se quiser usar apenas a função `soma` no seu script, sem importar o restante do módulo, pode-se fazer o seguinte :

```python
from matematica import soma

resultado = soma(10, 5)
print(resultado)  # saída : 15
```

Neste caso, apenas a função `soma` foi importada. Se tentar usar `subtracao` ou `PI`, receberá um erro, pois eles não foram importados.

- exemplo 2: importando múltiplos itens

Também é possível importar várias funções e variáveis ao mesmo tempo :

```python
from matematica import soma, subtracao, PI

print(soma(10, 5))        # saída : 15
print(subtracao(10, 5))   # saída : 5
print(PI)                 # saída : 3.14159
```

### `import ... as`

O comando `import ... as` permite que importe um módulo e, ao mesmo tempo, atribua a ele um alias (ou pseudônimo). Isso é útil para encurtar o nome de um módulo ou para evitar conflitos de nomes quando dois módulos têm o mesmo nome.

Veja a sintaxe abaixo :

```python
import nome_do_modulo as alias
```

Aqui, `nome_do_modulo` é o nome do módulo que está importando, e `alias` é o nome que deseja usar para se referir ao módulo no código.

- exemplo 3 : usando alias para módulos

Vamos dizer exista um módulo chamado `calculadora.py` :

```python
# calculadora.py

def multiplicacao(a, b):
    return a * b

def divisao(a, b):
    if b != 0:
        return a / b
    else:
        return "Divisão por zero não é permitida"
```

Se o nome do módulo for longo, ou se quiser evitar conflitos de nomes, pode importá-lo com um alias :

```python
import calculadora as calc

resultado = calc.multiplicacao(6, 7)
print(resultado)  # saída : 42
```

Agora, pode-se usar `calc` em vez de `calculadora` para acessar as funções dentro desse módulo.

### `from ... import ... as`

O comando `from ... import ... as` combina as funcionalidades de `from ... import` e `import ... as`. Ele permite que se importe itens específicos de um módulo e lhes atribua novos nomes (alias) dentro do seu código.

Veja a sintaxe abaixo :

```python
from nome_do_modulo import nome as alias
```

Aqui, `nome_do_modulo` é o nome do módulo de onde se está importando, `nome` é a função, variável ou classe que se deseja importar, e `alias` é o novo nome que se deseja usar para referenciar esse item.

- exemplo 4 : usando alias para funções específicas

Voltando ao módulo `matematica.py` :

```python
from matematica import soma as adicionar

resultado = adicionar(10, 20)
print(resultado)  # saída : 30
```

Aqui, a função `soma` foi importada com o nome `adicionar`. Dentro do script, deve-se usar o nome `adicionar` para referir-se à função `soma`.

## comparando as abordagens

- **`import nome_do_modulo`** : importa todo o módulo. Deve-se usar o nome do módulo para acessar suas funções e variáveis;
- **`from nome_do_modulo import nome`** : importa apenas funções ou variáveis específicas, sem a necessidade de referenciar o módulo;
- **`import nome_do_modulo as alias`** : importa todo o módulo, mas permite que se use um nome diferente para referenciá-lo;
- **`from nome_do_modulo import nome as alias`** : importa funções ou variáveis específicas e permite que lhes atribua novos nomes;

### quando usar cada abordagem

- Use **`import nome_do_modulo`** quando precisar de várias funções ou variáveis de um módulo e não se importa em acessar essas funcionalidades usando o nome do módulo.
- Use **`from nome_do_modulo import nome`** quando você precisar de apenas algumas funcionalidades de um módulo e quer evitar a sobrecarga de importar tudo.
- Use **`import nome_do_modulo as alias`** quando o nome do módulo for muito longo ou se houver um conflito de nomes com outro módulo.
- Use **`from nome_do_modulo import nome as alias`** quando se quiser importar uma função ou variável específica e atribuir-lhe um nome que seja mais descritivo ou conveniente no contexto do código.

## exemplo completo

Vamos juntar tudo em um exemplo prático. Suponha que se tenha dois módulos: `geometria.py` e `algebra.py`.

**arquivo : `geometria.py`**

```python
# geometria.py

def area_quadrado(lado):
    return lado * lado

def area_retangulo(largura, altura):
    return largura * altura
```

**arquivo : `algebra.py`**

```python
# algebra.py

def quadrado(numero):
    return numero * numero

def raiz_quadrada(numero):
    return numero ** 0.5
```

Agora, pode-se usar as diferentes formas de `import` em um script principal:

```python
# main.py

from geometria import area_quadrado as quadrado_area
import algebra as alg

lado = 5
numero = 16

print(f"Área do quadrado: {quadrado_area(lado)}")  # Usando alias para a função de geometria
print(f"Quadrado de {lado}: {alg.quadrado(lado)}")  # Usando alias para o módulo de álgebra
print(f"Raiz quadrada de {numero}: {alg.raiz_quadrada(numero)}")
```

**Saída esperada:**

```
Área do quadrado: 25
Quadrado de 5: 25
Raiz quadrada de 16: 4.0
```

## execícios

<details>
<summary>Lista de Exercícios</summary>

1. Exercícios de `import`
    1. Crie um módulo chamado `matematica.py` que contenha funções `soma(a, b)` e `multiplicacao(a, b)`. No seu script principal, importe o módulo completo e use as funções para calcular `soma(5, 3)` e `multiplicacao(4, 6)`.
        ```python
        # main.py
        import matematica

        print(f'{matematica.soma(5, 3) = }')
        print(f'{matematica.multiplicacao(4, 6) = }')

        # matematica.py
        def soma(a, b):
            return a + b

        def multiplicacao(a, b):
            return a * b
        ```
    1. Crie um módulo chamado `utilidades.py` com uma função `menor(a, b)` e uma variável `pi`. No seu script principal, importe o módulo completo e imprima o valor de `pi` e o resultado de `menor(10, 20)`.
    1. Crie um módulo chamado `strings.py` com uma função `concatena(s1, s2)` que retorna a concatenação de duas strings. No seu script principal, importe o módulo completo e use a função para concatenar as strings `"Olá"` e `"Mundo"`.
    1. Crie um módulo chamado `calculos.py` com uma função `fatorial(n)` que retorna o fatorial de um número. No seu script principal, importe o módulo completo e calcule o fatorial de `5`.
        ```python
        # main.py
        import calculos as calc

        calc.fatorial(5)

        # calculos.py
        def fatorial(n):
            resultado = 1

            while n > 0:
                print(f'{n = }, {resultado = }')
                resultado *= n  # resultado = resultado * n
                n -= 1  # n = n - 1

            print(f'{n = }')
            print(f'{resultado = }')
        ```
    1. Crie um módulo chamado `data.py` com uma função `data_atual()` que retorna a data atual no formato `"YYYY-MM-DD"`. No seu script principal, importe o módulo completo e exiba a data atual.
        ```python
        # main.py
        import data

        print(f'{data.data_atual() = }')

        # data.py
        def data_atual():
            return "2024-09-03"
        ```
1. Exercícios de `from ... import`
    1. Crie um módulo chamado `matematica_basica.py` com funções `soma(a, b)`, `subtracao(a, b)`, e `multiplicacao(a, b)`. No seu script principal, importe apenas a função `soma` e utilize-a para somar `8` e `12`.
    1. Crie um módulo chamado `strings_avancadas.py` com funções `capitalizar(s)` e `inverter(s)`. No seu script principal, importe a função `inverter` e use-a para inverter a string `"Python"`.
    1. Crie um módulo chamado `geometria_basica.py` com funções `area_circulo(raio)` e `perimetro_quadrado(lado)`. No seu script principal, importe apenas a função `perimetro_quadrado` e calcule o perímetro de um quadrado com lado `7`.
    1. Crie um módulo chamado `algebra_basica.py` com funções `quadrado(x)` e `raiz_quadrada(x)`. No seu script principal, importe apenas a função `raiz_quadrada` e calcule a raiz quadrada de `16`.
    1. Crie um módulo chamado `conversao.py` com funções `km_para_milhas(km)` e `celsius_para_fahrenheit(celsius)`. No seu script principal, importe apenas a função `km_para_milhas` e converta `100` quilômetros para milhas.
1. Exercícios de `import ... as`
    1. Crie um módulo chamado `calculadora.py` com funções `adicao(a, b)`, `subtracao(a, b)`, e `multiplicacao(a, b)`. No seu script principal, importe o módulo usando o alias `calc` e use a função `adicao` para somar `15` e `25`.
    1. Crie um módulo chamado `convert.py` com funções `dolar_para_euro(dolares)` e `euro_para_reais(euros)`. No seu script principal, importe o módulo com o alias `conv` e converta `50` dólares para euros.
    1. Crie um módulo chamado `estatisticas.py` com funções `media(lista)` e `mediana(lista)`. No seu script principal, importe o módulo como `est` e calcule a média de `[1, 2, 3, 4, 5]`.
    1. Crie um módulo chamado `tempo.py` com funções `dias_para_horas(dias)` e `horas_para_minutos(horas)`. No seu script principal, importe o módulo com o alias `temp` e calcule o número de horas em `3` dias.
    1. Crie um módulo chamado `letras.py` com funções `contar_vogais(s)` e `contar_consoantes(s)`. No seu script principal, importe o módulo usando o alias `let` e conte o número de vogais na string `"Programação"`.
1. Exercícios de `from ... import ... as`
    1. Crie um módulo chamado `ferramentas.py` com funções `ordenar_lista(lista)` e `filtrar_lista(lista, critério)`. No seu script principal, importe `ordenar_lista` como `ordenar` e use-a para ordenar a lista `[4, 2, 9, 1]`.
    1. Crie um módulo chamado `textos.py` com funções `remover_espacos(s)` e `contar_palavras(s)`. No seu script principal, importe `contar_palavras` como `contar` e conte o número de palavras na string `"Python é divertido"`.
    1. Crie um módulo chamado `matematica_avancada.py` com funções `logaritmo(x, base)` e `potencia(base, expoente)`. No seu script principal, importe `potencia` como `exp` e calcule `2` elevado à `10`.
    1. Crie um módulo chamado `formatacao.py` com funções `formatar_data(data)` e `formatar_moeda(valor)`. No seu script principal, importe `formatar_data` como `formatar` e formate a data `"2024-09-03"`.
    1. Crie um módulo chamado `aleatorios.py` com funções `gerar_numero_aleatorio()` e `gerar_lista_aleatoria(tamanho)`. No seu script principal, importe `gerar_numero_aleatorio` como `numero_aleatorio` e gere um número aleatório.
1. Exercícios Combinados
    1. Crie um módulo chamado `financeiro.py` com funções `calcular_juros(principal, taxa, tempo)` e `calcular_investimento(principal, taxa, tempo)`. No seu script principal, importe `calcular_juros` como `juros` e `calcular_investimento` como `investimento`, e calcule o investimento inicial de `1000` com taxa de `5%` ao longo de `2` anos.
    1. Crie um módulo chamado `analise.py` com funções `media_lista(lista)` e `desvio_padrao(lista)`. No seu script principal, importe `desvio_padrao` como `desvio` e calcule o desvio padrão da lista `[2, 4, 4, 4, 5, 5, 7, 9]`.
        ```python
        # main.py
        from funcoes import desvio_padrao as desvio

        lista = [2, 4, 4, 4, 5, 5, 7, 9]
        desvio(lista)

        # analise.py
        def media_lista(lista):
            tamanho = len(lista)

            soma = 0
            for valor in lista:
                soma += valor

            media = soma / tamanho

            return media

        def desvio_padrao(lista):

            print(f'{lista = }')
            media = media_lista(lista)
            print(f'{media = }')

            difer_elem = []

            for valor in lista:
                diferenca = valor - media
                quadrado = diferenca ** 2
                difer_elem.append(quadrado)

            media_quad = media_lista(difer_elem)
            print(f'{media_quad = }')
            desvio_padrao = media_quad ** (1/2)

            print(f'o desvio da lista eh : {desvio_padrao = }')
        ```
    1. Crie um módulo chamado `comparacao.py` com funções `maior(a, b)` e `menor(a, b)`. No seu script principal, importe `menor` como `encontrar_menor` e calcule o menor entre `8` e `12`.
    1. Crie um módulo chamado `geometria.py` com funções `volume_cubo(lado)` e `volume_esfera(raio)`. No seu script principal, importe `volume_cubo` como `volume_c` e `volume_esfera` como `volume_e`, e calcule o volume de um cubo com lado `3` e uma esfera com raio `4`.
    1. Crie um módulo chamado `dados.py` com funções `criar_lista(tamanho)` e `criar_dicionario(chaves, valores)`. No seu script principal, importe `criar_lista` como `criar_lista_dados` e `criar_dicionario` como `criar_dict`, e crie uma lista com `5` elementos e um dicionário com as chaves `['a', 'b']` e valores `[1, 2]`.
    1. Crie um módulo chamado `crypto.py` com funções `criptografar(texto)` e `descriptografar(texto)`. No seu script principal, importe `criptografar` como `cripto` e `descriptografar` como `descripto`, e criptografe o texto `"Segredo"`.
    1. Crie um módulo chamado `geradores.py` com funções `gerar_username(nome)` e `gerar_senha(tamanho)`. No seu script principal, importe `gerar_username` como `username` e `gerar_senha` como `senha`, e gere um nome de usuário e uma senha de `12` caracteres.
    1. Crie um módulo chamado `contas.py` com funções `adicionar_conta(nome, valor)` e `remover_conta(nome)`. No seu script principal, importe `adicionar_conta` como `adicionar` e `remover_conta` como `remover`, e adicione uma conta chamada `"Aluguel"` com valor `1200`.
    1. Crie um módulo chamado `desenho.py` com funções `desenhar_circulo(raio)` e `desenhar_quadrado(lado)`. No seu script principal, importe `desenhar_circulo` como `circulo` e `desenhar_quadrado` como `quadrado`, e desenhe um círculo com raio `5` e um quadrado com lado `10`.
    1. Crie um módulo chamado `enderecos.py` com funções `formatar_endereco(cidade, estado)` e `validar_cep(cep)`. No seu script principal, importe `formatar_endereco` como `formatar_end` e `validar_cep` como `validar_cep`, e formate o endereço para `"São Paulo"` e `"SP"` e valide o CEP `"12345-678"`.
    1. Crie um módulo chamado `arquivos.py` com funções `ler_arquivo(caminho)` e `escrever_arquivo(caminho, conteudo)`. No seu script principal, importe `ler_arquivo` como `ler` e `escrever_arquivo` como `escrever`, e escreva o texto `"Exemplo"` em um arquivo chamado `"teste.txt"` e depois leia o conteúdo desse arquivo.
    1. Crie um módulo chamado `mensagens.py` com funções `enviar_email(remetente, destinatario, assunto, corpo)` e `enviar_sms(numero, mensagem)`. No seu script principal, importe `enviar_email` como `email` e `enviar_sms` como `sms`, e envie um e-mail para `"exemplo@dominio.com"` com o assunto `"Teste"` e uma mensagem `"Olá"`.
    1. Crie um módulo chamado `relatorios.py` com funções `gerar_relatorio(dados)` e `salvar_relatorio(caminho)`. No seu script principal, importe `gerar_relatorio` como `relatorio` e `salvar_relatorio` como `salvar`, e gere um relatório com dados `["Dados1", "Dados2"]` e salve-o no caminho `"relatorio.txt"`.
    1. Crie um módulo chamado `relogio.py` com funções `hora_atual()` e `tempo_decorrido(inicio, fim)`. No seu script principal, importe `hora_atual` como `hora` e `tempo_decorrido` como `tempo`, e exiba a hora atual e calcule o tempo decorrido entre `10` e `20`.
    1. Crie um módulo chamado `cartas.py` com funções `embaralhar_cartas()` e `distribuir_cartas(jogadores)`. No seu script principal, importe `embaralhar_cartas` como `embaralhar` e `distribuir_cartas` como `distribuir`, e embaralhe um baralho e distribua as cartas para `4` jogadores.
    1. Crie um módulo chamado `arquitetura.py` com funções `criar_plano(tipo)` e `revisar_plano(plano)`. No seu script principal, importe `criar_plano` como `plano` e `revisar_plano` como `revisar`, e crie um plano para um `"escritório"` e revise o plano.
    1. Crie um módulo chamado `conversores.py` com funções `farenheit_para_celsius(fahrenheit)` e `celsius_para_kelvin(celsius)`. No seu script principal, importe `farenheit_para_celsius` como `farenheit_celsius` e `celsius_para_kelvin` como `celsius_kelvin`, e converta `32` graus Fahrenheit para Celsius e depois para Kelvin.
    1. Crie um módulo chamado `financeiro_avancado.py` com funções `calcular_amortizacao(principal, taxa, anos)` e `calcular_juros_compostos(principal, taxa, anos)`. No seu script principal, importe `calcular_amortizacao` como `amortizacao` e `calcular_juros_compostos` como `juros_compostos`, e calcule a amortização e os juros compostos para um empréstimo de `10000` com taxa `5%` ao longo de `10` anos.
    1. Crie um módulo chamado `analises_avancadas.py` com funções `analise_temporal(dados)` e `analise_espacial(dados)`. No seu script principal, importe `analise_temporal` como `temporal` e `analise_espacial` como `espacial`, e faça uma análise temporal e espacial de um conjunto de dados fictícios.
    1. Crie um módulo chamado `crimes.py` com funções `relatar_crime(tipo, descricao)` e `consultar_crimes(local)`. No seu script principal, importe `relatar_crime` como `relatar` e `consultar_crimes` como `consultar`, e relate um crime de `"furto"` e consulte os crimes ocorridos no `"bairro"`.

</details>


# compreensao-listas.md

Índice

1. [vantagens](#vantagens)
1. [sintaxe](#sintaxe)
1. [exemplos](#exemplos)
1. [exemplos aula](#exemplos-aula)
1. [conclusão](#conclusão)
1. [exercícios](#exercícios)

# compreensão de listas

A **compreensão de listas** (*list comprehension*) é uma maneira concisa e elegante de criar listas em Python. Ela permite construir novas listas aplicando uma expressão a cada item de uma sequência existente e, opcionalmente, filtrando itens com base em alguma condição.

## vantagens

- **sintaxe concisa** : reduz o número de linhas de código comparado aos loops tradicionais;
- **leitura fácil** : facilita a compreensão do código, tornando-o mais legível;
- **performance melhorada** : em muitos casos, compreensões de listas são mais rápidas do que construções de loops equivalentes;

## sintaxe

A sintaxe geral de uma compreensão de lista é :

```python
[<expressão> for <item_do_iterável> in <iterável>]
```

- **expressão** : operação ou valor que será aplicado a cada item;
- **item_do_iterável** : variável que representa cada elemento no iterável;
- **iterável** : uma sequência ou objeto que pode ser iterado (como listas, tuplas, strings, etc.);

Também é possível adicionar condições :

```python
[<expressão> for <item_do_iterável> in <iterável> if <condição>]
```

- **condição** : uma expressão booleana que filtra os itens do iterável;

## exemplos

### exemplo 1 : criando uma lista simples

```python
>>> # usando o loop tradicional
>>> numeros = []
>>> for i in range(10):
...     numeros.append(i)
...
>>> print(numeros)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>>
>>> # usando compreensão de lista
>>> numeros = [i for i in range(10)]
>>> print(numeros)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> |
```

- **loop tradicional** : é inicializada uma lista vazia e um loop `for` é usado para adicionar cada número de 0 a 9;
- **compreensão de lista** : a mesma operação é realizada em uma única linha, tornando o código mais conciso e legível;

### exemplo 2 : aplicando operações aos itens

```python
>>> # usando o loop tradicional
>>> quadrados = []
>>> for i in range(10):
...     quadrados.append(i**2)
...
>>> print(quadrados)
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
>>>
>>> # usando compreensão de lista
>>> quadrados = [i**2 for i in range(10)]
>>> print(quadrados)
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
>>> |
```

- **expressão** : `i**2` calcula o quadrado de cada número `i` no intervalo de 0 a 9;
- **iterável** : `range(10)` fornece os números de 0 a 9;

### exemplo 3 : filtrando itens com condição

```python
>>> # usando o loop tradicional
>>> pares = []
>>> for i in range(20):
...     if i % 2 == 0:
...         pares.append(i)
...
>>> print(pares)
[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
>>>
>>> # usando compreensão de lista
>>> pares = [i for i in range(20) if i % 2 == 0]
>>> print(pares)
[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
>>> |
```

- **condição** : `if i % 2 == 0` filtra apenas os números que são divisíveis por 2 (números pares);
- **vantagem** : a compreensão de lista combina a iteração e a filtragem em uma única linha;

### exemplo 4 : transformando strings

```python
>>> palavras = ['python', 'compreensão', 'lista', 'exemplo']
>>>
>>> # usando o loop tradicional
>>> maiusculas = []
>>> for palavra in palavras:
...     maiusculas.append(palavra.upper())
...
>>> print(maiusculas)
['PYTHON', 'COMPREENSÃO', 'LISTA', 'EXEMPLO']
>>>
>>> # usando a compreensão de lista
>>> maiusculas = [palavra.upper() for palavra in palavras]
>>> print(maiusculas)
['PYTHON', 'COMPREENSÃO', 'LISTA', 'EXEMPLO']
>>> |
```

- **expressão** : `palavra.upper()` converte cada palavra para letras maiúsculas;
- **iterável** : a lista `palavras` é percorrida, aplicando a transformação a cada elemento;

### exemplo 5 : compreensão com funções

```python
>>> frase = "Compreensões de listas são poderosas"
>>>
>>> # usando o loop tradicional
>>> comprimentos = []
>>> for palavra in frase.split():
...     comprimentos.append(len(palavra))
...
>>> print(comprimentos)
[12, 2, 6, 3, 10]
>>>
>>> # usando compreensão de lista
>>> comprimentos = [len(palavra) for palavra in frase.split()]
>>> print(comprimentos)
[12, 2, 6, 3, 10]
>>> |
```

- **`frase.split()`:** : divide a frase em uma lista de palavras;
- **`len(palavra)`** : calcula o comprimento de cada palavra;

### exemplo 6 : compreensão aninhada (nested)

```python
>>> # usando o loop tradicional
>>> coordenadas = []
>>> for x in range(3):
...     for y in range(3):
...         coordenadas.append((x, y))
...
>>> print(coordenadas)
[(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]
>>>
>>> # usando compreensão de lista
>>> coordenadas = [(x, y) for x in range(3) for y in range(3)]
>>> print(coordenadas)
[(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]
>>> |
```

- **loops aninhados** : para cada valor de `x`, o loop interno itera sobre `y`;
- **expressão** : cria tuplas `(x, y)` para cada combinação possível;

### exemplo 7 : filtrando com condição complexa

```python
>>> # usando o loop tradicional
>>> numeros = []
>>> for i in range(1, 51):
...     if i % 3 == 0 and i % 5 == 0:
...         numeros.append(i)
...
>>> print(numeros)
[15, 30, 45]
>>>
>>> # usando compreensão de lista
>>> numeros = [i for i in range(1, 51) if i % 3 == 0 and i % 5 == 0]
>>> print(numeros)
[15, 30, 45]
>>> |
```

- **condição** : `i % 3 == 0 and i % 5 == 0` seleciona números divisíveis por ambos 3 e 5;
- **iterável** : `range(1, 51)` fornece números de 1 a 50;

---

### exemplo 8 : compreensão de lista com função condicional

```python
>>> # usando o loop tradicional
>>> resultado = []
>>> for i in range(10):
...     if i % 2 == 0:
...         resultado.append("Par")
...     else:
...         resultado.append("Ímpar")
>>>
>>> print(resultado)
['Par', 'Ímpar', 'Par', 'Ímpar', 'Par', 'Ímpar', 'Par', 'Ímpar', 'Par', 'Ímpar']
>>>
>>> # usando compreensão de lista
>>> resultado = ["Par" if i % 2 == 0 else "Ímpar" for i in range(10)]
>>> print(resultado)
['Par', 'Ímpar', 'Par', 'Ímpar', 'Par', 'Ímpar', 'Par', 'Ímpar', 'Par', 'Ímpar']
>>> |
```

- **expressão condicional** : `"par" if i % 2 == 0 else "ímpar"` avalia cada número e retorna a string correspondente;
- **iterável** : itera sobre números de 0 a 9;

### exemplo 9 : compreensão de lista com funções e filtragem

```python
>>> nomes = ['Ana', 'Bruno', 'Carlos', 'Diana', 'Eduardo', 'Fátima']
>>>
>>> # usando o loop tradicional
>>> nomes_filtrados = []
>>> for nome in nomes:
...     if len(nome) > 5:
...         nomes_filtrados.append(nome.upper())
...
>>> print(nomes_filtrados)
['CARLOS', 'EDUARDO', 'FÁTIMA']
>>>
>>> # usando compreensão de lista
>>> nomes_filtrados = [nome.upper() for nome in nomes if len(nome) > 5]
>>> print(nomes_filtrados)
['CARLOS', 'EDUARDO', 'FÁTIMA']
>>> |
```

- **condição** : `if len(nome) > 5` filtra nomes com mais de 5 letras;
- **expressão** : `nome.upper()` converte os nomes filtrados para maiúsculas;

### exemplo 10 : achatar lista de listas

```python
>>> listas = [[1, 2], [3, 4], [5, 6]]
>>>
>>> # usando o loop tradicional
>>> lista_plana = []
>>> for sublista in listas:
...     for item in sublista:
...         lista_plana.append(item)
...
>>> print(lista_plana)
[1, 2, 3, 4, 5, 6]
>>>
>>> # usando compreensão de lista
>>> lista_plana = [item for sublista in listas for item in sublista]
>>> print(lista_plana)
[1, 2, 3, 4, 5, 6]
>>> |
```

- **loops aninhados** : o primeiro loop percorre cada sublista, e o segundo loop percorre cada item dentro das sublistas;
- **expressão** : cada `item` é adicionado à nova lista plana;

## exemplos aula

Segue abaixo os exemplos mais complexos realizados em aula :

```python
>>> # iterando sobre uma lista de 100 números,
>>> # primeiro filtrando pelos múltiplos de 4 E 5
>>> # depois separando em tuplas de string (par ou impar) e o valor de n
>>> tuplas = []
>>> for n in range(100):
...    if n % 4 == 0 and n % 5 == 0:
...        if n % 2 == 0:
...            tuplas.append(('par',n))
...        else:
...            tuplas.append(('impar',n))
...
>>> tuplas
[('par', 0), ('par', 20), ('par', 40), ('par', 60), ('par', 80)]
>>>
>>> # mesma coisa que acima, mas usando compreensao de lista
>>> # e operador ternário
>>> [('par',n) if n % 2 == 0 else ('impar',n) for n in range(100) if n % 4 == 0 and n % 5 == 0]
[('par', 0), ('par', 20), ('par', 40), ('par', 60), ('par', 80)]
>>> |
```
```python
>>> mista = [True, 'carlos', 42, 'maria', False, 3.14]
>>>
>>> resultado = []
>>> # filtragem da lista mista, separando apenas o valores dos tipos
>>> # string e inteiros, depois, se for string deixa em caixa alta
>>> # se for inteiro, eleva ao quadrado
>>> for item in mista:
...     if isinstance(item,str) or isinstance(item,int):
...         if isinstance(item,str):
...             resultado.append(item.upper())
...         else:
...             resultado.append(item ** 2)
...
>>> resultado
[1, 'CARLOS', 1764, 'MARIA', 0]
>>>
>>> # a mesma coisa que acima, mas agora usando compreensão de listas
>>> # e o operador ternário
>>> [item.upper() if isinstance(item,str) else item ** 2 for item in mista if isinstance(item,str) or isinstance(item,int)]
[1, 'CARLOS', 1764, 'MARIA', 0]
>>> |
```

## conclusão

As **compreensões de listas** são uma ferramenta poderosa em Python que permitem escrever código mais compacto e legível. Elas são particularmente úteis para :

- **transformar dados** : aplicando operações a todos os itens de uma sequência;
- **filtrar dados** : Selecionando itens que atendem a determinadas condições;
- **criar estruturas complexas** : Como listas aninhadas ou dicionários, de forma concisa;

## exercícios

<details>
<summary>Lista de Execícios</summary>

> [!TIP]
> para os seguintes execícios :
> - primeiro, crie a versão tradicional do exercício;
> - depois, a partir da primeira, crie a versão de compreensão de lista;

Exemplo :
```python
>>> # Dobro dos Números : Dada a lista `numeros = [1, 2, 3, 4, 5]`, crie
>>> # uma nova lista que contenha o dobro de cada número da lista original.
>>>
>>> numeros = [1, 2, 3, 4, 5]
>>>
>>> # usando o loop tradicional
>>> nova_lista = []
>>> for n in numeros:
...     nova_lista.append(n * 2)
...
>>> print(nova_lista)
[2, 4, 6, 8, 10]
>>>
>>> # usando compreensão de lista
>>> nova_lista = [n * 2 for n in numeros]
>>> nova_lista
[2, 4, 6, 8, 10]
>>> |
```

1. Nível Simples
    1. **Dobro dos Números**: Dada a lista `numeros = [1, 2, 3, 4, 5]`, crie uma nova lista que contenha o dobro de cada número da lista original.
    1. **Quadrado dos Números**: Dada a lista `numeros = [1, 2, 3, 4, 5]`, crie uma nova lista que contenha o quadrado de cada número da lista original.
    1. **Números Pares**: Dada a lista `numeros = [1, 2, 3, 4, 5, 6]`, crie uma nova lista que contenha apenas os números pares da lista original.
    1. **Números Ímpares**: Dada a lista `numeros = [1, 2, 3, 4, 5, 6]`, crie uma nova lista que contenha apenas os números ímpares da lista original.
    1. **Strings em Maiúsculas**: Dada a lista `palavras = ["python", "é", "legal"]`, crie uma nova lista que contenha cada palavra da lista original em maiúsculas.
1. Nível Intermediário
    1. **Comprimento das Strings**: Dada a lista `palavras = ["python", "é", "legal"]`, crie uma nova lista que contenha o comprimento de cada palavra da lista original.
    1. **Filtrar Booleans Verdadeiros**: Dada a lista `valores = [True, False, True, False]`, crie uma nova lista que contenha apenas os valores `True` da lista original.
    1. **Strings com mais de 3 Caracteres**: Dada a lista `palavras = ["oi", "python", "sim", "não"]`, crie uma nova lista que contenha apenas as palavras com mais de 3 caracteres.
    1. **Números Divisíveis por 3**: Dada a lista `numeros = [3, 6, 9, 12, 15, 18]`, crie uma nova lista que contenha apenas os números que são divisíveis por 3.
    1. **Negativos a partir de uma Tupla**: Dada a tupla `numeros = (1, -2, 3, -4, 5)`, crie uma nova lista que contenha apenas os números negativos da tupla.
1. Nível Avançado
    1. **Multiplicação de Pares por 2**: Dada a lista `numeros = [1, 2, 3, 4, 5, 6]`, crie uma nova lista onde os números pares são multiplicados por 2, e os ímpares permanecem inalterados.
    1. **Conversão de Strings em Booleans**: Dada a lista `strings = ["True", "False", "True", "False"]`, crie uma nova lista que converta as strings `"True"` e `"False"` para seus respectivos valores booleanos.
    1. **Filtrar Tuplas que Contêm Inteiros**: Dada a lista `tuplas = [(1, 2), ("a", "b"), (3, 4)]`, crie uma nova lista que contenha apenas as tuplas que contêm apenas inteiros.
    1. **Primeiros Caracteres de Strings**: Dada a lista `palavras = ["Python", "é", "incrível"]`, crie uma nova lista que contenha o primeiro caractere de cada palavra.
    1. **Listas com Todos os Valores Verdadeiros**: Dada a lista `listas = [[True, True], [True, False], [False, False]]`, crie uma nova lista que contenha apenas as listas onde todos os valores são `True`.
1. Nível Complexo
    1. **Somar Valores de Tuplas**: Dada a lista `tuplas = [(1, 2), (3, 4), (5, 6)]`, crie uma nova lista que contenha a soma dos valores de cada tupla.
    1. **Inverter Strings**: Dada a lista `palavras = ["Python", "é", "incrível"]`, crie uma nova lista que contenha cada palavra invertida.
    1. **Substituição Condicional**: Dada a lista `numeros = [1, 2, 3, 4, 5, 6]`, crie uma nova lista onde os números menores que 4 são substituídos por `"Pequeno"`, e os demais são substituídos por `"Grande"`.
    1. **Concatenar Listas**: Dada a lista de listas `listas = [[1, 2], [3, 4], [5, 6]]`, crie uma nova lista que contenha todos os elementos concatenados em uma única lista.
    1. **Números em Strings com Mais de 5 Dígitos**: Dada a lista `numeros = ["12345", "678901", "23456"]`, crie uma nova lista que contenha apenas os números que tenham mais de 5 dígitos.
1. Nível Muito Complexo
    1. **Intersecção de Listas**: Dadas as listas `a = [1, 2, 3]` e `b = [2, 3, 4]`, crie uma nova lista que contenha os elementos que estão em ambas as listas.
    1. **Números Flutuantes Menores que Inteiros**: Dada a lista `numeros = [1, 2.5, 3.7, 4]`, crie uma nova lista que contenha apenas os números flutuantes que são menores que os inteiros.
    1. **Filtragem Condicional em Tuplas**: Dada a lista de tuplas `tuplas = [(1, 2), (3, 4), (5, 6)]`, crie uma nova lista que contenha apenas as tuplas onde o primeiro valor é menor que o segundo.
    1. **Booleanos em Listas Mistas**: Dada a lista mista `mista = [True, 1, False, 0, "True", "False"]`, crie uma nova lista que contenha apenas os valores booleanos da lista.
    1. **Criação de Tuplas a partir de Listas**: Dada a lista `numeros = [1, 2, 3, 4]`, crie uma nova lista que contenha tuplas, onde cada tupla é composta por um número da lista original e seu quadrado.

</details>


# condicionais-if-elif-else.md

Índice Estruturas Condicionais

1. [estutura sequencial](#estrutura-sequencial)
1. [if](#if)
1. [else](#else)
1. [elif](#elif)
1. [if aninhado](#if-aninhado)
1. [comparando if simples e if aninhado](#comparando-if-simples-e-if-aninhado)

# estruturas condicionais em python

## estrutura sequencial

A estrutura sequencial de um algoritmo corresponde ao fato de que um conjunto de ações será executado em uma sequência linear de cima para baixo e da esquerda para a direita.

Veja um exemplo :

```python
# como calcular o valor de x de uma função quadrática usando a fórmula de
# Bhaskara
# considere a equação quadrática : x^2 + 2x - 3 = 0, encontre os dois valores
# possíveis para o X
a = 1
b = 2
c = -3

delta = b ** 2 - 4 * a * c

x1 = (-b + (delta ** (1/2))) / (2 * a)
x2 = (-b - (delta ** (1/2))) / (2 * a)

print('Os valores de X são',x1,'e',x2,'.')
```

Nesse exemplo, pode-se ver que o algoritmo inicia na primeira linha, executa sucessivamente cada uma e termina quando chega na última linha. Nenhuma linha foi ignorada.

Há algumas estruturas das linguagens de programação que permitem alterar esse fluxo.

Provavelmente a estrutura condicional mais conhecida seja a `if-else`.

## if

Em Python, o `if` é usado para fazer uma decisão baseada em uma condição. A palavra `if` significa **se** em inglês. Quando usamos `if` em Python, estamos dizendo ao computador para fazer algo **se** uma determinada condição for verdadeira.

Veja sua estrutura básica :

```python
if <condição>:
    # código a ser executado se a condição for verdadeira
```

- **condição**: uma expressão que o Python avalia como verdadeira (True) ou falsa (False);
- **código a ser executado**: um bloco de código que será executado apenas se a condição for verdadeira;

Agora veja alguns exemplos simples :

```python
idade = 18

if idade >= 18:
    print('Você já pode dirigir.')
```

Neste exemplo, a condição `idade >= 18` é verdadeira, pois a variável `idade` é igual a 18. Portanto, o Python executa o código dentro do bloco `if` e imprime "Você já pode dirigir."

```python
idade = 15

if idade >= 18:
    print('Você já pode dirigir.')
```

Neste outro exemplo, a condição `idade >= 18` é falsa, pois a variável `idade` é igual a 15. Portanto, o Python não irá executar o código dentro do bloco `if`.

## else

O `else` é usado em conjunto com o `if` para definir o que deve ser feito quando a condição do `if` não é verdadeira. A palavra `else` significa **senão** em inglês. Portanto, estamos dizendo ao computador para fazer algo se a condição do `if` for falsa. Seu uso é opcional.

Veja sua estrutura básica :

```python
if condição:
    # código a ser executado se a condição for verdadeira
else:
    # código a ser executado se a condição for falsa
```

- **código a ser executado se a condição for falsa**: um bloco de código que será executado apenas se a condição do `if` for falsa;

Veja agora alguns exemplos :

```python
idade = 15

if idade >= 18:
    print("Você já pode dirigir.")
else:
    print("Você está proibido de dirigir.")
```

Neste exemplo, a condição `idade >= 18` é falsa, pois a variável `idade` é igual a 15. Portanto, o Python não executa o código dentro do bloco `if`, mas sim o código dentro do bloco `else`, imprimindo "Você está proibido de dirigir."

## elif

Em Python, o `elif` é uma combinação de `else` e `if`, que significa `senão se` em inglês. Ele permite verificar múltiplas condições em uma estrutura condicional, adicionando alternativas ao `if` inicial. Se a condição do `if` for falsa, o Python verifica a condição do `elif`. Você pode usar quantos `elif` precisar para cobrir todas as possibilidades. Assim como o `else`, o uso do `elif` também é opcional.

Veja sua estrutura básica :

```python
if condição1:
    # código a ser executado se condição1 for verdadeira
elif condição2:
    # código a ser executado se condição1 for falsa e condição2 for verdadeira
elif condição3:
    # código a ser executado se condição1 e condição2 forem falsas e condição3 for verdadeira
else:
    # código a ser executado se todas as condições anteriores forem falsas
```

- **condição1, condição2, condição3, ...**: expressões que o Python avalia como verdadeiras (True) ou falsas (False);
- **código a ser executado**: blocos de código que serão executados se a condição correspondente for verdadeira;

Veja um exemplo simples :

```python
nota = 75

if nota >= 90:
    print("Você tirou um A.")
elif nota >= 80:
    print("Você tirou um B.")
elif nota >= 70:
    print("Você tirou um C.")
else:
    print("Você está de recuperação.")
```

Neste exemplo, o Python verifica a condição `nota >= 90`. Como ela é falsa, ele passa para a próxima condição `nota >= 80`, que também é falsa. Em seguida, ele verifica `nota >= 70`, que é verdadeira. Portanto, ele executa o código dentro desse bloco "elif" e imprime "Você tirou um C.".

É possível usar quantos "elif" precisar para cobrir todas as possíveis condições. Veja um exemplo mais detalhado:

```python
dia_da_semana = "quarta-feira"

if dia_da_semana == "segunda-feira":
    print("Hoje é segunda-feira.")
elif dia_da_semana == "terça-feira":
    print("Hoje é terça-feira.")
elif dia_da_semana == "quarta-feira":
    print("Hoje é quarta-feira.")
elif dia_da_semana == "quinta-feira":
    print("Hoje é quinta-feira.")
elif dia_da_semana == "sexta-feira":
    print("Hoje é sexta-feira.")
else:
    print("Hoje é fim de semana.")
```

Neste exemplo, o Python verifica cada condição `elif` na ordem em que aparecem. Quando ele encontra a condição verdadeira (`dia_da_semana == "quarta-feira"`), ele executa o bloco de código correspondente e ignora os demais.

<details>
    <summary>Lista de Exercícios</summary>

1. Exercícios Simples
    1. Verifique se um número é positivo. Caso seja, exiba "Positivo".
    1. Verifique se um número é negativo. Caso seja, exiba "Negativo".
    1. Verifique se um número é igual a zero. Caso seja, exiba "Zero".
    1. Verifique se um número é maior que 10. Caso seja, exiba "Maior que 10".
    1. Verifique se um número é menor que 5. Caso seja, exiba "Menor que 5".
    1. Verifique se um número é par. Caso seja, exiba "Par".
    1. Verifique se um número é ímpar. Caso seja, exiba "Ímpar".
    1. Verifique se uma pessoa é maior de idade (idade >= 18). Caso seja, exiba "Maior de idade".
    1. Verifique se uma pessoa é menor de idade (idade < 18). Caso seja, exiba "Menor de idade".
    1. Verifique se um número é positivo, negativo ou zero. Exiba a mensagem correspondente.
1. Exercícios Intermediários
    1. Verifique se um número é maior que outro. Caso seja, exiba "Maior".
    1. Verifique se um número é menor que outro. Caso seja, exiba "Menor".
    1. Verifique se dois números são iguais. Caso sejam, exiba "Iguais".
    1. Verifique se um número é maior ou igual a outro. Caso seja, exiba "Maior ou igual".
    1. Verifique se um número é menor ou igual a outro. Caso seja, exiba "Menor ou igual".
    1. Verifique se um número está entre 1 e 10. Exiba "Entre 1 e 10" ou "Fora do intervalo".
    1. Verifique se uma pessoa pode votar (idade >= 16). Exiba "Pode votar" ou "Não pode votar".
    1. Verifique se um número é divisível por 3. Exiba "Divisível por 3" ou "Não é divisível por 3".
    1. Verifique se um ano é bissexto (divisível por 4, mas não por 100, exceto se for divisível por 400). Exiba "Bissexto" ou "Não bissexto".
        ```python
        ano = 2095

        if ano % 400 == 0:
            eh_div_400 = True
        else:
            eh_div_400 = False

        if ano % 100 == 0:
            eh_div_100 = True
        else:
            eh_div_100 = False

        if ano % 4 == 0:
            eh_div_4 = True
        else:
            eh_div_4 = False

        print('o ano', ano)
        if eh_div_400 or (not eh_div_100 and eh_div_4):
            print('é bissexto')
        else:
            print('não é bissexto')
        ```
    1. Verifique se um número é positivo, negativo ou zero e exiba a mensagem correspondente.
1. Exercícios Avançados
    1. Verifique se a média das notas de um aluno é maior ou igual a 7. Caso seja, exiba "Aprovado". Caso contrário, exiba "Reprovado".
    1. Verifique se a temperatura está abaixo de 0. Caso esteja, exiba "Congelante". Se estiver entre 0 e 20, exiba "Frio". Se estiver acima de 20, exiba "Quente".
    1. Verifique se um número é par ou ímpar, e se é maior ou menor que 10. Exiba as mensagens correspondentes.
    1. Verifique se um aluno passou de ano. As notas finais de três matérias devem ser todas maiores ou iguais a 6. Caso seja, exiba "Passou". Caso contrário, exiba "Não passou".
    1. Verifique se um número está entre 1 e 100. Se estiver entre 1 e 50, exiba "Entre 1 e 50". Se estiver entre 51 e 100, exiba "Entre 51 e 100". Caso contrário, exiba "Fora do intervalo".
    1. Verifique se uma pessoa é maior de idade (idade >= 18) e se é aposentada (idade >= 65). Exiba "Maior de idade" ou "Aposentado" ou "Menor de idade".
        ```python
        idade = 78

        if idade >= 65:
            print('é aposentado')
        elif idade >= 18:
            print('é maior de idade')
        else:
            print('menor de idade')

        if idade >= 18 and idade < 65:
            print('é maior de idade')
        elif idade >= 65:
            print('é aposentado')
        else:
            print('menor de idade')
        ```
    1. Verifique se um número é múltiplo de 5 ou de 10. Exiba "Múltiplo de 5", "Múltiplo de 10" ou "Não é múltiplo de 5 nem de 10".
    1. Verifique se a nota final de um aluno é maior ou igual a 7. Se for, exiba "Aprovado". Se for menor que 5, exiba "Reprovado". Se estiver entre 5 e 7, exiba "Recuperação".
    1. Verifique se a temperatura está abaixo de 0. Caso esteja, exiba "Congelante". Se estiver entre 0 e 15, exiba "Frio". Se estiver entre 16 e 30, exiba "Agradável". Se estiver acima de 30, exiba "Quente".
    1. Verifique se uma pessoa pode votar (idade >= 16) e se é obrigada a votar (idade >= 18 e < 70). Exiba "Não pode votar", "Pode votar" ou "Obrigada a votar".
1. Exercícios Complexos
    1. Verifique se um triângulo é equilátero, isósceles ou escaleno com base nos comprimentos de seus lados.
    1. Verifique se uma pessoa pode se aposentar. Ela deve ter pelo menos 65 anos ou ter trabalhado por pelo menos 30 anos. Exiba "Pode se aposentar" ou "Não pode se aposentar".
        ```python
        idade = 45
        tempo_trab = 31

        if idade >= 65 or tempo_trab > 30:
            print('pode ser aposentar')
        else:
            print('ainda não pode se aposentar')
        ```
    1. Verifique se uma nota está entre 0 e 10. Se estiver fora, exiba "Nota inválida". Caso contrário, verifique se é maior ou igual a 7 (Aprovado), entre 5 e 6.9 (Recuperação) ou menor que 5 (Reprovado).
    1. Verifique se um ponto (x, y) está dentro, fora ou sobre a borda de um círculo de raio 5 centrado na origem.
    1. Verifique se um número é positivo, negativo ou zero. Além disso, verifique se é par ou ímpar e exiba as mensagens correspondentes.
    1. Verifique se uma data (dia, mês, ano) é válida. Considere anos bissextos e meses com diferentes números de dias. Exiba "Data válida" ou "Data inválida".
    1. Verifique se um ano é bissexto. Se for, exiba "Bissexto". Caso contrário, verifique se é par ou ímpar e exiba a mensagem correspondente.
    1. Verifique se três valores podem formar um triângulo. Caso possam, verifique se é equilátero, isósceles ou escaleno.
    1. Verifique se um número é par ou ímpar. Além disso, verifique se está entre 1 e 100 e exiba as mensagens correspondentes.
1. Exercícios Muito Complexos
    1. Verifique se uma data (dia, mês, ano) é válida. Caso seja, verifique se é uma data futura, passada ou presente em relação à data atual.
        ```python

        hoje_dia = 2
        hoje_mes = 8
        hoje_ano = 2024

        teste_dia = 2
        teste_mes = 8
        teste_ano = 2024

        #1   3   5   7   8  10  12
        #jan_mar_mai_jul_ago_out_dez = 31
        #4   6   9  11
        #abr_jun_set_nov = 30
        #2
        #fev = 28 # ou 29

        if (teste_mes == 1 or teste_mes == 3 or teste_mes == 5 or teste_mes == 7 or teste_mes == 8 or teste_mes == 10 or teste_mes == 12) and teste_dia <= 31:
            dia_mes_valido = True
        elif (teste_mes == 4 or teste_mes == 6 or teste_mes == 9 or teste_mes == 11) and teste_dia <= 30:
            dia_mes_valido = True
        elif teste_mes == 2 and teste_dia < 28:
            dia_mes_valido = True
        else:
            dia_mes_valido = False

        mesmo_ano = False
        if teste_ano < hoje_ano:
            print('data ano passada')
        elif teste_ano > hoje_ano:
            print('data ano futura')
        else:
            print('mesmo ano')
            mesmo_ano = True

        mesmo_mes = False
        if mesmo_ano and teste_mes < hoje_mes:
            print('data mes passada')
        elif mesmo_ano and teste_mes > hoje_mes:
            print('data mes futura')
        elif mesmo_ano and teste_mes == hoje_mes:
            mesmo_mes = True
            print('mesmo mes')

        if mesmo_ano and mesmo_mes and (teste_dia < hoje_dia):
            print('data dia passada')
        elif mesmo_ano and mesmo_mes and (teste_dia > hoje_dia):
            print('data dia futuro')
        elif mesmo_ano and mesmo_mes and (teste_dia == hoje_dia):
            print('mesmo dia, mesmo mes, mesmo ano')
        ```
    1. Verifique se uma pessoa pode dirigir. Ela deve ter pelo menos 18 anos e ter passado no exame de direção. Exiba "Pode dirigir" ou "Não pode dirigir".
    1. Verifique se um aluno está aprovado, em recuperação ou reprovado com base em suas notas em três provas e uma prova final. As regras de aprovação são: média >= 7 (Aprovado), média entre 5 e 6.9 (Recuperação), média < 5 (Reprovado).
    1. Verifique se um ano é bissexto. Caso seja, verifique se a data 29/02/ano é válida. Exiba "Data válida" ou "Data inválida".

</details>

## if aninhado

Um `if` aninhado é uma estrutura condicional que está dentro de outro `if`, `elif` ou `else`. Em outras palavras, é um `if` dentro de um `if`. Isso permite criar decisões mais complexas, verificando condições dentro de outras condições.

Veja um exemplo básico :

```python
if condição1:
    # código a ser executado se condição1 for verdadeira
    if condição2:
        # código a ser executado se condição2 também for verdadeira
    else:
        # código a ser executado se condição2 for falsa
else:
    # código a ser executado se condição1 for falsa
```

### if aninhado em dois níveis

Veja um exemplo onde é verificado a idade e, dentro disso, é verificafo a cidadania para determinar se uma pessoa pode votar :

```python
idade = 20
cidadania = "brasileira"

if idade >= 18:
    if cidadania == "brasileira":
        print("Você pode votar.")
    else:
        print("Você não pode votar porque não é cidadão brasileiro.")
else:
    print("Você não pode votar porque é menor de idade.")
```

Neste exemplo, temos duas condições a serem verificadas:
1. A idade deve ser maior ou igual a 18;
1. A cidadania deve ser "brasileira";

Se a idade é maior ou igual a 18, o Python verifica a cidadania. Se ambas as condições forem verdadeiras, ele imprime "Você pode votar". Se a idade for menor que 18, ele imprime "Você não pode votar porque é menor de idade".

### if aninhado em três níveis

Veja ver um exemplo mais complexo com três níveis de "if" aninhado :

```python
idade = 25
cidadania = "brasileira"
residencia = "São Paulo"

if idade >= 18:
    if cidadania == "brasileira":
        if residencia == "São Paulo":
            print("Você pode votar em São Paulo.")
        else:
            print("Você pode votar, mas não em São Paulo.")
    else:
        print("Você não pode votar porque não é cidadão brasileiro.")
else:
    print("Você não pode votar porque é menor de idade.")
```

Neste exemplo, verificamos três condições:
1. A idade deve ser maior ou igual a 18;
1. A cidadania deve ser "brasileira";
1. A residência deve ser "São Paulo";

Se todas as condições forem verdadeiras, ele imprime "Você pode votar em São Paulo". Se a cidadania for "brasileira" mas a residência não for "São Paulo", ele imprime "Você pode votar, mas não em São Paulo". Se a cidadania não for "brasileira", ele imprime "Você não pode votar porque não é cidadão brasileiro". Se a idade for menor que 18, ele imprime "Você não pode votar porque é menor de idade".

### mais exemplos

1. **verificando múltiplas condições aninhadas em uma compra**

```python
saldo = 1000
preco_item = 500
quantidade_em_estoque = 10

if saldo >= preco_item:
    if quantidade_em_estoque > 0:
        print("Compra realizada com sucesso!")
    else:
        print("Item fora de estoque.")
else:
    print("Saldo insuficiente.")
```

Neste exemplo, a compra só será realizada se houver saldo suficiente e o item estiver em estoque.

2. **verificando aninhamentos para determinar a faixa etária e o período do dia**

```python
idade = 16
periodo_do_dia = "tarde"

if idade < 18:
    if periodo_do_dia == "manhã":
        print("Você é menor de idade e está na escola de manhã.")
    elif periodo_do_dia == "tarde":
        print("Você é menor de idade e está na escola à tarde.")
    else:
        print("Você é menor de idade e está em casa à noite.")
else:
    if periodo_do_dia == "manhã":
        print("Você é adulto e está trabalhando de manhã.")
    elif periodo_do_dia == "tarde":
        print("Você é adulto e está trabalhando à tarde.")
    else:
        print("Você é adulto e está descansando à noite.")
```

Este exemplo determina a mensagem a ser exibida com base na idade e no período do dia.

## comparando if simples e if aninhado

### exemplo 1: verificação de senha e nome de usuário

**com `if` aninhado**

```python
usuario = "admin"
senha = "1234"

if usuario == "admin":
    if senha == "1234":
        print("Acesso permitido.")
    else:
        print("Senha incorreta.")
else:
    print("Usuário não encontrado.")
```

**sem `if` aninhado**

```python
usuario = "admin"
senha = "1234"

if usuario == "admin" and senha == "1234":
    print("Acesso permitido.")
elif usuario == "admin":
    print("Senha incorreta.")
else:
    print("Usuário não encontrado.")
```

### exemplo 2: verificação de temperatura e umidade

**com `if` aninhado**

```python
temperatura = 30
umidade = 70

if temperatura > 25:
    if umidade > 60:
        print("Está quente e úmido.")
    else:
        print("Está quente e seco.")
else:
    if umidade > 60:
        print("Está frio e úmido.")
    else:
        print("Está frio e seco.")
```

**sem `if` aninhado**

```python
temperatura = 30
umidade = 70

if temperatura > 25 and umidade > 60:
    print("Está quente e úmido.")
elif temperatura > 25 and umidade <= 60:
    print("Está quente e seco.")
elif temperatura <= 25 and umidade > 60:
    print("Está frio e úmido.")
else:
    print("Está frio e seco.")
```

### exemplo 3: verificação de estoque e saldo para compra

**com `if` aninhado**

```python
saldo = 200
preco_item = 150
estoque = 5

if estoque > 0:
    if saldo >= preco_item:
        print("Compra realizada com sucesso!")
    else:
        print("Saldo insuficiente.")
else:
    print("Item fora de estoque.")
```

**sem `if` aninhado**

```python
saldo = 200
preco_item = 150
estoque = 5

if estoque > 0 and saldo >= preco_item:
    print("Compra realizada com sucesso!")
elif estoque > 0:
    print("Saldo insuficiente.")
else:
    print("Item fora de estoque.")
```

### resumo das comparações

- **if simples**:
  - Útil para verificar condições diretamente relacionadas.
  - Pode se tornar complicado com múltiplos níveis de verificação.
- **if aninhado**:
  - Clarifica a estrutura das decisões.
  - Facilita a leitura e a manutenção do código.
  - Melhora a organização do código para decisões complexas.

Os exemplos mostraram que o uso de `if` aninhado pode tornar o código mais claro e fácil de entender quando múltiplas condições devem ser verificadas, enquanto o `if` simples pode ser mais direto para condições simples e independentes.

<details>
    <summary>Lista de Exercícios</summary>

Para os exercícios abaixo, use a estrutura de `if` que achar mais conveniente.

1. Exercícios Simples
    1. Verifique se um número é positivo. Caso seja, verifique se é maior que 10.
    1. Verifique se um número é negativo. Caso seja, verifique se é menor que -10.
    1. Verifique se um número é zero. Caso não seja, verifique se é positivo ou negativo.
    1. Verifique se um número é par. Caso seja, verifique se é maior que 20.
    1. Verifique se uma pessoa é maior de idade (idade >= 18). Se for, verifique se tem 65 anos ou mais.
1. Exercícios Intermediários
    1. Verifique se um número é maior que 10. Caso seja, verifique se é menor que 20.
    1. Verifique se um número é positivo. Caso seja, verifique se é ímpar.
    1. Verifique se uma pessoa pode votar (idade >= 16). Se puder, verifique se é obrigatória a votação (idade >= 18 e < 70).
    1. Verifique se uma string não está vazia. Caso não esteja, verifique se o primeiro caracter é uma vogal.
    1. Verifique se um número é divisível por 3. Caso seja, verifique se também é divisível por 5.
1. Exercícios Avançados
    1. Verifique se a média das notas de um aluno é maior ou igual a 7. Caso seja, verifique se a nota em matemática é maior que 5.
    1. Verifique se a temperatura está abaixo de 0. Caso esteja, exiba "Congelante". Se não, verifique se está entre 0 e 20, exiba "Frio".
    1. Verifique se um número é par ou ímpar. Se for par, verifique se é maior que 10. Se for ímpar, verifique se é menor que 5.
    1. Verifique se um número está entre 1 e 100. Se estiver, verifique se é múltiplo de 10.
    1. Verifique se a média das notas de um aluno é maior ou igual a 7. Caso seja, exiba "Aprovado". Caso contrário, verifique se está entre 5 e 6.9 e exiba "Recuperação".
1. Exercícios Complexos
    1. Verifique se três valores podem formar um triângulo. Caso possam, verifique se é equilátero, isósceles ou escaleno.
    1. Verifique se uma pessoa pode se aposentar. Ela deve ter pelo menos 65 anos. Se não tiver, verifique se trabalhou por pelo menos 30 anos.
    1. Verifique se uma data (dia, mês, ano) é válida. Considere anos bissextos. Se o ano for bissexto, verifique se o mês é fevereiro e o dia é 29.
    1. Verifique se um número é positivo, negativo ou zero. Se for positivo, verifique se é maior que 100. Se for negativo, verifique se é menor que -100.
    1. Verifique se um aluno passou de ano. As notas finais de três matérias devem ser todas maiores ou iguais a 6. Caso seja, verifique se a média é maior ou igual a 7.
1. Exercícios Muito Complexos
    1. Verifique se uma pessoa pode dirigir. Ela deve ter pelo menos 18 anos e ter passado no exame de direção. Caso não tenha 18 anos, verifique se está perto de completar 18 (falta menos de um mês).
    1. Verifique se um aluno está aprovado, em recuperação ou reprovado com base em suas notas em três provas e uma prova final. A média das três provas deve ser maior ou igual a 7. Caso contrário, verifique se a média com a prova final é maior ou igual a 5.
    1. Verifique se uma pessoa é elegível para uma promoção. Ela deve ter pelo menos 5 anos de experiência na empresa. Caso não tenha, verifique se tem uma avaliação de desempenho excelente. Se não tiver, verifique se completará 5 anos de experiência em menos de 6 meses.
        ```python
        anos_experiencia = 6
        meses_experiencia = 4
        aval_desempenho = 'regular'


        if anos_experiencia >= 5:
            print('já pode ser promovido')
        else:
            if aval_desempenho == 'excelente':
                print('tem bom comportamento, pode ser promovido')
            else:
                if anos_experiencia >= 4 and anos_experiencia < 5 and meses_experiencia > 6:
                    print('pode ser promovido')
                else:
                    print('vosmecê ainda não pode ser promovido')
        ```

</details>



# copias-rasa-e-profunda.md

Índice

1. [cópia atribuição direta](#cópia-atribuição-direta)
1. [cópia rasa](#cópia-rasa)
1. [exercícios cópia rasa](#exercícios-cópia-rasa)
1. [cópia profunda](#cópia-profunda)
1. [cópia rasa e profunda em outros tipos](#cópia-rasa-e-profunda-em-outros-tipos)
1. [exercícios cópia profunda](#exercícios-cópia-profunda)

# operações de cópia

## cópia atribuição direta

A cópia com atribuição direta no Python é uma técnica simples, mas pode ser confusa se não entendida corretamente. Quando se faz uma atribuição direta, como `lista_b = lista_a`, não está criando uma nova lista independente; ao invés disso, está apenas criando uma nova referência ao mesmo objeto na memória. Isso significa que qualquer alteração feita em uma das listas será refletida na outra, pois ambas apontam para o mesmo local na memória.

### exemplo 1 : atribuição direta com objetos imutáveis

Embora a atribuição direta seja mais problemática com objetos mutáveis, é útil entender como ela funciona com objetos imutáveis para contrastar os comportamentos.

```python
>>> a = 10
>>> b = a
>>>
>>> print("Valor de a:", a)
10
>>> print("Valor de b:", b)
10
>>>
>>> b = 20
>>> print("Após mudar b:")
>>> print("Valor de a:", a)
10
>>> print("Valor de b:", b)
20
>>> |
```

**explicação :** neste exemplo, `a` e `b` inicialmente referenciam o mesmo valor imutável `10`. Porém, quando `b` é atribuído a `20`, ele passa a referenciar um novo objeto imutável `20`, enquanto `a` continua referenciando `10`. Isso ocorre porque, para objetos imutáveis, a atribuição direta não afeta o outro nome após a mudança de valor.

### exemplo 2 : atribuição direta com listas (objetos mutáveis)

Vamos explorar o que acontece quando se usa a atribuição direta com listas, que são objetos mutáveis.

```python
>>> lista_a = [1, 2, 3]
>>> lista_b = lista_a
>>>
>>> lista_b.append(4)
>>>
>>> print("Lista A:", lista_a)
[1, 2, 3, 4]
>>> print("Lista B:", lista_b)
[1, 2, 3, 4]
>>> |
```

**explicação :** aqui, `lista_a` e `lista_b` são referências ao mesmo objeto na memória. Portanto, quando se adiciona `4` a `lista_b`, `lista_a` também é alterada, porque ambas as variáveis apontam para a mesma lista.

### exemplo 3 : atribuição direta e modificação interna de listas

Considere um caso em que a lista contém objetos mutáveis, como sublistas:

```python
>>> lista_a = [[1, 2], [3, 4]]
>>> lista_b = lista_a
>>>
>>> lista_b[0].append(99)
>>>
>>> print("Lista A:", lista_a)
[[1, 2, 99], [3, 4]]
>>> print("Lista B:", lista_b)
[[1, 2, 99], [3, 4]]
>>> |
```

**explicação :** novamente, `lista_a` e `lista_b` referenciam o mesmo objeto. Quando se modifica uma das sublistas em `lista_b`, a alteração também aparece em `lista_a` porque as sublistas também são objetos mutáveis que ambas as variáveis referenciam.

### exemplo 4 : verificando referências com `id()`

Pode-se usar a função `id()` para verificar se duas variáveis realmente referenciam o mesmo objeto na memória.

```python
>>> lista_a = [1, 2, 3]
>>> lista_b = lista
>>>
>>> print(f'{id(lista_a) = }')
id(lista_a) = 124121926781376
>>> print(f'{id(lista_b) = }')
id(lista_b) = 124121926781376
>>> |
```

**explicação :** os IDs de `lista_a` e `lista_b` serão os mesmos, confirmando que ambas as variáveis referenciam o mesmo objeto na memória. Ao executar o código acima em sua máquina, certamente os valores dos IDs serão diferentes.

### quando usar atribuição direta

- **quando se deseja que duas variáveis compartilhem a mesma lista :** isso é útil em alguns casos onde se quer que todas as alterações sejam refletidas em ambas as variáveis;

- **em operações de otimização de memória :** atribuição direta é mais eficiente em termos de memória, pois não cria cópias adicionais dos dados;

### limitações da atribuição direta

- **risco de modificações indesejadas :** se não deseja que alterações em uma variável afetem outra, a atribuição direta pode causar problemas difíceis de depurar;

- **não adequado para listas que precisam ser independentes :** se precisa de listas independentes para manipular dados de maneira segura, evite a atribuição direta e opte por técnicas de cópia;

## cópia rasa

A cópia rasa (shallow copy) no Python é um conceito importante quando trabalhamos com listas e outros tipos de dados mutáveis. Embora uma cópia rasa crie uma nova lista, ela não cria cópias independentes dos objetos que estão dentro da lista original; ao invés disso, ela copia as referências para esses objetos. Isso significa que se os elementos dentro da lista forem mutáveis (como outras listas, dicionários ou objetos), modificações nesses elementos afetarão tanto a lista original quanto a cópia.

### como funciona a cópia rasa

Quando se faz uma cópia rasa de uma lista, o Python cria um novo objeto de lista, mas os elementos dentro dessa lista copiada ainda referenciam os mesmos objetos que os elementos da lista original. A cópia rasa é feita em um único nível da estrutura de dados. Se a lista contém objetos mutáveis (como outras listas ou dicionários), as referências para esses objetos são copiadas, mas os próprios objetos não são duplicados.

### exemplo 1 : cópia rasa com objetos imutáveis

Primeiro, veja como a cópia rasa funciona com objetos imutáveis como inteiros e strings:

```python
>>> lista_original = [1, 2, 3, "a", "b", "c"]
>>> lista_copiada = lista_original[:]
>>>
>>> lista_copiada[0] = 100
>>> lista_copiada[3] = "z"
>>>
>>> print("Lista original:", lista_original)
[1, 2, 3, "a", "b", "c"]
>>> print("Lista copiada:", lista_copiada)
[100, 2, 3, "z", "b", "c"]
>>> |
```

**explicação :** neste exemplo, `lista_copiada` é uma cópia rasa de `lista_original`. Como está sendo lidando com objetos imutáveis (inteiros e strings), a modificação em `lista_copiada` não afeta `lista_original`. Isso ocorre porque cada elemento da lista é imutável e, portanto, uma nova cópia do valor é feita na nova lista;

### exemplo 2: cópia rasa com objetos mutáveis (listas)

Agora, veja como a cópia rasa se comporta com objetos mutáveis, como listas aninhadas:

```python
>>> lista_original = [[1, 2, 3], [4, 5, 6]]
>>> lista_copiada = lista_original[:]
>>>
>>> lista_copiada[0].append(99)
>>>
>>> print("Lista original:", lista_original)
[[1, 2, 3, 99], [4, 5, 6]]
>>> print("Lista copiada:", lista_copiada)
[[1, 2, 3, 99], [4, 5, 6]]
>>> |
```

**explicação :** aqui, `lista_original` e `lista_copiada` são listas diferentes. No entanto, os elementos dentro de cada lista (que são eles mesmos listas) ainda referenciam os mesmos objetos na memória. Quando se altera um desses objetos (como adicionar `99` à primeira sublista), essa alteração é refletida em ambas as listas;

### exemplo 3 : cópia rasa com dicionários

O mesmo comportamento ocorre quando se trabalha com dicionários dentro de listas:

```python
>>> lista_original = [{"a": 1, "b": 2}, {"c": 3, "d": 4}]
>>> lista_copiada = lista_original[:]
>>>
>>> lista_copiada[0]["a"] = 100
>>>
>>> print("Lista original:", lista_original)
[{"a": 100, "b": 2}, {"c": 3, "d": 4}]
>>>
>>> print("Lista copiada:", lista_copiada)
[{"a": 100, "b": 2}, {"c": 3, "d": 4}]
>>> |
```

**explicação :** como os dicionários são mutáveis, a modificação feita em um dicionário dentro de `lista_copiada` é refletida em `lista_original`, pois ambos compartilham a referência ao mesmo dicionário;

### exemplo 4 : criando cópias rasas de diferentes formas

Além de usar o fatiamento (`[:]`) para criar uma cópia rasa, também pode usar outras técnicas como a função `list()` ou o método `copy()`:

#### usando `list()`
```python
>>> lista_original = [1, 2, 3]
>>> lista_copiada = list(lista_original)
>>>
>>> lista_copiada[0] = 100
>>>
>>> print("Lista original:", lista_original)
[1, 2, 3]
>>> print("Lista copiada:", lista_copiada)
[100, 2, 3]
>>> |
```

#### usando `copy()`
```python
>>> lista_original = [1, 2, 3]
>>> lista_copiada = lista_original.copy()
>>>
>>> lista_copiada[0] = 100
>>>
>>> print("Lista original:", lista_original)
[1, 2, 3]
>>> print("Lista copiada:", lista_copiada)
[100, 2, 3]
>>> |
```

**explicação :** ambos `list()` e `copy()` criam uma cópia rasa da lista. As mudanças em `lista_copiada` não afetam `lista_original` porque os objetos copiados são valores imutáveis. No entanto, se os objetos fossem mutáveis, as alterações internas ainda seriam compartilhadas;

### quando a cópia rasa é adequada?

- **listas de objetos imutáveis :** se a lista contém apenas objetos imutáveis (como números ou strings), a cópia rasa geralmente é segura e eficiente;

- **listas de objetos mutáveis com cuidado :** se precisar de uma nova lista, mas não se importa em compartilhar referências para objetos mutáveis dentro dessa lista, a cópia rasa é adequada;

### limitações da cópia rasa

A principal limitação da cópia rasa é que, para listas que contêm objetos mutáveis, as modificações nesses objetos refletirão tanto na lista original quanto na cópia. Se precisar de cópias independentes dos objetos internos, será necessário usar uma cópia profunda.

## exercícios cópia rasa

<details>
<summary>Lista de Exercícios</summary>

1. **Cópia de Lista Simples**: Dada a lista `original = [1, 2, 3, 4]`, faça uma cópia rasa dela e adicione o número 5 na cópia. Imprima ambas.
1. **Cópia de Tupla**: Dada a tupla `original = (1, 2, 3, 4)`, faça uma cópia rasa dela e modifique o valor do primeiro item da tupla original para 0. Imprima ambas.
1. **Cópia de Set**: Dado o conjunto `original = {1, 2, 3, 4}`, faça uma cópia rasa dele e adicione o número 5 à cópia. Imprima ambos.
1. **Cópia de Dicionário**: Dado o dicionário `original = {'a': 1, 'b': 2}`, faça uma cópia rasa dele e adicione uma nova chave `'c'` com valor 3 à cópia. Imprima ambos.
1. **Cópia de String**: Dada a string `original = "Python"`, faça uma cópia rasa dela e modifique o valor da cópia. Imprima ambas.
1. **Cópia de Lista com Sublista**: Dada a lista `original = [[1, 2], [3, 4]]`, faça uma cópia rasa dela e modifique o primeiro elemento da sublista na cópia. Imprima ambas.
1. **Cópia de Tupla com Lista**: Dada a tupla `original = ([1, 2], [3, 4])`, faça uma cópia rasa dela e modifique um valor na lista da cópia. Imprima ambas.
1. **Cópia de Set com Strings**: Dado o conjunto `original = {"apple", "banana"}`, faça uma cópia rasa dele e adicione um novo item à cópia. Imprima ambos.
1. **Cópia de Dicionário com Listas**: Dado o dicionário `original = {'numbers': [1, 2], 'letters': ['a', 'b']}`, faça uma cópia rasa dele e adicione um item à lista de números na cópia. Imprima ambos.
1. **Cópia de Lista com Strings**: Dada a lista `original = ["Python", "Java"]`, faça uma cópia rasa dela e substitua um item na cópia. Imprima ambas.
1. **Cópia de Tupla com Tuplas**: Dada a tupla `original = ((1, 2), (3, 4))`, faça uma cópia rasa dela e substitua um item na tupla da cópia. Imprima ambas.
1. **Cópia de Set com Números**: Dado o conjunto `original = {10, 20, 30}`, faça uma cópia rasa dele e remova um item da cópia. Imprima ambos.
1. **Cópia de Dicionário com Tuplas**: Dado o dicionário `original = {'coordinates': (10, 20), 'color': 'red'}`, faça uma cópia rasa dele e modifique um valor na cópia. Imprima ambos.
1. **Cópia de Lista com Dicionários**: Dada a lista `original = [{'a': 1}, {'b': 2}]`, faça uma cópia rasa dela e adicione uma nova chave a um dicionário na cópia. Imprima ambas.
1. **Cópia de Tupla com Set**: Dada a tupla `original = ({1, 2}, {3, 4})`, faça uma cópia rasa dela e adicione um item a um set na cópia. Imprima ambos.
1. **Cópia de Lista com Strings e Números**: Dada a lista `original = ["apple", 1, "banana", 2]`, faça uma cópia rasa dela e substitua um item na cópia. Imprima ambas.
1. **Cópia de Set com Dicionários**: Dado o conjunto `original = {{'a': 1}, {'b': 2}}`, faça uma cópia rasa dele e modifique um valor em um dicionário na cópia. Imprima ambos.
1. **Cópia de Dicionário com Listas Aninhadas**: Dado o dicionário `original = {'list1': [1, 2], 'list2': [3, 4]}`, faça uma cópia rasa dele e adicione um item a uma lista na cópia. Imprima ambos.
1. **Cópia de Lista com Tuplas Aninhadas**: Dada a lista `original = [(1, 2), (3, 4)]`, faça uma cópia rasa dela e substitua uma tupla na cópia. Imprima ambas.
1. **Cópia de Tupla com Listas e Dicionários**: Dada a tupla `original = ([1, 2], {'a': 3})`, faça uma cópia rasa dela e adicione um item à lista na cópia. Imprima ambas.
1. **Cópia de Lista com Booleans**: Dada a lista `original = [True, False]`, faça uma cópia rasa dela e altere um valor na cópia. Imprima ambas.
1. **Cópia de Tupla com Sets e Strings**: Dada a tupla `original = ({'apple'}, "banana")`, faça uma cópia rasa dela e adicione um item ao set na cópia. Imprima ambas.
1. **Cópia de Set com Strings e Números**: Dado o conjunto `original = {1, "apple", 2, "banana"}`, faça uma cópia rasa dele e remova um item da cópia. Imprima ambos.
1. **Cópia de Dicionário com Strings e Números**: Dado o dicionário `original = {'string': 'hello', 'number': 42}`, faça uma cópia rasa dele e modifique um valor na cópia. Imprima ambos.
1. **Cópia de Lista com Strings e Tuplas**: Dada a lista `original = ["hello", (1, 2), "world"]`, faça uma cópia rasa dela e substitua um item na cópia. Imprima ambas.
1. **Cópia de Tupla com Lista e Set**: Dada a tupla `original = ([1, 2], {3, 4})`, faça uma cópia rasa dela e modifique a lista na cópia. Imprima ambas.
1. **Cópia de Lista com Tuplas e Strings**: Dada a lista `original = [(1, 2), "foo", (3, 4)]`, faça uma cópia rasa dela e substitua um item na cópia. Imprima ambas.
1. **Cópia de Set com Inteiros e Strings**: Dado o conjunto `original = {1, 2, "a", "b"}`, faça uma cópia rasa dele e adicione um item à cópia. Imprima ambos.
1. **Cópia de Dicionário com Tuplas Aninhadas**: Dado o dicionário `original = {'pair1': (1, 2), 'pair2': (3, 4)}`, faça uma cópia rasa dele e substitua um valor na tupla da cópia. Imprima ambos.
1. **Cópia de Lista com Números e Strings**: Dada a lista `original = [1, "text", 3.5, "example"]`, faça uma cópia rasa dela e substitua um item na cópia. Imprima ambas.

</details>

## cópia profunda

A cópia profunda (deep copy) no Python é uma técnica usada para criar uma nova lista ou estrutura de dados que é completamente independente da original. Ao contrário da cópia rasa, que copia apenas as referências aos objetos contidos na lista original, a cópia profunda cria cópias reais e independentes desses objetos, resultando em uma duplicata completa e separada da estrutura de dados original.

### como funciona a cópia profunda

Quando se realiza uma cópia profunda de uma lista, o Python cria um novo objeto de lista, e então copia recursivamente todos os elementos dessa lista original. Se algum desses elementos for uma estrutura de dados mutável, como outra lista ou dicionário, ele também será copiado em profundidade, garantindo que a nova lista seja totalmente independente da original.

Para realizar uma cópia profunda em Python, usa-se o módulo `copy` e sua função `deepcopy`.

### módulo `copy`

Antes de utilizá-la, é necessário importar a função `deepcopy` do módulo `copy`:

```python
import copy
```

- **Exemplo 1: Cópia Profunda de uma Lista Simples**

Veja um exemplo básico de cópia profunda:

```python
import copy

lista_original = [1, 2, 3, 4]
lista_copiada = copy.deepcopy(lista_original)

lista_copiada.append(5)

print("Lista original:", lista_original)  # saída : [1, 2, 3, 4]
print("Lista copiada:", lista_copiada)    # saída : [1, 2, 3, 4, 5]
```

Aqui, `lista_copiada` é uma cópia profunda de `lista_original`. Como se está lidando com objetos imutáveis (inteiros), o comportamento parece semelhante à cópia rasa. A diferença se torna mais evidente quando se lida com objetos mutáveis.

- **Exemplo 2: Cópia Profunda com Listas Aninhadas**

Veja o comportamento da cópia profunda com listas aninhadas:

```python
import copy

lista_original = [[1, 2, 3], [4, 5, 6]]
lista_copiada = copy.deepcopy(lista_original)

lista_copiada[0].append(99)

print("Lista original:", lista_original)  # saída : [[1, 2, 3], [4, 5, 6]]
print("Lista copiada:", lista_copiada)    # saída : [[1, 2, 3, 99], [4, 5, 6]]
```

Neste exemplo, `lista_copiada` é uma cópia profunda de `lista_original`. Isso significa que `lista_copiada` é completamente independente, incluindo as sublistas. Quando se modifica uma sublista em `lista_copiada`, a sublista correspondente em `lista_original` permanece inalterada.

- **Exemplo 3: Cópia Profunda com Dicionários em Listas**

A cópia profunda também é importante quando se está lidando com listas que contêm dicionários:

```python
import copy

lista_original = [{"a": 1, "b": 2}, {"c": 3, "d": 4}]
lista_copiada = copy.deepcopy(lista_original)

lista_copiada[0]["a"] = 100

print("Lista original:", lista_original)  # saída : [{"a": 1, "b": 2}, {"c": 3, "d": 4}]
print("Lista copiada:", lista_copiada)    # saída : [{"a": 100, "b": 2}, {"c": 3, "d": 4}]
```

No caso de `lista_copiada`, qualquer alteração feita nos dicionários contidos dentro da lista não afetará `lista_original`, pois cada dicionário foi duplicado completamente.

- **Exemplo 4: Cópia Profunda com Estruturas de Dados Complexas**

Considere uma estrutura de dados mais complexa, como uma lista contendo outras listas, dicionários, e até mesmo tuplas:

```python
import copy

lista_original = [[1, 2], {"chave": [3, 4]}, (5, 6)]
lista_copiada = copy.deepcopy(lista_original)

lista_copiada[0].append(99)
lista_copiada[1]["chave"].append(100)

print("Lista original:", lista_original)  # saída : [[1, 2], {"chave": [3, 4]}, (5, 6)]
print("Lista copiada:", lista_copiada)    # saída : [[1, 2, 99], {"chave": [3, 4, 100]}, (5, 6)]
```

Neste exemplo, `lista_copiada` é uma cópia profunda de `lista_original`. Modificações feitas na cópia (como adicionar `99` à primeira sublista ou `100` ao valor da chave no dicionário) não afetam a lista original.

- **Exemplo 5: Cópia Profunda e Objetos Personalizados**

A cópia profunda também funciona com objetos de classes personalizadas, desde que esses objetos possam ser copiados.

```python
import copy

class Ponto:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __repr__(self):
        return f"Ponto({self.x}, {self.y})"

ponto_original = Ponto(1, 2)
lista_original = [ponto_original]

lista_copiada = copy.deepcopy(lista_original)

lista_copiada[0].x = 10
lista_copiada[0].y = 20

print("Lista original:", lista_original)  # saída : [Ponto(1, 2)]
print("Lista copiada:", lista_copiada)    # saída : [Ponto(10, 20)]
```

Aqui, `lista_copiada` é uma cópia profunda de `lista_original`, incluindo o objeto `Ponto`. Alterar o objeto na cópia não afeta o objeto na lista original.

### quando usar

- **Quando se precisa de uma duplicação completa e independente:** se está lidando com uma estrutura de dados complexa e quer garantir que a cópia seja totalmente separada do original, a cópia profunda é o caminho;

- **Quando há objetos mutáveis aninhados:** se a lista ou estrutura de dados contém listas, dicionários ou outros objetos mutáveis, a cópia profunda garantirá que todas as partes da estrutura sejam independentes;

### limitações

- **Desempenho:** a cópia profunda pode ser significativamente mais lenta e consumir mais memória do que a cópia rasa, especialmente para estruturas de dados grandes e complexas;

- **Complexidade:** em casos onde não é necessário duplicar completamente todos os objetos internos, a cópia profunda pode ser excessiva;

## cópia rasa e profunda em outros tipos

O conceito de cópia rasa e cópia profunda se aplica principalmente a estruturas de dados mutáveis, como listas e dicionários.

### tuplas

Tuplas são estruturas de dados imutáveis no Python. Por causa dessa imutabilidade, o conceito de cópia rasa e cópia profunda não se aplica da mesma forma que para listas.

- **cópia rasa :** para tuplas, uma cópia rasa é feita por atribuição direta, e não há necessidade de técnicas especiais para cópias rasas ou profundas, pois está apenas criando uma nova referência ao mesmo objeto imutável;
    ```python
    >>> tupla_original = (1, 2, 3)
    >>> tupla_copiada = tupla_original
    >>>
    >>> print("Tupla original:", tupla_original)
    (1, 2, 3)
    >>> print("Tupla copiada:", tupla_copiada)
    (1, 2, 3)
    >>> |
    ```
    **explicação :** a tupla `tupla_copiada` é uma nova referência à mesma tupla imutável. Não há necessidade de cópia rasa ou profunda aqui.

- **cópia profunda :** como tuplas são imutáveis e não podem ser alteradas após a criação, uma cópia profunda não é necessária ou aplicável. se a tupla contém objetos mutáveis (como listas), você ainda precisa considerar o impacto desses objetos na cópia, mas a tupla em si não precisa de uma cópia profunda.

### dicionários

Dicionários são mutáveis e, portanto, podem se beneficiar das técnicas de cópia rasa e profunda.

- **cópia rasa :** para fazer uma cópia rasa de um dicionário, pode-se usar o método `copy()` ou a função `dict()`.
    ```python
    >>> dicionario_original = {"a": 1, "b": [2, 3]}
    >>> dicionario_copiado = dicionario_original.copy()
    >>>
    >>> dicionario_copiado["b"].append(4)
    >>>
    >>> print("Dicionário original:", dicionario_original)
    {"a": 1, "b": [2, 3, 4]}
    >>> print("Dicionário copiado:", dicionario_copiado)
    {"a": 1, "b": [2, 3, 4]}
    >>> |
    ```
    **explicação :** a cópia rasa do dicionário cria um novo dicionário onde as referências para os objetos dentro do dicionário original são copiadas. Mudanças nos objetos mutáveis (como a lista associada à chave `"b"`) afetam ambos os dicionários.

- **cópia profunda :** para criar uma cópia profunda de um dicionário, pode-se usar `copy.deepcopy()`.

    ```python
    import copy

    dicionario_original = {"a": 1, "b": [2, 3]}
    dicionario_copiado = copy.deepcopy(dicionario_original)

    dicionario_copiado["b"].append(4)

    print("Dicionário original:", dicionario_original)  # saída : {"a": 1, "b": [2, 3]}
    print("Dicionário copiado:", dicionario_copiado)    # saída : {"a": 1, "b": [2, 3, 4]}
    ```

    **explicação :** a cópia profunda cria um novo dicionário com cópias independentes dos objetos internos. Modificar a lista no dicionário copiado não afeta a lista no dicionário original;

### sets

Sets são mutáveis, e o conceito de cópia rasa e profunda também se aplica a eles.

- **cópia rasa :** para fazer uma cópia rasa de um set, pode-se usar o método `copy()` ou a função `set()`.
    ```python
    >>> set_original = {1, 2, 3}
    >>> set_copiado = set_original.copy()
    >>>
    >>> set_copiado.add(4)
    >>>
    >>> print("Set original:", set_original)
    {1, 2, 3}
    >>> print("Set copiado:", set_copiado)
    {1, 2, 3}
    >>> |
    ```
    **explicação :** a cópia rasa do set cria um novo set, mas não copia objetos mutáveis que possam estar dentro do set. neste caso, os sets contêm apenas inteiros, que são imutáveis.

- **cópia profunda :** para sets, a cópia profunda não é frequentemente necessária, pois sets não podem conter objetos complexos que precisem de uma cópia profunda; se um set contém objetos mutáveis, pode-se usar `copy.deepcopy()` para garantir uma cópia completamente independente.

    ```python
    import copy

    set_original = {frozenset([1, 2]), frozenset([3, 4])}
    set_copiado = copy.deepcopy(set_original)

    set_copiado.add(frozenset([5, 6]))

    print("Set original:", set_original)  # Saída: {frozenset({1, 2}), frozenset({3, 4})}
    print("Set copiado:", set_copiado)    # Saída: {frozenset({1, 2}), frozenset({3, 4}), frozenset({5, 6})}
    ```

    **explicação :** a cópia profunda garante que o set copiado não compartilhe referências com o set original, mas, na prática, sets geralmente não precisam de cópia profunda porque eles não contêm tipos complexos mutáveis;

## exercícios cópia profunda

<details>
<summary>Lista de Exercícios</summary>

1. Exercícios com `list`
    1. **Lista Simples**: Crie uma lista contendo três listas internas. Faça uma cópia profunda da lista original e modifique um elemento da cópia. Verifique se a lista original permanece inalterada.
    1. **Listas Aninhadas**: Crie uma lista de três níveis de profundidade (lista dentro de lista dentro de lista). Faça uma cópia profunda e modifique o nível mais profundo. Verifique se a lista original foi alterada.
    1. **Lista com Objetos Mutáveis**: Crie uma lista contendo listas e dicionários. Faça uma cópia profunda e adicione um novo elemento em um dos dicionários internos. Verifique se a alteração afeta a lista original.
    1. **Listas Referenciadas**: Crie duas listas onde uma referência a outra. Faça uma cópia profunda da lista principal e adicione um elemento à cópia. Verifique se a referência entre as listas na cópia foi preservada ou alterada.
    1. **Lista de Dicionários**: Crie uma lista com dicionários como elementos. Faça uma cópia profunda da lista e modifique um valor em um dos dicionários. Verifique se a lista original foi afetada.
1. Exercícios com `tuple`
    1. **Tupla com Objetos Mutáveis**: Crie uma tupla contendo listas e dicionários. Faça uma cópia profunda e modifique uma das listas dentro da cópia. Verifique se a tupla original permanece inalterada.
    1. **Tuplas Aninhadas**: Crie uma tupla que contém outras tuplas e listas. Faça uma cópia profunda e modifique um elemento em uma das listas internas. Verifique se a tupla original foi afetada.
    1. **Tupla e Ciclos de Referência**: Crie uma tupla que referencie uma lista que, por sua vez, referencia a própria tupla. Faça uma cópia profunda e modifique a lista dentro da cópia. Verifique se o ciclo de referência foi tratado corretamente.
    1. **Tupla com Conjuntos**: Crie uma tupla contendo um conjunto (set) e uma lista. Faça uma cópia profunda e modifique o conjunto na cópia. Verifique se a tupla original foi afetada.
    1. **Tupla Imutável**: Crie uma tupla contendo apenas objetos imutáveis (números e strings). Faça uma cópia profunda e verifique se a cópia é igual ao original. Explique por que a cópia profunda não criou uma nova instância.
1. Exercícios com `dict`
    1. **Dicionário Simples**: Crie um dicionário com listas como valores. Faça uma cópia profunda do dicionário e modifique um valor da lista em um dos pares chave-valor. Verifique se o dicionário original foi alterado.
    1. **Dicionários Aninhados**: Crie um dicionário contendo outros dicionários como valores. Faça uma cópia profunda e modifique um valor em um dicionário interno. Verifique se o dicionário original permanece inalterado.
    1. **Dicionário com Listas e Conjuntos**: Crie um dicionário onde os valores são listas e conjuntos. Faça uma cópia profunda e modifique um dos conjuntos. Verifique se o dicionário original foi alterado.
    1. **Cópia de Dicionário com Tuplas**: Crie um dicionário onde as chaves são tuplas e os valores são listas. Faça uma cópia profunda e modifique um valor na lista. Verifique se a cópia afeta o dicionário original.
    1. **Dicionário Referenciando Ele Mesmo**: Crie um dicionário que contenha uma chave cujo valor seja o próprio dicionário (ciclo de referência). Faça uma cópia profunda e verifique como o ciclo foi tratado.
1. Exercícios com `set`
    1. **Conjunto Simples**: Crie um conjunto contendo listas como elementos (use um `frozenset` para tornar o conjunto imutável). Faça uma cópia profunda e modifique uma das listas. Verifique se o conjunto original foi alterado.
    1. **Conjunto de Dicionários**: Crie um conjunto onde os elementos são dicionários. Faça uma cópia profunda e modifique um valor em um dos dicionários internos. Verifique se o conjunto original foi afetado.
    1. **Conjunto de Conjuntos**: Crie um conjunto onde os elementos são outros conjuntos (use `frozenset`). Faça uma cópia profunda e adicione um novo elemento a um dos conjuntos internos. Verifique se o conjunto original permanece inalterado.
    1. **Conjunto e Tuplas**: Crie um conjunto onde os elementos são tuplas que contêm listas. Faça uma cópia profunda e modifique um elemento de uma lista dentro da cópia. Verifique se o conjunto original foi alterado.
    1. **Conjuntos Aninhados**: Crie um conjunto contendo outros conjuntos (use `frozenset` para tornar isso possível). Faça uma cópia profunda e adicione um novo elemento ao conjunto interno. Verifique se o conjunto original foi afetado.

</details>


# curso.md

# Trilha 4 - Desenvolvimento Python

Trilha de Desenvolvimento Python - 252h
- Lógica de Programação - 60h
- Formação Python - 156h
- Desenvolvimento de Websites com Django - 36h

O profissional formado nesta trilha está apto a concorrer em seleções de perfis iniciais de atuação na área de TI. O participante tem conhecimentos em Banco de dados, SQL, HTML 5, CSS 3, na linguagem de programação Python e no framework Django, sendo capaz de analisar, planejar, desenvolver e testar aplicações desktop com interface gráfica e aplicações e web desenvolvidas em Python e também aplicações web desenvolvidas usando o framework Django. Este profissional pode atuar como Desenvolvedor Back-end, Desenvolvedor Front-end, Programador Full Stack, Programador Python, Testador de Software, em nível inicial.

- Turma : 1800014164
- Turno : noite
- Início : 22/07/2024
- Término : 23/10/2024 (previsão)
- Sala : 405
- Horário : 18h às 22h

## Acesso Computadores
Para acessar os computadores nos laboratórios da escola, é necessário entrar com o `usuário` e `senha`.

- Login : número da matrícula
- Senha : `tech@2024`

Ao realizar o primeiro acesso, será pedido para alterar a senha de acesso. A nova senha deverá atender os requisitos de complexidade :

- não conter :
    - nome do usuário
    - matrícula
    - data de nascimento
- conter ao menos 3 das regras abaixo :
    - caracteres maiúsculos (A - Z)
    - caracteres minúsculos (a - z)
    - números (0 - 9)
    - caracteres especiais, não alfanuméricos (!,@,#,&,% etc)


# desafios.md

# desafios

Abaixo há uma lista de exercícios que são um pouco mais complexos que os exercícios propostos com o material. Sinta-se livre para realizá-los da melhor forma que achar (sempre usando **APENAS** o material de aula).


## árvore feliz

Faça um programa que peça um número ao usuário e monte um pinheiro como o mostrado abaixo. Se altura for menor que 3, o tronco terá apenas um de altura, senão será dois.
```
     #
    ###
   #####
  #######
 #########
###########
     #
     #
```
Exemplo de um pinheiro com altura 6.

## lanchonete

O cardápio de uma lanchonete é o seguinte :

```
Especificação......Código....Preço
Cachorro Quente.....100.....R$ 1,20
Bauru Simples.......101.....R$ 1,30
Bauru com ovo.......102.....R$ 1,50
Hambúrguer..........103.....R$ 1,20
Cheeseburguer.......104.....R$ 1,30
Refrigerante........105.....R$ 1,00
```

Faça um programa que leia o código dos itens pedidos e as quantidades desejadas. Calcule e mostre o valor a ser pago por item (preço * quantidade) e o total geral do pedido. Considere que o cliente deve informar quando o pedido deve ser encerrado.

## votação

Uma grande emissora de televisão quer fazer uma enquete entre os seus telespectadores para saber qual o melhor jogador após cada jogo. Para isto, faz-se necessário o desenvolvimento de um programa, que será utilizado pelas telefonistas, para a computação dos votos. Sua equipe foi contratada para desenvolver este programa, utilizando a linguagem de programação da sua escolha. Para computar cada voto, a telefonista digitará um número, entre 1 e 23, correspondente ao número da camisa do jogador. Um número de jogador igual zero, indica que a votação foi encerrada. Se um número inválido for digitado, o programa deve ignorá-lo, mostrando uma breve mensagem de aviso, e voltando a pedir outro número. Após o final da votação, o programa deverá exibir :
- O total de votos computados;
- Os númeos e respectivos votos de todos os jogadores que receberam votos;
- O percentual de votos de cada um destes jogadores;
- O número do jogador escolhido como o melhor jogador da partida, juntamente com o número de votos e o percentual de votos dados a ele.

Observe que os votos inválidos e o zero final não devem ser computados como votos. O resultado aparece ordenado pelo número do jogador. O programa deve fazer uso de listas. O programa deverá executar o cálculo do percentual de cada jogador através de uma função. Esta função receberá dois parâmetros: o número de votos de um jogador e o total de votos. A função calculará o percentual e retornará o valor calculado. Abaixo segue uma tela de exemplo. O disposição das informações deve ser o mais próxima possível ao exemplo. Os dados são fictícios e podem mudar a cada execução do programa. Ao final, o programa deve ainda gravar os dados referentes ao resultado da votação em um arquivo texto no disco, obedecendo a mesma disposição apresentada na tela.

```
Enquete: Quem foi o melhor jogador?

Número do jogador (0=fim): 9
Número do jogador (0=fim): 10
Número do jogador (0=fim): 9
Número do jogador (0=fim): 10
Número do jogador (0=fim): 11
Número do jogador (0=fim): 10
Número do jogador (0=fim): 50
Informe um valor entre 1 e 23 ou 0 para sair!
Número do jogador (0=fim): 9
Número do jogador (0=fim): 9
Número do jogador (0=fim): 0

Resultado da votação:

Foram computados 8 votos.

Jogador....Votos........%
...09........4......50,0%
...10........3......37,5%
...11........1......12,5%
O melhor jogador foi o número 9, com 4 votos, correspondendo a 50% do total de votos.
```

## tamanho strings

Faça um programa que leia 2 strings e informe o conteúdo delas seguido do seu comprimento. Informe também se as duas strings possuem o mesmo comprimento e são iguais ou diferentes no conteúdo.

```
Compara duas strings
String 1: Brasil Hexa 2006
String 2: Brasil! Hexa 2006!
Tamanho de "Brasil Hexa 2006": 16 caracteres
Tamanho de "Brasil! Hexa 2006!": 18 caracteres
As duas strings são de tamanhos diferentes.
As duas strings possuem conteúdo diferente.
```

## gerador leetspeak

Leet é uma forma de se escrever o alfabeto latino usando outros símbolos em lugar das letras, como números por exemplo. A própria palavra leet admite muitas variações, como l33t ou 1337. O uso do leet reflete uma subcultura relacionada ao mundo dos jogos de computador e internet, sendo muito usada para confundir os iniciantes e afirmar-se como parte de um grupo. Pesquise sobre as principais formas de traduzir as letras. Depois, faça um programa que peça uma texto e transforme-o para a grafia leet speak.

## sequência de fibonacci

A sequência de Fibonacci é uma série de números onde cada número é a soma dos dois anteriores. A sequência começa com os números 0 e 1, e então cada número subsequente é gerado somando-se os dois números anteriores. Os primeiros termos da sequência de Fibonacci são :

0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...

Observe que :
- O terceiro número (1) é a soma dos dois primeiros (0 + 1).
- O quarto número (2) é a soma do segundo e do terceiro (1 + 1).
- O quinto número (3) é a soma do terceiro e do quarto (1 + 2).

Para calcular a sequência de Fibonacci, é preciso seguir estas etapas :

1. **definir os dois primeiros números** da sequência como 0 e 1;
1. **calcular o próximo número** como a soma dos dois números anteriores;
1. **repetir o processo** até que a quantidade desejada de números na sequência seja gerada;

Seu objetivo é criar um algoritmo que gera os `n` primeiros números da sequência de Fibonacci, onde `n` é um valor fornecido pelo usuário.

## calculadora romanos

Crie uma calculadora de números romanos.

- crie uma calculadora romana das operações `+`, `-`, `*`, `/`, `**`;
    - o intervalo de entrada e resultado deve ser (-4000,4000);
    - isto é, o valor mínimo recebido e calculado será -3999;
    - e o valor máximo recebido e calculado será 3999;
- o resultado da divisão deve ser representado como quociente e resto;
- a entrada dos dois números deve ser em números romanos;
- o resultado deve ser mostrado em números romanos;
- todos os cálculos devem ser salvos em um dicionário, que deve ser armazenado em uma lista;
- encerre o programa quando o usuário digitar `sair`;
- ao final, mostre todos as operações realizadas;
- exemplos :
    - operação tradicional :
        - calculo = {'valor_1': 'X', 'valor_2': 'IV', 'operacao': '+', 'resposta': 'XIV'}
    - operação onde foi entrado um valor maior que 3999 ou menor que -3999 :
        - calculo = {'valor_1': 'erro', 'valor_2': 'MM', 'operacao': '/', 'resposta': 'erro'}
    - modelo usando subtração com algum valor negativo :
        - calculo = {'valor_1': '-C', 'valor_2': 'X', 'operacao': '-', 'resposta': '-CX'}
    - modelo de divisão :
        - calculo = {'valor_1': 'XI', 'valor_2': 'III', 'operacao': '/', 'resposta': 'III', 'resto': 'II'}

## funções do Python

O Python possui diversas funções built-in que facilitam o trabalho. Embora ajudem, é interessante tentar replicar o comportamento delas para entender como funciona e, também, para praticar.
Então, recrie as seguintes funções :
- `sum()`, `len()`, `pow()`, `max()`, `min()`, `abs()`, `round()`, `range()`, `divmod()`


# empacotamento-desempacotamento.md

Índice

1. [empacotamento tuplas e listas](#empacotamento-tuplas-e-listas)
1. [empacotamento de dicionários](#empacotamento-de-dicionários)
1. [desempacotamento](#desempacotamento)
1. [exercícios](#exercícios)

# empacotamento e desempacotamento

## empacotamento tuplas e listas

Empacotamento de variáveis em Python refere-se ao processo de agrupar múltiplos valores em uma única estrutura de dados, como uma tupla ou lista. Isso é especialmente útil quando se deseja armazenar uma coleção de valores que pertencem a um mesmo contexto.

### tuplas

Por padrão, quando se agrupa vários valores separados por vírgulas, o Python automaticamente os empacota em uma tupla. Isso é conhecido como **empacotamento de tuplas**.

- exemplo 1 : empacotamento em uma tupla
```python
>>> # empacotando valores em uma tupla
>>> dados = 10, 20, 30
>>>
>>> print(f'{dados = }')
dados = (10, 20, 30)
>>>
>>> print(f'{type(dados) = }')
type(dados) = <class 'tuple'>
>>> |
```

Neste exemplo, `dados` é uma tupla que contém os valores `10`, `20` e `30`. O Python automaticamente criou essa tupla ao identificar múltiplos valores separados por vírgulas.

- exemplo 2 : tupla com um único elemento
Se quiser criar uma tupla com apenas um elemento, é necessário incluir uma vírgula, pois, sem a vírgula, o Python não interpretará o valor como uma tupla.

```python
>>> # empacotando um único valor em uma tupla
>>> item = 42,
>>> print(f'{item = }')
item = (42,)
>>> print(f'{type(item)}')
<class 'tuple'>
>>> |
```

Aqui, `item` é uma tupla contendo um único valor, `42`. Sem a vírgula, o Python trataria `42` apenas como um número inteiro.

### listas

Embora o empacotamento seja mais comumente associado a tuplas, também é possível empacotar valores em uma lista, mas isso requer a utilização de colchetes (`[]`).

- exemplo 3 : empacotamento em uma lista
```python
>>> # empacotando valores em uma lista
>>> dados_lista = [10, 20, 30]
>>>
>>> print(f'{dados_lista = }')
dados_lista = [10, 20, 30]
>>>
>>> print(f'{type(dados_lista) = }')
type(dados_lista) = <class 'list'>
>>> |
```

Aqui, `dados_lista` é uma lista que contém os valores `10`, `20` e `30`.

### empacotamento implícito

O Python permite empacotar valores sem a necessidade de utilizar parênteses ou colchetes explicitamente.

- exemplo 4 : empacotamento implícito
```python
>>> # empacotamento implícito em uma tupla
>>> valores = 5, 'Python', True
>>>
>>> print(f'{valores = }')
valores = (5, 'Python', True)
>>> |
```

Neste caso, `valores` é uma tupla, mesmo que os parênteses não tenham sido explicitamente utilizados.

### considerações importantes

1. **imutabilidade das tuplas** : uma vez que os valores são empacotados em uma tupla, eles não podem ser modificados individualmente, pois tuplas são imutáveis. Se for necessário alterar os valores, é recomendável usar uma lista;

2. **heterogeneidade de dados** : tanto tuplas quanto listas permitem armazenar valores de diferentes tipos de dados. Isso significa que se pode empacotar inteiros, strings, booleanos, entre outros, em uma única estrutura;

- exemplo 5 : empacotando diferentes tipos de dados
```python
>>> # empacotando diferentes tipos de dados
>>> dados_mistos = 100, 'Cem', 99.9, False
>>> print(f'{dados_mistos = }')
dados_mistos = (100, 'Cem', 99.9, False)
>>> |
```

3. **utilização de empacotamento** : o empacotamento é muito útil em situações onde se deseja passar múltiplos valores como um único objeto. Isso pode facilitar a manipulação de dados em várias operações, como armazenar os resultados de uma função que retorna múltiplos valores.

## empacotamento dicionários

O empacotamento de dicionários em Python é um recurso poderoso que permite a criação dinâmica de dicionários a partir de uma combinação de chaves e valores, ou mesmo a fusão de vários dicionários em um único. Diferente do desempacotamento, que trata de extrair itens de um dicionário, o empacotamento se concentra em como agrupar dados em um dicionário.

### empacotamento explícito

O empacotamento mais comum é feito de maneira explícita, onde se define as chaves e valores diretamente :

```python
>>> dados = {
...     "nome": "Maria",
...     "idade": 28,
...     "cidade": "Porto Alegre"
... }
>>>
>>> print(dados)
{'nome': 'Maria', 'idade': 28, 'cidade': 'Porto Alegre'}
>>> |
```

Aqui, foi criado um dicionário chamado `dados`, empacotando as chaves `"nome"`, `"idade"`, e `"cidade"` com seus respectivos valores `"Maria"`, `28`, e `"Porto Alegre"`.

### empacotamento com compreensão de dicionários

É possível empacotar dicionários de forma dinâmica usando compreensão de dicionários (similar à compreensão de listas) :

```python
>>> nomes = ["Ana", "Bruno", "Carlos"]
>>> idades = [25, 30, 22]
>>>
>>> dados = {nome: idade for nome, idade in zip(nomes, idades)}
>>>
>>> print(dados)
{'Ana': 25, 'Bruno': 30, 'Carlos': 22}
>>> |
```

Utilizou-se a função `zip()` para combinar as listas `nomes` e `idades`. O dicionário `dados` é empacotado onde cada nome é uma chave e a idade correspondente é o valor.

## desempacotamento

Desempacotamento de variáveis é o processo de extrair valores de uma estrutura de dados, como uma tupla ou lista, e atribuí-los a variáveis individuais. Essa técnica é extremamente útil para manipular dados de forma clara e organizada, permitindo que os valores sejam extraídos de uma coleção e atribuídos diretamente às variáveis correspondentes.

### desempacotamento simples

O desempacotamento mais básico acontece quando uma tupla ou lista é "desempacotada" em múltiplas variáveis, onde cada valor é atribuído a uma variável específica.

- exemplo 1 : desempacotamento de uma tupla
```python
>>> # desempacotando uma tupla
>>> dados = (10, 20, 30)
>>>
>>> a, b, c = dados
>>>
>>> print(f'{a = }')
a = 10
>>> print(f'{b = }')
b = 20
>>> print(f'{c = }')
c = 30
>>> |
```

Aqui, a tupla `dados` contém três valores. O desempacotamento ocorre quando esses valores são atribuídos diretamente às variáveis `a`, `b` e `c`.

- exemplo 2 : desempacotamento de uma lista
```python
>>> # desempacotando uma lista
>>> dados_lista = [40, 50, 60]
>>>
>>> x, y, z = dados_lista
>>>
>>> print(f'{x = }')
x = 40
>>> print(f'{y = }')
y = 50
>>> print(f'{z = }')
z = 60
>>> |
```

No caso acima, a lista `dados_lista` é desempacotada em três variáveis `x`, `y` e `z`.

### desempacotamento com empacotamento de resto

O Python permite que se desempacote apenas parte de uma estrutura de dados, ou que se utilize a técnica de "empacotamento de resto" para capturar valores excedentes.

- exemplo 3 : desempacotamento parcial com "restante"
```python
>>> # desempacotando com valores restantes
>>> valores = [1, 2, 3, 4, 5]
>>>
>>> a, b, *resto = valores
>>>
>>> print(f'{a = }')
a = 1
>>> print(f'{b = }')
b = 2
>>> print(f'{resto = }')
resto = [3, 4, 5]
>>> |
```

Neste exemplo, `a` recebe o primeiro valor da lista `valores`, `b` recebe o segundo, e o restante dos valores é empacotado na lista `resto` usando `*`.

- exemplo 4 : desempacotamento com valores ignorados
```python
>>> # desempacotando e ignorando valores
>>> dados = (100, 200, 300, 400)
>>>
>>> _, _, c, d = dados
>>>
>>> print(f'{c = }')
c = 300
>>> print(f'{d = }')
d = 400
>>> |
```

aqui, os dois primeiros valores da tupla `dados` são ignorados usando `_`, e os dois últimos valores são atribuídos a `c` e `d`.

### desempacotamento em estruturas aninhadas

também é possível desempacotar valores de estruturas de dados aninhadas, como tuplas dentro de tuplas ou listas dentro de listas.

- exemplo 5 : desempacotamento de tuplas aninhadas
```python
>>> # desempacotando tuplas aninhadas
>>> dados = (10, (20, 30))
>>>
>>> a, (b, c) = dados
>>>
>>> print(f'{a = }')
a = 10
>>> print(f'{b = }')
b = 20
>>> print(f'{c = }')
c = 30
>>> |
```

Neste caso, a variável `a` recebe o valor `10`, enquanto `b` e `c` recebem os valores `20` e `30` da tupla interna.

- exemplo 6 : desempacotamento de listas aninhadas
```python
>>> # desempacotando listas aninhadas
>>> dados_lista = [100, [200, 300], 400]
>>>
>>> x, (y, z), w = dados_lista
>>>
>>> print(f'{x = }')
x = 100
>>> print(f'{y = }')
y = 200
>>> print(f'{z = }')
z = 300
>>> print(f'{w = }')
w = 400
>>> |
```

Aqui, a lista `dados_lista` é desempacotada em variáveis `x`, `y`, `z` e `w`, onde `y` e `z` recebem os valores da lista interna `[200, 300]`.

### considerações importantes

1. **correspondência de quantidade** : ao desempacotar, é importante que o número de variáveis corresponda ao número de elementos na estrutura, a menos que se esteja usando `*` para capturar valores restantes;

2. **flexibilidade de desempacotamento** : o desempacotamento oferece uma maneira flexível e expressiva de extrair valores de estruturas complexas, como listas ou tuplas aninhadas, permitindo que se acesse dados específicos de forma direta e concisa;

3. **uso do caractere `*`** : o caractere `*` é uma ferramenta poderosa para capturar múltiplos valores restantes em uma lista ou tupla, oferecendo flexibilidade ao lidar com dados de tamanho variável;

## exercícios

<details>
<summary>Lista de Exercícios</summary>

1. Exercícios de Empacotamento
    1. Crie uma tupla com os números de 1 a 5 e mostre o resultado.
    1. Crie uma lista com os nomes de 3 cidades e mostre o resultado.
    1. Empacote os valores `10`, `20` e `30` em uma tupla e mostre a tupla resultante.
    1. Crie um dicionário empacotando as chaves "nome", "idade" e "cidade" com os valores "Ana", 25 e "São Paulo".
    1. Crie uma lista que empacote os números de 1 a 10 e mostre a lista resultante.
    1. Empacote os valores `True`, `False` e `None` em uma tupla e mostre a tupla.
    1. Crie uma lista que empacote três strings de cores (ex.: "vermelho", "azul", "verde") e mostre a lista resultante.
    1. Empacote os valores 3.14, 2.71 e 1.41 em uma tupla e mostre a tupla resultante.
    1. Crie um dicionário empacotando as chaves "produto", "preço" e "quantidade" com os valores "Notebook", 2500 e 5.
    1. Empacote três listas diferentes em uma lista maior e mostre o resultado.
1. Exercícios de Desempacotamento de Tuplas
    1. Desempacote a tupla `(1, 2, 3)` em três variáveis `a`, `b` e `c`, e mostre os valores de cada variável.
    1. Desempacote a tupla `("Python", "Java", "C++")` em três variáveis e mostre os valores de cada uma.
    1. Desempacote a tupla `(True, False, None)` em três variáveis e mostre os valores.
    1. Desempacote a tupla `("Alice", 30, "Engenheira")` em variáveis `nome`, `idade` e `profissao`, e mostre os valores.
    1. Dada a tupla `(10, 20, 30, 40, 50)`, desempacote o primeiro e o último valor em duas variáveis e mostre-os.
1. Exercícios de Desempacotamento de Listas
    1. Desempacote a lista `[5, 10, 15]` em três variáveis e mostre os valores de cada uma.
    1. Desempacote a lista `["Maçã", "Banana", "Laranja"]` em três variáveis e mostre os valores.
    1. Desempacote a lista `[1.1, 2.2, 3.3]` em três variáveis e mostre os valores.
    1. Dada a lista `[100, 200, 300, 400]`, desempacote o segundo e o terceiro valor em duas variáveis e mostre os valores.
    1. Desempacote a lista `[True, False]` em duas variáveis e mostre os valores.
1. Exercícios de Empacotamento e Desempacotamento Mistos
    1. Crie uma lista de tuplas, onde cada tupla empacota dois valores (ex.: `[("A", 1), ("B", 2)]`). Desempacote e mostre os valores de cada tupla.
    1. Dada uma lista `[(1, 2), (3, 4), (5, 6)]`, desempacote os pares de valores de cada tupla em variáveis `x` e `y` e mostre os resultados.
    1. Empacote três listas em uma tupla e depois desempacote cada lista em variáveis separadas.
    1. Crie um dicionário onde as chaves sejam strings e os valores sejam listas. Depois, desempacote uma das listas em variáveis separadas.
    1. Dada uma lista `[(10, 20), (30, 40), (50, 60)]`, desempacote os valores de cada tupla e mostre os resultados.
1. Exercícios com Dicionários
    1. Dado o dicionário `{"nome": "Carlos", "idade": 28, "cidade": "Rio"}`, desempacote os valores em variáveis separadas e mostre os resultados.
    1. Crie um dicionário onde as chaves sejam números e os valores sejam tuplas. Desempacote uma das tuplas em variáveis separadas.
    1. Dado o dicionário `{"a": 1, "b": 2, "c": 3}`, desempacote as chaves e valores em duas listas separadas.
    1. Empacote uma lista de tuplas em um dicionário onde a primeira posição da tupla é a chave e a segunda é o valor.
    1. Dado um dicionário `{"x": (10, 20), "y": (30, 40)}`, desempacote os valores das tuplas e mostre os resultados.

</details>


# estruturas-repeticao.md

Índice

1. [while](#while)
1. [contador e acumulador](#contador-e-acumulador)
1. [exercícios while](#exercícios-while)
1. [comando for](#comando-for)
1. [exercícios for](#exercícios-for)
1. [loops aninhados](#loops-aninhados)
1. [exercícios loops aninhados](#exercícios-loops-aninhados)
1. [for vs while](#for-vs-while)
1. [exercícios for vs while](#exercícios-for-vs-while)
1. [else em loops](#else-em-loops)
1. [exercícios else](#exercícios-else)

# estruturas de repetição

## while

A estrutura de repetição `while` em Python é usada para executar um bloco de código repetidamente, desde que uma condição seja verdadeira. A cada iteração (a cada repetição), a condição é avaliada; se continuar sendo verdadeira, o loop continua, caso contrário, ele para.

Veja a sintaxe básica :

```python
while condicao:
    # Bloco de código a ser repetido
```

- **`condicao`**: uma expressão que será avaliada como `True` ou `False`;
- **bloco de código**: o conjunto de instruções que será executado repetidamente enquanto a condição for `true`;

### exemplo de contagem

Veja como fica uma contagem simples, iniciando em 1 e terminando em 5 :

```python
contador = 1

while contador <= 5:
    print("Contagem : ", contador)
    contador = contador + 1
```

O código inicia com a definição da variável `contador` e o valor 1 é atribuída a ela. Em seguida, o comando `while` testa a condição especificada nele, se `contador <= 5`. Enquanto a condição for verdadeira, seu bloco de código interno será executado. No bloco de código, é utilizado um `print` para exibir uma string e o valor da variável `contador`. Logo depois, é somado 1 ao conteúdo da variável contador usando `contador = contador + 1`.

Esse código terá como resultado :

```
Contagem : 1
Contagem : 2
Contagem : 3
Contagem : 4
Contagem : 5
```

Após `contador` chegar a 6, a condição `contador <= 5` se tornará `False`, e o loop será interrompido.

### exemplo com entrada do usuário

O `while` é frequentemente usado para repetir ações até que o usuário forneça uma resposta específica.

```python
resposta = ""

while resposta != "sair":
    resposta = input("Digite algo (ou 'sair' para encerrar): ")
    print('Você digitou :', resposta)
```

- O loop continuará pedindo uma entrada do usuário e imprimindo-a até que o usuário digite "sair";
- Quando a entrada for "sair", a condição `resposta != "sair"` será `False`, e o loop será interrompido;

### exemplo com uma condição complexa

Às vezes, a condição dentro de um `while` pode ser mais complexa e envolver múltiplas variáveis.

```python
numero = 10
divisor = 2

while numero % divisor == 0:
    print(numero, 'é divisível por', divisor)
    numero = numero / 2
```

- A condição `numero % divisor == 0` verifica se `numero` é divisível por `divisor`;
- Enquanto o `numero` for divisível por `2`, ele será dividido por 2 a cada iteração, e a mensagem será impressa;
- O loop para quando `numero` não for mais divisível por 2;

### cuidados com o `while`

Um cuidado importante ao usar `while` é evitar loops infinitos, que acontecem quando a condição nunca se torna `False`. Por exemplo:

```python
contador = 1

while contador <= 5:
    print("Contagem : ", contador)
    # Esquecemos de incrementar o contador!
```

Esse código nunca sairá do loop porque `contador` nunca muda, fazendo com que a condição seja sempre verdadeira. Isso pode travar o programa.

## contador e acumulador

Os conceitos de **acumulador** e **contador** são amplamente usados em loops, especialmente com `while`, para realizar operações repetitivas como somar valores ou contar ocorrências.

### contador

Um **contador** é uma variável que é usada para contar quantas vezes um evento ocorre. Geralmente, ele é incrementado por um valor fixo (como 1) a cada iteração do loop.

É possível contar quantas vezes um loop `while` é executado. Veja o código abaixo :

```python
contador = 0
resposta = ''

while resposta != "sair":
    resposta = input("Digite algo (ou 'sair' para encerrar): ")
    print('Você digitou :', resposta)
    contador = contador + 1

print('o loop while foi executado', contador, 'vezes')
```

O código acima começa declarando as variáveis `contador` e `resposta`. Em seguida, o comando `while` testa se a resposta é diferente a `sair`. Enquanto a condição for verdadeira, o bloco de código dentro do `while` é executado. Dentro dele, a cada iteração, é feita uma pergunta (`input("Digite algo (ou 'sair' para encerrar): ")`) para o usuário e salvar o for digitado na variável `resposta`. Em seguida, é mostrado o que o usuário digitou com usando um `print` e o contador é incrementado em 1.

Ao final, quando o usuário finalmente digitar **sair**, o loop (laço de repetição) será encerrado e o `print` final irá mostrar a quantidade de vezes que a pergunta fora feita ao usuário.

### acumulador

Um **acumulador** é uma variável que acumula valores ao longo das iterações de um loop. Geralmente, ele começa em um valor inicial (como 0) e a cada iteração, um novo valor é adicionado a ele.

Veja como somar os números de 1 a 5 usando um acumulador :

```python
soma = 0
numero = 1

while numero <= 5:
    soma = soma + numero
    print('Adicionando', numero, ', a soma agora é', soma)
    numero = numero + 1

print('a soma final é', soma)
```

A variável `soma` é inicializada com o valor 0 e a variável `numero` é inicializada com o valor 1. Depois, o comando `while` testa se a condição `numero <= 5` é verdadeira. Enquanto for, o bloco de código é executado. Dentro dele, a cada iteração, o valor e `numero` é adicionado a `soma` (`soma = soma + numero`). Em seguida, o `numero` é incrementado em 1 a cada iteração.

Ao final, é mostrado o valor final da variável `soma`.

### combinando acumulador e contador

É possível combinar um contador e um acumulador no mesmo loop.

Considere o seguinte, é preciso somar os números pares de 1 a 10 e contar quantos números pares existem nesse intervalo.

```python
contador_pares = 0
soma_pares = 0
numero = 1

while numero <= 10:
    if numero % 2 == 0:
        contador_pares = contador_pares + 1
        soma_pares = soma_pares + numero
    numero = numero + 1

print('Quantidade de números pares :', contador_pares)
print('Soma dos números pares :', soma_pares)
```

O código acima inicia com a declaração das variáveis `contador_pares`, `soma_pares` e `numero`. O comando `while` testa se `numero <= 10` é verdadeiro, se for o bloco de código é executado. Em seguida, é feito um testes para número par (`numero % 2 == 0`). Quando o teste der verdadeiro, o `contador_pares` é incrementado em 1 e a `soma_pares` é somado com o valor da variável `numero`. Em seguida, mesmo que a condição do `if` seja falsa, a variável `numero` é incrementada em 1.

Ao finalizar o loop, é mostrado os valores das variáveis `contador_pares` e `soma_pares`.

Veja agora um uso de um acumulador, mas agora usando com multiplicação :

```python
# algoritmo para calcular o fatorial de 5
produto = 1
numero = 1

while numero <= 5:
    produto = produto * numero
    print('Multiplicando por',numero,', produto agora é', produto)
    numero = numero + 1

print('o fatorial de 5 é', produto)
```

### exercícios `while`

<details>
<summary>Lista de Exercícios</summary>

1. Nível Simples
    1. Crie um programa que peça ao usuário para digitar um número inteiro positivo e continue pedindo até que o número digitado seja maior que 10.
    1. Crie um programa que peça ao usuário para digitar números inteiros e some esses números até que o usuário digite um número negativo.
    1. Crie um programa que peça ao usuário para digitar uma senha (string) até que ele acerte a senha correta "Python123".
    1. Crie um programa que peça ao usuário para digitar um número decimal até que ele digite um valor maior que 0.5.
    1. Crie um programa que exiba "Olá!" 5 vezes utilizando um while e uma variável contador.
1. Nível Simples com if-elif-else
    1. Crie um programa que peça ao usuário para digitar números inteiros até que ele digite um número maior que 50. Se o número for ímpar, exiba "Ímpar". Caso contrário, exiba "Par".
    1. Crie um programa que peça ao usuário para digitar palavras até que ele digite "sair". Se a palavra contiver a letra "a", exiba "Contém a letra 'a'". Caso contrário, exiba "Não contém a letra 'a'".
    1. Crie um programa que peça ao usuário para digitar números decimais até que a soma dos números seja maior que 100. Se o número digitado for maior que 10, exiba "Número grande". Caso contrário, exiba "Número pequeno".
    1. Crie um programa que peça ao usuário para digitar valores booleanos (True ou False) até que ele digite "False". Se for "True", exiba "Verdadeiro". Caso contrário, exiba "Falso".
    1. Crie um programa que peça ao usuário para digitar números inteiros até que ele digite um número negativo. Se o número for divisível por 3, exiba "Divisível por 3". Caso contrário, exiba "Não divisível por 3".
1. Nível Intermediário
    1. Crie um programa que peça ao usuário para digitar números inteiros até que ele digite um número maior que 20. Em seguida, exiba todos os números digitados em uma lista.
    1. Crie um programa que peça ao usuário para digitar números decimais até que ele digite um número menor que 1.5. Em seguida, exiba a média dos números digitados.
    1. Crie um programa que peça ao usuário para digitar palavras até que ele digite "stop". Em seguida, exiba todas as palavras em uma única string concatenada.
    1. Crie um programa que peça ao usuário para digitar valores booleanos (True ou False) até que ele digite "True". Em seguida, exiba quantas vezes o valor "False" foi digitado.
    1. Crie um programa que peça ao usuário para digitar números inteiros e adicione-os a uma lista até que a lista tenha 5 elementos. Em seguida, exiba a lista completa.
1. Nível Intermediário com if-elif-else
    1. Crie um programa que peça ao usuário para digitar números inteiros até que ele digite um número par. Se o número for maior que 10, adicione-o a uma lista de "números grandes". Caso contrário, adicione-o a uma lista de "números pequenos". Exiba as duas listas ao final.
    1. Crie um programa que peça ao usuário para digitar palavras até que ele digite "fim". Se a palavra tiver mais de 5 caracteres, adicione-a a uma lista de "palavras longas". Caso contrário, adicione-a a uma lista de "palavras curtas". Exiba as duas listas ao final.
    1. Crie um programa que peça ao usuário para digitar números decimais até que ele digite um número negativo. Se o número for maior que 1, exiba "Grande". Se for menor que 1, exiba "Pequeno". Se for igual a 1, exiba "Igual a 1".
    1. Crie um programa que peça ao usuário para digitar valores booleanos (True ou False) até que ele digite "False" duas vezes seguidas. Exiba quantas vezes "True" foi digitado.
    1. Crie um programa que peça ao usuário para digitar números inteiros até que ele digite um número maior que 100. Se o número for múltiplo de 5, adicione-o a uma lista de "múltiplos de 5". Caso contrário, adicione-o a uma lista de "não múltiplos de 5". Exiba as duas listas ao final.
1. Nível Avançado
    1. Crie um programa que peça ao usuário para digitar números inteiros até que ele digite um número primo. Exiba todos os números digitados até então.
    1. Crie um programa que peça ao usuário para digitar números decimais até que ele digite um número igual a 0. Em seguida, exiba o maior número digitado.
        ```python
        pedido = float(input('Digite um decimal : '))
        maior = pedido

        while pedido != 0:
            pedido = float(input('Digite um decimal : '))
            if pedido > maior:
                maior = pedido
        print('o maior numero foi :', maior)
        ```
    1. Crie um programa que peça ao usuário para digitar palavras até que ele digite uma palavra que comece com a letra "z". Em seguida, exiba a palavra mais longa digitada.
        ```python
        print('digite numeros, pare tudo digitando 0')

        numero = float(input('digite um numero : '))
        maior = numero

        while numero != 0.0:  # numero != 0
            numero = float(input('digite outro numero : '))

            if numero > maior:
                maior = numero

        print('o numero eh :', numero)
        print('o maior eh :', maior)
        ```
    1. Crie um programa que peça ao usuário para digitar valores booleanos (True ou False) até que ele digite "True" três vezes. Exiba a quantidade total de valores digitados.
    1. Crie um programa que peça ao usuário para digitar números inteiros até que ele digite um número negativo. Em seguida, exiba a soma de todos os números digitados.
1. Nível Avançado com if-elif-else
    1. Crie um programa que peça ao usuário para digitar números inteiros até que ele digite um múltiplo de 7. Se o número for par, adicione-o a uma lista de "pares". Se for ímpar, adicione-o a uma lista de "ímpares". Exiba as duas listas ao final.
    1. Crie um programa que peça ao usuário para digitar palavras até que ele digite "exit". Se a palavra contiver a letra "e", adicione-a a uma lista de "palavras com e". Caso contrário, adicione-a a uma lista de "palavras sem e". Exiba as duas listas ao final.
    1. Crie um programa que peça ao usuário para digitar números decimais até que ele digite um número menor que 0. Se o número for positivo, exiba "Positivo". Se for negativo, exiba "Negativo". Se for zero, exiba "Zero".
    1. Crie um programa que peça ao usuário para digitar valores booleanos (True ou False) até que ele digite "False" três vezes seguidas. Exiba a quantidade total de "True" digitados.
    1. Crie um programa que peça ao usuário para digitar números inteiros até que a soma dos números seja maior que 50. Se o número digitado for maior que 10, exiba "Grande". Caso contrário, exiba "Pequeno".
1. Nível Complexo
    1. Crie um programa que peça ao usuário para digitar números inteiros até que ele digite um número divisível por 4. Em seguida, exiba o menor número digitado.
    1. Crie um programa que peça ao usuário para digitar números decimais até que ele digite um número entre 0 e 1. Em seguida, exiba a média dos números digitados.
    1. Crie um programa que peça ao usuário para digitar palavras até que ele digite "fim". Em seguida, exiba as palavras digitadas em ordem inversa.
    1. Crie um programa que peça ao usuário para digitar valores booleanos (True ou False) até que ele digite "True" cinco vezes. Em seguida, exiba quantas vezes "False" foi digitado.
    1. Crie um programa que peça ao usuário para digitar números inteiros até que a soma dos números seja maior que 100. Em seguida, exiba todos os números digitados que sejam divisíveis por 5.
1. Nível Complexo com if-elif-else
    1. Crie um programa que peça ao usuário para digitar números inteiros até que ele digite um número primo. Se o número for maior que 50, adicione-o a uma lista de "números grandes". Caso contrário, adicione-o a uma lista de "números pequenos". Exiba as duas listas ao final.
    1. Crie um programa que peça ao usuário para digitar palavras até que ele digite uma palavra que tenha exatamente 5 letras. Se a palavra começar com "a", adicione-a a uma lista de "palavras com a". Caso contrário, adicione-a a uma lista de "outras palavras". Exiba as duas listas ao final.
    1. Crie um programa que peça ao usuário para digitar números decimais até que ele digite um número menor que 0. Se o número for maior que 5, adicione-o a uma lista de "números altos". Caso contrário, adicione-o a uma lista de "números baixos". Exiba as duas listas ao final.
    1. Crie um programa que peça ao usuário para digitar valores booleanos (True ou False) até que ele digite "True" quatro vezes seguidas. Se o valor for "True", adicione-o a uma lista de "verdadeiros". Caso contrário, adicione-o a uma lista de "falsos". Exiba ambas as listas ao final.
    1. Crie um programa que peça ao usuário para digitar números inteiros até que ele digite um número que seja a soma dos dois números anteriores. Se o número digitado for maior que 20, adicione-o a uma lista de "números grandes". Caso contrário, adicione-o a uma lista de "números pequenos". Exiba as duas listas ao final.
1. Nível Muito Complexo
    1. Crie um programa que peça ao usuário para digitar números inteiros até que ele digite um número que seja divisível por todos os números anteriormente digitados. Exiba a lista completa de números ao final.
    1. Crie um programa que peça ao usuário para digitar números decimais até que ele digite um número que seja a média de todos os números anteriormente digitados. Exiba o maior e o menor número digitado ao final.
    1. Crie um programa que peça ao usuário para digitar palavras até que ele digite uma palavra que tenha as mesmas letras (em qualquer ordem) que a primeira palavra digitada. Em seguida, exiba a quantidade total de palavras digitadas.
    1. Crie um programa que peça ao usuário para digitar valores booleanos (True ou False) até que ele digite uma sequência de "True", "False", "True", "False". Exiba quantas vezes "True" e "False" foram digitados ao final.
        ```python
        cont_true = 0
        cont_fals = 0
        parada = '0000'
        continua = True

        # cond parada TFTF
        while continua:
            resposta = bool(input('digite um boolean : '))

            if resposta:
                cont_true = cont_true + 1
                parada = parada[1:] + 'T'
            else:
                cont_fals = cont_fals + 1
                parada = parada[1:] + 'F'

            print(parada)
            if parada == 'TFTF':
                continua = False

        print('contagem True :', cont_true)
        print('contagem False :', cont_fals)
        ```
    1. Crie um programa que peça ao usuário para digitar números inteiros até que a soma dos números digitados seja igual ao produto dos números digitados. Em seguida, exiba todos os números digitados e a soma total.
1. Nível Muito Complexo com if-elif-else
    1. Crie um programa que peça ao usuário para digitar números inteiros até que ele digite um número que seja divisível pelo número de elementos já digitados. Se o número for maior que 100, adicione-o a uma lista de "números muito grandes". Caso contrário, adicione-o a uma lista de "outros números". Exiba ambas as listas ao final.
    1. Crie um programa que peça ao usuário para digitar palavras até que ele digite uma palavra que tenha um número de letras igual ao número total de palavras digitadas anteriormente. Se a palavra começar com uma vogal, adicione-a a uma lista de "palavras com vogal". Caso contrário, adicione-a a uma lista de "palavras com consoante". Exiba ambas as listas ao final.
    1. Crie um programa que peça ao usuário para digitar números decimais até que ele digite um número que seja o dobro de algum dos números já digitados. Se o número for maior que 10, adicione-o a uma lista de "números grandes". Caso contrário, adicione-o a uma lista de "números pequenos". Exiba ambas as listas ao final.
    1. Crie um programa que peça ao usuário para digitar valores booleanos (True ou False) até que ele digite um padrão alternado de "True" e "False" três vezes seguidas. Exiba a quantidade total de "True" e "False" digitados ao final.
    1. Crie um programa que peça ao usuário para digitar números inteiros até que ele digite um número que seja múltiplo da soma dos dígitos de um dos números anteriormente digitados. Se o número for par, adicione-o a uma lista de "pares". Caso contrário, adicione-o a uma lista de "ímpares". Exiba ambas as listas ao final.
</details>

## comando `for`

O comando `for` em Python é uma estrutura de repetição que permite iterar sobre elementos de uma sequência (como listas, tuplas, strings ou intervalos) ou qualquer outro objeto iterável. A cada iteração, ele atribui o próximo elemento da sequência a uma variável e executa um bloco de código.

```python
# sintaxe básica
for variável in sequência:
    # bloco de código
```

- **variável** : uma variável que assume o valor de cada item da sequência durante cada iteração;
- **sequência** : pode ser qualquer tipo de coleção, como uma lista, string, tupla, conjunto, ou até mesmo um intervalo (usando `range()`);
- **bloco de código** : o código que será executado para cada item na sequência;

Veja alguns exemplos

1. iterando sobre uma lista :

    Uma lista, nada mais é que uma sequência de itens. Então, é possível usar o comando `for` para passar por cada elemento individualmente.
    ```python
    >>> frutas = ["maçã", "banana", "laranja"]
    >>> for fruta in frutas:
    ...     print(fruta)
    ...
    maçã
    banana
    laranja
    >>> |
    ```

1. iterando sobre uma string :
    ```python
    >>> palavra = 'Arnold'
    >>> for letra in palavra:
    ...     print(letra)
    ...
    A
    r
    n
    o
    l
    d
    >>> |
    ```

### `for` e `if-elif-else`

É possível incluir declarações condicionais dentro de um loop `for` para controlar o fluxo de execução :

```python
>>> numeros = [1, 2, 3, 4, 5, 6]
>>> for num in numeros:
...     if num % 2 == 0:
...         print(f'{num} é par')
...     else:
...         print(f'{num} é ímpar')
...
1 é ímpar
2 é par
3 é ímpar
4 é par
5 é ímpar
6 é par
>>> |
```

### exercícios `for`

<details>
<summary>Lista de Exercícios</summary>

1. Itere sobre uma lista de números e imprima cada número.
1. Itere sobre uma string e imprima cada caractere.
1. Itere sobre uma lista de palavras e imprima cada palavra em maiúsculas.
1. Itere sobre uma lista de números e imprima o quadrado de cada número.
1. Itere sobre uma string e conte quantas letras "a" ela possui.
1. Crie uma lista de números e use um loop `for` para criar uma nova lista com o dobro de cada número.
1. Itere sobre uma lista de strings e imprima cada uma em ordem reversa.
1. Itere sobre uma lista de números e imprima apenas os números pares.
1. Itere sobre uma lista de palavras e imprima apenas as palavras que começam com a letra "p".
1. Itere sobre uma lista de números e imprima o cubo de cada número.
1. Crie uma lista de números e use `for` para somar todos os números da lista.
1. Itere sobre uma string e crie uma nova string com todas as vogais removidas.
1. Itere sobre uma lista de palavras e imprima o comprimento de cada uma.
1. Itere sobre uma lista de números e imprima a metade de cada número.
1. Itere sobre uma string e imprima cada caractere junto com seu índice.
1. Crie uma lista de palavras e use `for` para criar uma nova lista com cada palavra em maiúsculas.
1. Itere sobre uma lista de números e imprima apenas os números ímpares.
1. Itere sobre uma string e imprima apenas as letras que aparecem mais de uma vez.
1. Itere sobre uma lista de números e imprima o produto de todos os números.
1. Itere sobre uma lista de palavras e imprima apenas as palavras que contêm a letra "e".
1. Itere sobre uma lista de números e crie uma nova lista com apenas os números que são divisíveis por 3.
1. Itere sobre uma string e imprima cada caractere junto com a quantidade de vezes que ele aparece na string.
1. Itere sobre uma lista de palavras e imprima cada palavra com suas letras em ordem alfabética.
1. Itere sobre uma lista de números e imprima a soma de todos os números maiores que 10.
1. Itere sobre uma lista de strings e crie uma nova string que seja a concatenação de todas as strings da lista.

</details>

## loops aninhados

Loops aninhados em Python ocorrem quando se coloca um loop dentro de outro. Isso permite percorrer estruturas de dados mais complexas, como listas de listas (ou matrizes) e realizar operações em camadas diferentes de iteração.

### usando o loop `for` aninhado

Quando se aninha loops `for`, o loop externo inicia e, para cada iteração do loop externo, o loop interno percorre completamente sua estrutura.

1. iterando sobre uma matriz

```python
>>> matriz = [
...     [1, 2, 3],
...     [4, 5, 6],
...     [7, 8, 9]
... ]
>>>
>>> for linha in matriz:
...     for coluna in linha:
...         print(coluna, end=' ')
...     print()
...
1 2 3
4 5 6
7 8 9
>>> |
```

1. O loop externo `for linha in matriz` percorre cada lista dentro da lista principal `matriz`;
1. O loop interno `for coluna in linha` percorre cada elemento dentro da lista atual (`linha`);
1. O `print(coluna, end=' ')` imprime cada elemento da linha na mesma linha;
1. O `print()` fora do loop interno quebra a linha, garantindo que cada linha da matriz seja impressa em uma linha separada;

### usando o loop `while` aninhado

No caso do `while`, é necessário controlar explicitamente as condições de parada tanto do loop externo quanto do interno.

1. iterando sobre uma matriz com `while`

```python
>>> matriz = [
...     [1, 2, 3],
...     [4, 5, 6],
...     [7, 8, 9]
... ]
>>>
>>> i = 0
>>> while i < len(matriz):
>>>     j = 0
>>>     while j < len(matriz[i]):
>>>         print(matriz[i][j], end=' ')
>>>         j += 1
>>>     print()
>>>     i += 1
1 2 3
4 5 6
7 8 9
>>> |
```

1. O loop externo `while i < len(matriz)` controla a iteração sobre as linhas da matriz.
1. O loop interno `while j < len(matriz[i])` controla a iteração sobre os elementos dentro da linha atual.
1. O `print(matriz[i][j], end=' ')` imprime cada elemento da linha.
1. Após o loop interno, o `print()` cria uma nova linha.
1. `i += 1` e `j += 1` atualizam os contadores para mover-se para a próxima linha e próximo elemento, respectivamente.

### usando `for` e `while` juntos

É também possível combinar `for` e `while` em loops aninhados, dependendo da lógica que deseja implementar.

1. `for` e `while` juntos

```python
>>> matriz = [
...     [1, 2, 3],
...     [4, 5, 6],
...     [7, 8, 9]
... ]
>>>
>>> for linha in matriz:
...     j = 0
...     while j < len(linha):
...         print(linha[j], end=' ')
...         j += 1
...     print()
1 2 3
4 5 6
7 8 9
>>> |
```

1. O loop externo `for linha in matriz` percorre cada linha da matriz;
1. O loop interno `while j < len(linha)` percorre cada elemento da linha usando um contador manual `j`;
1. O `print(linha[j], end=' ')` imprime cada elemento;
1. O `print()` no final quebra a linha;

### exercícios loops aninhados

<details>
<summary>Lista de Exercícios</summary>

1. exercícios com `for` aninhado
    1. crie um programa que imprime o seguinte padrão utilizando loops aninhados `for`:
    ```
    *
    * *
    * * *
    * * * *
    * * * * *
    ```
    ```python
    for i in range(0,5):
        # print(f'{list(range(0,i+1)) = }')
        for j in range(0, i+1):
            print('*', end='')
        print()


    i = 0
    while i < 5:
        j = 0
        while j < i+1:
            print('*', end='')
            j = j + 1
        print()
        i = i + 1
    ```
    1. dda uma matriz 3x3, crie um programa que soma todos os elementos da matriz usando loops `for` aninhados.
    1. crie uma lista de listas onde cada sublista contém os números de 1 a 5. Use loops `for` aninhados para imprimir todos os elementos.
    1. dada uma matriz 4x4, use loops `for` aninhados para imprimir a diagonal principal (elementos onde o índice da linha é igual ao índice da coluna).
    1. escreva um programa que crie um tabuleiro de xadrez 8x8 utilizando loops `for` aninhados, onde o tabuleiro é representado por "X" e "O".
1. exercícios com `while` aninhado
    1. crie um programa que imprime o seguinte padrão utilizando loops aninhados `while`:
    ```
    1
    1 2
    1 2 3
    1 2 3 4
    1 2 3 4 5
    ```
    1. dada uma matriz 3x3, escreva um programa que encontra o maior valor da matriz utilizando loops `while` aninhados.
    1. usando loops `while` aninhados, crie um programa que imprime uma matriz identidade 4x4.
    1. escreva um programa que cria uma matriz 5x5 e preenche-a com números aleatórios entre 1 e 100. Use loops `while` aninhados para encontrar e imprimir o menor valor da matriz.
    1. crie um programa que usa loops `while` aninhados para imprimir todos os números pares de uma matriz 3x3.
1. exercícios com combinação de `for` e `while`
    1. dada uma lista de listas, use um loop `for` externo e um loop `while` interno para imprimir todos os elementos das sublistas.
    1. crie um programa que use um loop `while` externo para iterar sobre os índices de uma lista de listas e um loop `for` interno para somar os elementos de cada sublista.
    1. escreva um programa que leia uma matriz 4x4 e use um loop `for` para iterar sobre as linhas e um loop `while` para contar o número de elementos pares em cada linha.
    1. dada uma matriz 3x3, use um loop `for` externo para iterar sobre as linhas e um loop `while` interno para calcular o produto dos elementos de cada linha.
    1. crie um programa que usa um loop `while` para iterar sobre uma lista de listas e um loop `for` para encontrar a soma dos elementos ímpares em cada sublista.
1. Exercícios Avançados
    1. escreva um programa que gere uma matriz 3x3 com números aleatórios entre 1 e 50. Use loops `for` aninhados para transpor a matriz (trocar linhas por colunas).
    1. dada uma matriz `NxN`, escreva um programa que utilize loops aninhados `while` para calcular a soma dos elementos acima da diagonal principal.
    1. crie um programa que leia duas matrizes 3x3 e use loops `for` aninhados para calcular a soma dessas matrizes.
    1. dada uma matriz `M x N`, crie um programa que use loops `for` e `while` aninhados para imprimir os elementos na forma de espiral.
    1. crie um programa que usa um loop `for` para iterar sobre os índices de uma lista de listas e um loop `while` para encontrar o maior número primo em cada sublista.

</details>

## for vs while

No Python, os loops `for` e `while` são estruturas de repetição que permitem executar um bloco de código várias vezes, mas funcionam de maneiras diferentes.

### loop `for`

O loop `for` é utilizado para iterar sobre uma sequência (como uma lista, tupla, string ou range). Ele percorre cada elemento da sequência, um por um, até que todos os elementos tenham sido processados.

```python
>>> estrutura básica
>>> for elemento in sequencia:
...     # Bloco de código a ser repetido
```

- **`elemento`** : uma variável que assume o valor de cada item da sequência em cada iteração;
- **`sequencia`** : a sequência de elementos que será iterada;

#### características do `for`
1. **iteração pré-definida** : o número de iterações é conhecido desde o início, baseado no tamanho da sequência;
2. **fácil manipulação de sequências** : ideal para trabalhar com listas, strings, tuplas, etc;
3. **menos propenso a loops infinitos** : como o número de iterações é determinado pela sequência, é menos provável que o loop entre em um estado infinito;

### loop `while`

O loop `while` repete um bloco de código enquanto uma condição booleana é verdadeira. Ele é útil quando o número de iterações não é conhecido de antemão, mas depende de uma condição que pode mudar durante a execução do loop.

```python
>>> # estrutura básica
>>> while condicao:
>>>     # Bloco de código a ser repetido
```

- **`condicao`** : uma expressão que é avaliada antes de cada iteração. Se for `True`, o loop continua; se for `False`, o loop para;

#### características do `while`
1. **iteração não definida** : o número de iterações depende da condição, e pode não ser conhecido antecipadamente;
2. **flexibilidade** : permite loops mais complexos, onde a condição de término pode depender de várias variáveis;
3. **propenso a loops infinitos** : se a condição nunca se tornar `false`, o loop continuará indefinidamente;


### comparação `for` vs `while`

| característica | `for` | `while` |
| ---- | ---- | ---- |
| **uso principal** | iteração sobre sequências conhecidas | condições complexas ou indefinidas |
| **número de iterações** | pré-determinado (baseado na sequência) | indeterminado (baseado na condição)|
| **sintaxe** | mais concisa para iterar sequências | mais flexível, mas potencialmente mais longa |
| **segurança** | menos propenso a loops infinitos | maior risco de loops infinitos |
| **aplicabilidade** | ideal para listas, strings, tuplas, etc. | ideal para loops dependentes de condições variáveis |
| **controle do loop** | controlado pela sequência | controlado pela condição booleana |

### quando usar `for`?
- quando o número de iterações é conhecido ou pode ser determinado com base na sequência (como iterar sobre uma lista ou usando `range()`).
- quando se deseja iterar sobre cada elemento de uma estrutura de dados.

### quando usar `while`?
- quando o número de iterações não é conhecido antecipadamente e depende de uma condição que pode variar durante a execução.
- quando é necessário repetir uma ação até que uma determinada condição seja atendida.

### exemplos

1. iterar uma lista de números e imprimir cada elemento :
    ```python
    >>> numeros = [1, 2, 3, 4, 5]
    >>>
    >>> # iterando com for
    >>> for numero in numeros:
    ...     print(numero)
    ...
    1
    2
    3
    4
    5
    >>>
    >>> # iterando com o while
    >>> i = 0
    >>>
    >>> while i < len(numeros):
    ...     numero = numeros[i]
    ...     print(numero)
    ...     i += 1
    ...
    1
    2
    3
    4
    5
    >>> |
    ```

1. somar os números de 1 a 5 :
    ```python
    >>> # iterando com for
    >>> soma = 0
    >>>
    >>> for i in range(1, 6):
    ...     soma += i
    ...
    >>> print(soma)
    15
    >>>
    >>> # iterando com while
    >>>soma = 0
    >>> i = 1
    >>>
    >>> while i <= 5:
    ...     soma += i
    ...     i += 1
    ...
    >>> print(soma)
    15
    >>> |
    ```

1. encontrar o primeiro número par em uma lista :
    ```python
    >>> numeros = [1, 3, 5, 6, 7, 9]
    >>>
    >>> # iterando com for
    >>>
    >>> for numero in numeros:
    ...     if numero % 2 == 0:
    ...         print(f"Primeiro número par : {numero}")
    ...         break
    ...
    Primeiro número par : 6
    >>>
    >>> # iterando com while
    >>> i = 0
    >>>
    >>> while i < len(numeros):
    ...     numero = numeros[i]
    ...     if numero % 2 == 0:
    ...         print(f"Primeiro número par : {numero}")
    ...         break
    ...     i += 1
    ...
    Primeiro número par : 6
    >>> |
    ```

1. contar até que um número aleatório seja maior que 5 :

    Esse exemplo é mais adequado para `while`, mas pode ser adaptado com um loop controlado.

    ```python
    >>> import random
    >>>
    >>> # iterando com for
    >>> for _ in range(100):  # define um limite arbitrário para evitar loop infinito
    ...     numero = random.randint(1, 10)
    ...     print(numero)
    ...         if numero > 5:
    ...         break
    ...
    3
    1
    2
    6
    >>>
    >>> # iterando com while
    >>> numero = 0
    >>>
    >>> while numero <= 5:
    ...     numero = random.randint(1, 10)
    ...     print(numero)
    ...
    1
    4
    7
    >>> |
    ```

1. repetir uma string 5 vezes
    ```python
    >>> # iterando com for
    >>> for _ in range(5):
    ...     print("Olá")
    ...
    Olá
    Olá
    Olá
    Olá
    Olá
    >>>
    >>> # iterando com while
    >>> i = 0
    >>>
    >>> while i < 5:
    ...     print("Olá")
    ...     i += 1
    ...
    Olá
    Olá
    Olá
    Olá
    Olá
    >>> |
    ```

## exercícios for vs while

<details>
<summary>Lista de Exercícios</summary>

Para cada exercício abaixo, crie as duas versões, isto é, use tanto o loop `for` quanto o loop `while`.

Exemplo :
```python
# imprimir cada elemento de uma lista de frutas :
# dada a lista frutas = ['maçã', 'banana', 'cereja'],
# imprima cada fruta;
frutas = ['maçã', 'banana', 'cereja']

# iterando com for
for fruta in frutas:
    print(fruta)

# iterando com while
i = 0
while i < len(frutas):
    print(frutas[i])
    i += 1

# outra forma com while
i = 0
while i < len(frutas):
    fruta = frutas[i]
    print(fruta)
    i += 1
```

1. **imprimir cada elemento de uma lista de frutas** : dada a lista `frutas = ['maçã', 'banana', 'cereja']`, imprima cada fruta;
1. **somar todos os números em uma tupla** : dada a tupla `numeros = (1, 2, 3, 4, 5)`, calcule e imprima a soma de todos os elementos;
1. **contar o número de vogais em uma string** : dada a string `texto = "programacao"`, conte quantas vogais existem no texto;
1. **reverter uma lista de números** : dada a lista `numeros = [1, 2, 3, 4, 5]`, imprima os números na ordem inversa;
1. **concatenar todas as strings em uma lista** : dada a lista `palavras = ['Eu', 'gosto', 'de', 'programar']`, concatene todas as strings em uma única string e imprima o resultado;
1. **encontrar o maior número em uma lista** : dada a lista `numeros = [4, 7, 1, 9, 3]`, encontre e imprima o maior número;
1. **contar quantos números pares existem em uma tupla** : dada a tupla `numeros = (2, 5, 8, 11, 14)`, conte quantos números são pares;
1. **imprimir cada caractere de uma string** : dada a string `nome = "Python"`, imprima cada caractere em uma linha separada;
1. **somar os números ímpares em uma lista** : dada a lista `numeros = [1, 2, 3, 4, 5, 6, 7]`, calcule a soma de todos os números ímpares;
1. **verificar se uma lista contém um número específico** : dada a lista `numeros = [10, 20, 30, 40, 50]` e o número `30`, verifique se o número está presente na lista;
1. **contar quantas vezes uma letra específica aparece em uma string** : dada a string `frase = "banana"` e a letra `a`, conte quantas vezes a letra `a` aparece;
1. **imprimir os elementos de uma tupla que estão em posições pares** : dada a tupla `numeros = (10, 20, 30, 40, 50, 60)`, imprima os elementos que estão em posições pares;
1. **criar uma nova lista apenas com os elementos ímpares de uma lista** : dada a lista `numeros = [1, 2, 3, 4, 5, 6]`, crie e imprima uma nova lista contendo apenas os números ímpares;
1. **concatenar os caracteres de uma string em ordem inversa** : dada a string `texto = "abcd"`, crie e imprima uma nova string com os caracteres em ordem inversa;
1. **multiplicar todos os elementos de uma lista por 2** : dada a lista `numeros = [2, 4, 6, 8]`, crie uma nova lista onde cada elemento é o dobro do valor original;
1. **contar quantos números negativos existem em uma lista** : dada a lista `numeros = [-3, -2, 0, 1, 4]`, conte quantos números são negativos;
1. **verificar se uma string é um palíndromo** : dada a string `palavra = "radar"`, verifique se a palavra é um palíndromo (lê-se da mesma forma de trás para frente);
1. **imprimir os elementos de uma tupla até encontrar um valor específico** : dada a tupla `numeros = (5, 10, 15, 20, 25)` e o número `15`, imprima os elementos até encontrar o número 15 (inclusive);
1. **substituir todas as vogais de uma string por `*`** : dada a string `frase = "substituir vogais"`, crie e imprima uma nova string onde todas as vogais são substituídas por `*`;
1. **imprimir o índice e o valor de cada elemento em uma lista** : dada a lista `numeros = [10, 20, 30, 40]`, imprima o índice e o valor de cada elemento;
1. **criar uma nova tupla apenas com os números maiores que 10** : dada a tupla `numeros = (3, 10, 15, 7, 20)`, crie e imprima uma nova tupla contendo apenas os números maiores que 10;
1. **imprimir uma string em formato de pirâmide** : dada a string `texto = "PYTHON"`, imprima a string em formato de pirâmide :
    ```
    P
    PY
    PYT
    PYTH
    PYTHO
    PYTHON
    ```
1. **remover todos os elementos duplicados de uma lista**: dada a lista `numeros = [1, 2, 2, 3, 4, 4, 5]`, crie e imprima uma nova lista sem elementos duplicados;
1. **imprimir apenas os caracteres que são letras maiúsculas de uma string**: dada a string `texto = "Programação Em Python"`, imprima apenas as letras maiúsculas;
1. **imprimir todos os elementos de uma lista de trás para frente**: dada a lista `numeros = [1, 2, 3, 4, 5]`, imprima os elementos começando do último até o primeiro;

</details>

## `else` em loops

No Python, o bloco `else` pode ser usado em conjunto com os loops `for` e `while`, e seu comportamento é um pouco diferente do que se vê em outras linguagens de programação. O bloco `else` em um loop é executado quando o loop termina normalmente, ou seja, quando ele não é interrompido por um `break`.

### `else` com `for`

No contexto de um loop `for`, o bloco `else` é executado após o loop percorrer todos os elementos do iterável. Se o loop for interrompido por um comando `break`, o bloco `else` é ignorado.

**exemplo 1 : loop `for` sem `break`**

```python
numeros = [1, 2, 3, 4, 5]

for numero in numeros:
    print(numero)
else:
    print("Loop completado sem interrupções.")
```

- o loop `for` percorre todos os números na lista `numeros`;
- após o loop terminar, o bloco `else` é executado, imprimindo "Loop completado sem interrupções.";
- como não há `break`, o `else` sempre será executado;

**exemplo 2 : loop `for` com `break`**

```python
numeros = [1, 2, 3, 4, 5]

for numero in numeros:
    if numero == 3:
        print("Número 3 encontrado, interrompendo o loop.")
        break
    print(numero)
else:
    print("Loop completado sem interrupções.")
```

- o loop `for` percorre os números até encontrar o número 3;
- quando o número 3 é encontrado, o loop é interrompido com `break`;
- neste caso, o bloco `else` não é executado porque o loop foi interrompido;

### `else` com `while`

O funcionamento do `else` em um loop `while` é semelhante ao do `for`. O bloco `else` é executado quando o loop termina normalmente, ou seja, quando a condição do `while` se torna falsa. Se o loop for interrompido por um `break`, o bloco `else` não é executado.

**exemplo 3 : loop `while` sem `break`**

```python
contador = 0

while contador < 5:
    print(contador)
    contador += 1
else:
    print("Loop `while` completado sem interrupções.")
```

- o loop `while` continua enquanto `contador` for menor que 5;
- quando a condição `contador < 5` se torna falsa, o loop termina, e o bloco `else` é executado, imprimindo "Loop `while` completado sem interrupções.";

**exemplo 4 : loop `while` com `break`**

```python
contador = 0

while contador < 5:
    if contador == 3:
        print("Contador atingiu 3, interrompendo o loop.")
        break
    print(contador)
    contador += 1
else:
    print("Loop `while` completado sem interrupções.")
```

- O loop `while` continua até `contador` atingir 3.
- Quando `contador` é igual a 3, o loop é interrompido com `break`.
- O bloco `else` não é executado porque o loop foi interrompido antes que a condição se tornasse falsa.

### resumo

- o `else` no `for` ou `while` é executado quando o loop termina naturalmente, sem ser interrompido por um `break`;
- se o loop for interrompido com um `break`, o bloco `else` é ignorado;
- o uso de `else` com loops pode ser útil para executar código que deve rodar apenas se o loop percorrer todos os elementos ou todas as iterações sem interrupções;

Essa funcionalidade é especialmente útil em casos onde você está procurando um item em uma coleção. Se o item for encontrado e o loop for interrompido, você não deseja executar o bloco `else`, mas se o item não for encontrado e o loop terminar normalmente, o `else` pode ser usado para indicar que a busca não teve sucesso.

## exercícios else

<details>
<summary>Lista de Exercícios</summary>

1. Dada a lista `numeros = [1, 2, 3, 4, 5]`, crie um loop `for` que percorra a lista e imprima cada número. Use um bloco `else` para imprimir "Loop finalizado" após a conclusão do loop.
1. Crie um loop `for` que percorra a string `"python"` e imprima cada caractere. No bloco `else`, imprima "Todos os caracteres foram exibidos".
1. Dado o tuple `nomes = ("Alice", "Bob", "Carlos", "Diana")`, crie um loop `for` que pare quando encontrar o nome "Carlos". Use `else` para imprimir "Nome não encontrado" caso "Carlos" não esteja no tuple.
1. Crie um loop `while` que continue enquanto o comprimento da lista `numeros = [2, 4, 6, 8, 10]` for maior que 0. Remova um elemento da lista a cada iteração e, quando o loop terminar, use `else` para imprimir "Todos os elementos foram removidos".
1. Dado o set `letras = {'a', 'b', 'c', 'd'}`, crie um loop `for` que percorra o set e imprima cada letra. No bloco `else`, imprima "Loop completo sem interrupções".
1. Dada a lista `numeros = [10, 20, 30, 40, 50]`, crie um loop `for` que interrompa a execução quando encontrar o número 30. Use `else` para imprimir "Número não encontrado" se o loop não for interrompido.
1. Crie um loop `while` que continue a remover o último caractere da string `texto = "abcdef"` enquanto o comprimento da string for maior que 3. Use `else` para imprimir "Texto curto" ao final.
1. Dado o tuple `pontos = (10, 20, 30, 40, 50)`, crie um loop `for` que pare quando o valor 60 for encontrado. Use `else` para imprimir "Valor não encontrado" se o loop terminar sem interrupção.
1. Dado o set `numeros = {1, 2, 3, 4, 5}`, crie um loop `for` que percorra o set e imprima cada número. Use um `else` para indicar que todos os números foram exibidos.
1. Crie um loop `while` que percorra a string `"palavra"` e interrompa o loop se encontrar o caractere `"w"`. Use `else` para imprimir "Caractere não encontrado" se o loop não for interrompido.
1. Dado o tuple `numeros = (1, 2, 3, 4, 5)`, crie um loop `for` que imprima cada número. Use `else` para imprimir "Fim do loop" após o loop percorrer todos os números.
1. Crie um loop `while` que continue removendo o primeiro elemento da lista `letras = ['a', 'b', 'c', 'd']` enquanto o comprimento da lista for maior que 1. Use `else` para imprimir "Apenas uma letra restante".
1. Dado o set `vogais = {'a', 'e', 'i', 'o', 'u'}`, crie um loop `for` que pare quando a letra `"i"` for encontrada. Use `else` para imprimir "Letra não encontrada" se o loop não for interrompido.
1. Crie um loop `while` que continue a iterar enquanto o número de elementos na lista `numeros = [10, 20, 30]` for maior que 2. Use `else` para imprimir "Quantidade de elementos suficiente".
1. Dado o tuple `frutas = ("maçã", "banana", "laranja", "uva")`, crie um loop `for` que imprima cada fruta. Use `else` para imprimir "Todas as frutas foram exibidas" ao final.
1. Crie um loop `while` que continue enquanto a string `"abcdefg"` contiver o caractere `"c"`. Remova `"c"` da string e use `else` para imprimir "Caractere removido com sucesso".
1. Dado o set `numeros = {1, 2, 3, 4, 5}`, crie um loop `for` que interrompa quando encontrar o número 4. Use `else` para imprimir "Número não encontrado" caso o loop não seja interrompido.
1. Crie um loop `while` que percorra a string `"looping"` e pare se encontrar o caractere `"p"`. Use `else` para imprimir "Nenhum caractere 'p' encontrado" se o loop não for interrompido.
1. Dado o tuple `cores = ("vermelho", "azul", "verde", "amarelo")`, crie um loop `for` que imprima cada cor. Use `else` para imprimir "Fim das cores" após o loop.
1. Crie um loop `while` que continue removendo elementos do set `numeros = {5, 10, 15, 20}` enquanto ele não estiver vazio. Use `else` para imprimir "Set vazio".

</details>


# expressoes-regulares.md

# índice

1. [introdução](#introdução)
1. [funções](#funções)
    1. [`re.search()`](#research)
    1. [`re.match()`](#rematch)
    1. [`re.findall()`](#refindall)
    1. [`re.sub()`](#resub)
    1. [`re.split()`](#resplit)
    1. [`re.compile()`](#recompile)
    1. [`re.escape()`](#reescape)
1. [metacaracteres](#metacaracteres)
    1. [`.` (ponto)](#-ponto)
    1. [`^` (circunflexo)](#-circunflexo)
    1. [`$` (cifrão)](#-cifrão)
    1. [`*` (asterisco)](#-asterisco)
    1. [`+` (mais)](#-mais)
    1. [`?` (interrogação)](#-interrogação)

# expressões regulares

## introdução

Uma [**expressão regular**](https://docs.python.org/pt-br/3/library/re.html) (ou regex) é uma sequência de caracteres que forma um padrão de busca. Essas expressões podem ser usadas para procurar, corresponder ou manipular textos.

No Python, para trabalhar com expressões regulares, utiliza-se o módulo **`re`**.

### importando módulo `re`

Para usar as expressões regulares, é preciso importar o módulo `re` :

```python
import re
```

Abaixo, a função `re.search()` é usada para procurar um padrão em uma string. Mais detalhes serão vistos adiante.

**exemplo :**

```python
import re

# definindo uma string
texto = "Hoje é um belo dia!"

# procurando pela palavra 'belo'
resultado = re.search("belo", texto)

# verificando se encontramos algo
if resultado:
    print("Padrão encontrado!")
else:
    print("Padrão não encontrado.")
```

Aqui, está sendo procurado a palavra "belo" na string "Hoje é um belo dia!". Se a palavra for encontrada, a seguinte mensagem será exibida :

```
Padrão encontrado!
```

Se o padrão não for encontrado, `re.search()` retorna `None`, o que será interpretado como falso.

**exemplo :**

```python
resultado = re.search("noite", texto)

if resultado:
    print("Padrão encontrado!")
else:
    print("Padrão não encontrado.")
```

Nesse caso, como "noite" não está presente na string, o resultado será:

```
Padrão não encontrado.
```

### case-sensitive

As expressões regulares possuem sensibilidade a maiúsculas e minúsculas (**case-sensitive**), o que significa que "belo" não é o mesmo que "Belo".

**exemplo :**

```python
resultado = re.search("Belo", texto)

if resultado:
    print("Padrão encontrado!")
else:
    print("Padrão não encontrado.")
```

Aqui, o padrão "Belo" não será encontrado porque no texto a palavra está escrita com letra minúscula.

```
Padrão não encontrado.
```

## resumo

Abaixo há três tabelas com o resumo da maior parte do conteúdo que será visto :

| Função | Explicação | Exemplo |
|---|---|---|
| `re.search(pattern, string, flags=0)` | Procura a primeira ocorrência do padrão na string. Retorna um objeto Match se encontrar, caso contrário retorna None. | `re.search(r'\d+', 'abc123def')` retorna um objeto Match correspondendo a '123'. |
| `re.match(padrao, string)` | Procura o padrão no início da string. Retorna um objeto Match se encontrar, caso contrário retorna None. | `re.match(r'\d+', '123abc')` retorna um objeto Match correspondendo a '123', mas `re.match(r'\d+', 'abc123')` retorna None. |
| `re.fullmatch(padrao, string)` | Procura o padrão em toda a string (do início ao fim). Retorna um objeto Match se encontrar, caso contrário retorna None. | `re.fullmatch(r'\d+', '123')` retorna um objeto Match, mas `re.fullmatch(r'\d+', '123abc')` retorna None. |
| `re.findall(padrao, string)` | Retorna uma lista com todas as ocorrências não sobrepostas do padrão na string. | `re.findall(r'\d+', 'abc123def456')` retorna ['123', '456']. |
| `re.finditer(padrao, string)` | Retorna um iterador que produz objetos Match para cada ocorrência não sobreposta do padrão na string. | `for m in re.finditer(r'\d+', 'abc123def456'): print(m.group())` imprime '123' e '456'. |
| `re.sub(padrao, substituicao, string)` | Substitui as ocorrências do padrão na string pela string de substituição. | `re.sub(r'\d+', 'NUM', 'abc123def')` retorna 'abcNUMdef'. |
| `re.split(padrao, string)` | Divide a string em uma lista usando o padrão como delimitador. | `re.split(r'\s+', 'olá mundo!')` retorna ['olá', 'mundo!']. |
| `re.compile(padrao)` | Compila o padrão em um objeto Pattern, que pode ser usado para realizar buscas e substituições de forma mais eficiente. | `padrao = re.compile(r'\d+')` cria um objeto Pattern que pode ser usado posteriormente com `padrao.search()`, `padrao.findall()`, etc. |
| `re.escape(padrao)` | Faz o escape de todos os caracteres especiais no padrão, para que sejam tratados como literais. | `re.escape('a.b')` retorna 'a\.b'. |

| Metacaractere | Explicação | Exemplo |
|---|---|---|
| `.` | Corresponde a qualquer caractere, exceto quebras de linha. | `a.c` corresponde a "abc", "a1c", etc. |
| `^` | Corresponde ao início da string ou linha. | `^Olá` corresponde a "Olá mundo", mas não a "O mundo diz Olá". |
| `$` | Corresponde ao final da string ou linha. | `mundo$` corresponde a "Olá mundo", mas não a "O mundo diz Olá". |
| `*` | Corresponde a zero ou mais ocorrências do elemento anterior. | `ab*c` corresponde a "ac", "abc", "abbc", etc. |
| `+` | Corresponde a uma ou mais ocorrências do elemento anterior. | `ab+c` corresponde a "abc", "abbc", mas não a "ac". |
| `?` | Corresponde a zero ou uma ocorrência do elemento anterior. | `ab?c` corresponde a "ac" e "abc". |
| `{}` | Especifica um número exato ou um intervalo de repetições. | `a{2}b` corresponde a "aab", `a{2,4}b` corresponde a "aab", "aaab" e "aaaab". |
| `[]` | Define um conjunto de caracteres. | `[abc]` corresponde a "a", "b" ou "c". |
| `[^]` | Define um conjunto de caracteres negado. | `[^abc]` corresponde a qualquer caractere que não seja "a", "b" ou "c". |
| `\` | Escapa um metacaractere ou representa uma sequência especial. | `\d` corresponde a qualquer dígito, `\.` corresponde a um ponto literal. |
| `\|` | Representa uma alternativa (OU). | `gato\|cachorro` corresponde a "gato" ou "cachorro". |
| `()` | Agrupa partes da expressão e cria um grupo de captura. | `(ab)+` corresponde a "ab", "abab", "ababab", etc. |
| `\w` | Corresponde a qualquer caractere alfanumérico ou sublinhado. | `\w+` corresponde a "palavra", "palavra123", "_palavra", etc. |
| `\W` | Corresponde a qualquer caractere que não seja alfanumérico ou sublinhado. | `\W+` corresponde a "espaço ", "!@#$", etc. |
| `\d` | Corresponde a qualquer dígito. | `\d+` corresponde a "123", "456789", etc. |
| `\D` | Corresponde a qualquer caractere que não seja um dígito. | `\D+` corresponde a "abc", "olá mundo", etc. |
| `\s` | Corresponde a qualquer espaço em branco (espaço, tabulação, nova linha, etc.). | `\s+` corresponde a " ", "\t\n", etc. |
| `\S` | Corresponde a qualquer caractere que não seja um espaço em branco. | `\S+` corresponde a "palavra", "123", etc. |
| `\b` | Corresponde a um limite de palavra. | `\bpalavra\b` corresponde a "palavra" em "a palavra é", mas não em "apalavraé". |
| `\B` | Corresponde a um local que não é um limite de palavra. | `\Bpalavra\B` corresponde a "palavra" em "apalavraé", mas não em "a palavra é". |

| Flag | Nome | Descrição                                                                                     |
|----|----|----|
| `re.IGNORECASE`  Ignore case (ou `re.I`) | Faz a correspondência sem diferenciar maiúsculas e minúsculas. |
| `re.MULTILINE` | Multiline (ou `re.M`) | Altera o comportamento de `^` e `$` para corresponder ao início e fim de cada linha, não apenas da string. |
| `re.DOTALL` | Dot all (ou `re.S`) | Faz com que o metacaractere `.` corresponda a todos os caracteres, incluindo quebras de linha. |
| `re.VERBOSE` | Verbose (ou `re.X`) | Permite adicionar espaços e comentários dentro do padrão regex para maior legibilidade. |
| `re.ASCII` | ASCII (ou `re.A`) | Faz com que escapes como `\w`, `\b`, `\s` correspondam apenas a caracteres ASCII. |
| `re.LOCALE` | Locale (ou `re.L`) | Faz com que escapes como `\w`, `\b`, `\s` dependam das convenções locais (obsoleto em Unicode). |
| `re.UNICODE` | Unicode (ou `re.U`) | Faz com que escapes como `\w`, `\b`, `\d` correspondam a caracteres Unicode (padrão no Python 3). |

**Observações:**

* essas tabelas incluem algumas das funcionalidades mais comuns, mas existem outros disponíveis;

## funções

### `re.search()`

A função `re.search()` procura o **primeiro** local onde o padrão é encontrado em qualquer parte da string. Se uma correspondência for encontrada, ela retorna um objeto de correspondência. Caso contrário, retorna `None`.

```python
re.search(padrão, string, flags=0)
```

- **`padrão`** : o padrão que você quer procurar (expressão regular);
- **`string`** : a string onde será feita a busca;
- **`flags`** : parâmetro opcional para modificar o comportamento da busca (isso será visto mais tarde);

1. **exemplo buscando palavra em frase**

    ```python
    import re

    # texto para busca
    texto = "O Python é uma linguagem poderosa."

    # procurando pela palavra "Python"
    resultado = re.search("Python", texto)

    # verificando se o padrão foi encontrado
    if resultado:
        print("Padrão encontrado:", resultado.group())
    else:
        print("Padrão não encontrado.")
    ```

    **Explicação**
    - **`re.search("Python", texto)`** : procura pela palavra "Python" em qualquer parte da string `texto`;
    - **`resultado.group()`** : se a correspondência for encontrada, `group()` retorna o texto que correspondeu ao padrão;

    **Saída**
    ```
    Padrão encontrado: Python
    ```

1. **exemplo caso padrão não encontrado**

    ```python
    # procurando pela palavra "Java"
    resultado = re.search("Java", texto)

    # verificando se o padrão foi encontrado
    if resultado:
        print("Padrão encontrado:", resultado.group())
    else:
        print("Padrão não encontrado.")
    ```

    Neste exemplo, a palavra "Java" não está presente no texto, então o resultado será :

    **Saída**
    ```
    Padrão não encontrado.
    ```

1. **exemplo usando `re.search()` com metacaracteres**

    Abaixo, é buscado qualquer palavra que comece com "P".

    ```python
    # procurando qualquer palavra que comece com "P"
    resultado = re.search(r"\bP\w+", texto)

    if resultado:
        print("Padrão encontrado:", resultado.group())
    else:
        print("Padrão não encontrado.")
    ```

    **Explicação**
    - **`\b`** : indica uma borda de palavra (mais detalhes adiante);
    - **`P\w+`** : procura por "P" seguido de um ou mais caracteres alfanuméricos;

    **Saída**
    ```
    Padrão encontrado: Python
    ```

### exercícios `re.search()`

<details>
<summary>Lista de Exercícios</summary>

1. Crie uma string que contenha o nome de três frutas separadas por vírgulas. Utilize a função `search()` para verificar se a fruta "banana" está presente na string.
1. Escreva uma string com uma frase sobre seu animal de estimação. Use `search()` para encontrar a palavra "cachorro" na frase e imprima o resultado.
1. Crie uma lista de compras como uma string. Utilize `search()` para verificar se "leite" está na lista.
1. Defina uma string que represente uma frase famosa. Use `search()` para localizar a palavra "liberdade" na frase.
1. Escreva uma string que contenha uma sequência de números de telefone. Utilize `search()` para buscar um número específico na sequência.
1. Crie uma string com um texto de uma receita culinária. Utilize `search()` para verificar se a palavra "açúcar" aparece na receita.
1. Defina uma string que contenha a letra do seu artista favorito. Use `search()` para verificar se uma palavra-chave relacionada ao tema da música está presente.
1. Crie uma string que contenha o nome de várias cidades. Utilize `search()` para procurar uma cidade específica e imprima se ela foi encontrada.
1. Escreva uma string que descreva um filme que você gosta. Utilize `search()` para verificar se o nome do ator principal está na descrição.
1. Defina uma string que contenha uma lista de tarefas a serem realizadas. Utilize `search()` para buscar uma tarefa específica e verifique se ela está listada.

</details>

---

### `re.match()`

A função `re.match()` tenta encontrar uma correspondência **no início da string**. Se a string começar com o padrão, ele retorna um objeto de correspondência. Caso contrário, retorna `None`.

```python
re.match(padrão, string, flags=0)
```

- **`padrão`** : o padrão que você quer procurar (expressão regular);
- **`string`** : a string onde será feita a busca;
- **`flags`** : parâmetro opcional para modificar o comportamento da busca (isso será visto mais tarde);

1. **exemplo verificando se uma string começa com uma palavra específica**

    ```python
    import re

    # texto para buscar
    texto = "Python é uma linguagem poderosa."

    # verificando se o texto começa com "Python"
    resultado = re.match("Python", texto)

    if resultado:
        print("Padrão encontrado:", resultado.group())
    else:
        print("Padrão não encontrado.")
    ```

    **Explicação**
    - **`re.match("Python", texto)`** : verifica se a string `texto` começa com "Python";
    - **`resultado.group()`** : retorna a correspondência encontrada, se houver;

    **Saída**
    ```
    Padrão encontrado: Python
    ```

1. **exemplo caso em que o padrão não está no início da string**

    ```python
    # texto para busca
    texto = "Aprender Python é muito interessante."

    # verificando se o texto começa com "Python"
    resultado = re.match("Python", texto)

    if resultado:
        print("Padrão encontrado:", resultado.group())
    else:
        print("Padrão não encontrado.")
    ```

    Neste caso, como "Python" não está no início da string, `re.match()` não encontrará correspondência.

    **Saída**
    ```
    Padrão não encontrado.
    ```

1. **exemplo usando `re.match()` com metacaracteres**

    Aqui vai ser verificado se a string começa com uma palavra que começa com "A".

    ```python
    # verificando se o texto começa com uma palavra que começa com "A"
    resultado = re.match(r"A\w+", texto)

    if resultado:
        print("Padrão encontrado:", resultado.group())
    else:
        print("Padrão não encontrado.")
    ```

    **Explicação**
    - **`A\w+`** : verifica se a string começa com "A" seguido de caracteres alfanuméricos;

    **Saída**
    ```
    Padrão encontrado: Aprender
    ```

### exercícios `re.match()`

<details>
<summary>Lista de Exercícios</summary>

1. Crie uma string que contenha o nome de uma cidade. Utilize a função `match()` para verificar se a string começa com a letra "S".
1. Escreva uma string que represente uma frase sobre sua cor favorita. Use `match()` para verificar se a frase começa com a palavra "Minha".
1. Defina uma string que contenha uma lista de países. Utilize `match()` para verificar se a string começa com "Brasil".
1. Crie uma string que descreva um esporte que você gosta. Utilize `match()` para verificar se a descrição começa com a palavra "Futebol".
1. Escreva uma string com o nome de um autor famoso. Use `match()` para verificar se o nome começa com a letra "A".
1. Defina uma string que contenha uma receita de culinária. Utilize `match()` para verificar se a receita começa com a palavra "Para".
1. Crie uma string que contenha uma citação inspiradora. Use `match()` para verificar se a citação começa com "A vida".
1. Escreva uma string que descreva um filme que você assistiu recentemente. Utilize `match()` para verificar se a descrição começa com o título do filme.
1. Defina uma string que contenha uma sequência de números. Use `match()` para verificar se a sequência começa com o número "1".
1. Crie uma string que represente uma lista de hobbies. Utilize `match()` para verificar se a string começa com "Ler".

</details>

---

### `re.findall()`

A função `re.findall()` encontra **todas as correspondências** do padrão na string e retorna uma lista com as correspondências. Diferente de `search()`, que retorna apenas a primeira correspondência, `findall()` retorna todas as ocorrências encontradas.

```python
re.findall(padrão, string, flags=0)
```

- **`padrão`** : o padrão que você quer procurar (expressão regular);
- **`string`** : a string onde será feita a busca;
- **`flags`** : parâmetro opcional para modificar o comportamento da busca;

1. **exemplo encontrando todas as palavras em uma string**

    ```python
    # texto para busca
    texto = "Python é uma linguagem poderosa e Python é popular."

    # procurando todas as palavras "Python"
    resultado = re.findall(r"Python", texto)

    # exibindo todas as correspondências
    print("Correspondências encontradas:", resultado)
    ```

    **Explicação**
    - **`findall(r"Python", texto)`** : encontra todas as ocorrências da palavra "Python" na string `texto`;
    - a função retorna uma lista com todas as correspondências;

    **Saída**
    ```
    Correspondências encontradas: ['Python', 'Python']
    ```

    Aqui, a função encontrou a palavra "Python" duas vezes no texto.

1. **exemplo encontrando todas as palavras em um texto**

    Agora, veja a busca por todas as palavras, ou seja, sequências de letras.

    ```python
    # procurando todas as palavras
    resultado = re.findall(r"\b\w+\b", texto)

    # exibindo todas as palavras encontradas
    print("Palavras encontradas:", resultado)
    ```

    **Explicação**
    - **`\b\w+\b`** : esse padrão encontra palavras completas. O `\b` representa a borda de uma palavra, e `\w+` corresponde a uma sequência de caracteres alfanuméricos;
    - **`findall()`** retorna todas as palavras encontradas como uma lista;

    **Saída**
    ```
    Palavras encontradas: ['Python', 'é', 'uma', 'linguagem', 'poderosa', 'e', 'Python', 'é', 'popular']
    ```

1. **exemplo encontrando todos os números em uma string**

    ```python
    # texto com números
    texto = "O preço é 100 reais e o desconto é 15%."

    # procurando todos os números
    resultado = re.findall(r"\d+", texto)

    # exibindo os números encontrados
    print("Números encontrados:", resultado)
    ```

    **Explicação**
    - **`\d+`** : esse padrão corresponde a um ou mais dígitos (números);
    - **`findall()`** : retorna todas as ocorrências de números na string;

    **Saída**
    ```
    Números encontrados: ['100', '15']
    ```

    Neste exemplo, a função encontrou dois números: "100" e "15".

1. **exemplo buscando por padrões mais complexos**

    Veja uma busca por todas as palavras que começam com uma letra maiúscula.

    ```python
    # texto com palavras que começam com maiúsculas
    texto = "Python é uma linguagem Popular desenvolvida por Guido van Rossum."

    # procurando todas as palavras que começam com letra maiúscula
    resultado = re.findall(r"\b[A-Z]\w*\b", texto)

    # exibindo as correspondências encontradas
    print("Palavras encontradas:", resultado)
    ```

    **Explicação**
    - **`\b[A-Z]\w*\b`** : o padrão corresponde a palavras que começam com uma letra maiúscula (A-Z) seguida de zero ou mais caracteres alfanuméricos (`\w*`);
    - a função retorna uma lista com todas as correspondências;

    **Saída**
    ```
    Palavras encontradas: ['Python', 'Popular', 'Guido', 'Rossum']
    ```

### exercícios `re.findall()`

<details>
<summary>Lista de Exercícios</summary>

1. Crie uma string que contenha várias cores separadas por espaços. Utilize a função `findall()` para encontrar todas as ocorrências da palavra "azul" na string.
1. Escreva uma string que contenha os nomes de frutas separados por vírgulas. Use `findall()` para localizar todas as ocorrências da fruta "maçã".
1. Defina uma string que contenha uma sequência de palavras relacionadas a tecnologia. Utilize `findall()` para encontrar todas as ocorrências da palavra "computador".
1. Crie uma string que descreva as suas atividades diárias. Utilize `findall()` para listar todas as ocorrências da palavra "trabalho" na descrição.
1. Escreva uma string que contenha várias cidades separadas por ponto e vírgula. Use `findall()` para localizar todas as ocorrências da cidade "Paris".
1. Defina uma string que contenha uma sequência de nomes de pessoas. Utilize `findall()` para encontrar todas as ocorrências do nome "Ana".
1. Crie uma string que contenha o nome de várias marcas de carros. Use `findall()` para localizar todas as ocorrências da marca "Toyota".
1. Escreva uma string que contenha a letra de uma música. Utilize `findall()` para listar todas as ocorrências da palavra "amor" na letra.
1. Defina uma string que contenha os títulos de livros separados por barras. Use `findall()` para localizar todas as ocorrências do título "O Hobbit".
1. Crie uma string que represente uma lista de ingredientes para uma receita. Utilize `findall()` para encontrar todas as ocorrências da palavra "farinha" na lista.

</details>

---

### `re.sub()`

A função `re.sub()` substitui todas as ocorrências de um padrão em uma string por um valor especificado. É muito útil quando se precisa fazer substituições complexas em um texto.

```python
re.sub(padrão, substituição, string, contagem=0, flags=0)
```

- **`padrão`** : o padrão (expressão regular) que você quer substituir;
- **`substituição`** : o texto ou valor que substituirá o padrão;
- **`string`** : a string onde será feita a substituição;
- **`contagem`** (opcional) : o número máximo de substituições a serem feitas. O valor padrão é 0, o que significa substituir todas as ocorrências;
- **`flags`** (opcional) : modificadores de comportamento das expressões regulares;

1. **exemplo substituindo uma palavra por outra**

    ```python
    import re

    # texto onde vamos fazer a substituição
    texto = "Eu adoro maçã. A maçã é minha fruta favorita."

    # substituindo "maçã" por "banana"
    resultado = re.sub(r"maçã", "banana", texto)

    # exibindo o resultado
    print("Texto após substituição:", resultado)
    ```

    **Explicação**
    - **`re.sub(r"maçã", "banana", texto)`** : substitui todas as ocorrências da palavra "maçã" por "banana";

    **Saída**
    ```
    Texto após substituição: Eu adoro banana. A banana é minha fruta favorita.
    ```

1. **exemplo limitando o número de substituições**

    ```python
    # substituindo "maçã" por "banana", mas limitando a 1 substituição
    resultado = re.sub(r"maçã", "banana", texto, count=1)

    # exibindo o resultado
    print("Texto após substituição:", resultado)
    ```

    **Explicação**
    - **`count=1`** : limita a substituição a apenas uma ocorrência;

    **Saída**
    ```
    Texto após substituição: Eu adoro banana. A maçã é minha fruta favorita.
    ```

1. **exemplo substituindo números por uma string fixa**

    Veja a substituição de todos os números em uma string pela palavra "número".

    ```python
    # texto com números
    texto = "O preço é 100 reais e o desconto é 15%."

    # substituindo números por "número"
    resultado = re.sub(r"\d+", "número", texto)

    # exibindo o resultado
    print("Texto após substituição:", resultado)
    ```

    **Explicação**
    - **`\d+`** : esse padrão encontra qualquer sequência de dígitos;
    - a função `re.sub()` substitui todos os números pela palavra "número";

    **Saída**
    ```
    Texto após substituição: O preço é número reais e o desconto é número%.
    ```

1. **exemplo usando uma função na substituição**

    Pode-se usar uma função para definir a lógica de substituição.

    ```python
    # Função que dobra o valor numérico encontrado
    def dobra(match):
        return str(int(match.group()) * 2)

    # texto com números
    texto = "O preço é 100 reais e o desconto é 15%."

    # substituindo números pela versão dobrada
    resultado = re.sub(r"\d+", dobra, texto)

    # exibindo o resultado
    print("Texto após substituição:", resultado)
    ```

    **Explicação**
    - **`dobra(match)`** : essa função recebe o objeto de correspondência e retorna o número dobrado;
    - **`re.sub(r"\d+", dobra, texto)`** : substitui todos os números pela versão dobrada deles;

    **Saída**
    ```
    Texto após substituição: O preço é 200 reais e o desconto é 30%.
    ```

### exercícios `re.sub()`

<details>
<summary>Lista de Exercícios</summary>

1. Crie uma string com uma frase que mencione a palavra "cachorro". Utilize a função `sub()` para substituir "cachorro" por "gato".
1. Escreva uma string que contenha o nome de várias frutas, separadas por vírgulas. Use `sub()` para substituir todas as ocorrências de "maçã" por "laranja".
1. Defina uma string que contenha a palavra "vermelho" repetida várias vezes. Utilize `sub()` para substituir "vermelho" por "azul".
1. Crie uma string que descreva um país famoso. Utilize `sub()` para substituir o nome do país por "Brasil".
1. Escreva uma string com o nome de uma cidade repetido duas vezes. Use `sub()` para substituir a primeira ocorrência da cidade por outra cidade de sua escolha.
1. Defina uma string que contenha uma frase sobre uma comida favorita. Utilize `sub()` para substituir o nome da comida por outra de sua escolha.
1. Crie uma string com o nome de vários filmes separados por espaços. Utilize `sub()` para substituir o nome de um filme específico por "Star Wars".
1. Escreva uma string com o nome de uma empresa várias vezes. Use `sub()` para substituir o nome da empresa por outro nome, como "TechCorp".
1. Defina uma string que contenha o nome de diferentes países. Utilize `sub()` para substituir o nome de um país por "Japão".
1. Crie uma string que contenha a descrição de um carro. Use `sub()` para substituir o nome do carro por outro modelo de sua escolha.

</details>

---

### `re.split()`

A função `re.split()` divide uma string em partes com base em um padrão de expressão regular. Ela funciona de maneira similar ao método `split()` de strings, mas permite o uso de padrões mais complexos.

```python
re.split(padrão, string, maxsplit=0, flags=0)
```

- **`padrão`** : o padrão (expressão regular) que define onde a string será dividida;
- **`string`** : a string que será dividida;
- **`maxsplit`** (opcional) : define o número máximo de divisões a serem feitas. O valor padrão é 0, o que significa dividir em todas as ocorrências do padrão;
- **`flags`** (opcional) : modificadores de comportamento das expressões regulares;

1. **exemplo dividindo uma string por espaços**

    ```python
    # texto onde vamos dividir
    texto = "Eu gosto de programar em Python."

    # dividindo a string por espaços
    resultado = re.split(r"\s+", texto)

    # exibindo o resultado
    print("Texto dividido:", resultado)
    ```

    **Explicação**
    - **`\s+`** : o padrão corresponde a um ou mais espaços em branco;
    - a função divide o texto em palavras, removendo os espaços;

    **Saída**
    ```
    Texto dividido: ['Eu', 'gosto', 'de', 'programar', 'em', 'Python.']
    ```

1. **exemplo dividindo uma string por números**

    Veja a divisão de uma string sempre que encontrar um número.

    ```python
    # texto com números
    texto = "Produto1 custa 100 reais e Produto2 custa 150 reais."

    # dividindo a string por números
    resultado = re.split(r"\d+", texto)

    # exibindo o resultado
    print("Texto dividido:", resultado)
    ```

    **Explicação**
    - **`\d+`** : o padrão encontra uma sequência de dígitos;
    - a função divide a string sempre que encontra um número;

    **Saída**
    ```
    Texto dividido: ['Produto', ' custa ', ' reais e Produto', ' custa ', ' reais.']
    ```

1. **exemplo limitando o número de divisões**

    Pode-se controlar quantas vezes a divisão será feita usando o parâmetro `maxsplit`.

    ```python
    # dividindo a string por espaços, mas limitando a 2 divisões
    resultado = re.split(r"\s+", texto, maxsplit=2)

    # exibindo o resultado
    print("Texto dividido:", resultado)
    ```

    **Explicação**
    - **`maxsplit=2`** : limita o número de divisões a 2;

    **Saída**
    ```
    Texto dividido: ['Produto1', 'custa', '100 reais e Produto2 custa 150 reais.']
    ```

1. **exemplo dividindo por pontuação**

    Agora, veja a divisão de uma string com base nos sinais de pontuação `!?.`.

    ```python
    # texto com pontuação
    texto = "Olá! Como você está? Eu estou bem."

    # dividindo a string por pontuação
    resultado = re.split(r"[!?.]+", texto)

    # exibindo o resultado
    print("Texto dividido:", resultado)
    ```

    **Explicação**
    - **`[!?.]+`** : o padrão corresponde a um ou mais caracteres de pontuação (`!`, `?`, ou `.`);
    - a função divide a string sempre que encontra um desses sinais;

    **Saída**
    ```
    Texto dividido: ['Olá', ' Como você está', ' Eu estou bem', '']
    ```

### exercícios `re.split()`

<details>
<summary>Lista de Exercícios</summary>

1. Crie uma string que contenha uma frase com várias palavras separadas por espaços. Utilize a função `split()` para dividir a string em uma lista de palavras.
1. Escreva uma string que contenha nomes de frutas separados por vírgulas. Use `split()` para separar as frutas e formar uma lista.
1. Defina uma string com uma lista de cidades separadas por ponto e vírgula. Utilize `split()` para separar cada cidade.
1. Crie uma string que contenha uma data no formato "dd/mm/yyyy". Use `split()` para separar o dia, o mês e o ano.
1. Escreva uma string com vários números de telefone separados por traços. Utilize `split()` para dividir os números em partes.
1. Defina uma string que contenha uma frase, e use `split()` para dividir a frase em uma lista de palavras usando como delimitador a letra "a".
1. Crie uma string com um parágrafo composto por várias frases separadas por ponto final. Use `split()` para separar o parágrafo em frases.
1. Escreva uma string que contenha várias palavras separadas por dois pontos. Utilize `split()` para criar uma lista de palavras.
1. Defina uma string que contenha um caminho de arquivo no formato "C:/pasta/subpasta/arquivo.txt". Utilize `split()` para separar as partes do caminho usando a barra ("/").
1. Crie uma string que contenha uma frase com palavras separadas por múltiplos espaços. Utilize `split()` sem passar nenhum argumento para dividir as palavras, removendo os espaços extras.

</details>

---

### `re.compile()`

A função `re.compile()` permite **compilar uma expressão regular** em um objeto de padrão reutilizável. Isso é particularmente útil quando se precisa usar a mesma expressão regular várias vezes no código, pois melhora a performance, evitando recompilar a expressão em cada uso.

```python
padrão_compilado = re.compile(padrão, flags=0)
```

- **`padrão`** : a expressão regular que você quer compilar;
- **`flags`** : parâmetro opcional para modificar o comportamento da expressão regular, como `re.IGNORECASE` para ignorar a diferença entre maiúsculas e minúsculas;

1. **exemplo compilando e reutilizando uma expressão regular**

    ```python
    import re

    # compilando o padrão para encontrar números
    padrão_números = re.compile(r"\d+")

    # texto onde vamos buscar
    texto = "O produto custa 250 reais e o desconto é de 10%."

    # usando o padrão compilado para encontrar todos os números
    resultado = padrão_números.findall(texto)

    # exibindo as correspondências
    print("Números encontrados:", resultado)
    ```

    **Explicação**
    - **`re.compile(r"\d+")`** : compila o padrão que encontra uma sequência de dígitos;
    - **`padrão_números.findall(texto)`** : usa o objeto compilado para encontrar todos os números no texto;

    **Saída**
    ```
    Números encontrados: ['250', '10']
    ```

    Aqui, o padrão compilado pode ser reutilizado várias vezes, sem precisar recompilar a expressão regular.

1. **exemplo melhorando a performance com `re.compile()`**

    Se for necessário aplicar o mesmo padrão várias vezes, `re.compile()` ajuda a melhorar a performance.

    ```python
    # compilando o padrão para encontrar palavras
    padrão_palavras = re.compile(r"\b\w+\b")

    # texto para busca
    texto = "Python é uma linguagem versátil e poderosa."

    # usando o padrão compilado várias vezes
    resultado1 = padrão_palavras.findall(texto)
    resultado2 = padrão_palavras.search(texto)
    resultado3 = padrão_palavras.sub("LINGUAGEM", texto)

    # exibindo os resultados
    print("Todas as palavras:", resultado1)
    print("Primeira palavra encontrada:", resultado2.group())
    print("Texto após substituição:", resultado3)
    ```

    **Explicação**
    - **`padrão_palavras.findall()`** : encontra todas as palavras;
    - **`padrão_palavras.search()`** : encontra a primeira palavra;
    - **`padrão_palavras.sub()`** : substitui todas as palavras pelo termo "LINGUAGEM";

    **Saída**
    ```
    Todas as palavras: ['Python', 'é', 'uma', 'linguagem', 'versátil', 'e', 'poderosa']
    Primeira palavra encontrada: Python
    Texto após substituição: LINGUAGEM LINGUAGEM LINGUAGEM LINGUAGEM LINGUAGEM LINGUAGEM LINGUAGEM
    ```

    Ao usar o padrão compilado, a busca é mais eficiente, especialmente em situações com muitas operações repetidas.

1. **exemplo usando flags com `re.compile()`**

    Pode-se adicionar **flags** ao compilar a expressão, como ignorar maiúsculas e minúsculas (`re.IGNORECASE`).

    ```python
    # compilando o padrão com a flag IGNORECASE
    padrão_ignorecase = re.compile(r"python", re.IGNORECASE)

    # texto com diferentes variações de capitalização
    texto = "Python é popular. python é versátil. PYTHON é poderoso."

    # encontrando todas as correspondências, ignorando maiúsculas/minúsculas
    resultado = padrão_ignorecase.findall(texto)

    # exibindo o resultado
    print("Correspondências encontradas:", resultado)
    ```

    **Explicação**
    - **`re.compile(r"python", re.IGNORECASE)`** : compila o padrão para encontrar "python" ignorando a capitalização;
    - **`padrão_ignorecase.findall(texto)`** : encontra todas as ocorrências, independentemente de maiúsculas e minúsculas;

    **Saída**
    ```
    Correspondências encontradas: ['Python', 'python', 'PYTHON']
    ```

### exercícios `re.compile()`

<details>
<summary>Lista de Exercícios</summary>

1. Crie uma expressão regular que busque por uma palavra específica dentro de uma string. Use `compile()` para compilar a expressão e, em seguida, aplique-a para verificar se a palavra "Python" está presente na frase "Estou aprendendo Python!".
1. Defina uma expressão regular que encontre todas as ocorrências de uma determinada palavra em um texto. Utilize `compile()` para compilar a expressão e, em seguida, aplique-a em uma string que contenha a palavra "banana" várias vezes.
1. Escreva uma expressão regular para verificar se uma string começa com um número. Use `compile()` para compilar a expressão e teste-a em diferentes strings como "123abc" e "abc123".
1. Crie uma expressão regular que valide um endereço de e-mail simples. Utilize `compile()` para compilar a expressão e aplique-a para verificar se "exemplo@email.com" é um e-mail válido.
1. Defina uma expressão regular para encontrar todas as ocorrências de um número em um texto. Use `compile()` para compilar a expressão e aplique-a a uma string que contenha várias sequências numéricas, como "Telefone: 1234, Código: 5678".
1. Crie uma expressão regular que busque por palavras que terminem com "ing". Compile a expressão usando `compile()` e aplique-a em uma lista de palavras, como "running", "playing", "sitting".
1. Escreva uma expressão regular para verificar se uma string contém apenas letras maiúsculas. Use `compile()` para compilar a expressão e aplique-a a strings como "HELLO" e "Hello".
1. Defina uma expressão regular que verifique se uma string contém um número específico de dígitos. Utilize `compile()` para compilar a expressão e teste-a em strings como "12345" e "123".
1. Crie uma expressão regular que localize todas as ocorrências de palavras que comecem com a letra "a". Utilize `compile()` para compilar a expressão e aplique-a em uma string contendo várias palavras, como "apple, banana, apricot".
1. Escreva uma expressão regular para validar um número de telefone no formato "xxx-xxx-xxxx". Use `compile()` para compilar a expressão e aplique-a a uma string como "123-456-7890".

</details>

---

### `re.escape()`

A função `re.escape()` escapa todos os caracteres especiais em uma string, tornando-os literais. Isso é útil quando se precisa lidar com strings que contêm caracteres especiais de regex (como `.` ou `*`), mas deseja tratá-los como caracteres normais e não como parte da sintaxe de expressões regulares.

```python
string_escapada = re.escape(string)
```

- **`string`** : a string que será escapada, ou seja, os caracteres especiais serão precedidos por uma barra invertida (`\`), para que sejam tratados como literais;

1. **exemplo escapando caracteres especiais**

    ```python
    # texto com caracteres especiais
    texto = "Preço: 100$ (desconto de 10%)."

    # escapando os caracteres especiais
    texto_escapado = re.escape(texto)

    # exibindo o texto escapado
    print("Texto escapado:", texto_escapado)
    ```

    **Explicação**
    - **`re.escape(texto)`** : escapa todos os caracteres especiais presentes no texto, como `$`, `(`, `)` e `%`, transformando-os em literais;

    **Saída**
    ```
    Texto escapado: Preço:\ 100\$\ \(desconto\ de\ 10%\)\.
    ```

    Aqui, todos os caracteres que têm significados especiais em expressões regulares (como `$`, `(`, `)`, `%`, etc.) são precedidos por uma barra invertida (`\`), tornando-os literais.

1. **exemplo usando `re.escape()` em um padrão de expressão regular**

    Quando se quer usar uma string contendo caracteres especiais como parte de um padrão literal em uma expressão regular, `re.escape()` é muito útil.

    ```python
    # texto e padrão que queremos buscar
    texto = "O arquivo data.log foi criado com sucesso."

    # escapando o ponto (.) no nome do arquivo
    padrão = re.escape("data.log")

    # Procurando o padrão escapado
    resultado = re.search(padrão, texto)

    if resultado:
        print("Padrão encontrado:", resultado.group())
    else:
        print("Padrão não encontrado.")
    ```

    **Explicação**
    - **`re.escape("data.log")`** : escapa o ponto (`.`), que normalmente tem um significado especial (corresponde a qualquer caractere);
    - **`re.search(padrão, texto)`** : procura pela string literal "data.log", em vez de tratar o `.` como um caractere coringa;

    **Saída**
    ```
    Padrão encontrado: data.log
    ```

    Aqui, o `.` é escapado para que ele seja tratado como um literal, e a busca encontra a correspondência exata da string "data.log".

1. **exemplo comparando uso com e sem `re.escape()`**

    Veja o que acontece quando se usa ou não `re.escape()` em um padrão com caracteres especiais.

    ```python
    import re

    # Texto onde vamos fazer a busca
    texto = "O arquivo dataXlog foi criado com sucesso."

    # Sem usar re.escape (o ponto é tratado como caractere coringa)
    resultado_sem_escape = re.search(r"data.log", texto)

    # Usando re.escape para tratar o ponto como literal
    padrão_escapado = re.escape("data.log")
    resultado_com_escape = re.search(padrão_escapado, texto)

    print("Sem re.escape:", resultado_sem_escape.group() if resultado_sem_escape else "Não encontrado")
    print("Com re.escape:", resultado_com_escape.group() if resultado_com_escape else "Não encontrado")

    ```

    **Explicação**
    - **Sem `re.escape()`** : o ponto (`.`) é tratado como coringa, correspondendo a qualquer caractere;
    - **Com `re.escape()`** : o ponto é tratado como um literal;

    **Saída**
    ```
    Sem re.escape: data.log
    Com re.escape: Não encontrado
    ```

    Neste caso, ambos os métodos funcionam, mas se houvesse outro caractere no lugar do ponto, a busca sem `re.escape()` poderia gerar resultados indesejados.

### exercícios `re.escape()`

<details>
<summary>Lista de Exercícios</summary>

1. Escreva uma string que contenha caracteres especiais como ".", "*", "+", e "?". Utilize a função `escape()` para gerar uma versão da string onde esses caracteres possam ser tratados literalmente em uma expressão regular.
1. Crie uma string que contenha barras invertidas ("\") e aplique a função `escape()` para transformar essa string em um formato seguro para uso em expressões regulares.
1. Defina uma string que contenha parênteses, colchetes e chaves. Utilize a função `escape()` para garantir que todos esses caracteres sejam tratados de forma literal em uma expressão regular.
1. Escreva uma string que inclua uma sequência de símbolos como "$", "^", e "|". Aplique `escape()` para assegurar que esses símbolos não sejam interpretados como metacaracteres quando usados em uma expressão regular.
1. Crie uma string contendo uma frase que inclua "?", ".", e "+" em seu texto. Utilize a função `escape()` para transformar essa frase em uma versão segura para uso em busca de padrões literais.
1. Escreva uma expressão regular que inclua o caractere "+" e use a função `escape()` para garantir que o caractere "+" seja tratado como literal ao invés de metacaractere.
1. Defina uma string que contenha um caminho de arquivo do tipo "C:\pasta\subpasta\arquivo.txt". Aplique `escape()` para permitir que esse caminho seja utilizado como literal em uma expressão regular.
1. Crie uma string que contenha o símbolo "@" e outros caracteres especiais de um endereço de e-mail. Use a função `escape()` para garantir que todos os caracteres sejam tratados literalmente.
1. Escreva uma string que contenha o texto "2+2=4" e utilize a função `escape()` para garantir que o símbolo "+" seja tratado de forma literal em uma expressão regular.
1. Defina uma string com caracteres como "*", "(", e ")", utilizados em uma fórmula matemática. Aplique a função `escape()` para tornar a string segura para busca literal usando expressões regulares.

</details>

---

## metacaracteres

### `.` (ponto)

O metacaractere `.` (ponto) em expressões regulares corresponde a **qualquer caractere**, exceto quebras de linha (por padrão). Isso significa que ele pode corresponder a letras, números, espaços ou qualquer outro símbolo, com exceção de uma nova linha.

1. **exemplo encontrar qualquer caractere**

    Veja o uso do `.` para encontrar qualquer caractere presente em uma posição específica.

    ```python
    import re

    # texto de exemplo
    texto = "A B C D E"

    # usando o ponto (.) para encontrar qualquer caractere (menos quebras de linha)
    resultado = re.findall(r"A.B", texto)

    # exibindo o resultado
    print("Resultado com '.':", resultado)
    ```

    **Explicação**
    - **`A.B`** : o padrão encontra "A", seguido de **qualquer caractere** (devido ao `.`), seguido de "B";
    - o padrão encontra a combinação "A B";

    **Saída**
    ```
    Resultado com '.': ['A B']
    ```

1. **exemplo usando o `.` com `re.split()`**

    ```python
    # texto de exemplo
    texto = "Palavra1 Palavra2 Palavra3"

    # dividindo por qualquer caractere (exceto nova linha)
    resultado = re.split(r"r.", texto)

    # exibindo o resultado
    print("Resultado de re.split() com '.':", resultado)
    ```

    **Explicação**
    - **`r.l`** : encontra qualquer sequência de "r", seguido de qualquer caractere (`.`), seguido de "l";
    - o `split()` divide o texto quando encontra esse padrão;

    **Saída**
    ```
    Resultado de re.split() com '.': ['Pa', 'vra1 Pa', 'vra2 Pa', 'vra3']
    ```

1. **exemplo substituindo caracteres com `re.sub()`**

    ```python
    # texto de exemplo
    texto = "123 abc !@#"

    # qualquer caractere (.) seguido por um não número será substituído por "X"
    resultado = re.sub(r".\D", "XX", texto)

    # exibindo o resultado
    print("Resultado de re.sub() com '.':", resultado)
    ```

    **Explicação**
    - o `.` encontra qualquer caractere, e o `re.sub()` substitui todos os caracteres por "X";

    **Saída**
    ```
    Resultado de re.sub() com '.': 12XXXXXXXX#
    ```

### exercícios `.`

<details>
<summary>Lista de Exercícios</summary>

1. Crie uma expressão regular que utilize o metacaractere ponto (`.`) para encontrar qualquer caractere entre duas letras "a". Aplique essa expressão à string "aba aca ada" e veja o que é retornado.
1. Escreva uma expressão regular que encontre todas as ocorrências de três caracteres consecutivos em uma string, onde o caractere do meio pode ser qualquer um. Utilize `.` para isso e aplique à string "abc 123 xyz".
1. Defina uma expressão regular que busque qualquer caractere antes e depois de uma vogal. Use o ponto (`.`) para representar os caracteres desconhecidos e aplique essa expressão à frase "o rato roeu a roupa".
1. Escreva uma expressão regular que utilize `.` para encontrar qualquer sequência de três caracteres, onde o primeiro e o último sejam números, e o caractere do meio pode ser qualquer um. Teste com a string "2a3 4+5 6!7".
1. Crie uma expressão regular que utilize o ponto (`.`) para localizar qualquer palavra de quatro caracteres em uma string. Aplique-a na frase "hoje faz sol e vou correr".
1. Defina uma expressão regular que busque por padrões onde o primeiro caractere é "c", o último é "o", e o caractere do meio pode ser qualquer um. Aplique à string "cao cto cno cqo".
1. Escreva uma expressão regular que utilize `.` para substituir todos os caracteres em uma senha fictícia, como "p@ssw0rd123", por asteriscos (*), exceto os números.
1. Crie uma expressão regular que busque por qualquer caractere que venha logo antes de um número. Utilize o metacaractere ponto (`.`) para representar o caractere desconhecido e aplique na string "x1 y2 z3".
1. Defina uma expressão regular que encontre qualquer palavra que tenha exatamente cinco letras, sendo a segunda uma vogal. Use `.` para os outros caracteres e aplique na frase "Python é fácil e divertido".
1. Escreva uma expressão regular que utilize o ponto (`.`) para encontrar todas as ocorrências onde o primeiro caractere de uma palavra seja "p", o último seja "r", e o caractere do meio pode ser qualquer um. Teste com a string "por par pir pur per".

</details>

---

### `^` (circunflexo)

O metacaractere `^` é usado para indicar o **início de uma string** ou linha (dependendo das flags usadas). Ele verifica se a string ou linha começa com um determinado padrão.

1. **exemplo verificar o início de uma string com `re.match()`**

    ```python
    # texto de exemplo
    texto = "Python é uma linguagem poderosa."

    # verificando se a string começa com "Python"
    resultado = re.match(r"^Python", texto)

    # exibindo o resultado
    if resultado:
        print("A string começa com 'Python'")
    else:
        print("A string não começa com 'Python'")
    ```

    **Explicação**
    - **`^Python`** : o `^` garante que "Python" só será correspondido se estiver no início da string;

    **Saída**
    ```
    A string começa com 'Python'
    ```

1. **exemplo usando `^` com `re.findall()`**

    ```python
    # texto de exemplo
    texto = "Python é poderoso.\npython é versátil."

    # encontrando "python" no início de cada linha (ignorando maiúsculas/minúsculas)
    resultado = re.findall(r"^python", texto, flags=re.IGNORECASE | re.MULTILINE)

    # exibindo o resultado
    print("Correspondências encontradas no início de linhas:", resultado)
    ```

    **Explicação**
    - **`^python`** : o `^` busca "python" no início da string. A flag `re.MULTILINE` permite que a busca seja feita no início de cada linha (não apenas da string inteira);
    - a flag `re.IGNORECASE` ignora a diferença entre maiúsculas e minúsculas;

    **Saída**
    ```
    Correspondências encontradas no início de linhas: ['Python', 'python']
    ```

1. **exemplo usando `^` para garantir o início da string com `re.sub()`**

    ```python
    # texto de exemplo
    texto = "Python é uma linguagem poderosa."

    # substituindo "Python" no início por "Java"
    resultado = re.sub(r"^Python", "Java", texto)

    # exibindo o resultado
    print("Resultado de re.sub() com '^':", resultado)
    ```

    **Explicação**
    - o padrão `^Python` só substitui "Python" se ele aparecer no início da string;

    **Saída**
    ```
    Resultado de re.sub() com '^': Java é uma linguagem poderosa.
    ```

### exercícios `^`

<details>
<summary>Lista de Exercícios</summary>

1. Crie uma expressão regular que utilize o metacaractere circunflexo (`^`) para verificar se uma string começa com a palavra "Olá". Teste a expressão com a frase "Olá, mundo!".
1. Escreva uma expressão regular que utilize `^` para verificar se uma string começa com um número. Aplique essa expressão à string "123abc".
1. Defina uma expressão regular que utilize `^` para verificar se uma string começa com a letra "P". Teste-a com as palavras "Python" e "java".
1. Crie uma expressão regular que utilize `^` para garantir que uma frase começa com a palavra "Era". Teste a expressão com a frase "Era uma vez".
1. Escreva uma expressão regular que utilize `^` para verificar se uma string começa com um símbolo como "@" ou "#". Teste-a com a string "@usuario123".
1. Defina uma expressão regular que utilize `^` para verificar se uma string começa com uma letra maiúscula. Aplique essa expressão à frase "Hoje é um bom dia".
1. Crie uma expressão regular que utilize `^` para verificar se uma string começa com a sequência "abc". Teste com a string "abcdef" e "xyzabc".
1. Escreva uma expressão regular que utilize `^` para verificar se uma string começa com um dígito (0-9). Aplique a expressão à string "8 maçãs".
1. Defina uma expressão regular que utilize `^` para verificar se uma string começa com a sequência "http". Aplique-a em uma URL como "http://example.com".
1. Crie uma expressão regular que utilize `^` para verificar se uma string começa com qualquer palavra de quatro letras. Aplique a expressão na frase "Lindo dia hoje!".

</details>

---

### `$` (cifrão)

O metacaractere `$` é usado para verificar se um padrão está presente no **final de uma string** ou linha (dependendo das flags).

1. **exemplo verificar o final de uma string com `re.search()`**

    ```python
    # texto de exemplo
    texto = "A linguagem Python é poderosa."

    # verificando se a string termina com "poderosa."
    resultado = re.search(r"poderosa\.$", texto)

    # exibindo o resultado
    if resultado:
        print("A string termina com 'poderosa.'")
    else:
        print("A string não termina com 'poderosa.'")
    ```

    **Explicação**
    - **`poderosa\.$`** : o padrão "poderosa." só será encontrado se estiver no final da string, graças ao `$`;

    **Saída**
    ```
    A string termina com 'poderosa.'
    ```

1. **exemplo usando `$` com `re.findall()`**

    ```python
    # texto de exemplo
    texto = "Eu gosto de Python.\nAmo programar em Python."

    # encontrando "Python" no final de cada linha
    resultado = re.findall(r"Python\.$", texto, flags=re.MULTILINE)

    # exibindo o resultado
    print("Correspondências encontradas no final de linhas:", resultado)
    ```

    **Explicação**
    - **`Python\.$`** : o padrão encontra "Python." no final de cada linha. A flag `re.MULTILINE` permite a verificação em cada linha, não apenas no final da string;

    **Saída**
    ```
    Correspondências encontradas no final de linhas: ['Python.']
    ```

1. **exemplo substituindo um padrão no final da string com `re.sub()`**

    ```python
    # texto de exemplo
    texto = "Eu adoro Python."

    # substituindo "Python." no final por "Java."
    resultado = re.sub(r"Python\.$", "Java.", texto)

    # exibindo o resultado
    print("Resultado de re.sub() com '$':", resultado)
    ```

    **Explicação**
    - o padrão `Python\.$` substitui "Python." por "Java." somente se "Python." estiver no final da string;

    **Saída**
    ```
    Resultado de re.sub() com '$': Eu adoro Java.
    ```

### exercícios `$`

<details>
<summary>Lista de Exercícios</summary>

1. Crie uma expressão regular que utilize o metacaractere cifrão (`$`) para verificar se uma string termina com a palavra "fim". Teste com a string "Essa é a última palavra: fim".
1. Escreva uma expressão regular que use o cifrão (`$`) para verificar se uma string termina com um número. Aplique à string "O total é 42".
1. Defina uma expressão regular que utilize o metacaractere `$` para verificar se uma string termina com a sequência "123". Teste com a string "Senha: abc123".
1. Crie uma expressão regular que utilize `$` para verificar se uma string termina com uma letra maiúscula. Aplique à frase "Hoje é um bom Dia".
1. Escreva uma expressão regular que utilize `$` para verificar se uma string termina com um ponto final. Teste com a frase "Este é o fim.".
1. Defina uma expressão regular que utilize `$` para verificar se uma string termina com a palavra "Python". Aplique à string "Eu estou aprendendo Python".
1. Crie uma expressão regular que utilize `$` para verificar se uma string termina com um espaço em branco. Teste com a frase "Aqui tem um espaço ".
1. Escreva uma expressão regular que utilize `$` para verificar se uma string termina com um símbolo como "!" ou "?". Aplique à string "Você está bem?".
1. Defina uma expressão regular que utilize `$` para verificar se uma string termina com três letras consecutivas. Teste com a string "finalabc".
1. Crie uma expressão regular que utilize `$` para verificar se uma string termina com um caractere numérico. Teste com a string "O resultado final foi 9".

</details>

---

### `*` (asterisco)

O metacaractere `*` significa **"zero ou mais ocorrências"** do padrão que o precede. Isso significa que o padrão anterior pode aparecer repetidamente (incluindo a possibilidade de não aparecer).

1. **exemplo encontrando padrões com `*`**

    ```python
    import re

    # texto de exemplo
    texto = "Aaaahhh! Isso é incrível!"

    # Padrão: "A" seguido de zero ou mais "a"
    resultado = re.findall(r"Aa*", texto)

    # exibindo o resultado
    print("Resultado com '*':", resultado)
    ```

    **Explicação**
    - **`Aa*`** : procura por um "A" seguido de zero ou mais letras "a". Isso significa que ele pode encontrar "A", "Aa", "Aaa", etc;

    **Saída**
    ```
    Resultado com '*': ['Aaaa']
    ```

1. **exemplo usando `*` com `re.search()`**

    ```python
    # texto de exemplo
    texto = "123 abc 456 def"

    # Procurando dígitos seguidos de zero ou mais espaços
    resultado = re.search(r"\d*\s*", texto)

    # exibindo o resultado
    print("Resultado com '*':", resultado.group())
    ```

    **Explicação**
    - **`\d*\s*`** : encontra zero ou mais dígitos seguidos de zero ou mais espaços;

    **Saída**
    ```
    Resultado com '*': 123
    ```

    Aqui, ele encontra a sequência "123 " (três dígitos e um espaço).

1. **exemplo substituindo com `*` usando `re.sub()`**

    ```python
    # texto de exemplo
    texto = "Gatoooo"

    # substituindo "o" repetido por "o"
    resultado = re.sub(r"o*", "o", texto)

    # exibindo o resultado
    print("Resultado de re.sub() com '*':", resultado)
    ```

    **Explicação**
    - **`o*`** : substitui qualquer sequência de "o" (zero ou mais) por apenas um "o";

    **Saída**
    ```
    Resultado de re.sub() com '*': Gato
    ```

### exercícios `*`

<details>
<summary>Lista de Exercícios</summary>

1. Crie uma expressão regular que utilize o metacaractere asterisco (`*`) para encontrar ocorrências de uma letra seguida por zero ou mais letras "a". Teste com a string "baaa ba b".
1. Escreva uma expressão regular que utilize `*` para encontrar palavras que tenham a letra "s" seguida por zero ou mais letras "e". Aplique à string "seu selo sente".
1. Defina uma expressão regular que use `*` para verificar se uma string contém zero ou mais espaços em branco antes de uma palavra. Teste com a string "   exemplo".
1. Crie uma expressão regular que utilize `*` para encontrar sequências de números seguidos por zero ou mais zeros. Aplique à string "120 3000 45000".
1. Escreva uma expressão regular que utilize `*` para encontrar palavras que começam com "a" e podem ter qualquer número de letras depois, incluindo nenhuma. Teste com as palavras "a", "abacaxi", "análise".
1. Defina uma expressão regular que utilize `*` para verificar se uma string contém zero ou mais caracteres antes da palavra "fim". Aplique à string "isso é o fim".
1. Crie uma expressão regular que utilize `*` para encontrar sequências de caracteres que começam com "x" e podem ter zero ou mais caracteres após isso. Teste com "x", "xyz", "xabc".
1. Escreva uma expressão regular que utilize `*` para verificar se uma string contém zero ou mais caracteres especiais antes de um número. Aplique à string "@#1".
1. Defina uma expressão regular que utilize `*` para encontrar palavras que podem ter uma letra "e" no início e qualquer número de letras após isso, incluindo nenhuma. Teste com "e", "elefante", "esperança".
1. Crie uma expressão regular que utilize `*` para verificar se uma string contém zero ou mais vogais seguidas de uma letra "s". Teste com as strings "s", "ass", "ooos".

</details>

---

### `+` (mais)

O metacaractere `+` significa **"uma ou mais ocorrências"** do padrão que o precede. Ao contrário de `*`, o padrão deve aparecer pelo menos uma vez.

1. **exemplo encontrando padrões com `+`**

    ```python
    # texto de exemplo
    texto = "Eu tenho 1000 maçãs."

    # Padrão: Encontrar um ou mais dígitos seguidos de um espaço
    resultado = re.findall(r"\d+ ", texto)

    # exibindo o resultado
    print("Resultado com '+':", resultado)
    ```

    **Explicação**
    - **`\d+`** : procura por um ou mais dígitos. Isso significa que encontra números inteiros ou sequências de números;

    **Saída**
    ```
    Resultado com '+': ['1000 ']
    ```

1. **exemplo usando `+` para dividir strings com `re.split()`**

    ```python
    # texto de exemplo
    texto = "Palavra123Outra"

    # dividindo o texto por uma ou mais sequências de dígitos
    resultado = re.split(r"\d+", texto)

    # exibindo o resultado
    print("Resultado de re.split() com '+':", resultado)
    ```

    **Explicação**
    - **`\d+`** : divide a string em partes, usando uma ou mais ocorrências de dígitos como separador;

    **Saída**
    ```
    Resultado de re.split() com '+': ['Palavra', 'Outra']
    ```

### exercícios `+`

<details>
<summary>Lista de Exercícios</summary>

1. Crie uma expressão regular que utilize o metacaractere mais (`+`) para encontrar sequências de uma letra "a" seguida por uma ou mais letras "b". Teste com a string "ab, abb, a, aaa".
1. Escreva uma expressão regular que utilize `+` para verificar se uma string contém uma ou mais ocorrências do caractere "x". Aplique à string "xxxy", "xy", e "y".
1. Defina uma expressão regular que utilize `+` para encontrar palavras que começam com a letra "s" e são seguidas por uma ou mais letras "e". Teste com as palavras "se", "selo", "s".
1. Crie uma expressão regular que utilize `+` para verificar se uma string contém uma ou mais dígitos consecutivos. Aplique à string "a123b", "abc", e "456".
1. Escreva uma expressão regular que utilize `+` para encontrar sequências de letras "o" seguidas de uma ou mais letras "k". Teste com a string "ook, oook, ok".
1. Defina uma expressão regular que utilize `+` para verificar se uma string contém uma ou mais vogais seguidas por uma letra "n". Aplique à string "an", "eenn", e "onn".
1. Crie uma expressão regular que utilize `+` para encontrar sequências de caracteres que começam com "m" e são seguidas por uma ou mais letras "a". Teste com "ma", "maa", "m".
1. Escreva uma expressão regular que utilize `+` para verificar se uma string termina com um ou mais caracteres especiais. Aplique à string "abc!!!", "abc", e "abc??".
1. Defina uma expressão regular que utilize `+` para encontrar palavras que começam com a letra "c" e são seguidas por uma ou mais letras "a" ou "e". Teste com "ca", "ceee", "c".
1. Crie uma expressão regular que utilize `+` para verificar se uma string contém uma sequência de uma ou mais letras "r" seguidas de uma letra "s". Teste com "rs", "rrrs", e "r".

</details>

---

### `?` (interrogação)

O metacaractere `?` significa **"zero ou uma ocorrência"** do padrão que o precede. Ou seja, o padrão pode aparecer no máximo uma vez.

1. **exemplo encontrando padrões com `?`**

    ```python
    # texto de exemplo
    texto = "cor ou cor?reto"

    # Padrão: Encontrar "cor" seguido de uma letra opcional "?"
    resultado = re.findall(r"cor\??", texto)

    # exibindo o resultado
    print("Resultado com '?':", resultado)
    ```

    **Explicação**
    - **`cor\??`** : encontra "cor" seguido de zero ou uma interrogação;

    **Saída**
    ```
    Resultado com '?': ['cor', 'cor?']
    ```

1. **exemplo usando `?` com `re.fullmatch()`**

    ```python
    # texto de exemplo
    texto = "coloor"

    # verificando se o texto corresponde a "colo" seguido de zero ou uma letra "o"
    resultado = re.fullmatch(r"colo?", texto)

    # exibindo o resultado
    if resultado:
        print("Resultado com '?':", resultado.group())
    else:
        print("Nenhuma correspondência.")
    ```

    **Explicação**
    - **`colo?`** : o padrão espera a palavra "col" seguida de zero ou uma letra "o";

    **Saída**
    ```
    Nenhuma correspondência.
    ```

    Aqui, não há correspondência porque a palavra tem duas letras "o", enquanto o `?` permite no máximo uma.

1. **exemplo substituindo padrões opcionais com `re.sub()`**

    ```python
    # texto de exemplo
    texto = "correto"

    # substituindo "r?" por "RR"
    resultado = re.sub(r"r?", "RR", texto)

    # exibindo o resultado
    print("Resultado de re.sub() com '?':", resultado)
    ```

    **Explicação**
    - **`r?`** : o padrão "r?" encontra zero ou uma letra "r", substituindo-a por "RR";

    **Saída**
    ```
    Resultado de re.sub() com '?': RRcoRRRRRRetoRR
    ```

### exercícios `?`

<details>
<summary>Lista de Exercícios</summary>

1. Crie uma expressão regular que utilize o metacaractere interrogação (`?`) para encontrar ocorrências da letra "a" seguida opcionalmente pela letra "b". Teste com a string "a, ab, b, aa".
1. Escreva uma expressão regular que utilize `?` para verificar se uma string contém a letra "x" seguida opcionalmente por "y". Aplique à string "xy", "x", e "y".
1. Defina uma expressão regular que utilize `?` para encontrar palavras que podem ou não ter a letra "e" no final. Teste com as palavras "casa" e "casae".
1. Crie uma expressão regular que utilize `?` para verificar se uma string contém a sequência "ab" seguida opcionalmente por um espaço. Teste com "ab", "ab ", e "abc".
1. Escreva uma expressão regular que utilize `?` para encontrar sequências de dígitos que podem ter um sinal de mais (+) ou menos (-) antes deles. Aplique à string "+123", "-456", e "789".
1. Defina uma expressão regular que utilize `?` para verificar se uma string termina com uma letra "s" ou não. Teste com as palavras "cachorro" e "cachorros".
1. Crie uma expressão regular que utilize `?` para encontrar palavras que começam com "a" e podem ter uma letra "b" logo após. Teste com "a", "ab", "abc".
1. Escreva uma expressão regular que utilize `?` para verificar se uma string contém a letra "c" seguida opcionalmente por uma letra "d". Aplique à string "cd", "c", e "d".
1. Defina uma expressão regular que utilize `?` para encontrar sequências de caracteres que começam com "m" e podem ter uma letra "a" opcionalmente após. Teste com "m", "ma", "mb".
1. Crie uma expressão regular que utilize `?` para verificar se uma string contém uma sequência de uma vogal seguida opcionalmente por uma consoante. Teste com "a", "an", "i", e "it".

</details>

---


# funcoes-built-in.md

Índice

1. [print()](#print)
1. [exercícios print()](#exercícios-print)
1. [len()](#len)
1. [sum()](#sum)
1. [pow()](#pow)
1. [max() e min()](#max-e-min)
1. [abs()](#abs)
1. [round()](#round)
1. [type()](#type)
1. [isinstance()](#isinstance)
1. [ord() e chr()](#ord-e-chr)
1. [help()](#help)
1. [exercícios()](#exercícios)
1. [input()](#input)
1. [range()](#range)
1. [exercícios range](#exercícios-range)
1. [enumerate()](#enumerate)
1. [exercícios enumerate](#exercícios-enumerate)
1. [zip()](#zip)
1. [exercícios zip](#exercícios-zip)
1. [`dir()`](#dir)
1. [exercícios `dir()`](#exercícios-dir)

# funções built-in

As funções built-in do Python são funções que já vêm integradas na linguagem, ou seja, estão disponíveis para uso imediato sem a necessidade de importação de módulos ou bibliotecas adicionais. Essas funções são projetadas para realizar tarefas comuns, como manipulação de strings, números, listas, entre outros, de forma simples e eficiente.

## `print()`

A função `print()` no Python é uma das funções mais fundamentais e amplamente utilizadas. Ela serve para exibir informações na tela, o que é útil tanto para o desenvolvimento e depuração de código quanto para fornecer feedback ao usuário.

A função `print()` exibe os valores que você passa como argumentos, convertendo-os em strings (se necessário) e mostrando-os na tela.

Veja um exemplo básico :

```python
>>> print("Olá, mundo!")
Olá, mundo!
```

Além disso, a função `print()` também possui diversas outras funcionalidades, além de exibir strings e conteúdo de variáveis.

### outras funcionalidades

1. **exibir múltiplos valores** : é possível passar vários argumentos para `print()`, e eles serão exibidos em sequência, separados por um espaço por padrão. os argumentos podem ser valores literais ou variáveis contendo valores.
    ```python
    >>> print("Python", "é", "nota", 10, "!")
    Python é nota 10 !
    >>>
    >>> nota = 10
    >>> linguagem = "Python"
    >>>
    >>> print(linguagem, "é", 'nota', nota, "!")
    Python é nota 10 !
    ```

1. **separador personalizado** : sempre que vários argumentos são passados para o `print()` (separados por vírgulas), por padrão, a função adiciona um espaço em branco entre os argumentos. contudo, é possível alterar esse comportamento especificando o argumento `sep` logo antes de fechar o parênteses. o valor que for passado ao `sep` deverá ser uma `string`.
    ```python
    >>> print("Python", "é", "incrível!", sep="-")
    Python-é-incrível!
    >>>
    >>> print("Python", "é", "incrível!", sep="_")
    Python_é_incrível!
    >>>
    >>> print("Python", "é", "incrível!", sep=" - ")
    Python - é - incrível!
    ```

1. **fim da linha personalizado** : sempre que se usa o `print()`, por padrão ele adiciona uma nova linha (`\n`) após exibir os valores. esse comportamento pode ser alterado usando o argumento `end` logo antes de fechar os parênteses. o valor que for passado ao `end` deverá ser uma `string`.
    ```python
    >>> print("Olá,", end=" ")
    >>> print("mundo!")
    Olá, mundo!
    >>>
    >>> nome = 'Arnold Schwarzenegger'
    >>> i = 0  # abreviação de índice
    >>> while i < len(nome):
    ...     print(nome[i], end='+-+')
    ...     i = i + 1
    ...
    A+-+r+-+n+-+o+-+l+-+d+-+ +-+S+-+c+-+h+-+w+-+a+-+r+-+z+-+e+-+n+-+e+-+g+-+g+-+e+-+r+-+
    ```
    Repare que, no exemplo acima, o `print()` dentro do loop `while` adiciona um `+-+` sempre que é executado, mesmo no último caractere do nome.

1. **combinando** : tanto o `sep` quanto o `end` podem ser usados juntos.
    ```python
    >>> linguagem = 'Python'
    >>> print(linguagem, "é", "incrível", sep="-", end="!")
    Python-é-incrível!>>> |
    ```
    No exemplo acima, é usado o `sep` para adicionar um traço entre cada argumento e é usado o `end` para adicionar o sinal de exclamação ao final da frase. Por causa desse comportamento do `end`, o prompt de entrada do Python fica na mesma linha.

### tudo para string

Qualquer objeto passado para `print()` é convertido em uma string usando a função `str()`. Isso significa que mesmo se você passar um número, uma lista, ou outro tipo de objeto, ele será exibido como uma string correspondente.

```python
>>> numeros = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> valor = 42
>>>
>>> print(valor, numeros)
42 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> |
```

### exercícios print()

<details>
<summary>Lista de Exercícios</summary>

1. exercícios usando o argumento `sep`
    1. Crie três variáveis inteiras e exiba-as usando `print()` com `sep='-'` entre os valores.
    1. Crie uma lista de números inteiros e exiba seus elementos separados por espaços usando `print()` e `sep=' '`.
    1. Crie três variáveis de tipo `float` e exiba-as usando `print()` com `sep=' | '`.
    1. Crie uma lista de strings e exiba os elementos separados por vírgulas usando `print()` e `sep=', '`.
    1. Crie quatro variáveis booleanas e exiba-as usando `print()` com `sep=' & '`.
    1. Crie uma lista de números inteiros e use um loop `while` para exibir os elementos separados por ponto e vírgula (`;`) usando `print()` e `sep=';'`.
    1. Crie três variáveis do tipo `str` e exiba-as usando `print()` com `sep='-'` somente se a primeira variável for igual à segunda.
    1. Crie uma lista de números `float` e exiba os elementos separados por um asterisco (`*`) usando `print()` e `sep='*'`.
    1. Crie uma lista de variáveis booleanas e exiba os elementos separados por dois pontos (`:`) usando `print()` e `sep=':'`.
    1. Crie quatro variáveis do tipo `int`, `float`, `bool` e `str`, e exiba-as usando `print()` com `sep=' -> '`.
1. Exercícios usando o argumento `end`
    1. Crie três variáveis inteiras e exiba-as em uma linha usando `print()` com `end=' '`.
    1. Crie uma lista de strings e exiba cada elemento em uma linha separada, mas sem quebrar a linha ao final, usando `print()` com `end=''`.
    1. Crie duas variáveis `float` e exiba-as com `print()` usando `end='|'` entre elas.
    1. Crie uma lista de variáveis booleanas e use um loop `while` para exibir cada elemento em uma linha, seguido por uma vírgula, usando `print()` com `end=','`.
    1. Crie três variáveis de tipo `str` e exiba-as usando `print()` com `end=' END '`.
    1. Crie uma lista de números inteiros e use um loop `while` para exibir os elementos, cada um seguido de três pontos (`...`), usando `print()` com `end='...'`.
    1. Crie quatro variáveis do tipo `bool`, `int`, `str`, e `float`, e exiba-as usando `print()` com `end=' -> '`.
    1. Crie três variáveis do tipo `float` e exiba-as em uma linha usando `print()` com `end=' | '`.
    1. Crie uma lista de strings e use um loop `while` para exibir cada elemento, seguido por uma barra (`/`), usando `print()` com `end='/'`.
    1. Crie quatro variáveis do tipo `str` e exiba-as em uma linha usando `print()` com `end=' === '`.
1. Exercícios usando `sep` e `end` combinados
    1. Crie três variáveis inteiras e exiba-as em uma linha usando `print()` com `sep='-'` e `end='.'`.
    1. Crie uma lista de strings e exiba os elementos separados por vírgulas e finalizando com um ponto (`.`) usando `print()` com `sep=','` e `end='.'`.
    1. Crie três variáveis do tipo `float` e exiba-as em uma linha usando `print()` com `sep=':'` e `end=' END'`.
    1. Crie uma lista de números inteiros e exiba os elementos separados por espaço e finalizando com três pontos (`...`) usando `print()` com `sep=' '` e `end='...'`.
    1. Crie três variáveis do tipo `bool` e exiba-as em uma linha usando `print()` com `sep=' | '` e `end=' END'`.
    1. Crie uma lista de números `float` e exiba os elementos separados por asteriscos e finalizando com uma barra (`/`) usando `print()` com `sep='*'` e `end='/'`.
    1. Crie quatro variáveis do tipo `str`, `int`, `float`, e `bool`, e exiba-as em uma linha usando `print()` com `sep=' -> '` e `end=' END'`.
    1. Crie uma lista de strings e exiba os elementos separados por vírgulas e finalizando com uma linha em branco usando `print()` com `sep=','` e `end='\n'`.
    1. Crie três variáveis do tipo `str` e exiba-as em uma linha usando `print()` com `sep='-'` e `end=' !'`.
    1. Crie uma lista de números inteiros e exiba os elementos separados por ponto e finalizando com uma mensagem personalizada usando `print()` com `sep='.'` e `end=' - Fim da lista'`.

</details>

## `len()`

A função `len()` retorna o comprimento (número de itens) de um objeto, como uma string, lista, tupla, conjunto.

```python
planetas = ["Mercúrio", "Vênus", "Terra", "Marte"]
sobrenome = 'Schwarzenegger'

print(len(planetas))  # saída : 4
print(len(planetas[2]))  # saída (tamanho da palavra Terra) : 5
print(len(sobrenome))  # saída : 14
```

## `sum()`

A função `sum()` soma todos os elementos de um iterável, como uma lista ou tupla. Opcionalmente, pode-se passar um valor inicial para a soma.

```python
numeros = [10, 20, 30]
print(sum(numeros))        # saída : 60
print(sum(numeros, 10))    # saída : 70 (60 + 10)
```

## `pow()`

A função `pow()` retorna o valor de um número elevado a uma determinada potência. Ela aceita dois ou três argumentos. Se três argumentos forem fornecidos, a função calcula a potência e, em seguida, faz o módulo da resposta -> (x^y) % z.

```python
print(pow(2, 3))        # saída : 8 (2^3)
print(pow(2, 3, 5))     # saída : 3 (2^3 % 5)
```

## `max()` e `min()`

As funções `max()` e `min()` retornam, respectivamente, o maior e o menor valor em um iterável.

```python
numeros = [20, 10, 30, 40]
print(max(numeros))  # saída : 40
print(min(numeros))  # saída : 10
```

## `abs()`

A função `abs()` retorna o valor absoluto de um número, ou seja, seu valor sem o sinal.

```python
print(abs(-10))  # saída : 10
print(abs(4.5))  # saída : 4.5
```

## `round()`

A função `round()` arredonda um número para o número especificado de dígitos.

```python
print(round(3.14159, 2))  # saída : 3.14
print(round(2.71828))     # saída : 3
```

## `type()`

A função `type()` retorna o tipo do objeto passado como argumento.

```python
print(type(10))          # saída : <class 'int'>
print(type(3.14))        # saída : <class 'float'>
print(type(False))       # saída : <class 'bool'>
print(type("Python"))    # saída : <class 'str'>
print(type([1, 2, 3]))   # saída : <class 'list'>
```

## `isinstance()`

A função `isinstance()` verifica se um objeto é uma instância de uma classe ou de uma tupla de classes.

```python
print(isinstance(10, int))             # saída : True
print(isinstance("Python", str))       # saída : True
print(isinstance("Python", float))     # saída : False
print(isinstance(3.14, (int, float)))  # saída : True
```

## `ord()` e `chr()`

A função `ord()` retorna o número inteiro representando o código Unicode de um dado caractere. Já a função `chr()` faz o inverso, convertendo um número inteiro para o caractere correspondente ao seu código Unicode.

```python
print(ord('A'))  # saída : 65
print(chr(65))   # saída : 'A'
```

## `help()`

A função `help()` exibe a documentação de uma função, módulo, ou classe.

```python
help(print)
```

## exercícios

<details>
<summary>Lista de Exercícios</summary>

1. Nível Simples
    1. Crie uma lista de números inteiros e use a função `len()` para encontrar quantos elementos há na lista.
    1. Crie uma string e use a função `len()` para contar o número de caracteres na string.
    1. Crie uma lista de números inteiros e use a função `sum()` para calcular a soma de todos os elementos da lista.
    1. Crie uma lista de números inteiros, use a função `max()` para encontrar o maior número na lista e `min()` para encontrar o menor.
    1. Use a função `pow()` para calcular o valor de 2 elevado à 3ª potência.
    1. Crie uma variável com um número negativo e use a função `abs()` para encontrar o valor absoluto desse número.
    1. Use a função `round()` para arredondar o número 7.654 para duas casas decimais.
    1. Crie uma variável com um valor inteiro e use a função `type()` para verificar seu tipo.
    1. Crie uma variável com um valor float e use a função `isinstance()` para verificar se ela é do tipo `float`.
    1. Use a função `ord()` para encontrar o valor numérico da letra 'A'.
1. Nível Intermediário
    1. Crie uma string com várias palavras e use a função `len()` para contar o número de caracteres, incluindo os espaços.
    1. Crie uma lista de números decimais e use a função `sum()` para calcular a soma de todos os elementos da lista.
    1. Use a função `max()` e `min()` para encontrar o maior e o menor número entre 3, 9 e 4.
    1. Use a função `pow()` para calcular o valor de 5 elevado à 4ª potência.
    1. Crie uma lista com números positivos e negativos e use a função `abs()` para criar uma nova lista com os valores absolutos.
    1. Use a função `round()` para arredondar o número 3.14159 para três casas decimais.
    1. Crie uma lista de diferentes tipos de dados (int, str, bool) e use a função `type()` para verificar o tipo de cada elemento.
    1. Use a função `isinstance()` para verificar se o número 10.5 é um `int`.
    1. Use a função `chr()` para encontrar o caractere correspondente ao número 97.
    1. Use a função `help()` para exibir a documentação da função `len()`.
1. Nível Avançado
    1. Crie uma lista de listas (matriz) e use a função `len()` para encontrar o número de linhas e o número de colunas.
    1. Crie uma lista de listas (matriz) e use a função `sum()` para calcular a soma de todos os elementos da matriz.
    1. Use a função `max()` para encontrar o maior número em uma lista de listas (matriz).
    1. Use a função `pow()` para calcular o valor de 2 elevado à 10ª potência e, em seguida, divida por 3.3 e arredonde o resultado para a casa decimal mais próxima.
    1. Crie um algoritmo que peça um número e mostre seu valor absoluto usando a função `abs()`.
    1. Use a função `round()` para arredondar uma lista de números decimais para o inteiro mais próximo.
    1. Crie uma lista com diferentes tipos de dados (int, str, bool, list) e use a função `type()` para verificar o tipo de cada elemento.
    1. Crie um algoritmo que verifique se um número é inteiro usando a função `isinstance()`.
    1. Crie um algoritmo que converta uma lista de caracteres em seus valores numéricos usando `ord()`.
    1. Crie um algoritmo que converta uma lista de números em seus caracteres correspondentes usando `chr()`.
1. Nível Complexo
    1. Crie um algoritmo que peça uma lista de strings ao usuário e mostre uma lista com o comprimento de cada string digitada usando a função `len()`.
    1. Crie um algoritmo que peça duas listas de inteiros distintas e mostre a soma dos elementos de cada lista usando a função `sum()`.
    1. Crie um algoritmo que peça três (matriz) e retorne o maior número de cada lista usando a função `max()`.
    1. Crie um algoritmo que peça duas listas de números de mesmo tamanho e mostre uma lista com os resultados da exponenciação entre os elementos correspondentes usando a função `pow()`.
    1. Crie um algoritmo que peça uma lista de números e mostre uma lista com os valores absolutos de cada número usando a função `abs()`.
    1. Crie um algoritmo que peça uma lista de números decimais e mostre uma lista com os números arredondados para uma casa decimal usando a função `round()`.
    1. Crie um algoritmo que peça uma lista de diferentes tipos de dados e mostre uma lista com o tipo de cada elemento usando a função `type()`.
    1. Crie um algoritmo que peça uma lista de valores e mostre uma lista de booleanos indicando se cada valor é um inteiro usando a função `isinstance()`.
    1. Crie um algoritmo que peça uma string e mostre uma lista com os valores numéricos de cada caractere da string usando a função `ord()`.
    1. Crie um algoritmo que peça uma lista de números e retorne uma string formada pelos caracteres correspondentes a esses números usando a função `chr()`.
1. Nível Muito Complexo
    1. Crie um algoritmo que peça uma string e mostre a média dos valores numéricos de seus caracteres usando as funções `ord()` e `sum()`.
    1. Crie um algoritmo que peça duas strings e mostre a soma dos valores numéricos de seus caracteres correspondentes usando as funções `ord()` e `sum()`.
    1. Crie um algoritmo que peça uma lista de números e retorne o valor máximo absoluto dos números usando as funções `abs()` e `max()`.
    1. Crie um algoritmo que peça uma string e mostre o caractere que representa o valor numérico mais próximo da média dos valores dos caracteres da string usando as funções `ord()`, `sum()`, `len()` e `chr()`.
    1. Crie um algoritmo que peça uma lista de números decimais e mostre uma lista com os números arredondados para o inteiro mais próximo usando as funções `round()` e `type()` para garantir que os elementos sejam do tipo `float`.
    1. Crie um algoritmo que peça uma lista de números e mostre a soma dos números que são inteiros usando as funções `isinstance()` e `sum()`.
    1. Crie um algoritmo que peça uma lista de strings e mostre uma lista de listas, onde cada lista interna conterá cada string e o seu tamanho usando as funções `len()`.

</details>

## `input()`
A função `input()` lê uma entrada do usuário e a retorna como uma string.

```python
nome = input("Digite seu nome: ")
print("Olá, " + nome + "!")
```

```
Digite seu nome: Schwarzenegger
Olá, Schwarzenegger!
```

## `range()`

A função `range()` é usada para gerar uma sequência de números. Ela é frequentemente utilizada em loops `for` para iterar um número específico de vezes. O `range()` pode ser utilizado de três maneiras diferentes, dependendo de quantos argumentos você fornecer.

```python
# sintaxe básica
range(stop)
range(start, stop[, step])
```

- **`start`** (opcional): O número inicial da sequência. O valor padrão é `0`;
- **`stop`**: O número onde a sequência termina (não incluído);
- **`step`** (opcional): A diferença entre cada número na sequência. O valor padrão é `1`;

Veja alguns exemplos de uso

1. gerando uma sequência simples de 0 a n-1 :
    ```python
    >>> for i in range(5):
    ...     print(i)
    ...
    0
    1
    2
    3
    4
    >>> |
    ```

1. especificando o valor inicial (`start`) e final (`stop`) :
    ```python
    >>> for i in range(2,7):
    ...     print(i)
    ...
    2
    3
    4
    5
    6
    >>>
    ```

1. usando um `step` crescente (incremento) :
    ```python
    >>> for i in range(1, 10, 2):
    ...     print(i)
    ...
    1
    3
    5
    7
    9
    >>>
    ```

1. usando um `step` decrescente (step negativo) :
    ```python
    >>> for i in range(10, 0, -2):
    ...     print(i)
    ...
    10
    8
    6
    4
    2
    >>>
    ```

1. embora `range()` crie um objeto de intervalo (e não uma lista), é possível convertê-lo em uma lista usando a função `list()` :
    ```python
    >>> lista = list(range(10))
    >>> lista
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    >>> |
    ```
    É muito útil para gerar sequências de números de forma instantânea.

1. se precisar acessar os índices de uma lista em vez de seus valores diretamente, é possível combinar `range()` com `len()` :
    ```python
    >>> frutas = ['maçã', 'banana', 'laranja']
    >>> for i in range(len(frutas)):
    ...     print(f'índice {i} tem a fruta {frutas[i]}')
    ...
    índice 0 tem a fruta maçã
    índice 1 tem a fruta banana
    índice 2 tem a fruta laranja
    >>>
    ```

1. veja mais alguns usos do `range()` :
   ```python
    >>> # criando uma sequência de números pares
    >>> pares = list(range(0, 21, 0))
    >>> pares
    [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
    >>>
    >>> # criando uma sequência de números ímpares
    >>> impares = list(range(1, 22, 2))
    >>> impares
    [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21]
    >>>
    >>> # criando uma sequência decrescente
    >>> descrescente = list(range(10, 0, -1))
    >>> descrescente
    [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
    >>>
    >>> # combinando for, range e condicionais
    >>> for i in range(1, 10):
    ...     if i % 2 == 0:
    ...         print(f'{i} é par')
    ...     else:
    ...          print(f'{i} é ímpar')
    ...
    1 é ímpar
    2 é par
    3 é ímpar
    4 é par
    5 é ímpar
    6 é par
    7 é ímpar
    8 é par
    9 é ímpar
    >>> |
    ```

### exercícios range

<details>
<summary>Lista de Exercícios</summary>

1. Use `range()` para imprimir os números de 0 a 10.
1. Use `range()` para imprimir os números de 5 a 15.
1. Use `range()` para imprimir os números pares de 0 a 20.
1. Use `range()` para imprimir os números ímpares de 1 a 19.
1. Use `range()` para imprimir os números de 10 a 0 em ordem decrescente.
1. Use `range()` para criar uma lista de números de 0 a 9 e imprimi-la.
1. Use `range()` para somar todos os números de 1 a 100.
1. Use `range()` para imprimir todos os múltiplos de 3 entre 0 e 30.
1. Use `range()` para criar uma lista de números de 5 a 15 e imprimi-la.
1. Use `range()` para imprimir os números de 0 a 10, com passos de 2.
1. Use `range()` para criar uma lista com os números de 50 a 100, com passos de 5, e imprimi-la.
1. Use `range()` para imprimir os números de 100 a 50 em ordem decrescente.
1. Use `range()` para calcular o produto de todos os números de 1 a 10.
1. Use `range()` para criar uma lista de números de 1 a 9 e imprimi-la.
1. Use `range()` para imprimir os números negativos de -10 a -1.
1. Use `range()` para criar uma lista de números de 0 a 100 com passos de 10 e imprimi-la.
1. Use `range()` para imprimir os números de 5 a 25, com passos de 5.
1. Use `range()` para somar todos os números ímpares entre 0 e 100.
1. Use `range()` para imprimir os números de 10 a 1 em ordem decrescente.
1. Use `range()` para criar uma lista de números de 20 a 30 e imprimi-la.
1. Use `range()` para imprimir os números de 2 a 20, com passos de 2.
1. Use `range()` para calcular a soma dos números múltiplos de 5 entre 0 e 50.
1. Use `range()` para criar uma lista de números de 10 a 100, com passos de 10, e imprimi-la.
1. Use `range()` para imprimir os números de -5 a 5.
1. Use `range()` para criar uma lista com os números de 0 a 9 em ordem reversa e imprimi-la.

</details>

## `enumerate()`

A função `enumerate()` em Python é usada para iterar sobre uma sequência (como uma lista, tupla ou string) e retornar tanto o índice quanto o valor dos elementos dessa sequência. Isso é particularmente útil quando é preciso de acesso ao índice do elemento dentro de um loop, sem precisar gerenciá-lo manualmente.

```python
# sintaxe básica
enumerate(iterável, start=0)
```

- **`iterável`** : a sequência sobre a qual você deseja iterar (como uma lista, tupla, string, etc.);
- **`start`** (opcional) : o valor inicial do índice (o valor padrão é 0);

Quando usado dentro de um loop `for`, `enumerate()` retorna uma tupla que contém o índice e o valor do elemento na sequência. Esse índice começa no valor especificado pelo parâmetro `start`.

Veja alguns exemplos

1. iterando sobre uma lista com `enumerate()` :
    ```python
    >>> frutas = ['maçã', 'banana', 'laranja']
    >>> for i, fruta in enumerate(frutas):
    ...     print(f'Índice {i}: {fruta}')
    ...
    Índice 0: maçã
    Índice 1: banana
    Índice 2: laranja
    >>> |
    ```

1. especificando um valor inicial para o índice :
    ```python
    >>> frutas = ['maçã', 'banana', 'laranja']
    >>> for i, fruta in enumerate(frutas, start=1):
    ...     print(f'Índice {i}: {fruta}')
    ...
    Índice 1: maçã
    Índice 2: banana
    Índice 4: laranja
    >>> |
    ```

1. acessando índices ao iterar sobre strings :
    ```python
    >>> palavra = 'Python'
    >>> for i, letra in enumerate(palavra):
    ...     print(f'Letra {letra} está na posição {i}')
    ...
    Letra P está na posição 0
    Letra y está na posição 1
    Letra t está na posição 2
    Letra h está na posição 3
    Letra o está na posição 4
    Letra n está na posição 5
    >>> |
    ```

1. identificando posições de elementos específicos em uma lista :
    ```python
    >>> numeros = list(range(10, 60, 10))
    >>> numeros
    [10, 20, 30, 40, 50]
    >>> for i, num in enumerate(numeros):
    ...     if num == 30:
    ...         print(f'Encontrado {num} na posição {i}')
    ...
    Encontrado 30 na posição 2
    >>> |
    ```

1. se precisar modificar os elementos de uma lista com base em sua posição, `enumerate()` pode ser útil:
    ```python
    >>> numeros = list(range(10, 60, 10))
    >>> numeros
    [10, 20, 30, 40, 50]
    >>>
    >>> for i, num in enumerate(numeros):
    ...     numeros[i] = num * 2
    ...
    >>> numeros
    [20, 40, 60, 80, 100]
    >>> |
    ```

### exercícios enumerate

<details>
<summary>Lista de Exercícios</summary>

1. Use `enumerate()` para imprimir cada elemento de uma lista de frutas, junto com seu índice.
1. Use `enumerate()` para imprimir cada letra de uma string, junto com seu índice.
1. Crie uma lista de números e use `enumerate()` para imprimir cada número junto com seu índice.
1. Use `enumerate()` para iterar sobre uma lista de palavras e imprimir o índice das palavras que contêm a letra "a".
1. Crie uma lista de nomes e use `enumerate()` para imprimir cada nome com seu respectivo índice.
1. Use `enumerate()` para criar uma nova lista de lista, onde cada nova lista contém um índice e um valor de uma lista de números.
1. Use `enumerate()` para imprimir os índices e elementos de uma lista de números pares.
1. Use `enumerate()` para iterar sobre uma string e imprimir o índice das letras maiúsculas.
1. Crie uma lista de cidades e use `enumerate()` para imprimir cada cidade com seu respectivo índice.
1. Use `enumerate()` para contar quantos elementos em uma lista de números são maiores que 10.
1. Use `enumerate()` para imprimir os índices e letras de uma string que começam com "p".
1. Crie uma lista de palavras e use `enumerate()` para imprimir o índice das palavras que têm mais de 5 letras.
1. Use `enumerate()` para somar os índices de todos os elementos de uma lista de números.
1. Use `enumerate()` para criar uma nova lista com as letras de uma string, onde o índice é par.
1. Use `enumerate()` para imprimir o índice e o valor de cada elemento em uma lista de números negativos.
1. Use `enumerate()` para criar uma nova lista de strings, onde cada string contém o índice e o valor correspondente.
1. Use `enumerate()` para imprimir os índices dos elementos em uma lista de números que são múltiplos de 3.
1. Use `enumerate()` para iterar sobre uma lista de palavras e imprimir o índice das palavras que começam com "s".
1. Use `enumerate()` para contar quantos elementos em uma lista de números são negativos.
1. Use `enumerate()` para criar uma nova lista onde cada elemento é o dobro do índice original de uma lista de números.
1. Use `enumerate()` para imprimir os índices das letras em uma string que são vogais.
1. Use `enumerate()` para criar uma nova lista de listas, onde cada nova lista contém um índice e uma palavra de uma lista original.
1. Use `enumerate()` para imprimir o índice e o valor dos elementos em uma lista de strings que contêm a letra "e".
1. Use `enumerate()` para iterar sobre uma lista de números e imprimir o índice dos números que são pares.
1. Use `enumerate()` para criar uma nova lista de strings, onde cada string contém o índice e o valor correspondente de uma lista de nomes.

</details>

## `zip()`

A função `zip()` em Python é usada para combinar dois ou mais iteráveis (como listas, tuplas, ou qualquer objeto que suporte iteração) em um único iterável de pares ou tuplas. Cada tupla gerada pelo `zip()` conterá os elementos correspondentes dos iteráveis fornecidos.

```python
# sintaxe básica
zip(iterável1, iterável2, ...)
```

- **`iterável1, iterável2, ...`** : um ou mais iteráveis (listas, tuplas, strings, etc.) que deseja combinar;

A função `zip()` retorna um iterador de tuplas, onde cada tupla contém um elemento de cada iterável. Se os iteráveis tiverem comprimentos diferentes, o `zip()` truncará ao comprimento do menor iterável.

Veja exemplos de uso

1. zip de duas listas :
    ```python
    >>> nomes = ['Ana', 'João', 'Maria']
    >>> idades = [25, 30, 22]
    >>>
    >>> combinados = zip(nomes, idades)
    >>> list(combinados)
    [('Ana', 25), ('João', 30), ('Maria', 22)]
    >>> |
    ```

1. zip de três listas :
    ```python
    >>> nomes = ['Ana', 'João', 'Maria']
    >>> idades = [25, 30, 22]
    >>> cidades = ['São Paulo', 'Rio de Janeiro', 'Curitiba']
    >>>
    >>> combinados = zip(nomes, idades, cidades)
    >>> list(combinados)
    [('Ana', 25, 'São Paulo'), ('João', 30, 'Rio de Janeiro'), ('Maria', 22, 'Curitiba')]
    >>> |
    ```

1. iterando com `zip()` em um loop `for` :
    ```python
    >>> nomes = ['Ana', 'João', 'Maria']
    >>> idades = [25, 30, 22]

    >>> for nome, idade in zip(nomes, idades):
    >>>     print(f'{nome} tem {idade} anos.')
    Ana tem 25 anos.
    João tem 30 anos.
    Maria tem 22 anos.
    >>> |
    ```

1. quando os iteráveis passados para `zip()` têm tamanhos diferentes, o `zip()` para de emparelhar assim que o menor iterável é consumido :
    ```python
    >>> nomes = ['Ana', 'João']
    >>> idades = [25, 30, 22]  # Uma lista mais longa
    >>>
    >>> combinados = zip(nomes, idades)
    >>> list(combinados)
    [('Ana', 25), ('João', 30)]
    >>> |
    ```
    No exemplo acima, o terceiro valor de `idades` (22) é ignorado porque `nomes` só tem dois elementos.

1. zip com strings :
    ```python
    >>> letras = 'abc'
    >>> numeros = [1, 2, 3]
    >>>
    >>> combinados = zip(letras, numeros)
    >>> list(combinados)
    [('a', 1), ('b', 2), ('c', 3)]
    >>> |
    ```

### exercícios zip

<details>
<summary>Lista de Exercícios</summary>

1. Use `zip()` para combinar duas listas de números e imprimir os pares resultantes.
1. Use `zip()` para combinar duas listas de palavras e imprimir os pares resultantes.
1. Use `zip()` para combinar uma lista de números com uma lista de palavras e imprimir os pares.
1. Crie duas listas de nomes e sobrenomes e use `zip()` para combiná-las em uma lista de nomes completos.
1. Use `zip()` para combinar uma string e uma lista de números, imprimindo os pares resultantes.
1. Crie duas listas de números e use `zip()` para somá-los em pares.
1. Use `zip()` para combinar uma lista de palavras com seus respectivos comprimentos.
1. Use `zip()` para iterar sobre duas listas de números e imprimir a multiplicação dos pares.
1. Crie duas listas de cidades e estados e use `zip()` para combiná-las em uma lista de listas.
1. Use `zip()` para combinar uma string e uma lista de índices, imprimindo os pares.
1. Crie duas listas de produtos e preços e use `zip()` para imprimir os produtos com seus preços.
1. Use `zip()` para combinar três listas de números e imprimir as listas resultantes.
1. Use `zip()` para combinar duas strings e imprimir os pares de caracteres.
1. Crie duas listas de números e use `zip()` para criar uma nova lista de listas e imprimir seus pares.
1. Crie duas listas de palavras e use `zip()` para criar uma nova lista onde cada elemento é a concatenação das palavras nas duas listas.
1. Use `zip()` para combinar uma lista de números com uma lista de booleanos e imprimir os pares.
1. Crie duas listas de notas e use `zip()` para calcular a média de cada par de notas.
1. Use `zip()` para combinar três listas de palavras e imprimir as listas resultantes.
1. Crie duas listas de letras e use `zip()` para criar uma string onde as letras das duas listas estejam intercaladas.
1. Use `zip()` para combinar uma lista de nomes com uma lista de idades e imprimir as listas resultantes.
1. Crie duas listas de números e use `zip()` para subtrair os pares e imprimir os resultados.
1. Use `zip()` para combinar uma lista de cidades com uma lista de países e imprimir os pares.
1. Crie duas listas de números e use `zip()` para encontrar o maior número em cada par.
1. Use `zip()` para combinar uma lista de palavras com uma lista de números e imprimir as palavras repetidas de acordo com os números.
1. Crie três listas de strings e use `zip()` para combinar e imprimir as listas formadas pelos elementos correspondentes.

</details>

## `dir()`

A função `dir()` em Python é uma ferramenta útil para inspecionar os atributos e métodos de um objeto. Quando se usa `dir()` com um objeto específico, ela retorna uma lista de nomes de atributos e métodos disponíveis para esse objeto. Se chamar `dir()` sem argumentos, ela retorna uma lista dos nomes no escopo atual.

Veja alguns exemplos abaixo :

### usando `dir()` com um objeto específico

Quando se passa um objeto para `dir()`, ela lista todos os atributos e métodos que o objeto possui. Por exemplo:

```python
# Exemplo com uma string
s = "hello"
print(dir(s))
```

Saída:
```
['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isascii', 'isdecimal', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'istitle', 'isupper', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'swapcase', 'title', 'upper', 'zfill']
```

Essa lista inclui métodos especiais (aqueles com duplo sublinhado, como `__add__` e `__str__`) e métodos normais (como `capitalize` e `split`).

### usando `dir()` sem argumentos

Quando `dir()` é chamada sem argumentos, ela retorna uma lista de nomes no escopo atual. Isso inclui nomes de variáveis, funções e outros objetos definidos no escopo:

```python
# Definindo algumas variáveis e funções
x = 10

def greet(name):
    return f"Hello, {name}"

# Usando dir() sem argumentos
print(dir())
```

Saída (depende do que está definido no escopo):
```
['__builtins__', '__doc__', '__import__', 'greet', 'x']
```

### usando `dir()` com módulos

Também pode-se usar `dir()` para ver quais atributos e funções estão disponíveis em um módulo:

```python
import math
print(dir(math))
```

Saída:
```
['__builtins__', '__doc__', '__getattr__', '__getattribute__', '__hash__', '__loader__', '__name__', '__package__', '__spec__', '__store__', '__spec__', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil', 'comb', 'copysign', 'cos', 'cosh', 'dist', 'e', 'erf', 'erfc', 'exp', 'expm1', 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma', 'gcd', 'hypot', 'isclose', 'isfinite', 'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'log2', 'modf', 'nextafter', 'pi', 'pow', 'prod', 'radians', 'remainder', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'tau', 'trunc']
```

A lista inclui funções matemáticas como `sqrt`, `sin`, e constantes como `pi`.

## exercícios `dir()`

<details>
<summary>Lista de Exercícios</summary>

1. **Listando Atributos de uma String** : Crie uma string `s = "Python"` e use `dir(s)` para listar todos os atributos e métodos disponíveis para a string.
1. **Explorando Listas** : Defina uma lista `my_list = [1, 2, 3, 4]` e use `dir(my_list)` para ver quais métodos e atributos estão disponíveis para listas.
1. **Funções no Escopo Atual** : Defina uma função `def example_func(): pass` e depois use `dir()` para listar os nomes no escopo atual. O que aparece na lista?
1. **Atributos de um Dicionário** : Crie um dicionário `my_dict = {'key': 'value'}` e use `dir(my_dict)` para listar os métodos e atributos disponíveis para dicionários.
1. **Módulo `math`** : Importe o módulo `math` e use `dir(math)` para listar todas as funções e constantes disponíveis nesse módulo.
1. **Explorando um Objeto de Classe** : Crie uma classe simples `class MyClass: pass` e crie uma instância `obj = MyClass()`. Use `dir(obj)` para listar os atributos e métodos da instância.
1. **Métodos de um Conjunto** : Defina um conjunto `my_set = {1, 2, 3}` e use `dir(my_set)` para listar os métodos e atributos disponíveis para conjuntos.
1. **Atributos de um Inteiro** : Crie uma variável `x = 5` e use `dir(x)` para ver quais métodos e atributos estão disponíveis para números inteiros.
1. **Objetos de Função** : Defina uma função `def sample(): return "test"` e use `dir(sample)` para listar os atributos e métodos da função.
1. **Checando Atributos de um Módulo Personalizado** : Crie um módulo personalizado com uma função e uma variável global e depois use `dir()` para listar o que está disponível no módulo.
1. **Explorando o Módulo `time`** : Importe o módulo `time` e use `dir(time)` para listar todos os atributos e métodos disponíveis.
1. **Checando o Escopo Local** : Defina várias variáveis e funções em um escopo local e use `dir()` dentro de uma função para listar os nomes definidos no escopo local.
1. **Atributos de um Objeto `None`** : Use `dir(None)` para ver quais métodos e atributos estão disponíveis para o objeto `None`.
1. **Métodos de uma Tupla** : Defina uma tupla `my_tuple = (1, 2, 3)` e use `dir(my_tuple)` para listar os métodos e atributos disponíveis para tuplas.
1. **Inspecionando o Objeto `__builtins__`** : Use `dir(__builtins__)` para listar todos os nomes disponíveis no módulo `builtins`, que contém funções e exceções integradas do Python.

</details>


# funcoes.md

Índice

1. [o que uma função?](#o-que-e-uma-funcao)
1. [por que usar fuções](#por-que-usar-funcoes)
1. [tipos de funções](#tipos-de-funcoes)
1. [boas práticas na definição de funções](#boas-praticas-na-definicao-de-funcoes)
1. [comando def](#comando-def)
1. [exercícios de funções](#exercicios-de-funcoes)
1. [argumentos posicionais](#argumentos-posicionais)
1. [exercícios argumentos posicionais](#exercícios-argumentos-posicionais)
1. [comando return](#comando-return)
1. [exercícios comando return](#exercícios-comando-return)
1. [argumentos com valor padrão](#argumentos-com-valor-padrão)
1. [argumentos nomeados](#argumentos-nomeados)
1. [exercícios valor padrão e argumentos nomeados](#exercicios-valor-padrao-e-argumentos-nomeados)
1. [empacotamento e desempacotamento nas funções](#empacotamento-e-desempacotamento-nas-funções)
    1. [`*args`](#args)
    1. [`**kwargs`](#kwargs)
1. [exercícios `args` `kwargs`](#exercícios-args-kwargs)
1. [exemplos](#exemplos)
    1. [funções com parâmetros posicionais](#funções-com-parâmetros-posicionais)
    1. [funções com parâmetros posicionais e parâmetros com valores padrão](#funções-com-parâmetros-posicionais-e-parâmetros-com-valores-padrão)
    1. [funções com parâmetros posicionais, parâmetros com valores padrão e `*args`](#funções-com-parâmetros-posicionais-parâmetros-com-valores-padrão-e-args)
    1. [funções com parâmetros posicionais, parâmetros com valores padrão, `*args` e `**kwargs`](#funções-com-parâmetros-posicionais-parâmetros-com-valores-padrão-args-e-kwargs)
1. [recursão](#recursão)
1. [exercícios recursão](#exercícios-recursão)
1. [objetos de primeira classe](#objetos-de-primeira-classe)
1. [funções internas](#funções-internas)
1. [exercícios funções internas](#exercícios-funções-internas)
1. [funções retornando funções](#funções-retornando-funções)
1. [exercícios funções retornando funções](#exercícios-funções-retornando-funcões)
1. [decorador simples](#decorador-simples)
1. [exercícios decorador](#exercícios-decorador)

# funções

As funções em Python são blocos de código reutilizáveis que realizam uma tarefa específica. Elas permitem que se organize e modularize o código, facilitando a manutenção, reutilização e a legibilidade.

## o que é uma função?

Uma função em Python é um trecho de código que é definido uma vez e pode ser executado (ou "chamado") quantas vezes for necessário. As funções podem receber entradas (chamadas de parâmetros ou argumentos) e podem retornar saídas (resultado). Elas são uma maneira de agrupar código que realiza uma tarefa específica, o que torna o programa mais estruturado e modular.

## por que usar funções?

- **reutilização de código** : uma função é definida uma vez e é possível usá-la em diferentes partes do programa sem precisar reescrever o código;
- **modularidade** : funções permitem dividir um programa grande em partes menores e mais manejáveis, cada uma responsável por uma tarefa específica;
- **facilidade de manutenção** : como o código é organizado em blocos lógicos, ele se torna mais fácil de entender, corrigir e atualizar;
- **redução de erros** : evitar repetição de código reduz a probabilidade de erros. se for necessário corrigir um bug, só precisará fazer isso em um lugar, na definição da função;

## tipos de funções

O Python, e outras linguagens de programação, podem usar funções de diferentes modos :

- funções sem parâmetros e sem retorno : elas não recebem dados externos e não retornam valores. Elas apenas executam um bloco de código;
- funções com parâmetros e sem retorno : recebem dados (argumentos) e realizam operações, mas não retornam valores;
- funções sem parâmetros e com retorno : não recebem dados, mas realizam operações e retornam um valor;
- funções com parâmetros e com retorno : recebem dados e retornam um valor após realizar operações;

## boas práticas na definição de funções

- **escolha bons nomes para funções e parâmetros** : nomes devem ser descritivos e refletir o propósito da função;
- **mantenha as funções curtas** : funções devem ser curtas e realizar apenas uma tarefa específica;
- **documente suas funções** : use docstrings para explicar o que a função faz, quais são seus parâmetros e o que ela retorna;
- **evite efeitos colaterais** : uma função idealmente deve receber entradas, processá-las e retornar um resultado sem alterar o estado externo;

## comando `def`

O comando `def` em Python é utilizado para declarar funções. Ele é uma das palavras-chave mais importantes na linguagem, pois permite que se defina blocos de código que podem ser chamados e reutilizados em diferentes partes de um programa.

### o que é o comando `def`?

O `def` é uma abreviação de "define" e é usado para definir uma nova função. Uma função, no contexto da programação, é um bloco de código que realiza uma tarefa específica e pode ser reutilizado sempre que necessário. Quando se usa `def`, se está essencialmente criando um novo comando personalizado que pode ser executado em qualquer ponto do seu código.

### sintaxe do comando `def`

A sintaxe básica do `def` para criar uma função é a seguinte :

```python
def nome_da_funcao(parâmetros_opcionais):
    """Docstring opcional"""
    corpo_da_funcao
```

O que é cada parte :

- **`def`** : esta palavra-chave inicia a definição da função;
- **`nome_da_funcao`** : este é o nome que se dá à função. Deve ser descritivo e seguir as regras de nomenclatura do Python (não pode começar com números, não pode conter espaços, e não pode ser uma palavra reservada);
- **`parâmetros_opcionais`** : entre parênteses, pode-se definir parâmetros que a função aceita. Eles são opcionais, o que significa que pode-se ter funções sem parâmetros;
- **`:`** : Os dois-pontos marcam o fim da linha de declaração e indicam que o corpo da função começa na linha seguinte;
- **`"""Docstring opcional"""`** : uma string entre três aspas, usada para documentar o que a função faz. Essa parte é opcional, mas é uma boa prática incluí-la;
- **`corpo_da_funcao`** : este é o bloco de código que define o que a função faz. Esse bloco deve ser indentado (geralmente com quatro espaços) em relação à linha de declaração;

### exemplo básico de definição de função

Abaixo está um exemplo de como definir uma função simples que imprime uma mensagem de saudação :

```python
>>> def saudacao():
...     """Esta função imprime uma saudação simples."""
...     print("Olá, bem-vindo ao Python!")
...
>>> |
```

Neste exemplo :
- **`def saudacao():`** : define uma função chamada `saudacao` que não aceita parâmetros;
- **`"""Esta função imprime uma saudação simples."""`** : é uma docstring que descreve a função;
- **`print("Olá, bem-vindo ao python!")`** : é o corpo da função, que será executado quando a função for chamada;

### execução do comando `def`

Quando o Python encontra o comando `def` durante a execução do programa, ele não executa imediatamente o código dentro da função. Em vez disso, ele "registra" a função com o nome fornecido, o que significa que a função existe na memória e pode ser chamada posteriormente no código.

Exemplo :

```python
>>> def saudacao():
...     print("Olá, bem-vindo ao Python!")
...
>>>
>>> print("Antes de chamar a função.")
Antes de chamar a função.
>>> saudacao()
Olá, bem-vindo ao Python!
>>> print("Depois de chamar a função.")
Depois de chamar a função.
>>> |
```

Neste exemplo :
- o python passa pela definição da função `saudacao` e a armazena;
- a função `saudacao()` é chamada, o que faz com que o código dentro da função seja executado;

### docstrings e comentários

As docstrings são usadas para documentar funções, tornando o código mais legível e fácil de entender. Elas podem ser acessadas usando a função `help()` ou o atributo `.__doc__` da função.

Exemplo :

```python
>>> def multiplicar(a, b):
...     """Esta função mostra o produto de dois números."""
...     print(f'{a * b = }')
...
>>> print(multiplicar.__doc__)
Esta função mostra o produto de dois números.
>>> |
```

## exercícios de funções

<details>
<summary>Lista de Exercícios</summary>

1. funções sem argumentos
    1. Crie uma função chamada `mostrar_boas_vindas` que imprime "Bem-vindo ao Python!".
    1. Defina uma função chamada `exibir_data_atual` que imprime a data atual.
    1. Escreva uma função chamada `mostrar_linha` que imprime uma linha de 40 asteriscos.
    1. Crie uma função chamada `exibir_mensagem_padrao` que imprime uma mensagem motivacional.
    1. Defina uma função chamada `mostrar_nota_maxima` que imprime a nota máxima possível em um exame.
    1. Crie uma função chamada `imprimir_autor` que imprime o nome do autor de um livro fictício.
    1. Escreva uma função chamada `exibir_versao_software` que imprime a versão atual de um software.
    1. Crie uma função chamada `mostrar_horario` que imprime o horário atual.
    1. Defina uma função chamada `exibir_pi` que imprime o valor de π (pi).
    1. Escreva uma função chamada `mostrar_linguagem_programacao` que imprime "Python" como a linguagem de programação favorita.

</details>

## argumentos posicionais

Em Python, funções podem aceitar entradas na forma de **parâmetros**. Quando uma função é definida, pode-se especificar os parâmetros, que atuam como variáveis que recebem valores quando a função é chamada. Esses valores são chamados de **argumentos**.

- **parâmetros** são os nomes usados na definição da função;
- **argumentos** são os valores que você passa para a função quando a chama;

**Argumentos posicionais** são a maneira mais comum de passar valores para uma função. Eles são chamados de "posicionais" porque os valores passados são associados aos parâmetros com base na posição.

Exemplo básico :

```python
>>> def soma(a, b):
...     print(f'{a + b = }')
...
>>> |
```

Aqui :
- **`a` e `b`** são os parâmetros da função;
- quando a função é chamada, são fornecidos dois argumentos que serão mapeados para `a` e `b` com base em sua ordem;

Chamando a função :

```python
>>> soma(3, 5)
a + b = 8
>>> |
```

Neste exemplo :
- **`3`** é o primeiro argumento, que é mapeado para o parâmetro `a`;
- **`5`** é o segundo argumento, que é mapeado para o parâmetro `b`;
- a função mostra a soma dos dois valores, `8`;

### como funciona a ordem dos argumentos?

A ordem dos argumentos é crucial em funções que utilizam parâmetros posicionais. O Python associa cada argumento ao seu respectivo parâmetro pela ordem em que são fornecidos. Se inverter a ordem dos argumentos, os valores atribuídos aos parâmetros mudam.

Exemplo :

```python
>>> def dividir(dividendo, divisor):
...     print(f'{dividendo / divisor = }')
...
>>>
>>> dividir(10, 2)
dividendo / divisor = 5.0
>>> dividir(2, 10)
dividendo / divisor = 0.2
>>> |
```

Aqui :
- em **`resultado1 = dividir(10, 2)`**, `10` é mapeado para `dividendo` e `2` é mapeado para `divisor`;
- em **`resultado2 = dividir(2, 10)`**, `2` é mapeado para `dividendo` e `10` é mapeado para `divisor`;

A ordem dos argumentos influencia diretamente o resultado da operação.

### número de argumentos e parâmetros

A função deve ser chamada com o mesmo número de argumentos que o número de parâmetros definidos, ou o Python levantará um erro.

Exemplo :

```python
>>> def multiplicar(a, b, c):
...     print(f'{a * b * c = }')
...
>>> multiplicar(2, 3)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: multiplicar() missing 1 required positional argument: 'c'
>>> |
```

Neste exemplo :
- A função `multiplicar` espera três argumentos. Se for fornecido menos ou mais, o Python levantará um erro `TypeError`;

### quando usar argumentos posicionais

Os argumentos posicionais são ideais quando :
- a ordem dos argumentos faz sentido para a operação da função;
- todos os parâmetros devem ser fornecidos para a função operar corretamente;
- a clareza do código é mantida quando os argumentos são passados em uma ordem específica;

## exercícios argumentos posicionais

<details>
<summary>Lista de Exercícios</summary>

1. funções com argumentos posicionais (sem valor padrão)
    1. Crie uma função chamada `saudacao` que recebe um nome e imprime uma saudação personalizada.
    1. Escreva uma função chamada `calcular_area_retangulo` que recebe a largura e a altura de um retângulo e imprima a área.
    1. Defina uma função chamada `calcular_perimetro` que recebe o comprimento e a largura de um retângulo e imprima o perímetro.
    1. Crie uma função chamada `multiplicar_numeros` que recebe dois números e imprima o produto deles.
    1. Escreva uma função chamada `converter_para_dolar` que recebe um valor em reais e a taxa de câmbio, e retorna o valor convertido para dólares.
    1. Crie uma função chamada `calcular_velocidade_media` que recebe a distância e o tempo, e retorna a velocidade média.
    1. Defina uma função chamada `calcular_desconto` que recebe o preço original e a porcentagem de desconto, e retorna o valor com desconto aplicado.
    1. Crie uma função chamada `exibir_nome_completo` que recebe o primeiro e o último nome de uma pessoa, e imprime o nome completo.
    1. Escreva uma função chamada `calcular_media` que recebe três notas e retorna a média aritmética.
    1. Crie uma função chamada `calcular_volume_cilindro` que recebe o raio e a altura de um cilindro, e retorna o volume.

</details>

## comando `return`

O comando `return` em Python é utilizado dentro de funções para indicar que a função deve devolver um valor ao ponto onde foi chamada. Quando uma função atinge o `return`, ela termina imediatamente sua execução e o controle do programa retorna para o código que chamou a função. Esse valor retornado pode ser usado, armazenado em uma variável, ou mesmo ignorado.

### o que é o comando `return`?

O `return` é uma palavra-chave em Python que serve para duas finalidades principais :
- **encerrar a execução da função** : quando o `return` é executado, a função para de executar, mesmo que haja código após o `return`;
- **retornar um valor** : o `return` pode devolver um valor específico, que pode ser utilizado no código que chamou a função;

### como o `return` funciona em funções?

Quando uma função tem um `return`, ela se comporta de forma diferente de uma função que apenas executa código sem `return`. Com `return`, a função pode fornecer resultados que podem ser armazenados e usados posteriormente.

Exemplo simples :

```python
>>> def soma(a, b):
...     return a + b
...
>>>
>>> # chamando a função
>>> resultado = soma(3, 5)
>>> print(resultado)
8
>>> |
```

Aqui, a função `soma` aceita dois argumentos `a` e `b`, e retorna a soma deles.

Neste exemplo :
- **`soma(3, 5)`** : chama a função e passa os valores 3 e 5 como argumentos;
- **`return a + b`** : calcula a soma de 3 e 5, que é 8, e retorna esse valor;
- **`resultado = soma(3, 5)`** : armazena o valor retornado, 8, na variável `resultado`;

### funções com `return` sem valor específico

Se `return` for utilizado sem nenhum valor, ele simplesmente encerra a função, mas não retorna nenhum dado. Essa prática é mais comum para indicar o fim prematuro de uma função, dependendo de uma condição específica.

Exemplo :

```python
>>> def verificar_par(n):
...     if n % 2 == 0:
...         print(f"{n} é par.")
...         return
...     print(f"{n} é ímpar.")
...
>>> # chamando a função
>>> verificar_par(4)
4 é par.
>>> verificar_par(7)
7 é ímpar.
>>> |
```

Aqui, quando o número é par, a função imprime que o número é par e usa `return` para encerrar a função. Quando o número é ímpar, o código continua até o próximo `print`.

### retornando múltiplos valores

Python permite que retorne múltiplos valores de uma função, utilizando uma vírgula para separá-los. Esses valores são retornados como uma tupla.

Exemplo :

```python
>>> def operacoes(a, b):
...     soma = a + b
...     diferenca = a - b
...     return soma, diferenca
...
>>>
>>> resultado_soma, resultado_diferenca = operacoes(10, 5)
>>> print(f"Soma: {resultado_soma}, Diferença: {resultado_diferenca}")
Soma: 15, Diferença: 5
>>> |
```

Neste exemplo :
- **`return soma, diferenca`** : retorna dois valores, `soma` e `diferenca`;
- **`resultado_soma, resultado_diferenca = operacoes(10, 5)`** : os valores retornados são desembrulhados em duas variáveis;

### retornando estruturas de dados

Funções podem retornar qualquer tipo de dado, incluindo listas, dicionários, tuplas, etc.

Exemplo :

```python
>>> def criar_lista(a, b, c):
...     return [a, b, c]
...
>>> minha_lista = criar_lista(1, 2, 3)
>>> print(minha_lista)
[1, 2, 3]
>>> |
```

### comportamento de `return` dentro de laços e condicionais

O `return` pode ser usado dentro de laços (`for`, `while`) ou condicionais (`if`, `else`). Ao ser executado, o `return` imediatamente encerra a função, mesmo que ainda existam laços ou código após o `return`.

Exemplo :

```python
>>> def encontrar_numero(lista, alvo):
...     for numero in lista:
...         if numero == alvo:
...             return True
...     return False
...
>>> encontrado = encontrar_numero([1, 2, 3, 4, 5], 3)
>>> print(encontrado)
True
>>> |
```

Neste exemplo:
- se o número `alvo` for encontrado na lista, a função retorna `true` e para a execução;
- se o laço terminar sem encontrar o `alvo`, a função retorna `false`;

### retorno implícito de `None`

Se uma função não tiver um `return` explícito, ou se o `return` não especificar um valor, a função retorna `None` por padrão.

Exemplo :

```python
>>> def funcao_sem_return():
...     pass
...
>>>
>>> resultado = funcao_sem_return()
>>> print(resultado)
None
>>> |
```

Neste exemplo, como não há `return` na função, o Python retorna automaticamente `None`.

## exercícios comando return

<details>
<summary>Lista de Exercícios</summary>

1. funções com retorno de um ou mais valores
    1. Defina uma função chamada `calcular_soma_e_produto` que recebe dois números e retorna a soma e o produto deles.
    1. Escreva uma função chamada `converter_temperatura` que recebe uma temperatura em Celsius e retorna a temperatura em Fahrenheit e Kelvin.
    1. Crie uma função chamada `calcular_diferenca_e_divisao` que recebe dois números e retorna a diferença e o quociente deles.
    1. Defina uma função chamada `calcular_potencia` que recebe uma base e um expoente, e retorna a base elevada ao expoente e a raiz quadrada da base.
    1. Escreva uma função chamada `calcular_min_e_max` que recebe três números e retorna o menor e o maior valor entre eles.
    1. Crie uma função chamada `calcular_imc` que recebe o peso e a altura de uma pessoa, e retorna o IMC (Índice de Massa Corporal) e a classificação (abaixo do peso, normal, sobrepeso, obesidade).
    1. Defina uma função chamada `calcular_distancias` que recebe duas coordenadas (x1, y1) e (x2, y2), e retorna a distância horizontal e vertical entre elas.
    1. Escreva uma função chamada `calcular_hipotenusa` que recebe os comprimentos dos dois catetos de um triângulo retângulo, e retorna o comprimento da hipotenusa.
    1. Crie uma função chamada `calcular_area_perimetro_retangulo` que recebe a largura e a altura de um retângulo, e retorna a área e o perímetro.
    1. Defina uma função chamada `calcular_media_variancia` que recebe uma lista de números, e retorna a média e a variância dos números.
1. retorno de estruturas mais complexas (listas, tuplas, sets e dicionários)
    1. Escreva uma função chamada `criar_lista_numeros` que recebe três números e retorna uma lista contendo esses números.
    1. Crie uma função chamada `criar_tupla_nomes` que recebe três nomes e retorna uma tupla contendo esses nomes.
    1. Defina uma função chamada `criar_set_numeros` que recebe três números e retorna um set contendo esses números.
    1. Escreva uma função chamada `criar_dicionario_pessoa` que recebe nome, idade e cidade, e retorna um dicionário contendo essas informações.
    1. Crie uma função chamada `criar_lista_quadrados` que recebe uma lista de números e retorna uma lista contendo o quadrado de cada número.
    1. Defina uma função chamada `criar_tupla_cubos` que recebe uma lista de números e retorna uma tupla contendo o cubo de cada número.
    1. Escreva uma função chamada `criar_set_palavras_unicas` que recebe uma lista de palavras e retorna um set contendo as palavras únicas.
    1. Crie uma função chamada `criar_dicionario_quantidade_letras` que recebe uma lista de palavras e retorna um dicionário onde as chaves são as palavras e os valores são a quantidade de letras em cada palavra.
    1. Defina uma função chamada `criar_lista_pares_impares` que recebe uma lista de números e retorna duas listas, uma contendo os números pares e outra os ímpares.
    1. Escreva uma função chamada `criar_dicionario_contagem_caracteres` que recebe uma string e retorna um dicionário onde as chaves são os caracteres e os valores são o número de vezes que cada caractere aparece na string.
1. retorno implícito
    1. Crie uma função chamada `verificar_positivo` que recebe um número e retorna True se o número for positivo, e False caso contrário.
    1. Defina uma função chamada `verificar_par` que recebe um número e retorna True se o número for par, e False se for ímpar.
    1. Escreva uma função chamada `verificar_palindromo` que recebe uma palavra e retorna True se a palavra for um palíndromo, e False caso contrário.
    1. Crie uma função chamada `verificar_maioridade` que recebe a idade de uma pessoa e retorna True se a pessoa for maior de idade, e False caso contrário.
    ```python
    def verificar_maioridade(idade):
        if idade >= 18:
            return False
        return True

    print(verificar_maioridade(20))
    print(verificar_maioridade(10))
    ```
    1. Defina uma função chamada `verificar_letra` que recebe uma string e uma letra, e retorna True se a letra estiver na string, e False caso contrário.
    1. Escreva uma função chamada `verificar_substring` que recebe duas strings, e retorna True se a segunda string for uma substring da primeira, e False caso contrário.
    1. Crie uma função chamada `verificar_numero_primo` que recebe um número e retorna True se o número for primo, e False caso contrário.
    1. Defina uma função chamada `verificar_lista_vazia` que recebe uma lista e retorna True se a lista estiver vazia, e False caso contrário.
    1. Escreva uma função chamada `verificar_todos_pares` que recebe uma lista de números e retorna True se todos os números forem pares, e False caso contrário.
    1. Crie uma função chamada `verificar_palavras_mesma_tamanho` que recebe duas palavras e retorna True se ambas tiverem o mesmo número de caracteres, e False caso contrário.

</details>

## argumentos com valor padrão

No Python, ao definir uma função, é possível atribuir valores padrão a alguns dos parâmetros. Isso permite que a função seja chamada sem a necessidade de fornecer explicitamente um valor para esses parâmetros, usando um valor predefinido caso o argumento não seja passado.

### o conceito de argumentos com valor padrão

Quando uma função é definida, é possível especificar valores padrão para um ou mais parâmetros. Esses valores são usados automaticamente se não fornecer um argumento correspondente quando chamar a função. Isso torna as funções mais flexíveis e fáceis de usar.

Veja um exemplo simples :

```python
>>> def saudar(nome, mensagem="Olá!"):
...     print(f"{mensagem} {nome}")
...
>>> |
```

Aqui, o parâmetro `mensagem` tem um valor padrão de `"Olá!"`. Isso significa que pode-se chamar a função `saudar` de duas maneiras diferentes:

1. **passando ambos os argumentos**:

```python
>>> saudar("João", "Bem-vindo")
Bem-vindo João
>>> |
```

2. **usando o valor padrão para `mensagem`**:

```python
>>> saudar("João")
Olá! João
>>> |
```

No segundo caso, como nenhum valor foi passado para `mensagem`, o valor padrão `"Olá!"` foi utilizado.

### vantagens dos argumentos com valor padrão

Os argumentos com valor padrão oferecem diversas vantagens, incluindo maior flexibilidade e simplicidade na chamada de funções.

#### 1. simplificação de chamada

Em funções com muitos parâmetros, os valores padrão permitem que o usuário da função forneça apenas os argumentos que são realmente necessários, simplificando a chamada.

#### 2. redução de erros

Ao fornecer valores padrão para parâmetros comuns, é possível evitar erros que ocorrem quando os usuários esquecem de passar um argumento importante.

#### 3. manutenção facilitada

Funções com valores padrão são mais fáceis de manter e atualizar, pois pode-se alterar os padrões para refletir mudanças nas necessidades sem exigir que todas as chamadas à função sejam modificadas.

### regras e comportamentos de argumentos com valor padrão

Existem algumas regras importantes e comportamentos a serem considerados ao usar valores padrão:

#### 1. ordem dos argumentos

Os argumentos com valor padrão devem vir após os argumentos sem valor padrão na definição da função. Isso porque o Python precisa saber quais argumentos são obrigatórios e quais são opcionais.

**Exemplo Correto**:

```python
>>> def conectar(host, porta=8080):
...     print(f"Conectando a {host} na porta {porta}")
...
>>> |
```

**Exemplo Incorreto**:

```python
>>> def conectar(porta=8080, host):
...     print(f"Conectando a {host} na porta {porta}")
...
>>> |
```

Este exemplo resultará em um erro de sintaxe porque um argumento obrigatório (`host`) vem após um argumento opcional (`porta`).

#### 2. argumentos com valor padrão e argumentos nomeados

Quando se define uma função com valores padrão, pode-se usar tanto argumentos posicionais quanto nomeados ao chamá-la.

```python
>>> def criar_conta(nome, tipo="Padrão", saldo_inicial=0):
...     print(f"Conta criada para {nome} do tipo {tipo} com saldo inicial de {saldo_inicial}")
...
>>> |
```

Essa função pode ser chamada de várias maneiras :

- **usando apenas argumentos posicionais** :

```python
>>> criar_conta("Maria", "Premium", 1000)
```

- **misturando argumentos posicionais e nomeados** :

```python
>>> criar_conta("Carlos", saldo_inicial=500)
```

Aqui, o valor de `saldo_inicial` foi alterado, mas o valor padrão de `tipo` foi mantido.

- **usando apenas argumentos nomeados** :

```python
>>> criar_conta(nome="Ana", saldo_inicial=250)
```

#### 3. avaliação de valores padrão

Os valores padrão dos argumentos são avaliados apenas uma vez, no momento em que a função é definida. Isso significa que se o valor padrão for um objeto mutável (como uma lista ou dicionário), ele será compartilhado entre todas as chamadas da função, o que pode levar a comportamentos inesperados.

**exemplo de comportamento inesperado**:

```python
>>> def adicionar_item(item, lista=[]):
...     lista.append(item)
...     return lista
...
>>> print(adicionar_item("maçã"))
['maçã']
>>> print(adicionar_item("banana"))
['maçã', 'banana']
>>> |
```

Aqui, o valor padrão da lista foi modificado entre as chamadas, porque a lista é um objeto mutável e é compartilhada entre as chamadas da função. Para evitar esse problema, uma prática comum é usar `None` como valor padrão e, em seguida, criar uma nova lista dentro da função, se necessário:

```python
>>> def adicionar_item(item, lista=None):
...     if lista is None:
...         lista = []
...     lista.append(item)
...     return lista
...
>>> print(adicionar_item("maçã"))
['maçã']
>>> print(adicionar_item("banana"))
['banana']
```

##### 4. usando `None` como valor padrão

Usar `None` como valor padrão é uma prática comum para argumentos que podem ter valores dinâmicos ou que devem ser inicializados dentro da função:

```python
>>> def conectar(host, porta=None):
...     if porta is None:
...         porta = 8080
...
...     print(f"Conectando a {host} na porta {porta}")
```

Neste exemplo, `porta` só será definido como `8080` se não for fornecido um valor ao chamar a função.

### exemplos práticos e comuns

Vamos ver alguns exemplos práticos onde os valores padrão são extremamente úteis.

#### 1. configurações de funções

Funções que lidam com configurações geralmente usam valores padrão para tornar a função mais versátil:

```python
>>> def configurar_banco_de_dados(host="localhost", usuario="root", senha=""):
...     print(f"Conectando ao banco de dados em {host} com o usuário {usuario}")
...
>>> |
```

Essa função pode ser chamada sem argumentos se quiser usar as configurações padrão:

```python
>>> configurar_banco_de_dados()
Conectando ao banco de dados localhost com o usuário root
>>> |
```

#### 2. funções com múltiplos cenários

Funções que podem ser usadas em múltiplos cenários podem ter valores padrão para tornar seu uso mais simples:

```python
>>> def calcular_preco(valor, desconto=0, taxa=0.1):
...     preco_final = valor - (valor * desconto) + (valor * taxa)
...     return preco_final
...
>>> print(calcular_preco(100))
110.0
>>> print(calcular_preco(100, desconto=0.2))
90.0
>>> |
```

Neste exemplo, o desconto e a taxa são opcionais, permitindo que a função seja usada em diferentes contextos sem exigir que todos os argumentos sejam sempre fornecidos.

## argumentos nomeados

No Python, funções podem receber argumentos de várias formas, e uma das mais flexíveis é o uso de **argumentos nomeados** (também conhecidos como **argumentos keyword**). Esse tipo de argumento permite que se especifique quais valores deseja passar para parâmetros específicos, utilizando o nome do parâmetro.

### o básico dos argumentos nomeados

Quando uma função é definida, é possível criar parâmetros que receberão valores quando a função for chamada. Esses parâmetros podem ser passados de duas maneiras:

- **argumentos posicionais** : os valores são passados na ordem em que os parâmetros foram definidos na função;
- **argumentos nomeados** : os valores são passados utilizando o nome do parâmetro, o que permite maior flexibilidade na ordem dos argumentos;

Veja um exemplo básico :

```python
>>> def saudar(nome, mensagem):
...     print(f"Olá, {nome}! {mensagem}")
...
>>> saudar("João", "Bem-vindo ao nosso curso!")
Olá, João! Bem-vindo ao nosso curso!
>>> |
```

No exemplo acima, `"João"` é o valor para o parâmetro `nome` e `"Bem-vindo ao nosso curso!"` é o valor para o parâmetro `mensagem`. Esses valores são passados de forma posicional, ou seja, na ordem em que os parâmetros foram definidos na função.

Agora, veja o mesmo exemplo usando argumentos nomeados:

```python
>>> saudar(nome="João", mensagem="Bem-vindo ao nosso curso!")
Olá, João! Bem-vindo ao nosso curso!
>>> |
```

Aqui, estamos explicitamente dizendo que `nome` deve receber o valor `"João"` e `mensagem` deve receber `"Bem-vindo ao nosso curso!"`. A ordem dos argumentos não importa mais:

```python
>>> saudar(mensagem="Bem-vindo ao nosso curso!", nome="João")
Olá, João! Bem-vindo ao nosso curso!
>>> |
```

Esse código produzirá o mesmo resultado, independentemente da ordem.

### vantagens dos argumentos nomeados

Os argumentos nomeados oferecem várias vantagens, especialmente em funções com muitos parâmetros ou com parâmetros que têm valores padrão.

#### clareza

Quando argumentos nomeados são usados, o código se torna mais legível, pois é claro qual valor está sendo passado para qual parâmetro. Considere a função abaixo:

```python
>>> def criar_usuario(nome, idade, ativo=True, admin=False):
...     print(f"Usuário: {nome}, Idade: {idade}, Ativo: {ativo}, Admin: {admin}")
...
>>> |
```

É possível chamar assim essa função :

```python
>>> criar_usuario("Maria", 28, False, True)
Usuário: Maria, Idade: 28, Ativo: False, Admin: True
>>> |
```

Esse código funciona, mas não é imediatamente óbvio o que cada `True` ou `False` representa. Usando argumentos nomeados, fica muito mais claro:

```python
>>> criar_usuario(nome="Maria", idade=28, ativo=False, admin=True)
Usuário: Maria, Idade: 28, Ativo: False, Admin: True
>>> |
```

#### flexibilidade

Outra vantagem é a flexibilidade. Em funções com muitos parâmetros, pode-se especificar apenas os que deseja alterar, sem se preocupar com a ordem ou ter que passar valores para todos os parâmetros.

Considere a função `criar_usuario` novamente:

```python
>>> criar_usuario(nome="Carlos", idade=30)
Usuário: Carlos, Idade: 30, Ativo: True, Admin: False
>>> |
```

Aqui, `ativo` e `admin` usarão seus valores padrão (`True` e `False`, respectivamente), e apenas `nome` e `idade` foram explicitamente definidos.

### combinando argumentos posicionais e nomeados

É possível combinar argumentos posicionais e nomeados em uma única chamada de função, mas existem algumas regras a seguir:

1. **argumentos posicionais devem vir antes dos argumentos nomeados**;
1. **argumentos nomeados podem vir em qualquer ordem, desde que não sejam duplicados com argumentos posicionais**;

Exemplo:

```python
>>> criar_usuario("Ana", 22, admin=True)
Usuário: Ana, Idade: 22, Ativo: True, Admin: True
>>> |
```

Neste exemplo, `nome` e `idade` são passados como argumentos posicionais, enquanto `admin` é um argumento nomeado.

### erros comuns e considerações

- **duplicação de argumentos** : se tentar passar o mesmo argumento tanto posicionalmente quanto nomeado, o python levantará um erro:

```python
>>> criar_usuario("Pedro", 35, nome="João")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: criar_usuario() got multiple values for argument 'nome'
>>> |
```

- **argumentos faltando**: se esquecer de passar um argumento obrigatório (sem valor padrão), o python levantará um erro indicando que o argumento está faltando:

```python
>>> criar_usuario(idade=25, admin=True)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: criar_usuario() missing 1 required positional argument: 'nome'
>>> |
```

### funções com muitos parâmetros e argumentos nomeados

Funções que recebem muitos parâmetros se beneficiam particularmente dos argumentos nomeados. Em APIs ou bibliotecas complexas, essa prática é comum para garantir que o código do usuário final seja mais legível e menos propenso a erros.

Imagine uma função que configura uma conexão de banco de dados:

```python
>>> def configurar_conexao(host, porta, usuario, senha, usar_ssl=False, timeout=30):
...     print(f"Conectando ao banco em {host}:{porta} como {usuario} com SSL={usar_ssl} e timeout={timeout}")
...
>>>
```

Aqui, o uso de argumentos nomeados facilita muito a chamada dessa função:

```python
>>> configurar_conexao(
...     host="localhost",
...     porta=5432,
...     usuario="admin",
...     senha="senha123",
...     usar_ssl=True,
...     timeout=10
... )
Conectando ao banco em localhost:5432 como admin com SSL=True e timeout=10
>>> |
```

## exercícios valor padrão e argumentos nomeados

<details>
<summary>Lista de Exercícios</summary>

1. Exercícios Básicos
    1. Crie uma função `saudar` que receba um nome e uma mensagem de saudação com valor padrão `"Olá!"`. Chame a função passando apenas o nome.
    1. Modifique a função `saudar` do exercício anterior para permitir que o usuário passe uma mensagem personalizada além do nome.
    1. Crie uma função `exibir_informacoes` que receba o nome de uma pessoa, idade (com valor padrão de 25 anos) e cidade (com valor padrão `"Porto Alegre"`). Chame a função sem passar a cidade.
    1. Crie uma função `calcular_desconto` que receba o valor de um produto e um desconto com valor padrão de 10%. Calcule o valor final do produto após aplicar o desconto.
    1. Crie uma função `mostrar_mensagem` que receba uma mensagem e um número de repetições (com valor padrão de 1). A função deve imprimir a mensagem o número de vezes especificado.
1. Exercícios Intermediários
    1. Crie uma função `criar_usuario` que receba `nome`, `idade` (valor padrão 18) e `ativo` (valor padrão True). A função deve imprimir os detalhes do usuário.
    1. Crie uma função `imprimir_lista` que receba uma lista e um separador (com valor padrão de vírgula). A função deve imprimir os elementos da lista separados pelo separador especificado.
    1. Crie uma função `conectar` que receba `host`, `porta` (com valor padrão 8080) e `usar_ssl` (com valor padrão False). A função deve imprimir as informações da conexão.
    1. Crie uma função `calcular_imposto` que receba o valor de um produto e uma taxa de imposto (com valor padrão de 5%). A função deve retornar o valor final do produto com o imposto aplicado.
    1. Crie uma função `formar_grupo` que receba uma lista de nomes e um número máximo de membros (com valor padrão de 5). A função deve dividir a lista de nomes em grupos do tamanho especificado.
    1. Crie uma função `calcular_media` que receba uma lista de notas e um parâmetro `peso` com valor padrão de 1. A função deve calcular e retornar a média ponderada das notas.
    1. Crie uma função `definir_cor` que receba um parâmetro `cor` com valor padrão `"azul"`. A função deve imprimir a cor definida.
    1. Crie uma função `enviar_email` que receba `destinatario`, `assunto` (com valor padrão `"Sem Assunto"`) e `corpo` (com valor padrão `"Sem Corpo"`). A função deve simular o envio de um e-mail.
    1. Crie uma função `calcular_preco` que receba o preço de um produto e uma taxa de desconto (com valor padrão de 10%). A função deve retornar o preço final após o desconto.
    1. Crie uma função `configurar_sistema` que receba `idioma` (com valor padrão `"Português"`) e `tema` (com valor padrão `"Claro"`). A função deve imprimir as configurações do sistema.
1. Exercícios Avançados
    1. Crie uma função `gerar_senha` que receba um comprimento e um caractere opcional (com valor padrão `None`). Se o caractere não for `None`, a senha gerada deve conter apenas esse caractere repetido o número de vezes especificado pelo comprimento.
    1. Crie uma função `formatar_texto` que receba um texto e um tamanho máximo (com valor padrão de 80 caracteres). A função deve truncar o texto se ele ultrapassar o tamanho máximo.
    1. Crie uma função `encontrar_maior` que receba uma lista de números e um valor mínimo opcional (com valor padrão `None`). A função deve retornar o maior número na lista maior que o valor mínimo, se especificado.
    1. Crie uma função `ordenar_lista` que receba uma lista e um parâmetro `reversa` com valor padrão `False`. A função deve ordenar a lista de forma crescente ou decrescente, dependendo do valor de `reversa`.
    1. Crie uma função `converter_temperatura` que receba uma temperatura e uma escala (`Celsius` ou `Fahrenheit`) com valor padrão `"Celsius"`. A função deve converter a temperatura para a outra escala.
    1. Crie uma função `contar_palavras` que receba um texto e um parâmetro `ignorar_case` (com valor padrão `True`). A função deve retornar a contagem de palavras, ignorando a diferença entre maiúsculas e minúsculas, se `ignorar_case` for True.
    1. Crie uma função `calcular_potencia` que receba uma base e um expoente (com valor padrão 2). A função deve retornar o resultado da base elevada ao expoente.
    1. Crie uma função `dividir_numero` que receba um número e um divisor (com valor padrão 1). A função deve retornar o quociente da divisão, mas levantar uma exceção se o divisor for 0.
    1. Crie uma função `criar_dicionario` que receba uma lista de chaves e um valor padrão (com valor padrão `None`). A função deve retornar um dicionário onde todas as chaves possuem o valor padrão.
    1. Crie uma função `substituir_vogais` que receba um texto e uma vogal (com valor padrão `"a"`). A função deve substituir todas as vogais no texto pela vogal especificada.
1. Exercícios de Desafios
    1. Crie uma função `soma_acumulada` que receba uma lista de números e um valor inicial (com valor padrão 0). A função deve retornar a soma acumulada de todos os números na lista, iniciando pelo valor inicial.
    1. Crie uma função `filtrar_palavras` que receba uma lista de palavras e um comprimento mínimo (com valor padrão 3). A função deve retornar uma nova lista contendo apenas as palavras com o comprimento igual ou maior que o mínimo.
    1. Crie uma função `calcular_fatorial` que receba um número e um parâmetro `mostrar_passos` (com valor padrão `False`). A função deve calcular e retornar o fatorial do número, mostrando os passos se `mostrar_passos` for True.
    1. Crie uma função `multiplicar_lista` que receba uma lista de números e um fator de multiplicação (com valor padrão 2). A função deve retornar uma nova lista com todos os elementos multiplicados pelo fator.
    1. Crie uma função `atualizar_configuracoes` que receba um dicionário de configurações e atualize valores usando argumentos nomeados com valores padrão. A função deve retornar o dicionário atualizado.

</details>

## empacotamento e desempacotamento nas funções

No Python, o empacotamento e desempacotamento são técnicas essenciais para manipular argumentos em funções. Essas técnicas permitem criar funções flexíveis que podem aceitar um número variável de argumentos, facilitando a escrita de código reutilizável e dinâmico.

### `*args`

No Python, `*args` é utilizado em funções para permitir que elas recebam uma quantidade variável de argumentos posicionais. Isso é muito útil quando não se sabe de antemão quantos argumentos serão passados para a função.

#### empacotamento com `*args`

Quando se usa `*args` na definição de uma função, todos os argumentos posicionais passados para a função são empacotados em uma tupla. Essa tupla é então passada para a função, e pode-se acessá-la e iterar sobre seus elementos como faria com qualquer outra tupla.

- exemplo 1 : empacotando argumentos com `*args`

```python
>>> def soma_todos(*args):
...     total = 0
...     for numero in args:
...         total += numero
...     return total
...
>>> # Chamando a função com diferentes números de argumentos
>>> resultado1 = soma_todos(1, 2, 3)
>>> resultado2 = soma_todos(4, 5, 6, 7, 8)
>>>
>>> print(resultado1)
6
>>> print(resultado2)
30
>>> |
```

1. **definição da função :** na função `soma_todos`, `*args` captura todos os argumentos posicionais em uma tupla chamada `args`;
1. **iteração :** a função então itera sobre a tupla `args` e soma cada valor;
1. **chamadas da função :** ao chamar `soma_todos(1, 2, 3)`, `args` é empacotado como `(1, 2, 3)`. para `soma_todos(4, 5, 6, 7, 8)`, `args` é empacotado como `(4, 5, 6, 7, 8)`;

#### desempacotamento com `*args`

O desempacotamento com `*args` permite que se passe uma coleção (como uma lista ou tupla) como argumentos para uma função. Os elementos da coleção são "desempacotados" e passados como argumentos individuais.

- exemplo 2 : desempacotando argumentos com `*args`

```python
>>> def mostra_argumentos(*args):
...     for i, valor in enumerate(args):
...         print(f"Argumento {i+1}: {valor}")
...
>>> # criando uma lista de argumentos
>>> valores = [10, 20, 30, 40]
>>>
>>> # desempacotando a lista e passando seus elementos como argumentos
>>> mostra_argumentos(*valores)
Argumento 1: 10
Argumento 2: 20
Argumento 3: 30
Argumento 4: 40
>>> |
```

1. **desempacotamento :** na chamada `mostra_argumentos(*valores)`, a lista `valores` é desempacotada. Isso é equivalente a chamar `mostra_argumentos(10, 20, 30, 40)`;
1. **iteração :** a função `mostra_argumentos` itera sobre os valores passados e os exibe com seu índice correspondente;

#### empacotamento e desempacotamento juntos

É possível combinar empacotamento e desempacotamento em funções, o que pode ser útil para repassar argumentos de uma função para outra.

- exemplo 3 : combinando empacotamento e desempacotamento

```python
>>> def soma_todos(*args):
...     total = sum(args)
...     return total
...
>>> def multiplica(valor_1, valor_2):
...     return valor_1 * valor_2
...
>>> def soma_e_multiplica(mult, *args):
...     soma = soma_todos(*args)  # desempacota args e repassa para soma_todos
...     resultado = multiplica(mult, soma)
...     return resultado
...
>>> # chamada da função com múltiplos argumentos
>>> resultado = soma_e_multiplica(2, 1, 2, 3, 4)
>>>
>>> print(resultado)
20
>>> |
```

1. **função `soma_todos` :** recebe um número variável de argumentos, empacotados em `args`;
1. **função `soma_e_multiplica` :** recebe um argumento `mult` e um número variável de argumentos posicionais. Esses argumentos são desempacotados e repassados para a função `soma_todos`;
1. **função `multiplica` :** recebe dois valores (o mult e o resultado da soma) e os retorna multiplicados;
1. **resultado :** a soma dos valores (`1 + 2 + 3 + 4 = 10`) é multiplicada por `mult` (2), resultando em `20`;

### `**kwargs`

No Python, `**kwargs` (abreviação de "keyword arguments") é utilizado em funções para permitir que elas recebam uma quantidade variável de argumentos nomeados. Esses argumentos são passados para a função como um dicionário, onde as chaves são os nomes dos argumentos e os valores são os respectivos valores passados.

#### empacotamento com `**kwargs`

Quando se usa `**kwargs` na definição de uma função, todos os argumentos nomeados (ou seja, passados como `chave=valor`) são empacotados em um dicionário. Este dicionário pode ser utilizado dentro da função para acessar e manipular esses valores.

- exemplo 1 : empacotando argumentos nomeados com `**kwargs`

```python
>>> def exibir_informacoes(**kwargs):
...     for chave, valor in kwargs.items():
...         print(f"{chave}: {valor}")
...
>>> # Chamando a função com diferentes argumentos nomeados
>>> exibir_informacoes(nome="Alice", idade=30, profissao="Engenheira")
nome: Alice
idade: 30
profissao: Engenheira
>>>
>>> exibir_informacoes(marca="Toyota", modelo="Corolla", ano=2020)
marca: Toyota
modelo: Corolla
ano: 2020
>>> |
```

1. **definição da função :** na função `exibir_informacoes`, `**kwargs` captura todos os argumentos nomeados passados para a função e os empacota em um dicionário chamado `kwargs`;
1. **iteração :** a função itera sobre os pares `chave, valor` do dicionário `kwargs` usando o método `.items()`;
1. **chamadas da função :** cada chamada da função passa um conjunto diferente de argumentos nomeados, e eles são todos empacotados no dicionário `kwargs`;

#### desempacotamento com `**kwargs`

O desempacotamento com `**kwargs` permite que se passe um dicionário de argumentos nomeados para uma função. O dicionário é "desempacotado" e seus pares `chave=valor` são passados como argumentos nomeados.

- exemplo 2 : desempacotando argumentos nomeados com `**kwargs`

```python
>>> def mostrar_caracteristicas(**kwargs):
...     for chave, valor in kwargs.items():
...         print(f"{chave.capitalize()}: {valor}")
...
>>> # Criando um dicionário de argumentos
>>> dados_pessoais = {
...     "nome": "Carlos",
...     "idade": 28,
...     "cidade": "Porto Alegre"
... }
>>>
>>> # desempacotando o dicionário e passando seus pares como argumentos nomeados
>>> mostrar_caracteristicas(**dados_pessoais)
Nome: Carlos
Idade: 28
Cidade: Porto Alegre
>>> |
```

1. **desempacotamento :** na chamada `mostrar_caracteristicas(**dados_pessoais)`, o dicionário `dados_pessoais` é desempacotado. isso é equivalente a chamar `mostrar_caracteristicas(nome="Carlos", idade=28, cidade="Porto Alegre")`;
2. **iteração :** a função `mostrar_caracteristicas` então itera sobre os pares `chave=valor` e os exibe;

#### empacotamento e desempacotamento juntos

É possível combinar empacotamento e desempacotamento em funções para repassar um dicionário de argumentos nomeados de uma função para outra.

- exemplo 3 : combinando empacotamento e desempacotamento

```python
>>> def registrar_usuario(**kwargs):
...     print("Registrando usuário com as seguintes informações:")
...     for chave, valor in kwargs.items():
...         print(f"{chave.capitalize()}: {valor}")
...
>>>def criar_usuario_padrao():
...     info_padrao = {
...         "nome": "Usuário Padrão",
...         "email": "padrao@example.com",
...         "nivel": "iniciante"
...     }
...     registrar_usuario(**info_padrao)
...
>>>
>>> # chamada da função para criar um usuário padrão
>>> criar_usuario_padrao()
Registrando usuário com as seguintes informações:
Nome: Usuário Padrão
Email: padrao@example.com
Nivel: iniciante
>>> |
```

1. **função `registrar_usuario` :** recebe os argumentos nomeados empacotados em `**kwargs`;
1. **função `criar_usuario_padrao` :** define um dicionário `info_padrao` com as informações padrão do usuário;
1. **desempacotamento :** o dicionário `info_padrao` é desempacotado e repassado para `registrar_usuario` usando `**info_padrao`;

#### modificando `**kwargs` antes de repassar

É também possível modificar o dicionário `kwargs` antes de repassá-lo para outra função, o que pode ser útil em situações onde se deseja adicionar, remover ou alterar argumentos.

- exemplo 4 : modificando `**kwargs`

```python
>>> def registrar_usuario(**kwargs):
...     print("Registrando usuário com as seguintes informações:")
...     for chave, valor in kwargs.items():
...         print(f"{chave.capitalize()}: {valor}")
...
>>> def criar_usuario_personalizado(**kwargs):
...     # adicionando um campo de registro
...     kwargs['registro_completo'] = True
...     registrar_usuario(**kwargs)
...
>>>
>>> # chamada da função para criar um usuário personalizado
>>> criar_usuario_personalizado(nome="Maria", email="maria@example.com", nivel="avançado")
Registrando usuário com as seguintes informações:
Nome: Maria
Email: maria@example.com
Nivel: Avançado
Registro_completo: True
>>> |
```

1. **modificação de `kwargs` :** na função `criar_usuario_personalizado`, o dicionário `kwargs` é modificado ao adicionar um novo par `chave=valor`;
2. **repassando `kwargs` :** o dicionário modificado é desempacotado e passado para a função `registrar_usuario`;

## exercícios `args` `kwargs`

<details>
<summary>Lista de Exercícios</summary>

1. Exercícios com `*args`
    1. **Função Soma:** Crie uma função que receba um número variável de argumentos e retorne a soma de todos eles.
    1. **Multiplicação de Números:** Crie uma função que receba vários números como argumentos e retorne o produto deles.
    1. **Contagem de Argumentos:** Crie uma função que receba um número variável de argumentos e retorne a quantidade de argumentos recebidos.
    1. **Listagem de Argumentos:** Crie uma função que receba vários argumentos e os imprima, um por linha.
    1. **Concatenação de Strings:** Crie uma função que receba várias strings como argumentos e as concatene em uma única string.
    1. **Média de Números:** Crie uma função que receba vários números e retorne a média aritmética.
    1. **Maior Número:** Crie uma função que receba vários números e retorne o maior número entre eles.
    1. **Menor Número:** Crie uma função que receba vários números e retorne o menor número entre eles.
    1. **Primeiro Argumento:** Crie uma função que receba vários argumentos e retorne o primeiro argumento recebido.
    1. **Último Argumento:** Crie uma função que receba vários argumentos e retorne o último argumento recebido.
    1. **Soma de Argumentos Positivos:** Crie uma função que receba vários números e retorne a soma dos números positivos.
    1. **Argumentos Ordenados:** Crie uma função que receba vários argumentos numéricos e retorne uma lista com os argumentos ordenados.
    1. **Contagem de Strings:** Crie uma função que receba vários argumentos e retorne a quantidade de argumentos que são strings.
    1. **Função Potência:** Crie uma função que receba um número base e vários expoentes como argumentos, retornando uma lista com os resultados das potências.
    1. **Combinação de Listas:** Crie uma função que receba várias listas como argumentos e retorne uma única lista contendo todos os elementos das listas recebidas.
    1. **Repetição de String:** Crie uma função que receba uma string e um número variável de números como argumentos, e retorne a string repetida de acordo com cada número.
    1. **Imprimir Índice e Argumento:** Crie uma função que receba vários argumentos e imprima o índice e o valor de cada argumento.
    1. **Argumentos Pares:** Crie uma função que receba vários números e retorne uma lista contendo apenas os números pares.
    1. **Somar Listas:** Crie uma função que receba várias listas de números como argumentos e retorne a soma de todos os números em todas as listas.
    1. **Concatenar com Separador:** Crie uma função que receba uma string separadora e um número variável de strings como argumentos, e retorne uma única string onde as strings são concatenadas utilizando o separador.
1. Exercícios com `**kwargs`
    1. **Função de Boas-vindas:** Crie uma função que receba `**kwargs` com as chaves `nome` e `idade`, e imprima uma mensagem de boas-vindas utilizando esses valores.
    1. **Informações de Produto:** Crie uma função que receba `**kwargs` com chaves como `nome`, `preço`, `categoria` e `disponibilidade`, e imprima uma descrição formatada do produto.
    1. **Contagem de Chaves:** Crie uma função que receba `**kwargs` e retorne a quantidade de chaves no dicionário `kwargs`.
    1. **Imprimir Valores:** Crie uma função que receba `**kwargs` e imprima apenas os valores dos argumentos nomeados recebidos.
    1. **Verificar Chave:** Crie uma função que receba `**kwargs` e uma chave específica, retornando se a chave está presente em `kwargs`.
    1. **Adicionar Chave:** Crie uma função que receba `**kwargs` e adicione uma chave `status` com o valor `ativo`, retornando o dicionário atualizado.
    1. **Combinar Dicionários:** Crie uma função que receba dois dicionários como `**kwargs` e combine-os em um único dicionário.
    1. **Filtrar Chaves:** Crie uma função que receba `**kwargs` e retorne um dicionário contendo apenas as chaves que começam com a letra "a".
    1. **Imprimir Chaves e Valores:** Crie uma função que receba `**kwargs` e imprima cada chave e valor, um por linha.
    1. **Chaves como Lista:** Crie uma função que receba `**kwargs` e retorne uma lista contendo todas as chaves do dicionário `kwargs`.
    1. **Concatenar Strings:** Crie uma função que receba `**kwargs` com várias strings e retorne uma única string concatenando todas elas.
    1. **Multiplicar Valores Numéricos:** Crie uma função que receba `**kwargs` e retorne o produto de todos os valores numéricos (inteiros ou floats) contidos em `kwargs`.
    1. **Filtrar Números:** Crie uma função que receba `**kwargs` e retorne um dicionário contendo apenas os pares `chave:valor` onde o valor seja um número.
    1. **Combinar com Defaults:** Crie uma função que receba `**kwargs` e combine os valores recebidos com um dicionário padrão de valores, retornando o dicionário final.
    1. **Ordenar por Valor:** Crie uma função que receba `**kwargs` e retorne um dicionário onde os pares `chave:valor` estejam ordenados pelo valor.
    1. **Verificar Tipos:** Crie uma função que receba `**kwargs` e retorne um dicionário onde as chaves são os nomes dos argumentos e os valores são os tipos dos argumentos.
    1. **Soma de Valores:** Crie uma função que receba `**kwargs` com valores numéricos e retorne a soma desses valores.
    1. **Alterar Valor:** Crie uma função que receba `**kwargs` e uma chave específica, alterando o valor dessa chave para um novo valor, e retornando o dicionário atualizado.
    1. **Remover Chave:** Crie uma função que receba `**kwargs` e uma chave específica, removendo essa chave do dicionário `kwargs` e retornando o dicionário final.
    1. **Contagem de Tipos:** Crie uma função que receba `**kwargs` e retorne um dicionário onde as chaves são os tipos dos valores em `kwargs` e os valores são a quantidade de vezes que cada tipo apareceu.

</details>

## exemplos

### funções com parâmetros posicionais

**exemplo 1 : soma de dois números**

```python
>>> def soma(a, b):
...     resultado = a + b
...     return resultado
...
>>>
>>> # chamando a função
>>> print(soma(10, 20))
30
>>> |
```

**explicação :**
- **declaração da função :** `def soma(a, b):` define uma função chamada `soma` que aceita dois parâmetros posicionais, `a` e `b`;
- **parâmetros posicionais :** quando a função `soma` é chamada, os valores são passados na ordem definida. No exemplo, `a` recebe `10` e `b` recebe `20`;
- **cálculo e retorno :** dentro da função, somamos `a` e `b` e armazenamos o resultado na variável `resultado`, que é então retornada;
- **chamada da função :** ao chamar `soma(10, 20)`, a função retorna `30`;

**exemplo 2 : calcular a área de um retângulo**

```python
>>> def calcular_area_comprimento(comprimento, largura):
...     area = comprimento * largura
...     return area
...
>>>
>>> # chamando a função
>>> print(calcular_area_comprimento(5, 3))  # saída : 15
15
>>> |
```

**explicação :**
- **declaração da função :** `def calcular_area_comprimento(comprimento, largura):` define uma função que calcula a área de um retângulo;
- **parâmetros posicionais :** a função recebe dois parâmetros: `comprimento` e `largura`. No exemplo, `comprimento` recebe `5` e `largura` recebe `3`;
- **cálculo e retorno :** multiplicamos `comprimento` por `largura` para obter a área, que é então retornada;
- **chamada da função :** ao chamar `calcular_area_comprimento(5, 3)`, a função retorna `15`;

### funções com parâmetros posicionais e parâmetros com valores padrão

**exemplo 1 : saudação personalizada**

```python
>>> def saudacao(nome, saudacao="Olá"):
...     return f"{saudacao}, {nome}!"
...
>>>
>>> # chamando a função com o valor padrão
>>> print(saudacao("João"))
Olá, João!
>>>
>>> # chamando a função com um valor diferente do padrão
>>> print(saudacao("Maria", "Bem-vinda"))
Bem-vinda, Maria!
>>> |
```

**explicação :**
- **declaração da função :** `def saudacao(nome, saudacao="olá"):` define uma função que faz uma saudação. O parâmetro `nome` é posicional, enquanto `saudacao` tem um valor padrão, `olá`;
- **parâmetro com valor padrão :** se o argumento para `saudacao` não for fornecido, a função usará "olá";
- **chamada da função (valor padrão) :** ao chamar `saudacao("joão")`, a função usa o valor padrão `olá` e retorna `"olá, joão!"`;
- **chamada da função (novo valor) :** ao chamar `saudacao("maria", "bem-vinda")`, o valor padrão é substituído por `"bem-vinda"`, retornando `"bem-vinda, maria!"`;

**exemplo 2 : cálculo do preço com desconto**

```python
>>> def calcular_preco_com_desconto(preco, desconto=10):
...     preco_final = preco - (preco * desconto / 100)
...     return preco_final
...
>>>
>>> # chamando a função com o valor padrão
>>> print(calcular_preco_com_desconto(100))
90.0
>>>
>>> # chamando a função com um valor diferente do padrão
>>> print(calcular_preco_com_desconto(100, 20))
80.0
>>> |
```

**explicação :**
- **declaração da função :** `def calcular_preco_com_desconto(preco, desconto=10):` define uma função que calcula o preço final após aplicar um desconto. `preco` é um parâmetro posicional e `desconto` tem um valor padrão de 10%;
- **parâmetro com valor padrão :** se o desconto não for especificado, a função aplicará um desconto de 10%;
- **chamada da função (valor padrão) :** ao chamar `calcular_preco_com_desconto(100)`, a função usa o desconto padrão de 10%, retornando `90.0`;
- **chamada da função (novo valor) :** ao chamar `calcular_preco_com_desconto(100, 20)`, o desconto é de 20%, retornando `80.0`;

### funções com parâmetros posicionais, parâmetros com valores padrão e `*args`

**exemplo 1 : calculando o total de vendas**

```python
>>> def calcular_vendas(base_vendas, bonus=0, *extras):
...     total = base_vendas + bonus
...     for extra in extras:
...         total += extra
...     return total
...
>>>
>>> # chamando a função sem extras
>>> print(calcular_vendas(1000, 200))
1200
>>>
>>> # chamando a função com extras
>>> print(calcular_vendas(1000, 200, 50, 30, 20))
1300
>>> |
```

**explicação :**
- **declaração da função :** `def calcular_vendas(base_vendas, bonus=0, *extras):` define uma função que calcula o total de vendas. O parâmetro `base_vendas` é posicional, `bonus` tem um valor padrão de `0`, e `*extras` captura argumentos adicionais;
- **parâmetros posicionais e valor padrão :** `base_vendas` é obrigatório e `bonus` é opcional (com valor padrão);
- **uso de `*args`:** `*extras` permite que a função aceite um número variável de argumentos adicionais. Eles são armazenados como uma tupla e somados ao `total`;
- **chamada da função (sem extras) :** `calcular_vendas(1000, 200)` retorna `1200`, somando `base_vendas` e `bonus`;
- **chamada da função (com extras) :** `calcular_vendas(1000, 200, 50, 30, 20)` retorna `1300`, somando `base_vendas`, `bonus` e os valores em `*extras`;

**exemplo 2 : criando uma mensagem com várias palavras**

```python
>>> def criar_mensagem(inicio, separador=" ", *palavras):
...     mensagem = inicio
...     for palavra in palavras:
...         mensagem += separador + palavra
...     return mensagem
...
>>>
>>> # chamando a função com um separador padrão
>>> print(criar_mensagem("Olá"))
Olá
>>>
>>> # chamando a função com várias palavras e um separador personalizado
>>> print(criar_mensagem("Olá", "-", "mundo", "como", "vai", "você"))
Olá-mundo-como-vai-você
>>> |
```

**explicação :**
- **declaração da função :** `def criar_mensagem(inicio, separador=" ", *palavras):` define uma função que cria uma mensagem concatenando várias palavras. `inicio` é um parâmetro posicional, `separador` tem um valor padrão de `" "`, e `*palavras` captura argumentos adicionais;
- **parâmetros posicionais e valor padrão :** `inicio` é obrigatório e `separador` é opcional;
- **uso de `*args` :** `*palavras` permite adicionar um número variável de palavras que serão concatenadas usando o `separador`;
- **chamada da função (sem `*args`) :** `criar_mensagem("olá")` retorna `"olá"`, já que não há palavras adicionais;
- **chamada da função (com `*args`) :** `criar_mensagem("olá", "-", "mundo", "como", "vai", "você")` retorna `"olá-mundo-como-vai-você"`, concatenando as palavras com o separador `"-"`;

### funções com parâmetros posicionais, parâmetros com valores padrão, `*args` e `**kwargs`

**exemplo 1 : configurando um pedido de comida**

```python
>>> def configurar_pedido(prato_principal, bebida="água", *acompanhamentos, **detalhes):
...     pedido = f"Prato principal: {prato_principal}, Bebida: {bebida}"
...     if acompanhamentos:
...         pedido += ", Acompanhamentos: " + ", ".join(acompanhamentos)
...     if detalhes:
...         pedido += ", Detalhes: " + ", ".join([f"{k}={v}" for k, v in detalhes.items()])
...     return pedido
...
>>>
>>> # chamando a função sem detalhes adicionais
>>> print(configurar_pedido("bife", "suco", "arroz", "batata"))
Prato principal: bife, Bebida: suco, Acompanhamentos: arroz, batata
>>>
>>> # chamando a função com detalhes adicionais
>>> print(configurar_pedido("bife", "suco", "arroz", "batata", sem_sal=True, ao_ponto="mal"))
Prato principal: bife, Bebida: suco, Acompanhamentos: arroz, batata, Detalhes: sem_sal=True, ao_ponto=mal
>>> |
```

**explicação :**
- **declaração da função :** `def configurar_pedido(prato_principal, bebida="água", *acompanhamentos, **detalhes):` define uma função para configurar um pedido de comida;
- **parâmetros posicionais e valor padrão :** `prato_principal` é obrigatório e `bebida` é opcional;
- **uso de `*args` e `**kwargs` :** `*acompanhamentos` captura acompanhamentos adicionais, e `**detalhes` captura detalhes adicionais como pares chave-valor;
- **chamada da função (sem `**kwargs`) :** `configurar_pedido("bife", "suco", "arroz", "batata")` retorna uma string descrevendo o prato principal, a bebida e os acompanhamentos;
- **chamada da função (com `**kwargs`) :** `configurar_pedido("bife", "suco", "arroz", "batata", sem_sal=true, ao_ponto="mal")` inclui detalhes adicionais no pedido;

**exemplo 2 : criando uma conta de usuário**

```python
>>> def criar_usuario(nome, sobrenome, idade=18, *interesses, **detalhes_adicionais):
...     usuario = f"Nome: {nome} {sobrenome}, Idade: {idade}"
...     if interesses:
...         usuario += ", Interesses: " + ", ".join(interesses)
...     if detalhes_adicionais:
...         usuario += ", Detalhes Adicionais: " + ", ".join([f"{k}={v}" for k, v in detalhes_adicionais.items()])
...     return usuario
...
>>>
>>> # chamando a função sem detalhes adicionais
>>> print(criar_usuario("João", "Silva", 25, "programação", "leitura"))
Nome: João Silva, Idade: 25, Interesses: programação, leitura
>>>
>>> # chamando a função com detalhes adicionais
>>> print(criar_usuario("João", "Silva", 25, "programação", "leitura", cidade="Porto Alegre", profissão="Engenheiro"))
Nome: João Silva, Idade: 25, Interesses: programação, leitura, Detalhes Adicionais: cidade=Porto Alegre, profissão=Engenheiro
>>> |
```

**explicação :**
- **declaração da função :** `def criar_usuario(nome, sobrenome, idade=18, *interesses, **detalhes_adicionais):` define uma função para criar uma conta de usuário;
- **parâmetros posicionais e valor padrão :** `nome` e `sobrenome` são obrigatórios, `idade` é opcional;
- **uso de `*args` e `**kwargs` :** `*interesses` captura uma lista de interesses do usuário, e `**detalhes_adicionais` captura informações adicionais como pares chave-valor;
- **chamada da função (sem `**kwargs`) :** `criar_usuario("joão", "silva", 25, "programação", "leitura")` retorna uma string descrevendo o nome, a idade e os interesses do usuário;
- **chamada da função (com `**kwargs`) :** `criar_usuario("joão", "silva", 25, "programação", "leitura", cidade="porto alegre", profissão="engenheiro")` inclui detalhes adicionais na descrição;

## recursão

A **recursão** é uma técnica de programação onde uma função chama a si mesma para resolver um problema. É usada quando um problema pode ser dividido em subproblemas menores de forma semelhante ao problema original, permitindo que o código se repita até alcançar uma condição de parada (base case), que é quando o problema não pode mais ser dividido ou resolvido por chamadas subsequentes.

### como funciona

A recursão segue um padrão em que uma função realiza duas ações principais:

1. **condição base (ou condição de parada)** : esta é a condição que determina quando a recursão deve parar. Sem uma condição base, a recursão continuaria indefinidamente, causando um erro de "stack overflow" (estouro da pilha) porque a memória reservada para as chamadas da função ficaria esgotada;

2. **chamada recursiva** : a função chama a si mesma com um novo argumento, que é uma versão reduzida ou alterada do problema original. Essa chamada recursiva é o que permite que a função repita o processo para resolver o subproblema;

A cada vez que uma função é chamada, o Python cria um novo **frame de execução** na pilha de chamadas (call stack), o que significa que cada chamada recursiva aguarda a conclusão da chamada anterior. Quando a condição base é atingida, o resultado é retornado e a pilha de chamadas começa a "desenrolar", retornando os resultados de volta pelas chamadas anteriores até o ponto inicial.

### exemplos de uso

#### fatorial

Um exemplo clássico de recursão é o cálculo do fatorial de um número. O fatorial de um número (n) (denotado como (n!)) é o produto de todos os números inteiros positivos até (n).

**definição matemática** :
- n! = n * (n - 1) * (n - 2) * ... * 1

- Ou, recursivamente :
  - n! = n * (n - 1)! (com (1! = 1) como caso base)

Em Python, isso pode ser escrito assim:

```python
>>> def fatorial(n):
...     # condição base: fatorial de 0 ou 1 é 1
...     if n == 0 or n == 1:
...         return 1
...     # chamada recursiva: n * fatorial de (n - 1)
...     return n * fatorial(n - 1)
...
>>> print(fatorial(5))
120
>>> |
```

Aqui, o `fatorial(5)` chamará `fatorial(4)`, que chamará `fatorial(3)`, e assim por diante até chegar em `fatorial(1)`. A partir daí, os valores são retornados até a função original.

#### sequência de fibonacci

Outro exemplo clássico é a **Sequência de Fibonacci**, onde o próximo número na sequência é a soma dos dois anteriores. A sequência começa com 0 e 1.

**definição recursiva** :
- Fibonacci(n) = Fibonacci(n-1) + Fibonacci(n-2)
- Caso base: Fibonacci(0) = 0, Fibonacci(1) = 1

A implementação em Python seria :

```python
>>> def fibonacci(n):
...     # condição base: fibonacci(0) é 0 e fibonacci(1) é 1
...     if n == 0:
...         return 0
...     elif n == 1:
...         return 1
...     # chamada recursiva: fibonacci(n-1) + fibonacci(n-2)
...     return fibonacci(n - 1) + fibonacci(n - 2)
...
>>> print(fibonacci(6))
8
>>> |
```

Nesse exemplo, `fibonacci(6)` chamará `fibonacci(5)` e `fibonacci(4)`, e assim por diante, até que os casos base sejam alcançados.

### para que se usa

A recursão é útil em várias situações onde um problema pode ser dividido de forma natural em subproblemas menores que podem ser resolvidos da mesma maneira. Alguns exemplos incluem:

1. **problemas de divisão e conquista** : como algoritmos de ordenação como merge sort e quick sort, que dividem um problema grande em partes menores e resolvem essas partes recursivamente;

2. **problemas com árvores ou grafos** : a recursão é frequentemente usada em estruturas de dados como árvores e grafos, onde cada nó pode ser tratado de maneira recursiva;

3. **soluções elegantes para problemas matemáticos** : muitos problemas matemáticos, como o cálculo de potências, combinações, ou recorrências, podem ser resolvidos recursivamente;

4. **algoritmos de busca** : como a busca em profundidade (depth first search) em grafos, onde cada vizinho é visitado recursivamente;

### como usar

Para usar recursão de forma eficaz, siga estas etapas :

1. **defina a condição base** : esta é a parte mais importante para evitar loops infinitos. Sempre certifique-se de que a função possui uma condição clara que encerra a recursão;

2. **reduza o problema** : a cada chamada recursiva, reduza o problema, de forma que ele se aproxime da condição base. Isso pode ser feito alterando o argumento da função;

3. **chame a função recursivamente** : chame a função novamente com o argumento modificado para resolver o subproblema;

### ponto de atenção

#### pilha de chamadas e limite de recursão

Cada chamada recursiva consome memória na **pilha de chamadas** (call stack). Em Python, há um limite de profundidade de recursão (padrão de 1000 chamadas), que pode ser verificado e alterado, se necessário:

```python
>>> import sys
>>> print(f'{sys.getrecursionlimit() = }')
sys.getrecursionlimit() = 1000
>>>
>>> sys.setrecursionlimit(2000)
>>>
>>> print(f'{sys.getrecursionlimit() = }')
sys.getrecursionlimit() = 2000
>>>
>>> |
```

Isso evita o "stack overflow" em situações onde a recursão não termina ou o número de chamadas recursivas é muito grande.

### quando evitar

Embora a recursão possa ser elegante e direta, nem sempre é a solução mais eficiente. Recursões mal planejadas podem levar a desperdício de memória e tempo, especialmente em problemas onde as chamadas se repetem muitas vezes, como no exemplo da sequência de Fibonacci. Nestes casos, técnicas como **memorização** ou transformar a recursão em **iteração** podem ser mais eficientes.

### recursão vs. iteração

- **recursão** : resolve o problema chamando a função repetidamente e dividindo o problema em subproblemas;
- **iteração** : resolve o problema usando laços (como `while` ou `for`) e controlando diretamente o fluxo com variáveis de estado;

Exemplo da sequência de Fibonacci de forma iterativa:

```python
>>> def fibonacci_iterativo(n):
...     a, b = 0, 1
...     for _ in range(n):
...         a, b = b, a + b
...     return a
...
>>> print(fibonacci_iterativo(6))
8
>>> |
```

A versão iterativa costuma ser mais eficiente em termos de uso de memória e tempo de execução.

### exemplos

Abaixo há 5 exemplos que mostram como resolver problemas tanto de forma **recursiva** quanto **iterativa**. Cada problema é resolvido com essas duas abordagens.

---

#### 1. soma de uma lista de números

##### versão recursiva :

```python
>>> def soma_recursiva(lista):
...     # condição base : lista vazia
...     if len(lista) == 0:
...         return 0
...     # chamada recursiva : soma o primeiro elemento com a soma do restante da lista
...     return lista[0] + soma_recursiva(lista[1:])
...
>>> print(soma_recursiva([1, 2, 3, 4]))
10
>>> |
```

##### versão iterativa :

```python
>>> def soma_iterativa(lista):
...     soma = 0
...     for num in lista:
...         soma += num
...     return soma
...
>>> print(soma_iterativa([1, 2, 3, 4]))
10
>>> |
```

---

#### 2. contagem regressiva

##### versão recursiva :

```python
>>> def contagem_regressiva_recursiva(n):
...     if n == 0:
...         print("Lançar!")
...     else:
...         print(n)
...         contagem_regressiva_recursiva(n - 1)
...
>>> contagem_regressiva_recursiva(5)
5, 4, 3, 2, 1, Lançar!
>>> |
```

##### versão iterativa :

```python
>>> def contagem_regressiva_iterativa(n):
...     while n > 0:
...         print(n)
...         n -= 1
...     print("Lançar!")
...
>>> contagem_regressiva_iterativa(5)
5, 4, 3, 2, 1, Lançar!
>>> |
```

---

#### 3. produto dos elementos de uma lista

##### versão recursiva :

```python
>>> def produto_recursivo(lista):
...     if len(lista) == 0:
...         return 1
...     return lista[0] * produto_recursivo(lista[1:])
...
>>> print(produto_recursivo([1, 2, 3, 4]))
24
>>> |
```

##### versão iterativa :

```python
>>> def produto_iterativo(lista):
...     produto = 1
...     for num in lista:
...         produto *= num
...     return produto
...
>>> print(produto_iterativo([1, 2, 3, 4]))
24
>>> |
```

---

#### 4. reverter uma string

##### versão recursiva :

```python
>>> def reverter_string_recursiva(s):
...     if len(s) == 0:
...         return ""
...     return s[-1] + reverter_string_recursiva(s[:-1])
...
>>> print(reverter_string_recursiva("python"))
nohtyp
>>> |
```

##### versão iterativa :

```python
>>> def reverter_string_iterativa(s):
...     resultado = ""
...     for char in s:
...         resultado = char + resultado
...     return resultado
...
>>> print(reverter_string_iterativa("python"))
nohtyp
>>> |
```

---

#### 5. verificar se um número é par

##### versão recursiva :

```python
>>> def eh_par_recursivo(n):
...     if n == 0:
...         return True
...     elif n == 1:
...         return False
...     return eh_par_recursivo(n - 2)
...
>>> print(eh_par_recursivo(8))
True
>>> print(eh_par_recursivo(7))
False
>>> |
```

##### versão iterativa :

```python
>>> def eh_par_iterativo(n):
...     while n > 1:
...         n -= 2
...     return n == 0
...
>>> print(eh_par_iterativo(8))
True
>>> print(eh_par_iterativo(7))
False
>>> |
```

---

Esses exemplos mostram como a recursão é usada para quebrar um problema em subproblemas menores, enquanto a iteração usa laços para alcançar o mesmo resultado. Dependendo do problema e da sua complexidade, uma abordagem pode ser mais eficiente que a outra.

## exercícios `recursão`

<details>
<summary>Lista de Exercícios</summary>

Para cada exercício abaixo, primeiro monte uma função de sua versão usando a iteração e depois sua versão usando a recursão.

1. **Soma dos primeiros N números naturais** : Escreva uma função recursiva que calcule a soma dos primeiros N números naturais.
1. **Fatorial de um número** : Crie uma função recursiva que calcule o fatorial de um número \(n!\).
1. **Soma dos elementos de uma lista** : Escreva uma função recursiva que receba uma lista de números e retorne a soma de seus elementos.
1. **Produto dos elementos de uma lista** : Crie uma função recursiva que calcule o produto dos elementos de uma lista.
1. **Contagem regressiva** : Implemente uma função recursiva que faça uma contagem regressiva de um número N até 0.
1. **Sequência de Fibonacci** : Escreva uma função recursiva para calcular o N-ésimo número da sequência de Fibonacci.
1. **Inverter uma string** : Crie uma função recursiva que inverta uma string.
1. **Contar ocorrências de um caractere em uma string** : Implemente uma função recursiva que conte quantas vezes um determinado caractere aparece em uma string.
1. **Número de dígitos de um número** : Escreva uma função recursiva que determine o número de dígitos de um número inteiro.
1. **Verificar se um número é par** : Crie uma função recursiva para verificar se um número é par sem usar operadores aritméticos além de subtração.
1. **Máximo divisor comum (MDC)** : Implemente o algoritmo de Euclides para encontrar o MDC entre dois números usando recursão.
1. **Imprimir os elementos de uma lista de trás para frente** : Escreva uma função recursiva que imprima os elementos de uma lista em ordem inversa.
1. **Somar todos os dígitos de um número** : Crie uma função recursiva que receba um número inteiro e retorne a soma de seus dígitos.
1. **Verificar se uma palavra é palíndromo** : Implemente uma função recursiva que verifique se uma string é um palíndromo (lê-se da mesma forma de trás para frente).
1. **Exponenciação** : Escreva uma função recursiva que calcule o valor de \(a^b\), onde \(a\) é a base e \(b\) é o expoente.
1. **Soma dos números pares de uma lista** : Crie uma função recursiva que receba uma lista de números e retorne a soma de todos os números pares.
1. **Somar elementos de uma lista de listas** : Escreva uma função recursiva que some todos os elementos de uma lista que contém outras listas.
1. **Encontrar o menor elemento de uma lista** : Implemente uma função recursiva que encontre o menor número em uma lista de números.
1. **Substituir um caractere em uma string** : Crie uma função recursiva que substitua todas as ocorrências de um caractere específico em uma string por outro caractere.
1. **Contar elementos em uma lista aninhada** : Escreva uma função recursiva que conte quantos elementos (incluindo os das sublistas) existem em uma lista aninhada.

</details>

## objetos de primeira classe

Em Python, **objetos de primeira classe** (ou "first-class objects") referem-se àqueles que podem ser manipulados como qualquer outra variável. Em termos simples, um objeto de primeira classe é algo que pode ser :

- atribuído a uma variável;
- passado como argumento para uma função;
- retornado como valor de uma função;
- armazenado em estruturas de dados (como listas ou dicionários);

Em Python, funções são objetos de primeira classe, o que significa que é possível manipulá-las como qualquer outro tipo de dado (como números ou strings). Isso é fundamental para o entendimento de decoradores.

### exemplos

1. atribuindo valor a uma variável

    ```python
    valor = 10
    outro_valor = valor
    outro_valor += 1

    print(f'{valor = }')
    # saída : valor = 10
    print(f'{outro_valor = }')
    # saída : outro_valor = 11
    ```

    No exemplo acima, um valor inteiro literal é salvo na variável `valor`. Depois, essa mesma variável é usada para atribuir seu valor em outra variável chamada `outro_valor`, que tem seu conteúdo acrescido de 1. Repare que as variáveis são independentes e alterar uma não afeta a outra.

1. atribuindo uma função a uma variável

    **Exemplo 1**
    ```python
    def saudacao():
        print('Seja bem-vindo')

    saudacao()
    # saída : Seja bem-vindo

    variavel = saudacao
    variavel()
    # saída : Seja bem-vindo
    ```

    **Explicação :**
    - `saudacao` é uma função que retorna uma mensagem de boas-vindas;
    - lembre-se que para uma função ser executada, ela precisa se chamada com os parênteses;
    - a função é atribuída à variável `variavel` (repare na falta dos parênteses); como funções são objetos de primeira classe, `variavel` agora se refere à mesma função;
    - quando se chama `variavel()`, é equivalente a se chamar `saudacao()`;

    **Exemplo 2**
    ```python
    valor = 10

    print(f'{valor = }')
    # saída : valor = 10

    imprime = print
    print = 1

    try:
        print(f'{valor = }')
    except TypeError as erro:
        imprime(erro)
        # saída : 'int' object is not callable

    imprime(f'{valor = }')
    # saída : valor = 10

    print = imprime
    print(f'{valor = }')
    # saída : valor = 10
    ```

    **Explicação :**
    - é criada uma variável chamada `valor` e mostrada com a função `print`;
    - o objeto da função `print` é copiado para a variável `imprime` e o valor literal inteiro 1 é guardado no objeto `print`;
    - são feitas duas tentativas de mostrar o conteúdo da variável `valor`; uma usando o objeto `print` como função, que gera o `TypeError` e outra usando a o objeto `imprime` como função, que então mostra o valor da variável `valor`;
    - repare que aqui o objeto `print` "perdeu" sua propriedade de mostrar as coisas no terminal, mas esse comportamento foi copiado para a variável `imprime`;
    - depois, `print` recebe o objeto de `imprime` e retoma sua funcionalidade original de mostrar o conteúdo dos objetos no terminal;

### por que isso é importante?

Esse comportamento é a base para criar funções mais complexas, como decoradores. Ser capaz de tratar uma função como um objeto significa que é possível passar funções como argumentos, armazená-las e até mesmo retorná-las de outras funções, conteúdo que será visto a seguir.

## funções internas

Funções internas (ou "Nested Functions") são simplesmente funções que são definidas dentro de outra função. Elas têm acesso às variáveis locais da função externa em que foram criadas, mas, por padrão, não podem ser acessadas de fora dessa função. Isso cria um escopo limitado, onde a função interna só pode ser usada dentro do bloco de código onde foi definida.

Esse conceito é importante porque permite :
- criar **escopos fechados** (ou isolados), onde certas funcionalidades ficam "escondidas" e são usadas apenas quando necessárias;
- facilitar o encapsulamento, garantindo que uma função interna tenha acesso apenas às variáveis de que precisa;

### exemplo

Veja um exemplo simples :

```python
def externa():
    mensagem = "Olá da função externa!"

    def interna():
        print(mensagem)

    # chamando a função interna dentro da função externa
    interna()

externa()
```

**Explicação :**
1. a função `externa()` contém uma variável local chamada `mensagem` e outra função chamada `interna()`;
2. a função `interna()` imprime o valor da variável `mensagem`;
3. quando se chama `externa()`, a função `interna()` é chamada dentro da `externa()` e imprime a mensagem "Olá da função externa!";
4. **a função `interna()` não é acessível fora de `externa()`;** se tentar chamá-la diretamente como `interna()`, será levantado um erro;
```python
interna()
# saída :
# Traceback (most recent call last):
#   File "main.py", line 10, in <module>
#     interna()
#     ^^^^^^^
# NameError: nome 'interna' is not defined. Did you mean: 'externa'?
```

### escopo e acesso a variáveis

Funções internas têm acesso ao **escopo da função externa**, o que significa que podem acessar variáveis definidas na função externa, mas variáveis dentro de `interna()` não são visíveis fora dela.

Veja um exemplo :

```python
def externa():
    x = 10  # variável no escopo da função externa

    def interna():
        y = 5  # variável no escopo da função interna
        print(f"{x = }, {y = }")  # a função interna pode acessar 'x' e 'y'

    interna()

externa()
# saída : x = 10, y = 5
```

Aqui, a função interna tem acesso à variável `x`, que foi definida no escopo da função externa, mas a variável `y` (definida no escopo da função interna) não pode ser acessada fora da função `interna`.

Se fosse feita uma tentativa de acessar `y` fora da função `interna()`, seria levantado um erro, porque `y` é local à função `interna()` e não existe no escopo de `externa()`.

### funções internas e escopo de variáveis (relembrando)

O comportamento de funções internas tem muito a ver com o [**escopo de variáveis**](namespaces.md), que define onde uma variável pode ser acessada. Em Python, o escopo segue as seguintes regras :

1. **local (função interna)** : variáveis definidas dentro da função interna são locais a ela;
1. **enclosing (função externa)** : variáveis definidas na função externa podem ser acessadas pela função interna;
1. **global** : variáveis globais podem ser acessadas de qualquer lugar, mas modificá-las requer a palavra-chave `global`;
1. **built-in** : são as funções e variáveis embutidas no python, como `len()` ou `int()`;

Se uma função interna quiser **modificar** uma variável da função externa, ela precisa usar a palavra-chave `nonlocal`.

### comando `nonlocal`

Veja um exemplo onde a função interna modifica uma variável da função externa usando `nonlocal`:

```python
def externa():
    contador = 0  # variável no escopo da função externa

    def interna():
        nonlocal contador  # declara que vai usar a variável da função 'externa'
        contador += 1  # modificando a variável 'contador'
        print(f"Contador atualizado: {contador}")

    interna()
    interna()  # chamando a função interna várias vezes

externa()
```

**Explicação :**
1. a função externa define a variável `contador`;
1. a função interna usa a palavra-chave `nonlocal` para declarar que ela quer modificar a variável `contador`, que está no escopo da função externa;
1. cada vez que `interna()` é chamada, o valor de `contador` é incrementado;

Sem `nonlocal`, a função interna não poderia modificar `contador`, pois, por padrão, as variáveis da função externa seriam apenas "lidas" e não alteradas.

### quando usar funções internas

Funções internas são úteis quando se quer :

1. **encapsular lógica** : se uma função depende de outra que só será usada dentro dela, faz sentido manter essa função interna; isso mantém o código mais organizado e evita poluição do escopo global;
    Exemplo :
    ```python
    def calcular_media(valores):
        def soma(lista):
            return sum(lista)

        total = soma(valores)
        return total / len(valores)

    numeros = [10, 20, 30]
    print(calcular_media(numeros))  # exemplo de função interna auxiliando o cálculo
    ```
    Aqui, `soma()` é uma função auxiliar que só faz sentido ser usada dentro de `calcular_media()`, portanto, ela é mantida encapsulada dentro da função maior.

2. **criar closures** : funções internas são frequentemente usadas em **closures**, que são funções que "lembram" as variáveis de seu ambiente externo mesmo depois de esse ambiente ter sido finalizado; isso é útil em vários contextos, como criar funções que guardam estado entre chamadas;

3. **esconder detalhes de implementação** : se deseja garantir que certos detalhes da implementação fiquem ocultos do resto do código, as funções internas são uma boa solução;

## exercícios funções internas

<details>
<summary>Lista de Exercícios</summary>

1. Crie uma função chamada `funcao_externa` que define e chama uma função interna que imprime "Função interna chamada".
1. Crie uma função `saudacao` que tenha uma função interna chamada `bom_dia` e que imprime "Bom dia!" quando chamada.
1. Crie uma função chamada `contagem` que tenha uma função interna que imprime os números de 1 a 5.
1. Modifique o exercício 3 para que a função interna receba um argumento que determine até qual número contar.
1. Crie uma função `calculo` que defina uma função interna chamada `soma` que recebe dois números e retorna sua soma.
1. Modifique o exercício 5 para que, além da soma, a função `calculo` tenha outra função interna chamada `subtracao` que retorna a subtração dos dois números.
1. Crie uma função `operacao` que tenha uma função interna chamada `multiplicacao` que multiplica dois números.
1. Crie uma função `dividir_por_dois` que tenha uma função interna que divida o número passado por 2 e retorne o resultado.
1. Crie uma função `reverter_string` que contenha uma função interna que receba uma string e a retorne invertida.
1. Crie uma função `contador` que contenha uma função interna que incremente uma variável de contagem em 1 cada vez que for chamada.
1. Modifique o exercício 10 para que a função `contador` chame a função interna várias vezes e imprima a contagem a cada vez.
1. Crie uma função `teste_acesso` que contenha uma função interna que imprime "Acesso permitido" se uma senha for correta, e "Acesso negado" caso contrário.
1. Crie uma função `filtrar_pares` que tenha uma função interna que receba uma lista e retorne apenas os números pares.
1. Crie uma função `verifica_maior` que tenha uma função interna que compare dois números e retorne o maior.
1. Crie uma função `mensagem_personalizada` que contenha uma função interna que recebe uma mensagem e imprime "Sua mensagem é: " seguido da mensagem.
1. Crie uma função `calcular_area_retangulo` que contenha uma função interna que recebe dois valores (comprimento e largura) e retorna a área de um retângulo.
1. Crie uma função `validar_idade` que contenha uma função interna que verifica se uma pessoa é maior de idade (18 anos ou mais) e retorna True ou False.
1. Crie uma função `cumprimentar_pessoa` que contenha uma função interna que recebe um nome e imprime "Olá, [nome]!".
1. Crie uma função `repetir_palavra` que tenha uma função interna que recebe uma palavra e a imprime repetidamente, 3 vezes.
1. Crie uma função `sequencia_fibonacci` que contenha uma função interna que gera e imprime os primeiros 10 números da sequência de Fibonacci.

</details>

## funções retornando funções

Em Python, como funções são objetos de primeira classe (ou seja, podem ser tratadas como dados), isso permite que uma função retorne outra função como seu valor de retorno. Isso significa que, em vez de uma função retornar um valor simples, como um número ou uma string, ela pode retornar outra função.

Essa técnica é muito poderosa, pois permite criar **funções dinâmicas**, ou seja, funções que se adaptam ou são criadas com base no contexto em que são chamadas.

### exemplo saudacao

Veja um exemplo simples de uma função que retorna outra função :

```python
def saudacao(intro):
    def interna(nome):
        return f"{intro}, {nome}!"
    return interna

# criando uma função personalizada
ola_funcao = saudacao("Olá")

# usando a função retornada
print(ola_funcao("Maria"))  # saída : Olá, Maria!
print(ola_funcao("João"))   # saída : Olá, João!
```

Aqui, `saudacao()` é uma função que retorna outra função, `interna()`.

**Explicação :**
1. `saudacao()` recebe um argumento `intro` (nesse caso, uma string, como "Olá");
1. dentro de `saudacao()`, foi definida uma função chamada `interna()` que usa o argumento `intro` e retorna uma saudação personalizada;
1. o importante aqui é que `saudacao()` **não chama `interna()` diretamente**, ela **retorna** a função `interna()` para que possa ser chamada depois;
1. quando `ola_funcao("maria")` é chamada, na verdade está sendo chamando a função `interna()`, que foi retornada por `saudacao()`;

Esse padrão pode ser muito útil para criar funções personalizadas ou dinâmicas. Por exemplo, pode-se criar várias saudações diferentes :

```python
# criando outras saudações
boa_noite_funcao = saudacao("Boa noite")
bom_dia_funcao = saudacao("Bom dia")

print(boa_noite_funcao("Carlos"))  # saída : Boa noite, Carlos!
print(bom_dia_funcao("Ana"))       # saída : Bom dia, Ana!
```

Aqui, as saudações são geradas dinamicamente, e `saudacao()` funciona como uma **fábrica de funções**.

### exemplo potência

Outro exemplo prático é criar uma função que retorna outra função para calcular a potência de um número com um expoente fixo.

```python
def potencia(expoente):
    def elevar(base):
        return f'{base ** expoente} ({base}^{expoente})'
    return elevar

# criando funções para elevar ao quadrado e ao cubo
quadrado = potencia(2)
cubo = potencia(3)

print(quadrado(4))  # saída : 16 (4^2)
print(cubo(4))      # saída : 64 (4^3)
```

Aqui, `potencia()` retorna uma função que eleva um número `base` ao valor do `expoente` que foi definido.

**Explicação :**
- `potencia(2)` cria uma função que sempre eleva um número ao quadrado;
- `potencia(3)` cria uma função que sempre eleva um número ao cubo;
- a função retornada (`elevar`) armazena o valor do `expoente` e usa esse valor quando é chamada com a `base`;

### closures

Ao falar de funções que retornam funções, é necessário introduzir o conceito de **closures**.

Uma **closure** é uma função que "lembra" o ambiente em que foi criada, mesmo após o término da execução da função que a gerou. Em outras palavras, uma closure permite que uma função interna acesse variáveis da função externa em que foi definida, mesmo depois que essa função externa já foi finalizada.

#### características

1. **acesso a variáveis do escopo externo** : a função interna pode acessar e manipular variáveis que pertencem ao escopo da função externa;
1. **persistência** : as variáveis do escopo externo permanecem disponíveis para a função interna mesmo após a execução da função externa ter sido concluída;
1. **encapsulamento** : as closures ajudam a encapsular comportamentos e estados, permitindo que dados sejam mantidos em um estado isolado;

#### como funcionam

Para entender melhor como as closures funcionam, veja um exemplo simples:

```python
def cria_contador():
    # variável do escopo da função externa
    contador = 0

    def incrementar():
        # permite que a função interna modifique a variável do escopo externo
        nonlocal contador
        contador += 1
        return contador

    # retorna a função interna
    return incrementar

# criando uma nova closure
fun_contador = cria_contador()

# Chamando a função retornada
print(f'{fun_contador() = }')  # saída : fun_contador() = 1
print(f'{fun_contador() = }')  # saída : fun_contador() = 2
print(f'{fun_contador() = }')  # saída : fun_contador() = 3
```

**Explicação :**
1. `cria_contador()` é uma função externa que define a variável `contador` e a função interna `incrementar()`;
1. a função interna `incrementar()` usa a palavra-chave `nonlocal` para indicar que ela deseja modificar a variável `contador` que está no escopo da função externa;
1. quando `cria_contador()` é chamada, ela retorna a função `incrementar()`, que é agora uma closure; essa closure "lembra" do valor de `contador`;
1. a cada vez que chamamos `fun_contador()`, a variável `contador` é incrementada, e seu valor é mantido entre as chamadas, mesmo que `cria_contador()` já tenha terminado;

#### por que usar

As closures são úteis por várias razões:

1. **encapsulamento de estado** : elas permitem encapsular o estado, mantendo variáveis acessíveis apenas dentro da closure; isso ajuda a evitar poluição do escopo global e mantém a lógica do programa mais organizada;

1. **criação de funções com comportamento dinâmico** : elas permitem a criação de funções que podem se adaptar com base em parâmetros que foram passados quando a closure foi criada;

1. **facilidade de implementação de decoradores** : closures são frequentemente usadas para implementar decoradores, que são uma maneira poderosa de modificar o comportamento de funções;

#### exemplo contador com estado

Veja o exemplo do contador para mostrar como as closures podem ser usadas em uma situação mais prática.

```python
def gerador_de_multiplicador(fator):
    def multiplicar(numero):
        return f'{numero * fator} ({numero} * {fator})'
    return multiplicar

# criando closures com diferentes fatores
dobro = gerador_de_multiplicador(2)
triplo = gerador_de_multiplicador(3)

print(dobro(5))   # saída : 10 (5 * 2)
print(triplo(5))  # saída : 15 (5 * 3)
```

**Explicação :**
- `gerador_de_multiplicador()` retorna uma função `multiplicar()` que multiplica um número pelo `fator` fornecido;
- quando `gerador_de_multiplicador(2)` é chamado, ele retorna uma closure que "lembra" que o fator é 2, permitindo que se chame `dobro(5)` e se obtenha o resultado correto;
- o mesmo vale para `triplo`, que "lembra" que seu fator é 3;

## exercícios funções retornando funções

<details>
<summary>Lista de Exercícios</summary>

1. Crie uma função `retorna_funcao` que retorna uma função que imprime "Função retornada".
1. Crie uma função `gerar_saudacao` que retorna outra função que recebe um nome e imprime "Olá, [nome]!".
1. Crie uma função `multiplicador(n)` que retorna uma função que multiplica um número pelo valor de `n`.
1. Crie uma função `potencia(expoente)` que retorna uma função que eleva um número ao valor do expoente.
1. Crie uma função `somador(valor)` que retorna uma função que soma `valor` a outro número passado.
1. Crie uma função `criador_de_boas_vindas(mensagem)` que retorna uma função que imprime a mensagem seguida de um nome.
1. Crie uma função `divisor(divisor)` que retorna uma função que divide um número pelo divisor.
1. Crie uma função `gerar_funcao_com_prefixo(prefixo)` que retorna uma função que imprime o prefixo seguido de um nome.
1. Crie uma função `concatenar_prefixo(sufixo)` que retorna uma função que adiciona o sufixo a uma string passada.
1. Crie uma função `aplicador_de_taxa(taxa)` que retorna uma função que aplica uma taxa percentual sobre um valor.
1. Crie uma função `gerar_calculadora(operacao)` que retorna uma função que realiza a operação (soma, subtração, multiplicação ou divisão) sobre dois números.
1. Crie uma função `verificador(minimo)` que retorna uma função que verifica se um número é maior ou igual ao valor mínimo.
1. Crie uma função `aplicador_de_desconto(desconto)` que retorna uma função que aplica um desconto percentual a um preço.
1. Crie uma função `fabrica_de_greetings(saudacao)` que retorna uma função que, ao ser chamada, imprime a saudação com um nome.
1. Crie uma função `gerar_contador(inicio)` que retorna uma função que incrementa e retorna o valor de `inicio` a cada vez que é chamada.
1. Crie uma função `fabrica_de_multiplicacao(fator)` que retorna uma função que multiplica um número pelo fator.
1. Crie uma função `validador_de_senha(senha)` que retorna uma função que verifica se a senha passada como argumento é a senha correta.
1. Crie uma função `criador_de_replicas(n)` que retorna uma função que imprime uma string repetidamente, `n` vezes.
1. Crie uma função `fabrica_de_comparador(x)` que retorna uma função que verifica se um número passado é maior, menor ou igual a `x`.
1. Crie uma função `gerador_de_boletos(taxa)` que retorna uma função que calcula o valor final de um boleto dado o valor inicial.

</details>

## decoradores

Decoradores em Python são uma forma de modificar ou estender o comportamento de funções ou métodos sem alterar seu código. Eles permitem adicionar funcionalidades a funções existentes de maneira elegante e reutilizável.

Um decorador é, na essência, uma função que recebe outra função como argumento e retorna uma nova função que geralmente estende ou altera o comportamento da função original.

### decorador simples

Para usar um decorador, é necessário aplicar os conceitos vistos anteriormente. [Funções internas](#funções-internas) e [retorno de funções](#funções-retornando-funções).

### funções como argumentos

Para usar os decoradores, ainda preciso ver mais um conceito novo : passar funções como argumentos de outras funções.

Veja um exemplo simples abaixo :

```python
def decorador(func):
    func()

def diga_whee():
    print('Whee!')

decorador(diga_whee)
# saída : Whee!
```

**Explicação :**
- a função `decorador` é uma função que tem um parâmetro chamado `func`;
- esse parâmetro, que é uma função, é então executado de dentro da função `decorador`;

#### adicionando comportamentos

Uma vantagem de executar uma função dentro de outra função é a possibilidade de se adicionar algum comportamento antes e depois de sua execução automaticamente. Tal comportamento é válido para qualquer função passada para o decorador.

Veja o exemplo abaixo :

```python
def decorador(func):
    print('Antes da função ser chamada.')
    func()
    print('Depois da função ser chamada.')

def diga_whee():
    print('Whee!')

decorador(diga_whee)
# Antes da função ser chamada.
# saída : Whee!
# Depois da função ser chamada.
```

**Explicação :**
- repare na nova funcionalidade da função `decorador`;
- ela adiciona uma mensagem antes e depois da execução da função passada;

Embora isso possa parecer relativamente sem utilidade, ainda há mais alguns detalhes faltantes para a função `decorador` realmente se tornar uma função decoradora.

Veja como fica quando aplicado o conceito de funções internas :

```python
def decorador(func):
    def wrapper():
        print('Antes da função ser chamada.')
        func()
        print('Depois da função ser chamada.')
    return wrapper

def diga_whee():
    print('Whee!')

diga_whee = decorador(diga_whee)
```

**Explicação :**
- assim como tem-se por convenção chamar o primeiro parâmetro de um método (função de uma classe), tem-se por padrão chamar a função interna de um decorador de `wrapper`;
- agora, a função `decorador` está passando a variável `func` com o objeto da função para dentro da função `wrapper`;
- dentro da função `wrapper` é feita a execução da função `func`, assim como a adição de suas mensagens antes e depois;
- dessa vez, a função `decorador` está retornando o objeto da função `wrapper`, isso permite que sua execução seja feita sob demanda em outro momento;
- como a ideia do decorador é adicionar um comportamento ou antes ou depois da função original, é válido retornar o objeto da função `wrapper` para a própria função que se quer alterar;
- exatamente o que é feito com `diga_whee = decorador(diga_whee)`, local onde ocorre a chamada da decoração;

Veja o que acontece quando é executado :

```python
diga_whee()
# saída :
# Algo está acontecendo antes da função ser chamada.
# Whee!
# Algo está acontecendo depois da função ser chamada.
```

Na verdade, o objeto de nome `diga_whee` recebeu o objeto da função interna `wrapper()`. No entanto, a função `wrapper()` tem uma referência à função original `diga_whee()` como `func`, e chama essa função entre as duas chamadas a `print()`.

Em suma, um decorador envolve uma função, modificando seu comportamento.

#### mais exemplo

Antes de prosseguir, veja um segundo exemplo. Como `wrapper()` é uma função do Python, a maneira como um decorador modifica uma função pode mudar dinamicamente. Por exemplo, para não incomodar seus vizinhos, o exemplo a seguir só executará o código decorado durante o dia:

**Exemplo :**

```python
from datetime import datetime

def nao_durante_noite(func):
    def silencio():
        print('Agora não pode fazer barulho')

    def wrapper():
        if 7 <= datetime.now().hour < 22:
            func()
        else:
            silencio()
    return wrapper

def diga_whee():
    print('Whee!')

# decorando a função diga_whee
diga_whee = nao_durante_noite(diga_whee)
```

Caso o código acima seja executado entre 22h da noite até 7h da manhã, o decorador irá retornar a função `silencio`, em vez da função originalmente decorada.

### usando `@`

Veja o código escrito anteriormente. A maneira que a função `diga_whee` foi decorada é um pouco desajeitada, não é intuitivo. Primeiro, é preciso digitar o nome `diga_whee` outras mais duas vezes para decorá-la. Além disso, a decoração fica escondida abaixo da definição da função.

Apesar disso funcionar, o Python permite que se use decoradores de uma maneira mais simples com o símbolo `@`, às vezes chamado de **sintaxe pie**. O exemplo a seguir faz exatamente a mesma coisa que o primeiro exemplo de decorador:

```python
def decorador(func):
    def wrapper():
        print('Antes da função ser chamada.')
        func()
        print('Depois da função ser chamada.')
    return wrapper

@decorador
def diga_whee():
    print('Whee!')
```

Então, usar `@decorador` é apenas uma maneira mais curta de dizer `diga_whee = decorador(diga_whee)`. É assim que se aplica um decorador a uma função de forma Pythonica.

### reutilizando decoradores

Lembre-se de que um decorador é apenas uma função do Python. Todas as ferramentas usuais de reutilização estão disponíveis. Agora, um módulo será criado, onde será armazenado os decoradores para usá-los em várias outras funções.

O arquivo criado vai ser chamar `decoradores.py` com o seguinte conteúdo :

```python
def faz_duas_vezes(func):
    def wrapper():
        func()
        func()
    return wrapper

def decorador(func):
    def wrapper():
        print('Antes da função ser chamada.')
        func()
        print('Depois da função ser chamada.')
    return wrapper
```

O decorador `faz_duas_vezes()` vai chamar a função decorada duas vezes.

> [!NOTE]
> Pode-se nomear sua função interna como quiser, e um nome genérico como `wrapper()` geralmente é suficiente e mais usado.

Agora pode-se usar este novo decorador em outros arquivos com uma importação :

```python
from decoradores import faz_duas_vezes

@faz_duas_vezes
def diga_whee():
    print('Whee!')
```

Quando executar este exemplo, verá que a função original `diga_whee()` é executada duas vezes :

```python
diga_whee()
# saída :
# Whee!
# Whee!
```

As duas exclamações "Whee!" mostradas confirmam que `@faz_duas_vezes` faz exatamente o que diz.

### decoradores com argumentos

Os decoradores vistos até agora não possuiam qualquer argumento. Veja o que acontece se tentar decorar uma função que recebe algum argumento :

```python
from decoradores import faz_duas_vezes

@faz_duas_vezes
def saudar(nome):
    print(f"Olá, {nome}")
```

Agora, o decorador `@faz_duas_vezes` é aplicado à função `saudar()`, que espera um nome como argumento. No entanto, ao chamar essa função, um erro é levantado:

```python
saudar('arnold')
# Traceback (most recent call last):
#   File "main.py", line 18, in <module>
#     saudar('arnold')
# TypeError: faz_duas_vezes.<locals>.wrapper() takes 0 positional arguments but 1 was given
```

Repare que o problema ocorreu na função interna do decorador `faz_duas_vezes`, a `wrapper`. Isso porque ela não aceita nenhum argumento, mas `nome="arnold"` foi passado para ela. Pode-se corrigir isso deixando `wrapper()` aceitar um argumento. Veja um exemplo abaixo :

```python
def faz_duas_vezes(func):
    def wrapper(x):
        func(x)
        func(x)
    return wrapper
```

Quando executar a função decorada novamente, a saída será como a esperada :

```python
@faz_duas_vezes
def saudar(nome):
    print(f"Olá, {nome}")

saudar('arnold')
# saída :
# Olá, arnold
# Olá, arnold
```

O problema é quando se usa o mesmo decorador em uma função sem argumentos,

```python
@faz_duas_vezes
def diga_whee():
    print('Whee!')

diga_whee()
# saída :
# Traceback (most recent call last):
#   File "main.py", line 23, in <module>
#     diga_whee()
# TypeError: faz_duas_vezes.<locals>.wrapper() missing 1 required positional argument: 'x'
```

Há praticamente o mesmo problema...

A solução é usar `*args` e `**kwargs` na função interna `wrapper`. Dessa forma, ela aceitará um número arbitrário de argumentos posicionais e nomeados.

```python
def faz_duas_vezes(func):
    def wrapper(*args, **kwargs):
        func(*args, **kwargs)
        func(*args, **kwargs)
    return wrapper
```

A função interna `wrapper()` agora aceita qualquer número de argumentos e os passa para a função que está decorando. Agora, qualquer uma das funções decoradas `diga_whee()` quanto `saudar()` funcionarão.

```python
from decoradores import faz_duas_vezes

@faz_duas_vezes
def diga_whee():
    print('Whee!')

diga_whee()
# saída :
# Whee!
# Whee!

@faz_duas_vezes
def saudar(nome):
    print(f"Olá, {nome}")

saudar("arnold")
# saída :
# Olá, arnold
# Olá, arnold
```

Agora, usa-se o mesmo decorador, `@faz_duas_vezes`, para decorar duas funções diferentes.

### decoradores com retorno

O que acontece com o valor de retorno de funções decoradas?

Veja um exemplo de retorno de uma função decorada :

```python
from decoradores import faz_duas_vezes

@faz_duas_vezes
def saudar(nome):
    print('Criando saudação')
    return f'Olá, {nome}'
```

Ao tentar usá-la :

```python
saida = saudar('arnold')
# saída :
# Criando saudação
# Criando saudação

print(saida)
# saída :
# None
```

Repare que o valor da variável `saida` foi `None`. Isso porque a função chamada, a `wrapper`, não tinha qualquer tipo de retorno especificado, logo, o Python assumiu que o retorno dela foi o valor padrão `None`.

Para corrigir isso, é preciso garantir que a função wrapper retorne o valor de retorno da função decorada.

```python
# decoradores.py

def faz_duas_vezes(func):
    def wrapper(*args, **kwargs):
        func(*args, **kwargs)
        resultado = func(*args, **kwargs)
        return resultado
    return wrapper
```

Agora, a função `wrapper` está retornando o retorno da função decorada através da variável `resultado`.

Veja o exemplo corrigido :

```python
from decoradores import faz_duas_vezes

@faz_duas_vezes
def saudar(nome):
    print('Criando saudação')
    return f'Oi {nome}'

saida = saudar('arnold')
print(saida)
# saída :
# Criando saudação
# Criando saudação
# Olá, arnold
```

Desta vez, `saudar()` retorna a saudação `Olá, arnold`.

## exercícios decorador

<details>
<summary>Lista de Exercícios</summary>

1. Funções Simples e Decoradores
    1. Crie um decorador que imprima "Iniciando função" antes de executar uma função e "Função finalizada" após a execução.
    1. Crie um decorador que adicione uma linha em branco antes e depois da execução de uma função.
    1. Crie um decorador que conte e imprima o número de vezes que uma função foi chamada.
    1. Crie um decorador que imprima a data e hora exatas em que uma função foi chamada.
    1. Crie um decorador que execute uma função duas vezes.
    1. Crie um decorador que imprima "Execução permitida" ou "Execução negada" antes de uma função, baseado em um parâmetro booleano.
    1. Crie um decorador que calcule e imprima o tempo de execução de uma função.
    1. Crie um decorador que ignore a execução de uma função e apenas imprima "Função ignorada".
    1. Crie um decorador que registre o nome da função e os argumentos que ela recebeu.
    1. Crie um decorador que converta o resultado de uma função em uma string e imprima o tipo do valor retornado.
1. Funções com Parâmetros
    1. Crie um decorador que multiplica o valor retornado por uma função por 2.
    1. Crie um decorador que inverte a ordem dos argumentos de uma função antes de chamá-la.
    1. Crie um decorador que adicione 10 ao primeiro argumento de uma função.
    1. Crie um decorador que verifique se os argumentos passados a uma função são inteiros. Se não forem, imprima uma mensagem de erro.
    1. Crie um decorador que execute uma função apenas se todos os seus argumentos forem números positivos.
    1. Crie um decorador que troque os valores de dois parâmetros de uma função antes de executá-la.
    1. Crie um decorador que limite a execução de uma função a apenas 3 chamadas.
    1. Crie um decorador que some 5 ao valor retornado por uma função.
    1. Crie um decorador que execute uma função apenas se a soma de seus argumentos for maior que 100.
    1. Crie um decorador que imprima os argumentos e o valor retornado de uma função.
1. Funções com Vários Decoradores
    1. Crie dois decoradores: um que imprime "Começando" e outro que imprime "Finalizando". Aplique-os a uma função.
    1. Crie dois decoradores: um que executa uma função três vezes e outro que imprime o tempo de execução. Aplique ambos à mesma função.
    1. Crie dois decoradores: um que inverte os argumentos e outro que soma 10 ao resultado da função. Aplique-os a uma função.
    1. Crie dois decoradores: um que verifica se os argumentos são inteiros e outro que multiplica o resultado por 2. Aplique ambos a uma função.
    1. Crie dois decoradores: um que limita as chamadas a 2 e outro que imprime os argumentos da função. Aplique ambos a uma função.
    1. Crie um decorador que converte o valor retornado em uma lista e outro que ordena essa lista. Aplique ambos a uma função que retorna vários números.
1. Decoradores para Controle de Fluxo
    1. Crie um decorador que execute uma função apenas entre 9h e 17h.
    1. Crie um decorador que execute uma função apenas se o valor de um argumento for maior que 10.
    1. Crie um decorador que execute uma função apenas se o valor de retorno da função for positivo.
    1. Crie um decorador que execute uma função apenas se o usuário fornecer uma senha correta (simulada com um valor fixo).

</details>

## `lambda`

A função `lambda` em Python é uma maneira de criar funções pequenas e anônimas (sem nome) de forma concisa. Elas são especialmente úteis quando se precisa de uma função para uma operação simples e não quer definir uma função convencional usando a palavra-chave `def`.

A sintaxe básica de uma função `lambda` é:

```python
lambda argumentos: expressão
```

- **argumentos** : os parâmetros que a função `lambda` aceitará;
- **expressão** : uma única expressão que a função calculará e retornará; note que não pode haver múltiplas instruções ou comandos;

### exemplos

1. **Função `lambda` Simples**

    Um exemplo básico de uma função `lambda` que recebe um número e o dobra:

    ```python
    dobrar = lambda x: x * 2

    resultado = dobrar(5)
    print(resultado)  # saída : 10
    ```

2. **Usando `lambda` com `map()`**

    A função `map()` aplica uma função a todos os itens em um iterável (como uma lista). Pode-se usar uma função `lambda` para definir a operação:

    ```python
    numeros = [1, 2, 3, 4, 5]
    dobrados = list(map(lambda x: x * 2, numeros))

    print(dobrados)  # saída : [2, 4, 6, 8, 10]
    ```

3. **Usando `lambda` com `filter()`**

    A função `filter()` filtra itens de um iterável com base em uma função que retorna `True` ou `False`. Aqui está como usar uma função `lambda` para filtrar números pares:

    ```python
    numeros = [1, 2, 3, 4, 5, 6]
    pares = list(filter(lambda x: x % 2 == 0, numeros))

    print(pares)  # saída : [2, 4, 6]
    ```

4. **Usando `lambda` com `sorted()`**

    É possível usar uma função `lambda` como uma chave de ordenação em listas. Aqui está um exemplo de como ordenar uma lista de tuplas pelo segundo elemento:

    ```python
    pessoas = [("Alice", 30), ("Bob", 25), ("Charlie", 35)]
    ordenado = sorted(pessoas, key=lambda x: x[1])

    print(ordenado)  # saída : [('Bob', 25), ('Alice', 30), ('Charlie', 35)]
    ```

5. **Funções `lambda` com Múltiplos Argumentos**

    Uma função `lambda` pode receber múltiplos argumentos. Aqui está um exemplo que calcula a soma de dois números:

    ```python
    soma = lambda x, y: x + y

    resultado = soma(3, 5)
    print(resultado)  # saída : 8
    ```

### Comparação com Funções Normais

Embora as funções `lambda` sejam muito úteis para operações simples, é importante notar que elas têm algumas limitações. Por exemplo, não é possível definir múltiplas expressões ou usar comandos complexos. Para funções mais complexas, é melhor usar a definição convencional com `def`.

Aqui está uma comparação:

```python
# usando uma função lambda
quadrado = lambda x: x ** 2
print(quadrado(4))  # saída : 16

# usando uma função convencional
def quadrado_funcao(x):
    return x ** 2

print(quadrado_funcao(4))  # saída : 16
```

## exercícios `lambda`

<details>
<summary>Lista de Exercícios</summary>

1. **Dobrar Números**: Crie uma função `lambda` que receba um número e retorne o dobro desse número. Teste a função com um valor de entrada.
1. **Triplicar Números**: Crie uma função `lambda` que receba um número e retorne o triplo desse número. Teste a função com um valor de entrada.
1. **Verificar Paridade**: Escreva uma função `lambda` que verifique se um número é par e retorne `True` ou `False`.
1. **Filtrar Números Ímpares**: Dada uma lista de números, use `filter()` e uma função `lambda` para criar uma nova lista contendo apenas os números ímpares.
1. **Elevar ao Quadrado**: Crie uma lista de números e use `map()` com uma função `lambda` para criar uma nova lista contendo os quadrados desses números.
1. **Ordenar Nomes**: Dada uma lista de nomes, use `sorted()` com uma função `lambda` para ordená-los pelo comprimento dos nomes.
1. **Soma de Dois Números**: Crie uma função `lambda` que receba dois números e retorne a soma deles. Teste a função com dois valores.
1. **Concatenar Strings**: Escreva uma função `lambda` que receba duas strings e as concatene. Teste a função com duas entradas.
1. **Verificar se uma String é Palíndromo**: Crie uma função `lambda` que verifique se uma string é um palíndromo (lê-se da mesma forma de trás para frente).
1. **Filtrar Palavras Longas**: Dada uma lista de palavras, use `filter()` e uma função `lambda` para criar uma nova lista contendo apenas palavras com mais de 5 letras.
1. **Multiplicação de Três Números**: Crie uma função `lambda` que receba três números e retorne o produto deles.
1. **Transformar Lista de Tuplas**: Dada uma lista de tuplas onde cada tupla contém um nome e uma idade, use `map()` e uma função `lambda` para criar uma nova lista com apenas os nomes.
1. **Inverter String**: Escreva uma função `lambda` que receba uma string e retorne essa string invertida.
1. **Ordenar Tuplas por Nome**: Dada uma lista de tuplas (nome, idade), use `sorted()` com uma função `lambda` para ordenar as tuplas pelo nome.
1. **Calcular Fatorial**: Crie uma função `lambda` que calcule o fatorial de um número (use recursão para isso).
1. **Filtrar Números em um Intervalo**: Dada uma lista de números, use `filter()` e uma função `lambda` para criar uma nova lista contendo apenas números entre 10 e 50.
1. **Verificar se uma String Começa com uma Vogal**: Escreva uma função `lambda` que verifique se uma string começa com uma vogal.
1. **Criar um Dicionário de Quadrados**: Dada uma lista de números, use `map()` e uma função `lambda` para criar um dicionário onde as chaves são os números e os valores são seus quadrados.
1. **Converter Temperaturas**: Crie uma função `lambda` que converta uma temperatura de Celsius para Fahrenheit. Teste a função com um valor de entrada.
1. **Calcular a Média**: Dada uma lista de números, use `reduce()` e uma função `lambda` para calcular a média dos números (importando `reduce` do módulo `functools`).

</details>


# input.md

Índice Input

* [input](#input)
* [exercícios input](#exercícios-input)

# input

A função `input` do Python é uma ferramenta fundamental para receber dados do usuário durante a execução de um programa. Ela é usada para ler uma linha de texto digitada pelo usuário e pode ser armazenada em uma variável para uso posterior no código.

Quando usada, a função `input` exibe uma mensagem (prompt) ao usuário e pausa a execução do programa até que o usuário digite algo e pressione a tecla Enter, finalizando assim a entrada de dados. **TUDO** o que o usuário digitar é retornado como uma `string`.

Veja um uso básico

```python
msg = input("Mensagem para o usuário: ")
```

O que acontece é o seguinte :
1. O Python exibe a "Mensagem para o usuário: ";
1. O usuário digita uma resposta e pressiona Enter;
1. A resposta do usuário é armazenada na variável `msg`;

Veja alguns exemplos de uso :

```python
# recebendo o nome do usuário
nome = input("Digite seu nome: ")
print("Olá, " + nome + "!")
```

No algoritmo anterior :
1. O programa pede que o usuário digite seu nome;
1. O usuário digita o nome e pressiona Enter;
1. O programa armazena o nome na variável `nome`;
1. O programa imprime uma mensagem de saudação usando o nome fornecido pelo usuário;

```python
# recebendo dois números
numero1 = input("Digite o primeiro número: ")
numero2 = input("Digite o segundo número: ")

# convertendo as entradas para inteiros
numero1 = int(numero1)
numero2 = int(numero2)

soma = numero1 + numero2
print("A soma dos números é :", soma)
```

No algoritmo acima :
1. O programa pede que o usuário digite dois números;
1. As entradas são inicialmente strings, então precisamos convertê-las para inteiros usando a função `int`;
1. Depois de converter, somamos os números e exibimos o resultado;

### dados recebidos

Por padrão, a função `input` ***SEMPRE*** retorna uma string. Se o valor esperado for um número, é necessário converter a string para o tipo de dado adequado (por exemplo, `int` ou `float`).

Aqui estão alguns exemplos :

```python
# recebendo um valor decimal
altura = input("Digite sua altura (em metros): ")
altura = float(altura)
print("Sua altura é :", altura, "metros")

# recebendo um valor inteiro
idade = int(input("Digite sua idade: "))
print("Sua idade é:", idade)
```

É necessário ter cuidado quando se está convertendo um tipo string para inteiro ou float. Pois se o conteúdo não puder ser convertido apropriadamente, irá levantar um erro. Por hora, não será visto como tratar isso.

## exercícios input

<details>
<summary>Lista de Exercícios</summary>

1. String
    1. Peça ao usuário para digitar seu nome e exiba uma saudação personalizada.
    1. Peça ao usuário para digitar uma palavra e exiba o primeiro e o último caractere.
    1. Peça ao usuário para digitar uma frase e exiba a quantidade de caracteres na frase.
    1. Peça ao usuário para digitar duas palavras e exiba-as concatenadas.
    1. Peça ao usuário para digitar uma frase e exiba a frase invertida.
1. String com if-elif-else
    1. Peça ao usuário para digitar uma palavra e verifique se a palavra contém a letra "a". Exiba uma mensagem apropriada.
    1. Peça ao usuário para digitar uma frase e verifique se a frase tem mais de 20 caracteres. Exiba uma mensagem apropriada.
    1. Peça ao usuário para digitar seu nome. Se o nome começar com a letra "A", exiba "Seu nome começa com A". Caso contrário, exiba "Seu nome não começa com A".
    1. Peça ao usuário para digitar uma palavra. Se a palavra for "Python", exiba "Linguagem de programação". Caso contrário, exiba "Palavra comum".
    1. Peça ao usuário para digitar uma frase. Se a frase terminar com um ponto (.), exiba "Frase completa". Caso contrário, exiba "Frase incompleta".
1. Int
    1. Peça ao usuário para digitar sua idade e exiba uma mensagem dizendo quantos anos ele terá em 10 anos.
    1. Peça ao usuário para digitar dois números inteiros e exiba a soma deles.
    1. Peça ao usuário para digitar um número inteiro e exiba o quadrado desse número.
    1. Peça ao usuário para digitar um número inteiro e exiba a metade desse número.
    1. Peça ao usuário para digitar dois números inteiros e exiba o produto deles.
1. Int com if-elif-else
    1. Peça ao usuário para digitar um número inteiro. Se o número for positivo, exiba "Positivo". Se for negativo, exiba "Negativo". Se for zero, exiba "Zero".
    1. Peça ao usuário para digitar dois números inteiros e exiba o maior deles.
    1. Peça ao usuário para digitar um número inteiro. Se o número for par, exiba "Par". Caso contrário, exiba "Ímpar".
    1. Peça ao usuário para digitar sua idade. Se a idade for maior ou igual a 18, exiba "Maior de idade". Caso contrário, exiba "Menor de idade".
    1. Peça ao usuário para digitar um número inteiro. Se o número for múltiplo de 3, exiba "Múltiplo de 3". Se for múltiplo de 5, exiba "Múltiplo de 5". Se for múltiplo de ambos, exiba "Múltiplo de 3 e 5".
1. Float
    1. Peça ao usuário para digitar um número decimal e exiba o dobro desse número.
    1. Peça ao usuário para digitar dois números decimais e exiba a média deles.
    1. Peça ao usuário para digitar um número decimal e exiba a raiz quadrada desse número.
    1. Peça ao usuário para digitar um número decimal e exiba o cubo desse número.
    1. Peça ao usuário para digitar dois números decimais e exiba a divisão do primeiro pelo segundo.
1. Float com if-elif-else
    1. Peça ao usuário para digitar um número decimal. Se o número for maior que 100, exiba "Maior que 100". Caso contrário, exiba "Menor ou igual a 100".
    1. Peça ao usuário para digitar dois números decimais e exiba o maior deles.
    1. Peça ao usuário para digitar um número decimal. Se o número for positivo, exiba "Positivo". Se for negativo, exiba "Negativo".
    1. Peça ao usuário para digitar um número decimal. Se o número for maior que 50 e menor que 100, exiba "Entre 50 e 100". Caso contrário, exiba "Fora do intervalo".
    1. Peça ao usuário para digitar um número decimal. Se o número for maior que 0,5, exiba "Maior que meio". Caso contrário, exiba "Menor ou igual a meio".
1. Bool
    1. Peça ao usuário para digitar "True" ou "False" e exiba o valor booleano correspondente.
    1. Peça ao usuário para digitar uma resposta "sim" ou "não" e exiba o valor booleano correspondente.
    1. Peça ao usuário para digitar se ele gosta de programação (sim ou não) e exiba a resposta como booleano.
    1. Peça ao usuário para digitar se ele é maior de idade (sim ou não) e exiba a resposta como booleano.
    1. Peça ao usuário para digitar se ele tem um pet (sim ou não) e exiba a resposta como booleano.
1. Bool com if-elif-else
    1. Peça ao usuário para digitar "True" ou "False". Se for "True", exiba "Verdadeiro". Se for "False", exiba "Falso".
    1. Peça ao usuário para digitar se ele está estudando (sim ou não). Se for "sim", exiba "Estudando". Caso contrário, exiba "Não estudando".
    1. Peça ao usuário para digitar se ele está trabalhando (sim ou não). Se for "sim", exiba "Trabalhando". Caso contrário, exiba "Não trabalhando".
    1. Peça ao usuário para digitar se ele gosta de esportes (sim ou não). Se for "sim", exiba "Gosta de esportes". Caso contrário, exiba "Não gosta de esportes".
    1. Peça ao usuário para digitar se ele usa óculos (sim ou não). Se for "sim", exiba "Usa óculos". Caso contrário, exiba "Não usa óculos".
1. Exercícios Mistos
    1. Peça ao usuário para digitar seu nome e idade. Exiba uma mensagem dizendo quantos anos ele terá em 5 anos.
    1. Peça ao usuário para digitar dois números inteiros e um número decimal. Exiba a soma dos três números.
    1. Peça ao usuário para digitar uma frase e um número inteiro. Exiba a frase repetida o número de vezes digitado.
    1. Peça ao usuário para digitar uma palavra e um número decimal. Exiba a palavra concatenada com o número decimal convertido para string.
    1. Peça ao usuário para digitar uma frase e um valor booleano (sim ou não). Exiba a frase concatenada com a string "Verdadeiro" ou "Falso", dependendo do valor booleano.
1. Exercícios Mistos com if-elif-else
    1. Peça ao usuário para digitar um número inteiro e um número decimal. Se a soma for maior que 100, exiba "Soma maior que 100". Caso contrário, exiba "Soma menor ou igual a 100".
    1. Peça ao usuário para digitar seu nome e idade. Se a idade for maior ou igual a 18, exiba "Maior de idade". Caso contrário, exiba "Menor de idade".
    1. Peça ao usuário para digitar uma palavra e um valor booleano (sim ou não). Se o valor booleano for "sim", exiba a palavra em maiúsculas. Caso contrário, exiba a palavra em minúsculas.
    1. Peça ao usuário para digitar dois números decimais. Se o primeiro for maior que o segundo, exiba "Primeiro maior". Caso contrário, exiba "Segundo maior ou igual".
    1. Peça ao usuário para digitar uma frase e um número inteiro. Se o número for positivo, exiba a frase com a quantidade de caracteres igual ao número. Se for negativo, exiba a frase invertida.

</details>



# instalando-python.md

Índice Instalando o Python

1. [o que é o python](#o-que-é-o-python)
1. [como instalar](#como-instalar)

# instalando o python

## o que é o python

Python é uma linguagem de programação de alto nível, interpretada e de propósito geral, conhecida por sua simplicidade e legibilidade. Criada pelo matemático holandês Guido van Rossum e lançada pela primeira vez em 1991, Python foi projetada para enfatizar a facilidade de leitura do código, utilizando uma sintaxe que permite aos programadores expressar conceitos de maneira clara e concisa.

Algumas características principais de Python incluem:

1. **Sintaxe Clara e Intuitiva**: A sintaxe de Python é semelhante ao inglês, o que torna o código mais legível e mais fácil de entender e escrever;
2. **Multiplataforma**: Python é compatível com a maioria dos sistemas operacionais, incluindo Windows, macOS e Linux;
3. **Bibliotecas e Frameworks Ricos**: Python possui uma vasta coleção de bibliotecas e frameworks, como NumPy, Pandas, Matplotlib, Django e Flask, que facilitam o desenvolvimento em diversas áreas, como ciência de dados, aprendizado de máquina, desenvolvimento web, automação e muito mais;
4. **Interpretada**: Python é uma linguagem interpretada, o que significa que o código é executado linha por linha, facilitando a depuração e tornando o desenvolvimento mais ágil;
5. **Paradigmas de Programação**: Suporta múltiplos paradigmas de programação, incluindo programação procedural, orientada a objetos e funcional;

Devido a essas características, Python é amplamente utilizada tanto por iniciantes quanto por desenvolvedores experientes e em várias áreas de desenvolvimento, desde scripts simples até aplicações complexas de inteligência artificial e análise de dados.

## como instalar

Há diversar formas de instalar o Python. Para cada sistema operacional há uma ou mais formas específicas:

- Windows : https://python.org.br/instalacao-windows/
- Linux : https://python.org.br/instalacao-linux/
- macOS : https://python.org.br/instalacao-mac/

### windows
O Python pode ser baixado do seu site em [www.python.org](https://www.python.org/downloads/), no botão em destaque. O nome do arquivo será algo como `python-3.xx-amd64.exe`, sendo o `x` substituído pela versão atual do programa. Quando ele for executado, ele poderá ser instalado de duas formas, com e sem direitos de administrador. Se for instalado com direitos de administrador, então o Python ficará disponível para todos os usuários da máquina. Se for instalado para o usuário local, então apenas ele terá o programa instalado.

Uma vez executado, é apresentada a tela de `Install Python 3.xx (64-bit)`. Nela há duas opções apresentadas:
- **Install Now** (instalar agora) : essa opção irá pedir a senha do administrador;
- **Customize installation** (customizar a instalação) : essa opção permite escolher instalar para o usuário local ou instalar para todos os usuários;

As opções abaixo podem ser deixadas inalteradas.
- [x] Use admin privileges when installing py.exe;
- [ ] Add python.exe to PATH;

Após selecionar a opção **Customize installation**, será mostrada a tela de `Optional Features` (Funções Opcionais).

- [x] Documentation
- [x] pip
- [x] tcl/tk and IDLE
- [x] Python test suite
- [x] py launcher
- [ ] for all users (requires admin privileges)

Marque as opções assim como consta acima. A **Documentation**, como o nome indica, vai instalar a documentação do Python, que também pode ser encontrada em [Python Docs](https://docs.python.org/3/). O **pip** é o gerenciador de pacotes do Python (Package Installer for Python). O **tcl/tk** é uma biblioteca usada para gerar aplicações gráficas e o IDLE é o ambiente integrado de desenvolvimento padrão que vem com o instalador do Python (integrated development environment for Python). O **py launcher** é um atalho para todas as versões do Python instaladas no sistema. O **for all users** é usado quando se quer que o Python seja instalado para todos os usuários da máquina, isto é, ele será instalado no *AppData* de cada usuário existente na máquina.

A próxima tema é a de `Advanced Options` (Opções Avançadas).

- [ ] Install Python 3.xx for all users
- [x] Associate files with Python
- [x] Create shortcuts for installed applications
- [x] Add Python to environment variables
- [x] Precompile standard library
- [x] Download debugging symbols
- [x] Download debug binaries

Se a opção **Install Python for all users** for marcada, ele será instalado na pasta Arquivo de Programas do Windows e dessa forma estará disponível para todos os usuários. Com exceção da primeira opção, todas as demais podem ser marcadas. No campo abaixo irá mostrar o caminho onde o Python será instalado.

Uma vez que a instalação for finalizada, é possível verficar se está instalado abrindo o *Prompt de Comando* e digitando `python --version`. Se a versão for mostrada, então tudo foi instalado corretamente.
```cmd
C:\> python --version
Python 3.xx

C:\> |
```

#### variáveis de ambiente
Adicionar um programa às variáveis de ambiente do Windows envolve a atualização da variável de ambiente `PATH` para incluir o diretório do programa.

Veja os passos :

1. Abrir as Propriedades do Sistema :
    - Pressione `Win + R`, digite `sysdm.cpl` e pressione `Enter`.
1. Acessar as Variáveis de Ambiente :
    - Na janela "Propriedades do Sistema", vá para a guia `Avançado` e clique em `Variáveis de Ambiente...`.
1. Editar a Variável PATH :
    - Na seção "Variáveis do sistema", encontre a variável `Path` e selecione-a.
    - Clique em `Editar...`.
1. Adicionar o Caminho do Programa :
    - Na janela "Editar Variável de Ambiente", clique em `Novo` e adicione o caminho completo do diretório do programa que deseja adicionar.
    - Por exemplo, se for adicionar o Python instalado para o usuário, vai estar em
        - `C:\Users\<seu_usuário>\AppData\Programs\Python\Python312`
    - Uma vez localizado, adicione esse caminho.
1. Salvar as Alterações :
    - Clique em `OK` para fechar todas as janelas abertas.

#### verificando
Para garantir que o programa foi adicionado ao `PATH`, abra o `Prompt de Comando` (CMD) e digite o comando relacionado ao programa para verificar se ele é reconhecido pelo sistema. Por exemplo, como foi adicionado o Python, digite `python --version` para verificar se o comando é executado corretamente.

Isso deve permitir que o programa seja executado a partir de qualquer diretório no Prompt de Comando.

### linux

Se você é usuário de Linux, provavelmente você já sabe instalar o Python ;)

<details>
  <summary>Lista de Exercícios</summary>

1. Instale o Python 3.6:
    1. Baixe e instale o Python 3.6 na sua máquina.
    1. Verifique a instalação rodando `python --version`.
1. Instale o Python 3.7:
    1. Baixe e instale o Python 3.7 na sua máquina.
    1. Verifique a instalação rodando `python --version`.
1. Remova o Python 3.6:
    1. Desinstale o Python 3.6 do seu sistema.
    1. Verifique a remoção rodando `python --version` e confirmando que a versão não está mais disponível.
1. Instale o Python 3.8:
    1. Baixe e instale o Python 3.8 na sua máquina.
    1. Verifique a instalação rodando `python --version`.
1. Remova o Python 3.7:
    1. Desinstale o Python 3.7 do seu sistema.
    1. Verifique a remoção rodando `python --version` e confirmando que a versão não está mais disponível.
1. Instale o Python 3.9:
    1. Baixe e instale o Python 3.9 na sua máquina.
    1. Verifique a instalação rodando `python --version`.
1. Remova o Python 3.8:
    1. Desinstale o Python 3.8 do seu sistema.
    1. Verifique a remoção rodando `python --version` e confirmando que a versão não está mais disponível.
1. Instale o Python 3.10:
    1. Baixe e instale o Python 3.10 na sua máquina.
    1. Verifique a instalação rodando `python --version`.
1. Instale o Python 3.11:
    1. Baixe e instale o Python 3.11 na sua máquina.
    1. Verifique a instalação rodando `python --version`.
1. Remova o Python 3.9:
    1. Desinstale o Python 3.9 do seu sistema.
    1. Verifique a remoção rodando `python --version` e confirmando que a versão não está mais disponível.
1. Instale o Python 3.6 e o Python 3.10 simultaneamente:
    1. Baixe e instale o Python 3.6 e o Python 3.10 na sua máquina.
    1. Verifique a instalação rodando `python --version`;
    1. Troque a ordem de precedência para o Python 3.6 no PATH.
    1. Verifique a instalação rodando `python --version`;
1. Remova o Python 3.6:
    1. Desinstale o Python 3.6 do seu sistema.
    1. Verifique a remoção rodando `python --version` e confirmando que a versão não está mais disponível.
1. Instale o Python 3.7 e o Python 3.11 simultaneamente:
    1. Baixe e instale o Python 3.7 e o Python 3.11 na sua máquina.
    1. Verifique a instalação rodando `python --version`.
    1. Troque a ordem de precedência para o Python 3.7 no PATH.
    1. Verifique a instalação rodando `python --version`;
1. Remova o Python 3.10:
    1. Desinstale o Python 3.10 do seu sistema.
    1. Verifique a remoção rodando `python --version` e confirmando que a versão não está mais disponível.
1. Instale o Python 3.8 e o Python 3.7 simultaneamente:
    1. Baixe e instale o Python 3.8 e o Python 3.7 na sua máquina.
    1. Verifique a instalação rodando `python --version`.
    1. Troque a ordem de precedência para o Python 3.8 no PATH.
    1. Verifique a instalação rodando `python --version`.
1. Remova o Python 3.11:
    1. Desinstale o Python 3.11 do seu sistema.
    1. Verifique a remoção rodando `python --version` e confirmando que a versão não está mais disponível.
1. Instale o Python 3.9 e o Python 3.8 simultaneamente:
    1. Baixe e instale o Python 3.9 e o Python 3.8 na sua máquina.
    1. Verifique a instalação rodando `python --version`;
    1. Troque a ordem de precedência para o Python 3.9 no PATH.
    1. Verifique a instalação rodando `python --version`.
1. Remova o Python 3.7:
    1. Desinstale o Python 3.7 do seu sistema.
    1. Verifique a remoção rodando `python --version` e confirmando que a versão não está mais disponível.
1. Remova o Python 3.8:
    1. Desinstale o Python 3.8 do seu sistema.
    1. Verifique a remoção rodando `python --version` e confirmando que a versão não está mais disponível.
1. Instale a última versão do Python (atual):
    1. Baixe e instale a última versão do Python 3 disponível.
    1. Verifique a instalação rodando `python --version`.
    1. Confirme que é a única versão instalada no sistema.

</details>


# instalando-vscode.md

Índice Instalando o VS Code

1. [baixando o vs code](#baixando-o-vs-code)
1. [instalar o vs code](#instalar-o-vs-code)
1. [extensão do vs code](#extensão-do-vs-code)

# como baixar e instalar o vs code

A seguir há um passo a passo de como baixar e instalar o VS Code.

## baixando o vs code

1. **Abrir o Navegador de Internet:**
    - Clique no ícone do navegador de internet (por exemplo, Google Chrome, Firefox, Edge) na barra de tarefas ou na área de trabalho.

2. **Acessar o Site de Download:**
    - Na barra de endereços do navegador, digite [https://code.visualstudio.com/download](https://code.visualstudio.com/download) e pressione Enter.

3. **Selecionar a Versão para Download:**
    - Na página serão apresentadas 3 versões para o download.
    - Selecione a versão apropriada para o seu sistema operacional (Windows, macOS ou Linux).
        - Para as aulas, selecione a versão **User Installer** do Windows.
        - Em sua casa, escolha a versão principal.

## instalar o vs code

### windows

A versão **User Installer** é usada para realizar uma instalação onde o usuário não possui as permissões de administrador na máquina. Ela terá um nome como `VSCodeUserSetup-x64-1.xx.exe`, onde `xx` representa a versão baixada.

1. **Executar o Instalador:**
    - Após o download, localize o arquivo baixado (geralmente na pasta "Downloads").
    - Clique duas vezes no arquivo `VSCodeSetup.exe` para iniciar o instalador.
1. **Iniciar a Instalação:**
    - Clique em "Sim" se o Windows solicitar permissão para fazer alterações no dispositivo.
    - Na tela de boas-vindas do instalador do VS Code, clique em "Next" (Avançar).
1. **Aceitar o Contrato de Licença:**
    - Marque a caixa "I accept the agreement" (Eu aceito o contrato) e clique em "Next" (Avançar).
1. **Escolher a Pasta de Instalação:**
    - Deixe a pasta de instalação padrão ou selecione outra pasta de sua escolha e clique em "Next" (Avançar).
1. **Criar Atalho no Menu Iniciar**
    - Deixe a opção padrão e clique em "Next" (Avançar).
1. **Selecionar Componentes Adicionais:**
    - Marque todas as opções faltantes, criar ícone na área de trabalho e adicionar o Code ao menu do Explorer.
    - Clique em "Next" (Avançar).
1. **Revisar e Instalar:**
    - Revise as opções de instalação de modo que fique parecido com o modelo abaixo :
    ```
    Local de destino:
        C:\Users\<seu_usuario>\AppData\Local\Programs\Microsoft VS Code

    Pasta do Menu Iniciar:
        Visual Studio Code

    Tarefas adicionais:
        Atalhos adicionais:
            Criar um atalho na área de trabalho
        Outros:
            Adicione a ação "Abrir com Code" ao menu de contexto de arquivo do Windows Explorer
            Adicione a ação "Abrir com Code" ao menu de contexto de diretório do Windows Explorer
            Registre Code como um editor para tipos de arquivos suportados
            Adicione em PATH (disponível após reiniciar)
    ```
   - Clique em "Install" (Instalar). Aguarde a instalação ser concluída.
1. **Finalizar a Instalação:**
   - Marque a opção "Launch Visual Studio Code" (Lançar Visual Studio Code) e clique em "Finish" (Concluir).

### macos

1. **Abrir o Arquivo de Download:**
   - Após o download, localize o arquivo baixado (geralmente na pasta "Downloads").
   - Clique duas vezes no arquivo `.dmg`.
2. **Mover o VS Code para a Pasta Aplicativos:**
   - Arraste o ícone do Visual Studio Code para a pasta "Applications" (Aplicativos).
3. **Abrir o VS Code:**
   - Vá até a pasta "Applications" (Aplicativos) e clique duas vezes no ícone do Visual Studio Code para abrir o aplicativo.

### linux

1. **Dependendo da Distribuição, Utilize o Método Apropriado:**

    **Ubuntu/Debian:**
    - Abra o terminal.
    - Digite o comando:
    ```
    sudo apt update
    sudo apt install code
    ```
    - Pressione Enter e siga as instruções para instalar.<br><br>

    **Fedora/RHEL:**
    - Abra o terminal.
    - Digite o comando:
    ```
    sudo rpm --import https://packages.microsoft.com/keys/microsoft.asc
    sudo sh -c 'echo -e "[code]\nname=Visual Studio Code\nbaseurl=https://packages.microsoft.com/yumrepos/vscode\nenabled=1\ngpgcheck=1\ngpgkey=https://packages.microsoft.com/keys/microsoft.asc" > /etc/yum.repos.d/vscode.repo'
    sudo dnf check-update
    sudo dnf install code
    ```
    - Pressione Enter e siga as instruções para instalar.<br><br>

2. **Abrir o VS Code:**
   - Após a instalação, abra o Visual Studio Code pelo menu de aplicativos ou digitando `code` no terminal.

### dicas finais

- **Tradução para Português:**
  - Abra o VS Code.
  - Vá até "View" (Exibir) > "Command Palette" (Paleta de Comandos).
  - Digite `Configure Display Language` e selecione `Portuguese (Brazil)`.

----

## extensão do vs code

O VS Code, por si só, é uma ferramente muito poderosa, mas ele pode melhorar.

O programa tem uma funcionalidade chamada de extensões, onde é possível adicionar extensões ao programa de modo que ele funcione melhor para determinados trabalhos.

Há uma extensão perfeita para trabalhar com Python no VS Code. Para instalá-la, siga os passos abaixo.

### instalando a extensão

1. **Abrir o VS Code:**
   - Clique no ícone do Visual Studio Code na área de trabalho ou na lista de aplicativos.
1. **Abrir o Gerenciador de Extensões:**
   - No lado esquerdo da janela do VS Code, clique no ícone de quadrados empilhados (Extensões). Alternativamente, você pode usar o atalho de teclado `Ctrl+Shift+X` no Windows/Linux ou `Cmd+Shift+X` no macOS.
1. **Procurar por "Python":**
   - Na barra de pesquisa do gerenciador de extensões, digite `Python`.
   - A extensão oficial do Python, desenvolvida pela Microsoft, deve aparecer como o primeiro resultado. Ela é identificada com o nome "Python" e o ícone de uma cobra amarela.
1. **Instalar a Extensão:**
   - Clique no botão "Install" (Instalar) ao lado da extensão "Python". A instalação pode levar alguns momentos.
1. **Selecionar o Interpretador Python:**
   - Após a instalação, o VS Code pode solicitar que você selecione um interpretador Python.
   - Se a solicitação aparecer, clique em "Select Python Interpreter" (Selecionar Interpretador Python).
   - Escolha o interpretador Python instalado no seu sistema. Se você tiver mais de uma versão do Python instalada, selecione a versão que deseja usar.

### verificando a instalação

1. **Criar um Novo Arquivo Python:**
   - Clique em "File" (Arquivo) > "New File" (Novo Arquivo).
   - Salve o arquivo com a extensão `.py` (por exemplo, `teste.py`).
2. **Escrever um Código Simples:**
   - Digite o seguinte código no arquivo:
     ```python
     print("Olá, mundo!")
     ```
   - Salve o arquivo.
3. **Executar o Código:**
   - Clique com o botão direito no arquivo e selecione "Run Python File in Terminal" (Executar Arquivo Python no Terminal).
   - O terminal deve abrir na parte inferior do VS Code e exibir a saída `Olá, mundo!`.

Agora, você está pronto para começar a programar em Python no VS Code com a extensão instalada.


# intercalando-formatando-strings.md

Índice Intercalando e Formatando Strings

1. [introduçao](#introdução)
1. [intercalando strings com +](#intercalando-strings-com-)
1. [operador %](#operador-)
1. [str.format](#strformat)
1. [f-string](#f-string)
1. [formatando strings](#formatando-strings)
1. [exercícios](#exercícios)

# Intercalando Strings

## introdução

Quando se está trabalhando com strings, é comum precisar integrar ou inserir valores e objetos nelas, para então criar novas strings dinamicamente. Essa tarefa é conhecida como intercalação de stings.

O Python possiu três ferramentas para realizar essa tarefa :
- O operador `módulo` (`%`);
- O método `str.format()`;
- Literais `f-strings`;

> [!IMPORTANT]
>
> Antes de seguir adiante, é importante saber que há duas formas de intercalação de strings :
> - `Intercalação Ansionsa` : é quando o Python insere os valores dos objetos na strings em tempo de exeucução enquanto a strings está sendo definida;
> - `Intercalação Preguiçosa` : é quando o Python atrasa a inserção dos objetos na strings até o seu uso. Nesse caso, serão criados modelos em um ponto do código e o preenchimento com os valores é feito em outro momento;
>
> Ao explorarmos os métodos adiante, isso será melhor explicado com exemplos para cada caso de uso.

## intercalando strings com +

Como foi visto anteriormente, uma forma de criar uma string é usando o operador `+` para intercalar strings e assim gerar novas strings. É possível usar para salvar em uma nova variável ou então exibir um texto já formatado :

```python
>>> nome = 'Arnold'
>>> sobrenome = 'Schwarzenegger'
>>>
>>> nome_completo = nome + ' ' + sobrenome
>>> nome_completo
'Arnold Schwarzenegger'
>>> print(nome + ' ' + sobrenome)
Arnold Schwarzenegger
>>> |
```

Embora essa forma funcione, ela não é muito prática pois torna difícil a leitura do código.

## operador %

Intercalar strings com o operador `%` é uma forma obsoleta, mas ainda funcional para isso. É importante saber que existe pois muitos códigos antigos ainda os usam. Ele pode ser usado tanto para *intercalação ansiosa* quanto para *intercalação preguiçosa*.

Veja exemplos de intercalação ansiosa :

```python
>>> x = 30
>>> y = 12
>>>
>>> operador = '+'
>>> 'A operação é %d %s %d = %d.' % (x, operador, y, x + y)
'A operação é 30 + 12 = 42.'
>>>
>>> operador = '-'
>>> 'A operação é %d %s %d = %d.' % (x, operador, y, x - y)
'A operação é 30 - 12 = 18.'
>>>
>>> operador = '/'
>>> 'A operação é %d %s %d = %d.' % (x, operador, y, x / y)
'A operação é 30 / 12 = 2.'
>>> |
```

A combinação de caracteres iniciando com o sinal de percentual `%` é conhecida como conversão específica. Nos exemplos acima, foi usado o especificador `%d`, usado quando se quer converter um valor decimal ou inteiro para uma strings. Repare no último exemplo que o valor decimal do resultado foi perdido na conversão.

Uma intercalação preguiçosa pode ser feita como abaixo :

```python
>>> x = 30
>>> y = 12
>>>
>>> modelo = 'A operação é %d %s %d = %d.'
>>>
>>> operador = '+'
>>> modelo % (x, operador, y, x + y)
'A operação é 30 + 12 = 42.'
>>>
>>> operador = '-'
>>> modelo % (x, operador, y, x - y)
'A operação é 30 - 12 = 18.'
>>>
>>> operador = '/'
>>> modelo % (x, operador, y, x / y)
'A operação é 30 / 12 = 2.'
>>> |
```

Essa forma de uso é útil quando se precisa reutilizar o mesmo modelo em mais de um local do código. Outros formatos incluem `%f` para números do tipo `float` e `%s` para strings.

```python
>>> pi = 3.141592
>>> 'o valor de PI é %f' % pi
'o valor de PI é 3.141592'
>>>
>>> nome_completo = 'Arnold Schwarzenegger'
>>> 'O nome completo é %s' % nome_completo
'O nome completo é Arnold Schwarzenegger'
>>> |
```

Por ser um método já muito antigo, datando dos primórdios da criação do Python, ele quase não é mais usando atualmente. Então maiores detalhes não serão abordados. Contudo, a documentação do Python é bem extensa sobre esse recurso. Mais pode ser encontrado [aqui](https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting).

## str.format()
Se for necessário intercalar valores em uma strings preguiçosamente, então o método `str.format()` é o que precisa. Ele proporciona uma sintaxe legível e permite ambos as intercalação preguiçosa e ansiosa.

Este método permite três abordagens diferentes :

1. Campo de substituição vazio, `{}`;
    ```python
    >>> modelo = """
    ... Caro {},
    ... Obrigado pela figurinha do {} que comprou.
    ... Atencionamente,
    ... {}
    ... """
    >>>
    >>> print(modelo.format('Tom', 'Campeonato Brasileiro', 'Seu amigo'))

    Caro Tom,
    Obrigado pela figurinha do Campeonato Brasileiro que comprou.
    Atencionamente,
    Seu amigo

    >>> |
    ```
    No exemplo acima, é criado um modelo de mensagem agradecendo pela compra de uma figurinha, podendo ser de qualquer álbum e agradecendo qualquer pessoa. Nesse exemplo, foi usado uma variável para guardar o texto como modelo.

    Veja abaixo um modelo usado na string diretamente.

    ```python
    >>> x = 10
    >>> y = 32
    >>> print('a soma de {} com {} é {}'.format(x, y, x+y))
    a soma de 10 com 32 é 42
    >>> |
    ```

2. Campo de substituição com índices iniciado em zero, `{0} ... {n}`;

    ```python
    >>> modelo = 'Disciplina : {0}\nNota : {1}'
    >>> print(modelo.format('Python', 'A'))
    Disciplina : Python
    Nota : A
    >>> print(modelo.format('C++', 'C'))
    Disciplina : C++
    Nota : C
    >>> print(modelo.format('C', 'Java'))
    Disciplina : C
    Nota : Java
    >>>
    >>> modelo = 'Disciplina : {1}\nNota : {0}'
    >>> print(modelo.format('C', 'Java'))
    Disciplina : Java
    Nota : C
    >>> |
    ```
    Como pode ser visto no modelo acima, foi criado um modelo com os campos determinados usando um índice iniciando em 0 e seguido de 1. É possível ver, também, que ao alterar a ordem, os valores são impressos errados. Em seguida, o modelo é alterado para aceitar as novas posições.

    Também é possível usar para criar prefixos, veja abaixo :
    ```python
    >>> prefixo = 're'
    >>> print('{0}criar, {0}iniciar, {0}nascer, {0}abastecer'.format(prefixo))
    recriar, reiniciar, renascer, reabastecer
    >>> |
    ```

3. Campo de susbtituição com argumentos nomeados, `{arg_1} ... {arg_n}`;

    Apesar dos métodos anteriores serem práticos, eles não são exatamente muito fáceis de ler. Mesmo quando a string é lida, não é claro o que será substituído. Para contornar esse problema, é possível usar palavras-chave para determinar os campos.

    ```python
    >>> modelo = """
    ... Caro {cliente},
    ... Obrigado por comprar o {produto}
    ... Com carinho
    ... {vendedor}
    ... """
    >>>
    >>> print(modelo.format(
    ...     cliente='Tom',
    ...     produto='Galaxy S90',
    ...     vendedor='Fulano'
    ... ))

    Caro Tom,
    Obrigado por comprar o Galaxy S90
    Com carinho
    Fulano

    >>> |
    ```
    Nessa string, é muito mais fácil de indentificar o que cada campo {} vai receber como parâmetro. Isso facilita tanto para a legibilidade quanto para atualizar o código, se necessário.

## f-string

Para a maioria das intercalações de strings, o método usado será a `f-string`. Ela foi adicionada ao Python em sua versão 3.6 e possui uma legibilidade muito melhor e concisa, além de possuir uma performance superior às demais.

Uma situação onde a `f-string` talvez não seja a melhor escolha é quando se faz necessário usar a intercalação preguiçosa. Outra consideração importante é que, como ela é executada de imediato, ela pode expor a aplicação a ataques maliciosos se não for tomado o devido cuidado.

```python
>>> x = 5
>>> y = 37
>>> f'A expressão é {x} + {y} = {x + y}.'
'A expressão é 5 + 37 = 42.'
>>> |
```

No exemplo acima, há duas variáveis que são somadas dentro do terceiro campo diretamente na `f-string`. Isso permite, inclusive, realizar operações mais complexas dentro das chaves.

```python
>>> pi = 3.14159265
>>> raio = 17
>>> f'A área do círculo é {pi * (raio ** 2)}.'
'A área do círculo é 907.9202768874502.'
>>>
>>> nome = 'Arnold'
>>> sobrenome = 'Schwarzenegger'
>>> f'Olá, {nome.upper()}. Seu nome completo é {nome + " " + sobrenome}.'
'Olá, ARNOLD. Seu nome completo é Arnold Schwarzenegger.'
>>>
>>> f'{[2**i for i in range(2, 20, 2)]}.'
'[4, 16, 64, 256, 1024, 4096, 16384, 65536, 262144].'
>>> |
```

A `f-string`, assim como a `str.format()` automaticamente convertem os números para strings.

Outro ponto muito interessante da `f-string` é ser possível realizar uma auto documentação. Isso é muito útil quando se quer documentar o que tem uma variável ou então quando se quer mostrar qual variável tem qual valor.

```python
>>> um_texto = 'contenho um texto muito interessante'
>>>
>>> f'O que é isso : <{um_texto = }>'
"O que é isso : <um_texto = 'contenho um texto muito interessante'>"
>>>
>>> f'{2 * 21 = }.'
'2 * 21 = 42.'
>>>
>>> print(f'{2 * 21 = }.')
2 * 21 = 42.
>>> |
```

## formatando strings

O Python também permite formatar as strings quando for exibir elas.

```python
>>> pi = 3.1415926535
>>>
>>> print('o valor de pi é {}'.format(pi))
o valor de pi é 3.1415926535
>>> print('o valor de pi é {:.2f}'.format(pi))
o valor de pi é 3.14
>>> print('o valor de pi é {:.4f}'.format(pi))
o valor de pi é 3.1416
>>>
>>> print(f'o valor de pi é {pi:.2f}')
o valor de pi é 3.14
>>> |
```
Esse tipo de formatação é válido tanto para `str.format()` quanto para `f-string`.

Também permite especificar o tamanho do campo e o alinhamento :
```python
>>> # alinhando à esquerda
>>> print(f'-{saudacao:<10}-')
-olá       -
>>>
>>> # alinhando à direita
>>> print(f'-{saudacao:>10}-')
-       olá-
>>>
>>> # centralizando
>>> print(f'-{saudacao:^10}-')
-   olá    -
>>> |
```

E especificar um preenchimento :
```python
>>> # alinhando à esquerda e preenchendo com _
>>> print(f'-{saudacao:_<20}-')
-olá_________________-
>>>
>>> # alinhando à direita e preenchendo com +
>>> print(f'-{saudacao:+>20}-')
-+++++++++++++++++olá-
>>>
>>> # centralizando e preenchendo com *
>>> print(f'-{saudacao:*^20}-')
-********olá*********-
>>>
>>> # preenchendo com zero a esquerda ou a direita
>>> print(f'-{3.14:0<20}-')
-3.140000000000000000-
>>> print(f'-{3.14:0>20}-')
-00000000000000003.14-
>>> |
```

## exercícios

<details>
<summary>Lista de Exercícios</summary>

1. Intercalação de Strings usando `+`
    1. Crie duas variáveis do tipo `str` e concatene-as usando o operador `+`.
    1. Crie três variáveis do tipo `str` e concatene-as usando o operador `+` para formar uma frase completa.
    1. Crie uma variável `str` que armazene um nome e outra que armazene uma saudação, depois concatene-as para exibir uma mensagem de boas-vindas.
    1. Crie uma variável `str` com o nome de uma pessoa e outra com a cidade onde ela mora. Concatene-as para exibir uma mensagem informando a cidade de residência.
    1. Crie uma variável `str` com o nome de uma fruta e outra com a cor dela. Concatene as strings para formar a frase "A [fruta] é [cor]".
    1. Crie três variáveis `str` que armazenem o primeiro nome, o sobrenome e a idade de uma pessoa. Concatene-as para exibir a frase "Nome: [primeiro nome] [sobrenome], Idade: [idade]".
    1. Crie uma variável `str` com o nome de uma cidade e outra com o nome de um país. Concatene-as para formar a frase "Cidade: [cidade], País: [país]".
    1. Crie duas variáveis `str` contendo uma saudação e um nome. Concatene as strings para exibir "Olá, [nome]!".
    1. Crie uma variável `str` com o nome de uma pessoa e outra com a profissão dela. Concatene-as para formar a frase "A [nome] é [profissão]".
    1. Crie uma variável `str` com o nome de um produto e outra com o preço dele. Concatene as strings para exibir "Produto: [produto], Preço: [preço]".
1. Intercalação de Strings usando o Operador `%`
    1. Crie uma variável `str` que armazene um nome e exiba "Meu nome é %s" usando o operador `%`.
    1. Crie uma variável `int` com a idade de uma pessoa e exiba "Eu tenho %d anos" usando o operador `%`.
    1. Crie uma variável `str` com o nome de uma fruta e outra com a cor dela. Exiba "A %s é %s" usando o operador `%`.
    1. Crie uma variável `float` com a altura de uma pessoa e exiba "Minha altura é %.2f metros" usando o operador `%`.
    1. Crie duas variáveis `str`, uma com o nome de um filme e outra com o diretor. Exiba "O filme %s foi dirigido por %s" usando o operador `%`.
    1. Crie uma variável `float` com o valor de um produto e exiba "O preço do produto é R$ %.2f" usando o operador `%`.
    1. Crie uma variável `str` com o nome de uma pessoa e outra com a profissão dela. Exiba "A %s é uma excelente %s" usando o operador `%`.
    1. Crie duas variáveis `str`, uma com o nome de uma cidade e outra com o nome de um país. Exiba "A cidade de %s está localizada em %s" usando o operador `%`.
    1. Crie uma variável `int` com a idade de uma pessoa e outra com a quantidade de anos de experiência dela. Exiba "Tenho %d anos e %d anos de experiência" usando o operador `%`.
    1. Crie uma variável `float` com o valor de um desconto e exiba "O desconto é de %.1f%%" usando o operador `%`.
1. Intercalação de Strings usando o Método `str.format()`
    1. Crie uma variável `str` que armazene um nome e exiba "Meu nome é {}" usando o método `str.format()`.
    1. Crie uma variável `int` com a idade de uma pessoa e exiba "Eu tenho {} anos" usando o método `str.format()`.
    1. Crie uma variável `str` com o nome de uma fruta e outra com a cor dela. Exiba "A {} é {}" usando o método `str.format()`.
    1. Crie uma variável `float` com a altura de uma pessoa e exiba "Minha altura é {:.2f} metros" usando o método `str.format()`.
    1. Crie duas variáveis `str`, uma com o nome de um filme e outra com o diretor. Exiba "O filme {} foi dirigido por {}" usando o método `str.format()`.
    1. Crie uma variável `float` com o valor de um produto e exiba "O preço do produto é R$ {:.2f}" usando o método `str.format()`.
    1. Crie uma variável `str` com o nome de uma pessoa e outra com a profissão dela. Exiba "A {} é uma excelente {}" usando o método `str.format()`.
    1. Crie duas variáveis `str`, uma com o nome de uma cidade e outra com o nome de um país. Exiba "A cidade de {} está localizada em {}" usando o método `str.format()`.
    1. Crie uma variável `int` com a idade de uma pessoa e outra com a quantidade de anos de experiência dela. Exiba "Tenho {} anos e {} anos de experiência" usando o método `str.format()`.
    1. Crie uma variável `float` com o valor de um desconto e exiba "O desconto é de {:.1f}%" usando o método `str.format()`.
1. Intercalação de Strings usando `f-strings`
    1. Crie uma variável `str` que armazene um nome e exiba "Meu nome é {nome}" usando uma `f-string`.
    1. Crie uma variável `int` com a idade de uma pessoa e exiba "Eu tenho {idade} anos" usando uma `f-string`.
    1. Crie uma variável `str` com o nome de uma fruta e outra com a cor dela. Exiba "A {fruta} é {cor}" usando uma `f-string`.
    1. Crie uma variável `float` com a altura de uma pessoa e exiba "Minha altura é {altura:.2f} metros" usando uma `f-string`.
    1. Crie duas variáveis `str`, uma com o nome de um filme e outra com o diretor. Exiba "O filme {filme} foi dirigido por {diretor}" usando uma `f-string`.
    1. Crie uma variável `float` com o valor de um produto e exiba "O preço do produto é R$ {preco:.2f}" usando uma `f-string`.
    1. Crie uma variável `str` com o nome de uma pessoa e outra com a profissão dela. Exiba "A {nome} é uma excelente {profissao}" usando uma `f-string`.
    1. Crie duas variáveis `str`, uma com o nome de uma cidade e outra com o nome de um país. Exiba "A cidade de {cidade} está localizada em {pais}" usando uma `f-string`.
    1. Crie uma variável `int` com a idade de uma pessoa e outra com a quantidade de anos de experiência dela. Exiba "Tenho {idade} anos e {experiencia} anos de experiência" usando uma `f-string`.
    1. Crie uma variável `float` com o valor de um desconto e exiba "O desconto é de {desconto:.1f}%" usando uma `f-string`.
1. Exercícios de Alinhamento de Strings
	1. Crie uma variável `str` com seu nome e exiba-a alinhada à esquerda em um campo de 20 caracteres.
	1. Crie uma variável `str` com o nome de uma cidade e exiba-a alinhada à direita em um campo de 30 caracteres.
	1. Crie uma variável `str` com o nome de um filme e exiba-a centralizada em um campo de 25 caracteres.
	1. Crie uma variável `str` com o nome de uma fruta e exiba-a alinhada à esquerda em um campo de 15 caracteres.
	1. Crie uma variável `str` com o título de um livro e exiba-o alinhado à direita em um campo de 40 caracteres.
	1. Crie uma variável `str` com o nome de uma banda e exiba-a centralizada em um campo de 30 caracteres.
	1. Crie uma variável `str` com o nome de uma cor e exiba-a alinhada à esquerda em um campo de 10 caracteres.
	1. Crie uma variável `str` com o nome de uma estação do ano e exiba-a alinhada à direita em um campo de 25 caracteres.
	1. Crie uma variável `str` com o nome de um país e exiba-o centralizado em um campo de 20 caracteres.
	1. Crie uma variável `str` com o nome de uma linguagem de programação e exiba-a alinhada à direita em um campo de 50 caracteres.
1. Exercícios de Preenchimento de Strings
    1. Crie uma variável `str` com seu nome e exiba-a preenchida com `*` à esquerda até completar 20 caracteres.
    1. Crie uma variável `str` com o nome de uma cidade e exiba-a preenchida com `-` à direita até completar 30 caracteres.
    1. Crie uma variável `str` com o nome de um filme e exiba-a preenchida com `.` centralizada em um campo de 25 caracteres.
    1. Crie uma variável `str` com o nome de uma fruta e exiba-a preenchida com `#` à esquerda até completar 15 caracteres.
    1. Crie uma variável `str` com o título de um livro e exiba-o preenchido com `~` à direita até completar 40 caracteres.
    1. Crie uma variável `str` com o nome de uma banda e exiba-a preenchida com `=` centralizada em um campo de 30 caracteres.
    1. Crie uma variável `str` com o nome de uma cor e exiba-a preenchida com `+` à esquerda até completar 10 caracteres.
    1. Crie uma variável `str` com o nome de uma estação do ano e exiba-a preenchida com `.` à direita até completar 25 caracteres.
    1. Crie uma variável `str` com o nome de um país e exiba-o preenchido com `*` centralizado em um campo de 20 caracteres.
    1. Crie uma variável `str` com o nome de uma linguagem de programação e exiba-a preenchida com `-` à direita até completar 50 caracteres.

</details>


# javascript-object-notation.md

Índice

1. [estrutura do json](#estrutura-do-json)
1. [json vs python](#json-vs-python)
1. [usos do json](#usos-do-json)
1. [conclusão](#conclusão)
1. [exercícios](#exercícios)

# JavaScript Object Notation

A notação JSON (JavaScript Object Notation) é um formato leve de troca de dados, muito utilizado para transmitir informações entre sistemas, especialmente em aplicações web. Ele é fácil de ler e escrever tanto por humanos quanto por máquinas. O JSON se baseia em uma coleção de pares chave-valor e em listas ordenadas de valores.

## estrutura do json

### objetos

No JSON, um objeto é uma coleção de pares de chave-valor. As chaves são strings e os valores podem ser de vários tipos: strings, números, arrays, booleanos, nulos ou até outros objetos.

Sintaxe :
- o objeto é delimitado por chaves `{ }`;
- cada chave deve estar entre aspas duplas `"`;
- chave e valor são separados por dois pontos `:`;
- os pares são separados por vírgulas `,`;

Exemplo :
```json
{
    "nome": "João",
    "idade": 30,
    "cidade": "São Paulo"
}
```

No exemplo acima :
- `"nome"` é a chave, e `"João"` é o valor (do tipo string);
- `"idade"` é a chave, e `30` é o valor (do tipo número);
- `"cidade"` é a chave, e `"São Paulo"` é o valor (do tipo string);

### arrays

Os arrays em JSON são listas ordenadas de valores. Eles são delimitados por colchetes `[ ]` e os valores são separados por vírgulas.

Sintaxe :
- o array é delimitado por colchetes `[ ]`;
- os valores dentro do array podem ser de qualquer tipo aceito pelo JSON;

Exemplo :
```json
{
    "nomes": ["Ana", "Bruno", "Carlos"],
    "idades": [25, 30, 35]
}
```

Aqui, o valor da chave `"nomes"` é um array de strings, e o valor da chave `"idades"` é um array de números.

### tipos de dados

O JSON suporta os seguintes tipos de dados:

- **String** : uma sequência de caracteres, delimitada por aspas duplas.
    ```json
    "nome": "Maria"
    ```

- **Número** : pode ser um número inteiro ou decimal (sem aspas).
    ```json
    "idade": 28
    ```

- **Booleano** : valores lógicos `true` ou `false`.
    ```json
    "casado": false
    ```

- **Nulo** : representado pela palavra-chave `null`.
    ```json
    "filhos": null
    ```

- **Objetos** : são coleções de pares chave-valor, podendo conter objetos aninhados.
    ```json
    {
        "endereco": {
        "rua": "Av. Paulista",
        "numero": 1000,
        "cidade": "São Paulo"
        }
    }
    ```

- **Arrays** : listas ordenadas de valores.
    ```json
    "cores": ["vermelho", "azul", "verde"]
    ```

### Exemplo

Abaixo há um exemplo mais complexo de um JSON que contém um objeto, arrays, e diferentes tipos de dados.

```json
{
"pessoa": {
    "nome": "Carlos",
    "idade": 40,
    "casado": true,
    "filhos": ["Pedro", "Ana"],
    "endereco": {
        "rua": "Rua das Flores",
        "numero": 123,
        "cidade": "Curitiba"
    },
    "telefones": [
        {
            "tipo": "celular",
            "numero": "99999-1234"
        },
        {
            "tipo": "residencial",
            "numero": "3333-5678"
        }
    ]
}
}
```

Explicação :
- `"pessoa"` é um objeto que contém várias informações;
- `"nome"` é uma string, `"idade"` é um número, e `"casado"` é um booleano;
- `"filhos"` é um array de strings;
- `"endereco"` é outro objeto aninhado, contendo informações de endereço;
- `"telefones"` é um array de objetos, cada um representando um tipo de telefone com seu número;

## json vs python

### tipos compatíveis

O Python e o JSON tem vários dados que são compatíveis entre si.

Abaixo há uma tabela comparativa entre os tipos de dados no JSON e suas correspondências no Python :

| Tipo de Dado JSON | Equivalente em Python | Descrição |
|-------------------|-----------------------|-----------|
| **Objeto**         | `dict`                | No JSON, um objeto é uma coleção de pares chave-valor. No Python, o equivalente é o dicionário (`dict`), onde as chaves podem ser strings (ou outros tipos imutáveis) e os valores podem ser de qualquer tipo. |
| **Array**          | `list`                | Um array em JSON é uma lista ordenada de valores. Em Python, o equivalente é a lista (`list`), que também é ordenada e permite armazenar valores de tipos variados. |
| **String**         | `str`                 | Em ambos, uma string é uma sequência de caracteres delimitada por aspas duplas no JSON e aspas simples ou duplas no Python. |
| **Número**         | `int` ou `float`      | No JSON, números podem ser inteiros ou decimais. No Python, inteiros são representados por `int` e decimais por `float`. |
| **Booleano**       | `bool`                | No JSON, booleanos são representados como `true` ou `false`. Em Python, os valores equivalentes são `True` e `False` (note a diferença na capitalização). |
| **Nulo**           | `None`                | No JSON, o valor nulo é representado por `null`. Em Python, o valor equivalente é `None`. |

#### exemplos

- JSON :
    ```json
    {
        "nome": "João",
        "idade": 25,
        "casado": false,
        "filhos": [
            "Ana",
            "Pedro"
        ],
        "endereco": null
    }
    ```

- Python :
    ```python
    {
        "nome": "João",
        "idade": 25,
        "casado": False,
        "filhos": [
            "Ana",
            "Pedro"
        ],
        "endereco": None
    }
    ```

### tipos incompatíveis

Nem todos os tipos de dados disponíveis no Python são suportados diretamente no JSON.

Abaixo está uma tabela comparativa mostrando alguns dos principais tipos de dados do Python que não têm um equivalente direto no JSON :

| Tipo de Dado Python | Suportado no JSON? | Explicação |
|---------------------|--------------------|------------|
| **`tuple`**          | Não                | Em Python, uma `tuple` é uma sequência imutável de valores. JSON não tem suporte para tipos imutáveis; o mais próximo seria um array (lista), que é mutável. |
| **`set`**            | Não                | O `set` é uma coleção não ordenada e sem valores duplicados. JSON não tem suporte para coleções não ordenadas. Se necessário, um `set` pode ser convertido em uma lista (array) antes de ser serializado em JSON. |
| **`complex`**        | Não                | O tipo `complex` em Python representa números complexos (com parte real e imaginária). JSON não tem suporte para números complexos; apenas números inteiros e de ponto flutuante são permitidos. |
| **`bytes`**          | Não                | O tipo `bytes` em Python é utilizado para representar dados binários. JSON suporta apenas strings de texto (UTF-8), e não dados binários. Para serializar dados binários, `bytes` precisam ser convertidos para uma string codificada, como Base64. |
| **`frozenset`**      | Não                | Um `frozenset` é um conjunto imutável em Python, mas como o JSON não suporta conjuntos nem mutáveis nem imutáveis, esse tipo não pode ser representado diretamente. |
| **Função (`function`)** | Não            | Funções (e outros tipos de objetos executáveis) não podem ser representados em JSON. JSON é apenas um formato de dados e não suporta lógica ou comportamento. |
| **Objeto personalizado** | Não            | Objetos de classes personalizadas em Python não são suportados diretamente no JSON. Para serem serializados, esses objetos precisam ser convertidos manualmente para dicionários (`dict`) ou outro tipo suportado. |

#### explicações

- **Tuplas** (`tuple`): Tuplas são semelhantes a listas, mas são imutáveis em Python. JSON não tem um conceito de imutabilidade, então só suportaria uma conversão para um array.

    Exemplo de conversão:
    ```python
    tuple_python = (1, 2, 3)
    list_json = [1, 2, 3]  # Após conversão para JSON
    ```

- **Conjuntos** (`set`): Como um conjunto não é ordenado e não permite duplicatas, não há equivalente em JSON. Um `set` precisa ser transformado em uma lista para ser serializado.

    Exemplo de conversão:
    ```python
    set_python = {1, 2, 3}
    list_json = [1, 2, 3]  # Após conversão para JSON
    ```

- **Números complexos** (`complex`): JSON não possui suporte para números complexos (aqueles com parte real e imaginária). Se necessário, teria que serializá-los como uma string ou objeto.

    Exemplo:
    ```python
    complex_python = 1 + 2j
    string_json = "1 + 2j"  # Após conversão para JSON como string
    ```

- **Bytes** (`bytes`): JSON só suporta strings de texto. Para serializar dados binários, é comum convertê-los em uma string codificada (por exemplo, Base64).

    Exemplo de conversão:
    ```python
    bytes_python = b'hello'
    base64_string_json = "aGVsbG8="  # Após conversão para Base64
    ```

- **Objetos personalizados**: Objetos de classes personalizadas não são serializáveis diretamente. Normalmente, você precisa definir como serializar um objeto (por exemplo, convertendo-o para um dicionário).

    Exemplo de conversão:
    ```python
    class Pessoa:
        def __init__(self, nome, idade):
            self.nome = nome
            self.idade = idade
        def para_dict(self):
            """ Método para converter a instância em um dicionário """
            return {'nome': self.nome, 'idade': self.idade}

    pessoa = Pessoa("João", 30)
    json_pessoa = pessoa.para_dict()
    print(dict_json)
    # saída : {"nome": "João", "idade": 30}
    ```

## usos do json

O JSON é amplamente utilizado para comunicação entre programas e scripts porque é um formato leve, legível e fácil de serializar e desserializar em praticamente qualquer linguagem de programação.

### comunicação entre dois scripts python via arquivo json

- **script 1**: escrevendo dados em um arquivo JSON

    Este script gera um objeto Python e o salva em um arquivo JSON para ser usado por outro script.

    ```python
    import json

    # dicionário Python
    dados = {
        "nome": "Carlos",
        "idade": 28,
        "cidade": "São Paulo",
        "habilidades": ["Python", "Java", "SQL"]
    }

    # escrevendo os dados em um arquivo JSON
    with open('dados.json', 'w') as arquivo_json:
        json.dump(dados, arquivo_json)

    print("Dados salvos no arquivo dados.json")
    ```

- **script 2** : lendo dados do arquivo JSON

    Este script lê o arquivo `dados.json` gerado pelo primeiro script e imprime as informações.

    ```python
    import json

    # lendo os dados do arquivo JSON
    with open('dados.json', 'r') as arquivo_json:
        dados = json.load(arquivo_json)

    print("Dados lidos do arquivo JSON:")
    print(dados)

    # acessando os dados individualmente
    print("Nome:", dados['nome'])
    print("Idade:", dados['idade'])
    print("Cidade:", dados['cidade'])
    print("Habilidades:", dados['habilidades'])
    ```

### comunicação entre um script python e uma api restful (via json)

Muitas APIs utilizam JSON para enviar e receber dados. Abaixo está um exemplo de um script Python que faz uma requisição POST para uma API simulada e envia dados no formato JSON.

- **exemplo** : enviando dados para uma api via json

    ```python
    import requests
    import json

    # dados a serem enviados para a API
    dados = {
        "nome": "João",
        "email": "joao@example.com",
        "senha": "senha123"
    }

    # URL da API simulada
    url = 'https://exemplo-api.com/cadastro'

    # enviando os dados para a API via POST
    response = requests.post(url, json=dados)

    # exibindo a resposta da API
    print("Status Code:", response.status_code)
    print("Resposta da API:", response.json())
    ```

### comunicação entre python e javascript (por meio de json)

Quando uma página da web utiliza JavaScript para se comunicar com o backend, o formato JSON é frequentemente utilizado para enviar e receber dados entre o frontend (JavaScript) e o backend (Python, por exemplo, usando Flask ou Django).

- backend em python (usando flask)

    ```python
    from flask import Flask, request, jsonify

    app = Flask(__name__)

    # Endpoint que recebe um JSON e responde com outro JSON
    @app.route('/dados', methods=['POST'])
    def receber_dados():
        dados_recebidos = request.json
        print("Dados recebidos:", dados_recebidos)

        # Respondendo com um JSON de confirmação
        resposta = {
            "status": "sucesso",
            "mensagem": "Dados recebidos com sucesso!",
            "dados": dados_recebidos
        }
        return jsonify(resposta)

    if __name__ == '__main__':
        app.run(debug=True)
    ```

- frontend em javascript

    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Comunicação via JSON</title>
    </head>
    <body>

    <script>
        // Dados a serem enviados para o backend
        const dados = {
            nome: "Maria",
            idade: 30,
            cidade: "Rio de Janeiro"
        };

        // Enviando os dados via POST usando Fetch API
        fetch('http://localhost:5000/dados', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(dados)
        })
        .then(response => response.json())
        .then(data => console.log("Resposta do servidor:", data))
        .catch(error => console.error("Erro:", error));
    </script>

    </body>
    </html>
    ```

### comunicação entre python e outra linguagem (ex: c#)

Você pode utilizar JSON para comunicar scripts Python com programas escritos em outras linguagens, como C#. Vamos ver como podemos usar isso em um cenário onde Python gera um arquivo JSON, e um programa em C# lê esses dados.

- Python gerando um arquivo JSON

    ```python
    import json

    # Dicionário Python
    dados = {
        "usuario": "Ana",
        "pontuacao": 4500,
        "nivel": 5
    }

    # Salvando os dados em um arquivo JSON
    with open('dados_jogo.json', 'w') as arquivo_json:
        json.dump(dados, arquivo_json)

    print("Dados do jogo salvos no arquivo dados_jogo.json")
    ```

- C# lendo o arquivo JSON gerado pelo Python

    Este programa em C# lê os dados do arquivo JSON gerado pelo script Python.

    ```csharp
    using System;
    using System.IO;
    using Newtonsoft.Json.Linq; // Instalar a biblioteca Newtonsoft.Json via NuGet

    class Program
    {
        static void Main()
        {
            // Lendo o arquivo JSON
            string json = File.ReadAllText("dados_jogo.json");

            // Convertendo para um objeto JObject
            JObject dados = JObject.Parse(json);

            // Acessando os valores no JSON
            string usuario = dados["usuario"].ToString();
            int pontuacao = int.Parse(dados["pontuacao"].ToString());
            int nivel = int.Parse(dados["nivel"].ToString());

            // Exibindo os dados lidos
            Console.WriteLine($"Usuário: {usuario}");
            Console.WriteLine($"Pontuação: {pontuacao}");
            Console.WriteLine($"Nível: {nivel}");
        }
    }
    ```

### comunicação entre dois scripts python via rede (sockets) com json

- Script 1 (Servidor) : recebendo dados em formato JSON

    ```python
    import socket
    import json

    # Configurando o servidor
    host = 'localhost'
    port = 5000

    servidor_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    servidor_socket.bind((host, port))
    servidor_socket.listen(1)

    print("Servidor aguardando conexão...")

    # Aguardando conexão
    conexao, endereco = servidor_socket.accept()
    print(f"Conectado por {endereco}")

    # Recebendo dados
    dados_recebidos = conexao.recv(1024).decode()
    json_data = json.loads(dados_recebidos)
    print("Dados recebidos:", json_data)

    # Fechando a conexão
    conexao.close()
    ```

- Script 2 (Cliente) : enviando dados em formato JSON

    ```python
    import socket
    import json

    # Configurando o cliente
    host = 'localhost'
    port = 5000

    cliente_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    cliente_socket.connect((host, port))

    # Dados a serem enviados
    dados = {
        "nome": "Alice",
        "idade": 27,
        "cidade": "Brasília"
    }

    # Convertendo para JSON e enviando
    json_data = json.dumps(dados)
    cliente_socket.send(json_data.encode())

    # Fechando a conexão
    cliente_socket.close()
    ```

## conclusão

O JSON é uma ferramenta extremamente útil para a comunicação entre diferentes programas, scripts, linguagens de programação, e até mesmo diferentes sistemas via rede ou APIs. O formato simples e flexível do JSON facilita a troca de informações e dados, tanto em cenários locais quanto distribuídos.

## exercícios

<details>
<summary>Lista de Exercícios</summary>

### dicas

- **Serializar (Python → JSON)** : Em Python, pode-se usar o método `json.dumps()` para converter objetos Python em strings JSON e `json.dump()` para gravar em arquivos JSON;

- **Desserializar (JSON → Python)** : para converter JSON em objetos Python, use `json.loads()` para strings e `json.load()` para ler de arquivos JSON;

1. Exercícios de Conversão de Objetos Python para JSON
    1. Converta um dicionário Python simples contendo as informações de um produto (nome, preço, quantidade) em JSON.
    1. Crie uma lista de frutas em Python e converta-a para JSON.
    1. Converta uma tupla de números (1, 2, 3, 4, 5) em JSON.
    1. Crie um dicionário Python com os dados de um estudante (nome, idade, notas) e salve-o em um arquivo JSON.
    1. Converta uma lista de dicionários, onde cada dicionário representa um livro (título, autor, ano), em JSON.
    1. Crie um conjunto (`set`) em Python contendo valores únicos e converta-o para JSON. Observe o comportamento e justifique a saída.
    1. Converta um dicionário aninhado que contenha os detalhes de um evento (nome do evento, data, lista de participantes) para JSON.
    1. Crie um objeto Python que contém uma chave com valor `None` e converta-o em JSON.
    1. Converta uma lista de números inteiros e números de ponto flutuante para JSON e salve-a em um arquivo.
    1. Crie um dicionário que contenha uma lista de endereços de e-mail e números de telefone, e converta-o para JSON.
    1. Converta uma lista de strings representando cores em JSON.
    1. Crie um dicionário com tipos de dados mistos (inteiro, string, booleano, lista) e converta-o para JSON.
    1. Crie um objeto Python com uma chave contendo um booleano (`True` ou `False`) e converta-o para JSON.
    1. Converta um objeto Python com um valor booleano `True` para JSON e observe como ele é representado.
    1. Crie um dicionário em Python contendo dados pessoais (nome, idade, endereço) e salve-o em um arquivo JSON.
    1. Converta um dicionário que contenha dados de um veículo (marca, modelo, ano) em uma string JSON.
    1. Crie um objeto Python com chaves que contenham listas aninhadas e converta-o para JSON.
    1. Crie uma lista de números pares de 0 a 20 em Python e converta-a para JSON.
    1. Converta um objeto Python com uma chave contendo um valor booleano `False` para JSON.
    1. Crie um objeto Python com um valor complexo, como `1 + 2j`, e converta-o para JSON, tratando o valor complexo de forma apropriada.
1. Exercícios de Conversão de JSON para Objetos Python
    1. Carregue um arquivo JSON contendo informações de um cliente (nome, idade, endereço) e converta-o em um dicionário Python.
    1. Converta uma string JSON representando uma lista de números inteiros em uma lista Python.
    1. Dada uma string JSON que representa um dicionário com pares chave-valor de um produto, converta-a em um dicionário Python.
    1. Carregue uma string JSON contendo uma lista de frutas e converta-a para uma lista Python.
    1. Converta uma string JSON contendo um dicionário aninhado que representa as notas de um aluno em um objeto Python.
    1. Leia um arquivo JSON que contém uma lista de objetos e converta cada objeto em um dicionário Python.
    1. Dada uma string JSON que representa um objeto com valores booleanos, converta-a para um dicionário Python.
    1. Carregue uma string JSON contendo uma lista de strings (nomes de cidades) e converta-a em uma lista Python.
    1. Converta uma string JSON que contém um valor booleano `true` para seu equivalente Python.
    1. Leia um arquivo JSON contendo uma lista de números de ponto flutuante e converta-o em uma lista Python.
    1. Dada uma string JSON que contém dados de um usuário (nome, idade, endereço), converta-a em um dicionário Python e acesse os valores.
    1. Carregue uma string JSON que contém um valor `null` e converta-o em seu equivalente Python (`None`).
    1. Converta uma string JSON que representa um array (lista) de números pares em uma lista Python.
    1. Dada uma string JSON que contém um dicionário com informações de um filme (título, diretor, ano), converta-a em um dicionário Python.
    1. Carregue uma string JSON que contém um dicionário com uma lista de hobbies e converta-a para um dicionário Python.
    1. Dada uma string JSON que contém uma lista de dicionários com dados de várias pessoas (nome, idade), converta-a em uma lista de dicionários Python.
    1. Converta uma string JSON que contém um dicionário com dados de um evento (nome, data, local) em um dicionário Python.
    1. Carregue uma string JSON que contém uma lista aninhada e converta-a em uma lista Python.
    1. Converta uma string JSON que contém um objeto com múltiplos tipos de dados (string, inteiro, booleano) em um dicionário Python.
    1. Leia um arquivo JSON que contém uma estrutura de dados complexa (listas aninhadas, dicionários) e converta-o em um objeto Python.

</details>


# livros.md

# Livros

Abaixo há diversos links de livros que podem ser usados para consultar.

* [Python 4 Everybody](https://www.py4e.com/book) (en-us / pt-br)
* [Python Notes for Professionals](https://books.goalkicker.com/PythonBook) (en-us)
* [Think Python](https://greenteapress.com/wp/think-python-3rd-edition) (en-us)
* [Learning Python Language eBook](https://riptutorial.com/ebook/python) (en-us)
* [Learn Python, Break Python](https://learnpythonbreakpython.com) (en-us)
* [Learn Python the Hard Way](https://learnpythonthehardway.org/python3) (en-us)


## Outros
Abaixo, há links relacionados a outros tópicos que também são interessantes.

* Git :
    * [Git Notes for Professionals](https://books.goalkicker.com/GitBook) (en-us)
* VS Code
    * [Boost Your Coding Fu](https://www.barbarianmeetscoding.com/boost-your-coding-fu-with-vscode-and-vim/dedication) (en-us)


# modulos.md

# índice

1. [módulo `sys`](#módulo-sys)
    - [exercícios módulo `sys`](#exercícios-módulo-sys)
1. [módulo `os`](#módulo-os)
    - [exercícios módulo `os`](#exercícios-módulo-os)
1. [módulo `random`](#módulo-random)
    - [exercícios módulo `random`](#exercícios-módulo-random)
1. [módulo `time`](#módulo-time)
    - [exercícios módulo `time`](#exercícios-módulo-time)
1. [módulo `string`](#módulo-string)
    - [exercícios módulo `string`](#exercícios-módulo-string)
1. [módulo `math`](#módulo-math)
    - [exercícios módulo `math`](#exercícios-módulo-math)
1. [módulo `json`](#módulo-json)
    - [exercícios módulo `json`](#exercícios-módulo-json)
1. [variável `__name__`](#variável-__name__)
    1. [exercícios `__name__`](#exercícios-name)
1. [`wildcards`](#wildcards)
    1. [exercícios wildcards](#exercícios-wildcards)
1. [`datetime`](#datetime)
    1. [exercícios `datetime`](#exercícios-datetime)

# módulos

## módulo `sys`

O módulo `sys` em Python é um dos módulos built-in que fornecem funções e variáveis usadas para manipular diferentes partes do ambiente de execução do Python. Esse módulo é essencial para interagir com o sistema e o interpretador do Python.

1. [`sys.argv`](#sysargv)
1. [`sys.exit`](#sysexit)
1. [`sys.path`](#syspath)
1. [`sys.stdin` `sys.stdout` `sys.stderr`](#sysstdin-sysstdout-sysstderr)
1. [`sys.platform`](#sysplatform)
1. [`sys.getsizeof`](#sysgetsizeof)
1. [`sys.version` e `sys.version_info`](#sysversion-e-sysversion_info)
1. [índice](#índice)

### `sys.argv`

O atributo `sys.argv` é uma lista que armazena os argumentos passados ao script via linha de comando. O primeiro item da lista (`sys.argv[0]`) é sempre o nome do script. Os outros elementos são os argumentos que o usuário passou ao rodar o script.

**exemplo** :
Considere um script chamado `script.py` que é executado com alguns argumentos.

```python
# script.py
import sys

# imprime o nome do script
print("Nome do script :", sys.argv[0])

# verifica se foram passados argumentos
if len(sys.argv) > 1:
    # imprime os argumentos
    print("Argumentos :", sys.argv[1:])
else:
    print("Nenhum argumento foi passado.")
```

Se rodar o script com o comando :

```bash
python script.py argumento1 argumento2
```

A saída será :

```
Nome do script : script.py
Argumentos : ['argumento1', 'argumento2']
```

### `sys.exit()`

O `sys.exit()` é usado para encerrar o programa. Ele pode aceitar um argumento opcional para especificar o código de saída. Se for um número inteiro, o sistema usará esse número como código de status. O valor `0` geralmente indica que o programa foi finalizado com sucesso, e qualquer valor diferente de zero indica que ocorreu um erro.

**exemplo** :

```python
# script.py
import sys

def verificar_entrada():
    if len(sys.argv) < 2:
        print("Erro: Nenhum argumento foi passado!")
        sys.exit(1)  # Código de saída 1 indica erro
    else:
        print(f"Argumento fornecido: {sys.argv[1]}")

verificar_entrada()
```

Se rodarmos o script sem argumentos:

```bash
python script.py
```

A saída será:

```
Erro: Nenhum argumento foi passado!
```

E o código de saída será `1`, indicando que houve um erro.

### `sys.path`

O `sys.path` é uma lista de strings que especifica os diretórios onde o Python procura módulos quando se usa a instrução `import`. O Python verifica cada diretório dessa lista ao tentar localizar o módulo que você está importando.

**exemplo** :

```python
# script.py
import sys

# imprime o caminho de busca dos módulos
print("Caminhos de busca:")
for caminho in sys.path:
    print(caminho)
```

Se quiser adicionar um diretório específico para que o Python busque módulos nele, pode fazer o seguinte :

```python
import sys

# adiciona um novo caminho de busca
sys.path.append('/meu/diretorio/de/modulos')

# agora o python também buscará nesse caminho
print("Novo caminho de busca adicionado.")
```

Isso pode ser útil quando se tem módulos personalizados em diretórios fora do padrão.

### `sys.stdin`, `sys.stdout`, `sys.stderr`

Esses três atributos representam a entrada padrão (`sys.stdin`), a saída padrão (`sys.stdout`) e a saída de erro padrão (`sys.stderr`) do sistema.

- `sys.stdin` : usado para ler dados de entrada;
- `sys.stdout` : usado para exibir saídas normais;
- `sys.stderr` : usado para exibir mensagens de erro;

Por padrão, `sys.stdout` e `sys.stderr` são o console, e `sys.stdin` é o teclado, mas é possível redirecioná-los.

**exemplo** 1 : redirecionando a saída para um arquivo

```python
# script.py
import sys

# redireciona a saída padrão para um arquivo
with open("saida.txt", "w") as f:
    sys.stdout = f
    print("Essa mensagem será gravada no arquivo, não no console.")
```

Aqui, ao executar o script, a mensagem será escrita no arquivo `saida.txt`, em vez de aparecer no console. Posteriormente será visto como manipular arquivos.

**exemplo** 2 : usando `sys.stdin` para ler da entrada padrão

```python
# script.py
import sys

print("Digite algo:")
entrada = sys.stdin.read(5)  # Lê até 5 caracteres da entrada
print("Você digitou:", entrada)
```

Esse código permite que o usuário digite algo, e o Python lê até 5 caracteres.

### `sys.platform`

O `sys.platform` retorna uma string que identifica o sistema operacional em que o Python está sendo executado. Isso pode ser útil para garantir que o código seja executado corretamente em diferentes sistemas operacionais.

**exemplo** :

```python
# script.py
import sys

print(f"Este código está rodando no sistema: {sys.platform}")

if sys.platform.startswith("win"):
    print("O sistema é Windows.")
elif sys.platform.startswith("linux"):
    print("O sistema é Linux.")
elif sys.platform == "darwin":
    print("O sistema é macOS.")
```

### `sys.getsizeof()`

O `sys.getsizeof()` retorna o tamanho em bytes de um objeto em Python. Isso pode ser útil para verificar o consumo de memória de diferentes estruturas de dados.

**exemplo** :

```python
# script.py
import sys

lista = [1, 2, 3, 4, 5]
dicionario = {1: 'a', 2: 'b', 3: 'c'}

print(f"Tamanho da lista : {sys.getsizeof(lista)} bytes")
print(f"Tamanho do dicionário : {sys.getsizeof(dicionario)} bytes")
```

### `sys.version` e `sys.version_info`

- `sys.version` retorna a versão completa do Python como uma string;
- `sys.version_info` retorna a versão como uma tupla, o que é útil para verificações de compatibilidade;

**exemplo** :

```python
# script.py
import sys

print("Versão do Python (string):", sys.version)
print("Versão do Python (tupla):", sys.version_info)

# Verifica se está rodando no Python 3.x
if sys.version_info[0] == 3:
    print("Este script está sendo executado no Python 3.")
```

## exercícios módulo `sys`

<details>
<summary>Lista de Exercícios</summary>

1. Obtenha o caminho completo do Python instalado no sistema. Utilize `sys.executable` para imprimir o caminho.
1. Mostre a versão do Python que está sendo usada. Utilize `sys.version` para exibir a versão completa do Python.
1. Liste todos os diretórios em que o Python procura por módulos. Use `sys.path` para exibir os diretórios de busca.
1. Adicione um novo caminho ao `sys.path`. Adicione um diretório fictício à lista de caminhos de busca por módulos.
1. Faça com que o programa saia com um código de erro 1. Utilize `sys.exit(1)` para sair com o código de erro 1.
1. Implemente um programa que peça para o usuário inserir um número e saia se o número for negativo. Utilize `sys.exit()` para terminar o programa se a condição for satisfeita.
1. Mostre o tamanho da referência de um objeto. Utilize `sys.getsizeof()` para imprimir o tamanho de diferentes tipos de objetos (por exemplo, `int`, `str`, `list`).
1. Obtenha o nome da plataforma que o Python está executando. Use `sys.platform` para mostrar o nome da plataforma.
1. Escreva um programa que leia argumentos da linha de comando e os imprima. Utilize `sys.argv` para capturar e exibir argumentos passados via linha de comando.
1. Calcule a soma de dois números passados como argumentos da linha de comando. Use `sys.argv` para capturar dois números e calcule a soma deles.
1. Verifique quantos argumentos foram passados ao programa via linha de comando. Utilize `len(sys.argv)` para contar os argumentos passados.
1. Limite o recursão máxima do Python para 100 chamadas. Utilize `sys.setrecursionlimit(100)` e faça um programa para verificar o novo limite.
1. Imprima o limite máximo de recursão atual do Python. Utilize `sys.getrecursionlimit()` para exibir o limite.
1. Implemente uma função recursiva para calcular o fatorial e teste os limites de recursão. Use `sys.getrecursionlimit()` e ajuste o limite para testar diferentes profundidades de recursão.
1. Verifique se o sistema tem suporte para Unicode. Utilize `sys.maxunicode` para verificar a maior representação de Unicode disponível no sistema.
1. Calcule e mostre o número máximo de objetos que podem ser armazenados em uma variável. Utilize `sys.maxsize` para exibir o maior número que o Python consegue manipular.
1. Escreva um programa que imprima a saída de um número grande e identifique como ele é representado no sistema. Utilize `sys.float_info` para exibir os detalhes de representação de números em ponto flutuante.
1. Crie um programa que exiba o nome do arquivo atualmente sendo executado. Utilize `sys.argv[0]` para exibir o nome do script Python em execução.
1. Exiba o tamanho máximo de um número inteiro suportado pelo sistema. Utilize `sys.maxsize` para mostrar o maior número de inteiro que o Python suporta.
1. Capture e exiba o status final do interpretador Python antes da saída. Use `sys.flags` para exibir os diferentes sinais e flags que controlam o comportamento do interpretador.

</details>

## módulo `os`

O módulo `os` do Python fornece várias funcionalidades para interagir com o sistema operacional de maneira independente da plataforma. Isso significa que ele funciona tanto no Windows, quanto no Linux ou macOS, facilitando operações como manipulação de arquivos, diretórios, variáveis de ambiente, e muito mais.

1. [`os.name`](#osname)
1. [`os.getenv()` e `os.environ`](#osgetenv-e-osenviron)
1. [`os.getcwd()` e `os.chdir`](#osgetcwd-e-oschdir)
1. [`os.listdir()`](#oslistdir)
1. [`os.mkdir()` e `os.makedirs()`](#osmodir-e-osmakedirs)
1. [`os.remove()` e `os.rmdir()`](#osremove-e-osrmdir)
1. [`os.rename()`](#osrename)
1. [`os.path`](#ospath)
1. [`os.system()`](#ossystem)
1. [`os.popen()`](#ospopen)
1. [índice](#índice)

### `os.name`

O `os.name` retorna uma string que indica o nome do sistema operacional no qual o código está sendo executado. Dependendo do sistema, a string pode ser:
- `'posix'` para sistemas como Linux e macOS;
- `'nt'` para sistemas Windows;

**exemplo** :

```python
# main.py
import os

print(f"Sistema operacional: {os.name}")

if os.name == 'nt':
    print("Este código está sendo executado no Windows.")
else:
    print("Este código está sendo executado em um sistema tipo Unix (Linux ou macOS).")
```

### `os.getenv()` e `os.environ`

O `os.getenv()` permite acessar variáveis de ambiente, enquanto `os.environ` é um dicionário que contém todas as variáveis de ambiente do sistema.

**exemplo** 1 : acessando uma variável de ambiente

```python
# main.py
import os

# acessa a variável de ambiente path
path = os.getenv('PATH')
print(f"Variável PATH: {path}")
```

**exemplo** 2 : listando todas as variáveis de ambiente

```python
# main.py
import os

# imprime todas as variáveis de ambiente
for chave, valor in os.environ.items():
    print(f"{chave}: {valor}")
```

**exemplo** 3: definindo uma variável de ambiente temporária

```python
# main.py
import os

# Define uma variável de ambiente temporária
os.environ['MINHA_VARIAVEL'] = 'valor_exemplo'

# Verifica se foi definida
print(f"MINHA_VARIAVEL: {os.getenv('MINHA_VARIAVEL')}")
```

### `os.getcwd()` e `os.chdir()`

O `os.getcwd()` retorna o diretório de trabalho atual (onde o script está sendo executado), e `os.chdir()` altera o diretório de trabalho para outro especificado.

**exemplo** 1 : obtendo o diretório atual

```python
# main.py
import os

# obtém o diretório de trabalho atual
diretorio_atual = os.getcwd()
print(f"Diretório atual: {diretorio_atual}")
```

**exemplo** 2 : mudando o diretório atual

```python
# main.py
import os

# muda o diretório de trabalho para "/home/user" (ou outro caminho válido no seu sistema)
os.chdir("/home/user")

# Verifica o diretório atual após a mudança
print(f"Novo diretório atual: {os.getcwd()}")
```

### `os.listdir()`

O `os.listdir()` retorna uma lista de todos os arquivos e diretórios em um determinado caminho.

**exemplo** :

```python
# main.py
import os

# Lista todos os arquivos e diretórios no diretório atual
arquivos = os.listdir()
print("Arquivos e diretórios no diretório atual:")
for arquivo in arquivos:
    print(arquivo)
```

Também é possível passar um caminho específico :

```python
# main.py
import os

# lista arquivos em um diretório específico
arquivos = os.listdir("/home/user")
print("Arquivos no diretório /home/user:")
for arquivo in arquivos:
    print(arquivo)
```

### `os.mkdir()` e `os.makedirs()`

- `os.mkdir()` cria um único diretório;
- `os.makedirs()` cria um diretório, incluindo todos os diretórios intermediários, se necessário;

**exemplo** 1 : criando um único diretório

```python
# main.py
import os

# cria um diretório chamado "novo_diretorio" no diretório atual
os.mkdir("novo_diretorio")
print("Diretório 'novo_diretorio' criado.")
```

**exemplo** 2 : criando diretórios intermediários

```python
# main.py
import os

# cria o diretório "dir1/dir2/dir3", incluindo todos os diretórios intermediários
os.makedirs("dir1/dir2/dir3")
print("Diretórios 'dir1/dir2/dir3' criados.")
```

### `os.remove()` e `os.rmdir()`

- `os.remove()` exclui um arquivo;
- `os.rmdir()` exclui um diretório vazio;

**exemplo** 1 : excluindo um arquivo

```python
# main.py
import os

# remove um arquivo chamado "arquivo.txt"
os.remove("arquivo.txt")
print("Arquivo 'arquivo.txt' removido.")
```

**exemplo** 2 : excluindo um diretório vazio

```python
# main.py
import os

# remove um diretório vazio chamado "meu_diretorio"
os.rmdir("meu_diretorio")
print("Diretório 'meu_diretorio' removido.")
```

### `os.rename()`

O `os.rename()` renomeia um arquivo ou diretório.

**exemplo** :

```python
# main.py
import os

# renomeia o arquivo "arquivo_velho.txt" para "arquivo_novo.txt"
os.rename("arquivo_velho.txt", "arquivo_novo.txt")
print("Arquivo renomeado para 'arquivo_novo.txt'.")
```

### `os.path`

O módulo `os` também contém o submódulo `os.path`, que oferece várias funções para manipulação de caminhos de arquivos.

**exemplo** 1 : verificando se um arquivo ou diretório existe

```python
# main.py
import os

# Verifica se o arquivo "meu_arquivo.txt" existe
if os.path.exists("meu_arquivo.txt"):
    print("O arquivo 'meu_arquivo.txt' existe.")
else:
    print("O arquivo 'meu_arquivo.txt' não existe.")
```

**exemplo** 2 : verificando se é um arquivo ou um diretório

```python
# main.py
import os

caminho = "meu_arquivo.txt"

if os.path.isfile(caminho):
    print(f"{caminho} é um arquivo.")
elif os.path.isdir(caminho):
    print(f"{caminho} é um diretório.")
else:
    print(f"{caminho} não é um arquivo nem um diretório.")
```

**exemplo** 3 : unindo partes de um caminho

```python
# main.py
import os

# junta diferentes partes de um caminho
caminho_completo = os.path.join("/home/user", "documentos", "arquivo.txt")
print(f"Caminho completo: {caminho_completo}")
```

### `os.system()`

O `os.system()` executa comandos diretamente no sistema operacional, como se fosse executado no terminal.

**exemplo** :

```python
# main.py
import os

# Executa o comando 'ls' no Linux/macOS ou 'dir' no Windows
os.system("ls")  # Use "dir" no Windows
```

Esse comando executa a listagem de arquivos no diretório atual (o comando específico varia conforme o sistema operacional).

### `os.popen()`

Enquanto `os.system()` executa um comando sem capturar a saída, `os.popen()` permite capturar a saída do comando.

**exemplo** :

```python
# main.py
import os

# executa o comando 'ls' e captura sua saída
comando = os.popen("ls")  # Use "dir" no Windows
saida = comando.read()

# exibe a saída capturada
print("Saída do comando:")
print(saida)
```

## exerícios módulo `os`

<details>
<summary>Lista de Exercícios</summary>

1. Liste todos os arquivos e diretórios do diretório atual. Utilize `os.listdir()` para listar o conteúdo do diretório atual.
1. Crie um novo diretório chamado `novo_diretorio` no diretório atual. Use `os.mkdir()` para criar o diretório.
1. Altere o diretório de trabalho atual para o diretório `novo_diretorio`. Utilize `os.chdir()` para alterar o diretório de trabalho.
1. Mostre o caminho completo do diretório de trabalho atual. Use `os.getcwd()` para obter o diretório atual.
1. Remova o diretório `novo_diretorio`. Utilize `os.rmdir()` para remover o diretório criado.
1. Crie um diretório aninhado chamado `pasta1/pasta2/pasta3`. Use `os.makedirs()` para criar a estrutura de diretórios.
1. Remova os diretórios aninhados `pasta1/pasta2/pasta3`. Utilize `os.removedirs()` para remover a árvore de diretórios.
1. Renomeie um arquivo ou diretório. Crie um arquivo ou diretório e renomeie-o usando `os.rename()`.
1. Obtenha informações sobre um arquivo, como seu tamanho e data de modificação. Utilize `os.stat()` para exibir informações detalhadas de um arquivo.
1. Verifique se um arquivo ou diretório existe. Use `os.path.exists()` para verificar se um arquivo ou diretório existe.
1. Verifique se o caminho é um diretório. Utilize `os.path.isdir()` para verificar se o caminho fornecido é um diretório.
1. Verifique se o caminho é um arquivo. Use `os.path.isfile()` para verificar se o caminho fornecido é um arquivo.
1. Obtenha o nome do diretório de um caminho fornecido. Utilize `os.path.dirname()` para extrair o diretório de um caminho.
1. Obtenha o nome do arquivo de um caminho fornecido. Use `os.path.basename()` para extrair o nome do arquivo de um caminho.
1. Separe a extensão do nome de um arquivo. Utilize `os.path.splitext()` para separar o nome e a extensão de um arquivo.
1. Junte dois caminhos de forma adequada ao sistema operacional. Use `os.path.join()` para combinar dois caminhos.
1. Obtenha o caminho absoluto de um arquivo. Utilize `os.path.abspath()` para converter um caminho relativo em absoluto.
1. Descubra o tamanho de um arquivo em bytes. Use `os.path.getsize()` para obter o tamanho de um arquivo.
1. Obtenha o nome de usuário que está executando o programa. Utilize `os.getlogin()` para exibir o nome do usuário atual.
1. Obtenha o ID do processo atual. Use `os.getpid()` para obter o ID do processo em execução.
1. Obtenha o ID do processo pai. Utilize `os.getppid()` para obter o ID do processo pai.
1. Defina uma nova variável de ambiente e exiba seu valor. Use `os.environ` para definir uma nova variável de ambiente e depois acesse seu valor.
1. Exiba todas as variáveis de ambiente do sistema. Utilize `os.environ` para listar todas as variáveis de ambiente.
1. Remova uma variável de ambiente do sistema. Use `os.environ.pop()` para remover uma variável de ambiente.
1. Execute um comando do sistema operacional usando Python. Utilize `os.system()` para executar um comando, como listar arquivos (`ls` ou `dir`).
1. Obtenha o caminho do diretório inicial do usuário. Use `os.path.expanduser('~')` para obter o diretório inicial do usuário.
1. Obtenha o separador de diretórios do sistema operacional atual. Utilize `os.sep` para exibir o separador de diretórios (`/` no Linux/Mac, `\` no Windows).
1. Obtenha o caminho do dispositivo null do sistema operacional. Use `os.devnull` para obter o caminho para o dispositivo null (`/dev/null` no Unix, `NUL` no Windows).
1. Suspenda a execução do programa por 5 segundos. Utilize `os.sleep(5)` para pausar a execução por 5 segundos.
1. Obtenha uma lista de todos os drives disponíveis no sistema (apenas Windows). Use `os.listdir()` com as letras dos drives e filtre os que estão disponíveis no sistema (Windows).

</details>

## módulo `random`

O módulo `random` do Python é utilizado para gerar números aleatórios e realizar operações aleatórias, como escolher itens de uma lista, embaralhar elementos e gerar números em diferentes intervalos. Ele é amplamente utilizado em várias aplicações, como simulações, jogos, amostragem e mais.

1. [`random.random()`](#randomrandom)
1. [`random.uniform()`](#randomuniform)
1. [`random.randint()`](#randomrandint)
1. [`random.randrange()`](#randomrandrange)
1. [`random.choice()`](#randomchoice)
1. [`random.choices()`](#randomchoices)
1. [`random.sample()`](#randomsample)
1. [`random.shuffle()`](#randomshuffle)
1. [`random.seed()`](#randomseed)
1. [`random.gauss()`](#randomgauss)
1. [`random.betavariate()`](#randombetavariate)
1. [índice](#índice)

### `random.random()`

A função `random()` gera um número de ponto flutuante (decimal) entre 0.0 e 1.0, incluindo 0, mas excluindo 1.

**exemplo** :

```python
# main.py
import random

numero = random.random()
print(f"Número aleatório entre 0 e 1: {numero}")
```

Saída típica :
```
Número aleatório entre 0 e 1: 0.573019845657438
```

### `random.uniform()`

A função `uniform(a, b)` gera um número de ponto flutuante entre os valores `a` e `b`, incluindo ambos os limites.

**exemplo** :

```python
# main.py
import random

numero = random.uniform(10, 20)
print(f"Número aleatório entre 10 e 20: {numero}")
```

Saída típica :
```
Número aleatório entre 10 e 20: 15.678921305495
```

### `random.randint()`

A função `randint(a, b)` gera um número inteiro aleatório entre `a` e `b`, incluindo ambos os limites.

**exemplo** :

```python
# main.py
import random

numero = random.randint(1, 6)
print(f"Número inteiro aleatório entre 1 e 6: {numero}")
```

Saída típica :
```
Número inteiro aleatório entre 1 e 6: 4
```

### `random.randrange()`

A função `randrange(start, stop, step)` gera um número inteiro aleatório no intervalo de `start` até `stop - 1`, com um incremento de `step`.

**exemplo** :

```python
# main.py
import random

numero = random.randrange(0, 10, 2)
print(f"Número aleatório par entre 0 e 10: {numero}")
```

Saída típica :
```
Número aleatório par entre 0 e 10: 4
```

Aqui, o valor gerado será um número par entre 0 e 8 (pois o `stop` é 10, mas o intervalo é até 9, e os números são gerados de 2 em 2).

### `random.choice()`

A função `choice(seq)` escolhe aleatoriamente um item de uma sequência, como uma lista, tupla ou string.

**exemplo** :

```python
# main.py
import random

opcoes = ['pedra', 'papel', 'tesoura']
escolha = random.choice(opcoes)
print(f"Escolha aleatória: {escolha}")
```

Saída típica :
```
Escolha aleatória: papel
```

### `random.choices()`

A função `choices(population, k)` retorna uma lista com `k` elementos escolhidos aleatoriamente de uma população, permitindo repetições.

**exemplo** :

```python
# main.py
import random

cores = ['vermelho', 'verde', 'azul', 'amarelo']
escolhas = random.choices(cores, k=3)
print(f"Escolhas aleatórias: {escolhas}")
```

Saída típica :
```
Escolhas aleatórias: ['azul', 'verde', 'azul']
```

### `random.sample()`

A função `sample(population, k)` retorna uma lista com `k` elementos escolhidos aleatoriamente de uma população, sem repetições.

**exemplo** :

```python
# main.py
import random

numeros = list(range(1, 50))
sorteados = random.sample(numeros, k=6)
print(f"Números sorteados: {sorteados}")
```

Saída típica :
```
Números sorteados: [12, 8, 42, 33, 19, 7]
```

### `random.shuffle()`

A função `shuffle(seq)` embaralha os itens de uma lista in-place, ou seja, a própria lista é modificada.

**exemplo** :

```python
import random

cartas = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']
random.shuffle(cartas)
print(f"Cartas embaralhadas: {cartas}")
```

Saída típica:
```
Cartas embaralhadas: ['7', '2', 'J', '4', '8', '3', 'A', 'K', '9', '10', '6', '5', 'Q']
```

### `random.seed()`

O comportamento da aleatoriedade no Python pode ser controlado usando `seed()`. Isso é útil quando você deseja que uma sequência de números aleatórios seja reprodutível.

**exemplo** :

```python
# main.py
import random

random.seed(10)
print(random.random())  # Sempre produzirá o mesmo resultado se seed(10) for usado.
print(random.random())  # Os mesmos números serão gerados sempre que seed(10) for usado.
```

Saída (sempre a mesma com `seed(10)`) :
```
0.5714025946899135
0.4288890546751146
```

### `random.gauss()`

A função `gauss(mu, sigma)` gera números aleatórios seguindo uma distribuição normal (ou gaussiana). O parâmetro `mu` é a média da distribuição, e `sigma` é o desvio padrão.

**exemplo** :

```python
# main.py
import random

media = 0
desvio_padrao = 1

for _ in range(5):
    print(random.gauss(media, desvio_padrao))
```

Saída típica :
```
-0.3653743596198731
1.0199221852790466
0.1918015869367224
-0.9074770176164197
-0.19738118153188115
```

### `random.betavariate()`

A função `betavariate(alpha, beta)` gera números seguindo uma distribuição beta, onde `alpha` e `beta` são parâmetros da distribuição.

**exemplo** :

```python
# main.py
import random

alpha = 2.0
beta = 5.0

for _ in range(5):
    print(random.betavariate(alpha, beta))
```

Saída típica :
```
0.2944020013389468
0.4153640288354197
0.28646777115539996
0.292441360879948
0.21664462489450598
```

## exercícios módulo `random`

<details>
<summary>Lista de Exercícios</summary>

1. Gere um número aleatório inteiro entre 1 e 10. Use `random.randint(1, 10)`.
1. Gere um número de ponto flutuante aleatório entre 0 e 1. Utilize `random.random()`.
1. Escolha aleatoriamente um elemento de uma lista. Use `random.choice()` com uma lista como argumento.
1. Escolha aleatoriamente 3 elementos diferentes de uma lista de 10 itens. Utilize `random.sample()` para selecionar 3 elementos.
1. Embaralhe aleatoriamente os elementos de uma lista. Use `random.shuffle()` para embaralhar os itens da lista.
1. Gere um número de ponto flutuante entre 5 e 10. Utilize `random.uniform(5, 10)`.
1. Gere um número aleatório de ponto flutuante com distribuição normal (gaussiana) com média 0 e desvio padrão 1. Use `random.gauss(0, 1)`.
1. Simule o lançamento de um dado de 6 lados 100 vezes e conte quantas vezes cada número apareceu. Use `random.randint()` e armazene os resultados em um dicionário ou lista.
1. Gere uma sequência aleatória de 5 números inteiros entre 1 e 50, sem repetição. Utilize `random.sample(range(1, 51), 5)`.
1. Gere uma senha aleatória de 8 caracteres usando letras e números. Use `random.choices()` com letras e números como entrada.
1. Escolha aleatoriamente um nome de uma lista de alunos. Utilize `random.choice()`.
1. Simule uma moeda sendo lançada 100 vezes e conte quantas vezes deu cara e quantas vezes deu coroa. Use `random.choice(['cara', 'coroa'])` em um loop.
1. Gere uma sequência aleatória de 6 números entre 1 e 60 (como uma simulação de loteria). Utilize `random.sample()` para gerar a sequência.
1. Gere um número aleatório entre 1 e 100 que seja múltiplo de 5. Use `random.choice(range(5, 101, 5))`.
1. Simule um jogo de roleta onde os números variam de 0 a 36. Utilize `random.randint(0, 36)` para simular a roleta.
1. Gere uma cor hexadecimal aleatória. Use `random.choice()` para selecionar valores de `0-9` e `A-F` e formar uma cor hexadecimal.
1. Crie uma lista de 10 números aleatórios e ordene-os em ordem crescente. Utilize `random.randint()` para gerar a lista e `sorted()` para ordená-la.
1. Implemente uma função que retorna um número aleatório par entre 1 e 100. Use `random.choice(range(2, 101, 2))`.
1. Simule o lançamento de dois dados e calcule a soma dos dois resultados. Utilize `random.randint(1, 6)` duas vezes e some os resultados.
1. Embaralhe uma lista de cartas (A, 2, 3, ..., K) e distribua 5 cartas. Use `random.shuffle()` e depois extraia os primeiros 5 elementos.
1. Simule o sorteio de uma rifa em que há 100 números e 5 são sorteados. Utilize `random.sample(range(1, 101), 5)`.
1. Gere uma lista de 10 números aleatórios entre 1 e 20, sem repetição, e verifique se há números repetidos. Use `random.sample()` e depois verifique duplicatas (não devem existir).
1. Gere uma sequência de 20 números aleatórios de ponto flutuante entre 0 e 1 e calcule a média. Use `random.random()` em um loop e calcule a média.
1. Implemente uma função que retorne um caractere aleatório de uma string. Utilize `random.choice()` para selecionar um caractere de uma string fornecida.
1. Crie um sistema simples de sorteio de prêmios, onde uma lista de prêmios é dada e um prêmio é escolhido aleatoriamente. Use `random.choice()` para selecionar o prêmio.
1. Simule a seleção de 3 alunos para um trabalho em grupo de uma turma de 20 alunos. Utilize `random.sample()` para selecionar 3 alunos de uma lista de 20.
1. Implemente uma função que simule o lançamento de 5 dados e retorne a soma dos valores. Utilize `random.randint()` em um loop para somar os resultados.
1. Crie um programa que simule uma senha de 4 dígitos numéricos. Use `random.choices(string.digits, k=4)` para gerar a senha.
1. Gere uma sequência aleatória de 8 caracteres composta de letras maiúsculas e minúsculas. Utilize `random.choices(string.ascii_letters, k=8)`.
1. Simule a geração de números de uma loteria onde 6 números são sorteados entre 1 e 49. Use `random.sample(range(1, 50), 6)`.
1. Implemente uma função que retorna um número aleatório ímpar entre 1 e 50. Use `random.choice(range(1, 51, 2))`.
1. Crie um programa que simule o embaralhamento de um baralho de cartas (semelhante ao exercício 20). Utilize `random.shuffle()` para embaralhar as cartas.
1. Gere uma lista de 10 números aleatórios entre 1 e 100 e encontre o maior valor. Use `random.randint()` para gerar a lista e `max()` para encontrar o maior valor.
1. Simule um jogo de dados em que 5 dados são lançados e o jogador ganha se a soma for maior que 18. Use `random.randint(1, 6)` em um loop e calcule a soma.
1. Crie uma função que simule uma rodada de "pedra, papel e tesoura" entre dois jogadores. Utilize `random.choice(['pedra', 'papel', 'tesoura'])` para cada jogador.
1. Simule a escolha de um elemento de uma lista ponderada, onde alguns elementos têm mais chances de serem escolhidos. Use `random.choices()` com pesos fornecidos.
1. Implemente uma função que retorne uma lista de 5 números aleatórios inteiros entre 10 e 100. Utilize `random.randint(10, 100)` em um loop ou `random.sample()`.
1. Implemente um jogo simples de adivinhação onde o programa gera um número entre 1 e 20 e o usuário tem que adivinhar. Utilize `random.randint(1, 20)` para gerar o número e peça ao usuário para adivinhar.
1. Gere uma lista de 5 números de ponto flutuante entre 0 e 10 e calcule o valor mínimo. Utilize `random.uniform(0, 10)` e `min()` para encontrar o menor valor.
1. Implemente um jogo de "cara ou coroa" onde o usuário pode jogar quantas vezes quiser. Use `random.choice(['cara', 'coroa'])`.
1. Crie uma função que gere uma lista de 5 números aleatórios entre 0 e 1 e retorne o maior valor. Utilize `random.random()` em um loop e `max()` para o maior valor.
1. Simule a distribuição de cartas em um jogo de pôquer para 4 jogadores. Use `random.sample()` para distribuir as cartas de um baralho.
1. Crie uma função que retorne uma letra aleatória (maiúscula ou minúscula). Use `random.choice(string.ascii_letters)`.
1. Simule o lançamento de uma moeda 1000 vezes e conte quantas vezes deu "cara". Use `random.choice()` em um loop.
1. Gere uma sequência aleatória de 20 números inteiros entre 0 e 100 e calcule a média. Utilize `random.randint(0, 100)` e `sum()` para calcular a média.

</details>

## módulo `time`

O módulo `time` do Python oferece várias funções para trabalhar com tempo, como a manipulação de horas, minutos, segundos, e funções para medir o tempo que uma ação leva para ser concluída. Ele é muito utilizado para calcular a duração de eventos, fazer pausas (delays) no código, além de obter e manipular o tempo no formato de segundos desde a *"época"* (epoch), que geralmente é 1º de janeiro de 1970 no sistema UNIX.

1. [`time.time()`](#timetime)
1. [`time.sleep()`](#timesleep)
1. [`time.localtime()`](#timelocaltime)
1. [`time.strftime()`](#timestrftime)
1. [`time.gmtime([])`](#timegmtime)
1. [`time.mktime(t)`](#timemktimet)
1. [`time.asctime([struct_time])`](#timeasctimestruct_time)
1. [`time.ctime([])`](#timectime)
1. [`time.perf_counter()`](#timeperf_counter)
1. [`time.monotonic()`](#timemonotonic)
1. [`time.process_time()`](#timeprocess_time)
1. [exemplos práticos do módulo `time`](#exemplos-práticos-do-módulo-time)
1. [índice](#índice)

### `time.time()`

Essa função retorna o número de segundos desde a *"época"*, ou seja, um número do tipo *float* que representa o tempo em segundos.  A *"época"* (epoch) é o ponto de referência para a contagem do tempo. No Unix, a *epoch* é definida como meia-noite (00:00:00) de 1 de janeiro de 1970.

**exemplo :**
```python
import time
segundos = time.time()
print(f"Segundos desde 1º de janeiro de 1970: {segundos}")
```

### `time.sleep(segundos)`

A função `sleep(seconds)` faz com que o programa pause ou "durma" por um determinado número de segundos. É útil em casos onde se deseja que o código aguarde um certo tempo antes de prosseguir.

**exemplo :**
```python
import time
print("Esperando 5 segundos...")
time.sleep(5)
print("Fim da espera.")
```

### `time.localtime()`

A função `localtime([seconds])` converte o tempo dado em segundos desde a *epoch* em um objeto de tempo local (`struct_time`). Se nenhum argumento for fornecido, ela utiliza o tempo atual (retornado por `time.time()`). O objeto `struct_time` tem vários atributos como `tm_year` (ano), `tm_mon` (mês), `tm_mday` (dia do mês), `tm_hour` (hora), etc.

**exemplo :**
```python
import time
tempo_atual = time.localtime()
print(f"Ano atual: {tempo_atual.tm_year}")
print(f"Mês atual: {tempo_atual.tm_mon}")
print(f"Dia atual: {tempo_atual.tm_mday}")
```

### `time.strftime()`

A função `strftime(formato[, struct_time])` converte um objeto `struct_time` em uma string formatada, de acordo com a especificação de formato fornecida. Por exemplo, `%Y` para ano completo, `%m` para mês, `%d` para dia do mês, `%H` para hora (formato 24h), `%M` para minutos, `%S` para segundos.

Mais Formatos [aqui](https://docs.python.org/3/library/time.html#time.strftime)

**exemplo :**
```python
import time
tempo_atual = time.localtime()
formato = time.strftime("%Y-%m-%d %H:%M:%S", tempo_atual)
print(f"Data e hora formatada: {formato}")
```

### `time.gmtime()`

Semelhante a `time.localtime()`, a função `gmtime([seconds])` retorna o tempo no fuso horário UTC (Tempo Universal Coordenado), em vez do fuso horário local.

**exemplo :**
```python
import time
tempo_utc = time.gmtime()
print(f"Ano atual (UTC): {tempo_utc.tm_year}")
```

### `time.mktime()`

A função `mktime(t)` faz o inverso de `time.localtime()` ou `time.gmtime()`, convertendo uma estrutura de tempo (`struct_time`) em segundos desde a *epoch*.

**exemplo :**
```python
import time
tempo_local = time.localtime()
segundos = time.mktime(tempo_local)
print(f"Segundos desde a epoch para a hora local: {segundos}")
```

### `time.asctime()`

A função `asctime([struct_time])` converte um objeto `struct_time` em uma string no formato: `'Dia_sem Mês Dia Hora:Min:Seg Ano'`. Se não for fornecido nenhum argumento, usa o tempo local.

**exemplo :**
```python
import time
print(time.asctime())  # Exemplo de saída: 'Tue Sep  6 10:05:12 2024'
```

### `time.ctime()`

A função `ctime([segundos])` converte o tempo, em segundos desde a epoch, em uma string legível. Se nenhum argumento for passado, usa o tempo atual.

**exemplo :**
```python
import time
print(time.ctime())  # Exemplo de saída: 'Tue Sep  6 10:05:12 2024'
```

### `time.perf_counter()`

A função `perf_counter()` retorna o valor de um temporizador de alta resolução, medido em segundos. É útil para medir o tempo de execução de trechos de código.

**exemplo :**
```python
import time
inicio = time.perf_counter()
time.sleep(2)
fim = time.perf_counter()
print(f"Tempo decorrido: {fim - inicio} segundos")
```

### `time.monotonic()`

A função `monotonic()` é similar a `time.perf_counter()`, mas este temporizador não pode ser ajustado para frente ou para trás (não é afetado por mudanças no relógio do sistema).

**exemplo :**
```python
import time
inicio = time.monotonic()
time.sleep(1)
fim = time.monotonic()
print(f"Tempo decorrido: {fim - inicio} segundos")
```

### `time.process_time()`

A função `process_time()` retorna o tempo de CPU usado pelo processo atual, em segundos.

**exemplo :**
```python
import time
inicio = time.process_time()
# Simulando um processo que consome CPU
for i in range(1000000):
    pass
fim = time.process_time()
print(f"Tempo de CPU usado: {fim - inicio} segundos")
```

---

### exemplos práticos do módulo `time`

#### exemplo de contagem regressiva

Use `time.sleep()` para implementar uma contagem regressiva.

```python
import time

def contagem_regressiva(segundos):
    while segundos:
        mins, secs = divmod(segundos, 60)
        timer = '{:02d}:{:02d}'.format(mins, secs)
        print(timer, end="\r")
        time.sleep(1)
        segundos -= 1
    print("Tempo esgotado!")

contagem_regressiva(10)
```

#### medição do tempo de execução de uma função

Usando `time.perf_counter()` para medir quanto tempo uma função leva para ser executada.

```python
import time

def funcao_lenta():
    print("Executando uma função lenta...")
    time.sleep(3)
    print("Função concluída.")

inicio = time.perf_counter()
funcao_lenta()
fim = time.perf_counter()

print(f"A função demorou {fim - inicio:.2f} segundos para ser executada.")
```

#### imprimindo a data e hora atual formatada

Usando `time.strftime()` para formatar a hora em um formato legível.

```python
import time

agora = time.localtime()
formato = time.strftime("%A, %d de %B de %Y, %H:%M:%S", agora)
print(f"Data e hora atual: {formato}")
```

#### medindo o tempo de cpu usado por um processo

Usando `time.process_time()` para ver quanto tempo de CPU foi utilizado.

```python
import time

inicio = time.process_time()
for i in range(10000000):
    pass
fim = time.process_time()

print(f"Tempo de CPU usado: {fim - inicio:.4f} segundos")
```

## exercícios módulo `time`

<details>
<summary>Lista de Exercícios</summary>

1. Exibindo o Tempo Atual. Use a função `time.time()` para exibir a quantidade de segundos desde o "Epoch" (01/01/1970).
1. Exibindo o Tempo em Formato Estruturado. Use a função `time.gmtime()` para exibir a data e hora atual no formato UTC (tempo universal coordenado).
1. Formatando o Tempo Local. Utilize a função `time.localtime()` para exibir a data e hora local. Em seguida, formate essa saída para mostrar apenas o ano, mês e dia.
1. Formatando uma Data Customizada. Use `time.strftime()` para formatar a data atual no formato `"Ano-Mês-Dia Hora:Minuto:Segundo"`.
1. Convertendo uma String de Data para um Struct_time. Utilize a função `time.strptime()` para converter a string `"12/09/2024 14:30:00"` para um objeto `struct_time`.
1. Exibindo Apenas o Ano Atual. Use a função `time.localtime()` para obter o ano atual e exibi-lo.
1. Medição de Tempo de Execução de Código. Crie um script que utilize `time.time()` para medir quanto tempo demora para executar um loop que itera 1 milhão de vezes.
1. Pausando a Execução do Programa. Use `time.sleep()` para pausar a execução do programa por 5 segundos.
1. Imprimindo um Relógio Simples. Crie um loop que utilize `time.sleep()` e `time.localtime()` para imprimir a hora atual a cada segundo, como um relógio simples.
1. Calculando a Diferença Entre Duas Datas. Use a função `time.mktime()` para calcular a diferença em segundos entre duas datas fornecidas.
1. Convertendo Tempo UTC para Tempo Local. Use a função `time.gmtime()` para pegar o tempo atual em UTC e, em seguida, converta para a hora local usando `time.localtime()`.
1. Exibindo o Tempo em Milissegundos. Modifique o programa para exibir o tempo atual em milissegundos usando `time.time()`.
1. Gerando um Timestamp Customizado. Crie um timestamp customizado para a data `01/01/2020 00:00:00` usando `time.mktime()`.
1. Exibindo a Data Atual em Diferentes Formatos. Use `time.strftime()` para exibir a data atual em três formatos diferentes (como "dd-mm-aaaa", "aaaa/mm/dd", etc.).
1. Validando uma Data a Partir de uma String. Use `time.strptime()` para validar se a string `"30/02/2020"` é uma data válida.
1. Verificando se é Horário de Verão. Use a função `time.localtime()` para verificar se o horário atual está em horário de verão (DST).
1. Simulando uma Contagem Regressiva. Crie um script que faça uma contagem regressiva de 10 segundos usando `time.sleep()`.
1. Comparando Duas Datas. Use `time.mktime()` para comparar duas datas fornecidas e determine qual é a mais recente.
1. Exibindo o Dia da Semana Atual. Utilize `time.localtime()` para determinar o dia da semana (onde 0 é segunda-feira e 6 é domingo).
1. Calculando o Tempo Restante para o Próximo Ano. Calcule quantos segundos faltam para o início do próximo ano (01/01/2025 00:00:00) a partir da data e hora atual.
1. Imprimindo a Data e Hora de 7 Dias Atrás. Use `time.time()` e `time.localtime()` para calcular e exibir a data e hora de 7 dias atrás.
1. Formatando o Tempo para Horário Completo e Amigável. Use `time.strftime()` para formatar a hora atual no formato `"12-hour:minute AM/PM"`.
1. Convertendo uma Data e Hora para o Timestamp. Crie uma data e hora arbitrária, como `"25/12/2024 15:00:00"`, e converta para o timestamp usando `time.mktime()`.
1. Exibindo o Mês Atual. Extraia e exiba o mês atual usando `time.localtime()`.
1. Implementando um Temporizador de 10 Segundos. Crie um programa que avise o usuário após 10 segundos, utilizando `time.sleep()`.
1. Calculando o Intervalo de Tempo Entre Duas Execuções. Crie um programa que execute duas funções e calcule o intervalo de tempo entre elas usando `time.perf_counter()`.
1. Convertendo uma Hora UTC para Horário Local. Pegue a hora UTC usando `time.gmtime()` e converta para a hora local usando `time.localtime()`.
1. Exibindo o Tempo de Início do Script. Use `time.ctime()` para exibir o horário em que o script foi iniciado.
1. Exibindo a Data Atual em Diferentes Idiomas. Use `time.strftime()` e altere as configurações de idioma do sistema para exibir a data atual em diferentes idiomas (pode ser feito manualmente no sistema operacional).

</details>

## módulo `string`

O módulo `string` do Python fornece constantes e funções úteis para manipular strings, principalmente quando se trabalha com caracteres e conjuntos de caracteres predefinidos. Ele ajuda a tornar operações comuns mais simples e legíveis, fornecendo acesso a letras, dígitos, pontuações, espaços em branco, e métodos úteis para formatação de strings.

1. [`string.ascii_letters`](#stringascii_letters)
1. [`string.ascii_lowercase`](#stringascii_lowercase)
1. [`string.ascii_uppercase`](#stringascii_uppercase)
1. [`string.digits`](#stringdigits)
1. [`string.hexdigits`](#stringhexdigits)
1. [`string.octdigits`](#stringoctdigits)
1. [`string.punctuation`](#stringpunctuation)
1. [`string.whitespace`](#stringwhitespace)
1. [`string.printable`](#stringprintable)
1. [`string.capwords`](#stringcapwordss-sepnone)
1. [exemplos práticos do módulo `string`](#exemplos-práticos-do-módulo-string)
1. [índice](#índice)

### `string.ascii_letters`

Contém todas as letras maiúsculas e minúsculas do alfabeto em inglês, combinando `ascii_lowercase` (minúsculas) e `ascii_uppercase` (maiúsculas). Útil quando se deseja gerar uma sequência de letras ou validar se um caractere é uma letra.

**exemplo :**
```python
import string
print(string.ascii_letters)  # Saída: 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
```

### `string.ascii_lowercase`

Contém todas as letras minúsculas do alfabeto em inglês (`'abcdefghijklmnopqrstuvwxyz'`). Ideal para operações que envolvem apenas letras minúsculas.

**exemplo :**
```python
import string
print(string.ascii_lowercase)  # Saída: 'abcdefghijklmnopqrstuvwxyz'
```

### `string.ascii_uppercase`

Contém todas as letras maiúsculas do alfabeto em inglês (`'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`). Útil para operações que envolvem apenas letras maiúsculas.

**exemplo :**
```python
import string
print(string.ascii_uppercase)  # Saída: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
```

### `string.digits`

Contém todos os dígitos decimais de 0 a 9 (`'0123456789'`). Muito útil para validar ou gerar números.

**exemplo :**
```python
import string
print(string.digits)  # Saída: '0123456789'
```

### `string.hexdigits`

Contém todos os dígitos hexadecimais, incluindo os números de 0 a 9 e as letras de A a F (tanto maiúsculas quanto minúsculas). A sequência é `'0123456789abcdefABCDEF'`. Usado em conversões ou validações de números hexadecimais.

**exemplo :**
```python
import string
print(string.hexdigits)  # Saída: '0123456789abcdefABCDEF'
```

### `string.octdigits`

Contém todos os dígitos octais, de 0 a 7 (`'01234567'`). Ideal para trabalhar com números no sistema octal.

**exemplo :**
```python
import string
print(string.octdigits)  # Saída: '01234567'
```

### `string.punctuation`

Contém todos os caracteres de pontuação comuns, como `!`, `@`, `#`, etc. Útil para remover ou validar a presença de pontuação em uma string.

**exemplo :**
```python
import string
print(string.punctuation)  # Saída: '!"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~'
```

### `string.whitespace`

Contém todos os caracteres que são considerados espaço em branco, como o espaço (`' '`), tabulação (`'\t'`), nova linha (`'\n'`), etc. Excelente para tarefas de limpeza de strings.

**exemplo :**
```python
import string
print(repr(string.whitespace))  # Saída: ' \t\n\r\x0b\x0c'
```

### `string.printable`

Contém todos os caracteres imprimíveis, que são a união de letras, dígitos, pontuação e espaços em branco. Ideal para validar se uma string contém apenas caracteres que podem ser impressos.

**exemplo :**
```python
import string
print(string.printable)  # Saída: todos os caracteres imprimíveis
```

### `string.capwords(s, sep=None)`

Essa função converte uma string de forma que a primeira letra de cada palavra seja maiúscula (capitaliza a string). Ela é semelhante ao método `str.title()`, mas usa o espaço como separador por padrão. Caso você passe um separador (como vírgula ou ponto), a função usa esse separador para detectar as palavras.

**exemplo :**
```python
import string
frase = "olá mundo, python é incrível"
print(string.capwords(frase))  # Saída: 'Olá Mundo, Python É Incrível'
```

---

### exemplos práticos do módulo `string`

#### gerar uma senha aleatória

Usando os caracteres disponíveis em `string.ascii_letters`, `string.digits` e `string.punctuation` para criar uma senha aleatória.

**exemplo :**
```python
import string
import random

def gerar_senha(tamanho=8):
    caracteres = string.ascii_letters + string.digits + string.punctuation
    senha = ''.join(random.choice(caracteres) for _ in range(tamanho))
    return senha

senha = gerar_senha(12)
print(f"Senha gerada: {senha}")
```

#### validar se uma string é alfabética

Verificar se uma string contém apenas letras utilizando `string.ascii_letters`.

**exemplo :**
```python
import string

def eh_alfabetica(texto):
    for caractere in texto:
        if caractere not in string.ascii_letters:
            return False
    return True

print(eh_alfabetica("Python"))  # Saída: True
print(eh_alfabetica("Python3"))  # Saída: False
```

#### remover pontuação de uma string

Utilizando `string.punctuation` para remover todos os sinais de pontuação de uma frase.

**exemplo :**
```python
import string

def remover_pontuacao(texto):
    return ''.join(caractere for caractere in texto if caractere not in string.punctuation)

frase = "Olá, mundo! Python é incrível."
frase_sem_pontuacao = remover_pontuacao(frase)
print(frase_sem_pontuacao)  # Saída: 'Olá mundo Python é incrível'
```

#### verificar se uma string contém apenas caracteres imprimíveis

Verificar se uma string contém apenas caracteres que podem ser impressos utilizando `string.printable`.

**exemplo :**
```python
import string

def eh_imprimivel(texto):
    return all(caractere in string.printable for caractere in texto)

print(eh_imprimivel("Python 3.10!"))  # Saída: True
print(eh_imprimivel("Texto\nNão Imprimível"))  # Saída: True (nova linha ainda é considerada imprimível)
```

#### capitalize todas as palavras de uma string

Utilizando `string.capwords()` para transformar a primeira letra de cada palavra em maiúscula.

**exemplo :**
```python
import string

frase = "python é uma linguagem incrível"
frase_capitalizada = string.capwords(frase)
print(frase_capitalizada)  # Saída: 'Python É Uma Linguagem Incrível'
```

## exercícios módulo `string`

<details>
<summary>Lista de Exercícios</summary>

1. Exibindo o Alfabeto Minúsculo. Use `string.ascii_lowercase` para exibir todas as letras minúsculas do alfabeto inglês.
1. Exibindo o Alfabeto Maiúsculo. Use `string.ascii_uppercase` para exibir todas as letras maiúsculas do alfabeto inglês.
1. Exibindo Todos os Dígitos. Use `string.digits` para exibir todos os dígitos (de 0 a 9).
1. Exibindo Caracteres Hexadecimais. Use `string.hexdigits` para exibir todos os caracteres válidos em um número hexadecimal.
1. Exibindo Caracteres Octais. Use `string.octdigits` para exibir todos os dígitos válidos em um número octal.
1. Exibindo Símbolos de Pontuação. Use `string.punctuation` para exibir todos os símbolos de pontuação.
1. Exibindo Todos os Caracteres Imprimíveis. Use `string.printable` para exibir todos os caracteres imprimíveis.
1. Exibindo os Caracteres de Espaçamento. Use `string.whitespace` para exibir todos os caracteres considerados espaço em branco (espaços, tabulações, etc.).
1. Verificando se uma String é Alfanumérica. Crie uma função que verifique se uma string contém apenas caracteres alfanuméricos utilizando `string.ascii_letters` e `string.digits`.
1. Convertendo uma String para Maiúscula. Utilize `string.ascii_uppercase` para criar uma função que converta qualquer string para letras maiúsculas.
1. Convertendo uma String para Minúscula. Use `string.ascii_lowercase` para criar uma função que converta qualquer string para letras minúsculas.
1. Removendo Pontuação de uma String. Crie uma função que remova todos os símbolos de pontuação de uma string utilizando `string.punctuation`.
1. Substituindo Espaços por Underlines. Use `string.whitespace` para substituir todos os espaços de uma string por underscores (`_`).
1. Gerando uma Senha Aleatória. Use `string.ascii_letters` e `string.digits` para gerar uma senha aleatória de 8 caracteres.
1. Verificando se uma String é Hexadecimal. Crie uma função que verifique se uma string contém apenas caracteres válidos para um número hexadecimal, usando `string.hexdigits`.
1. Removendo Dígitos de uma String. Crie uma função que remova todos os dígitos de uma string utilizando `string.digits`.
1. Verificando se uma String é uma Palavra. Crie uma função que verifique se uma string contém apenas letras (maiúsculas ou minúsculas), usando `string.ascii_letters`.
1. Formatando uma String de Forma Capitalizada. Utilize `string.capwords()` para capitalizar cada palavra de uma frase.
1. Gerando um Identificador de Produto. Crie uma função que gere um identificador de produto aleatório, contendo letras e números, utilizando `string.ascii_uppercase` e `string.digits`.
1. Gerando um Nome de Arquivo Seguro. Crie uma função que remova qualquer caractere especial de uma string, exceto letras, números e underscore, utilizando `string.ascii_letters`, `string.digits` e `'_`.
1. Contando o Número de Dígitos em uma String. Crie uma função que conte quantos dígitos existem em uma string usando `string.digits`.
1. Validando um Identificador. Crie uma função que valide se um identificador contém apenas letras, números e underscores utilizando `string.ascii_letters`, `string.digits`, e `'_'`.
1. Separando Palavras de uma Frase. Utilize `string.whitespace` para separar as palavras de uma frase em uma lista, ignorando os espaços em branco.
1. Gerando uma Frase sem Espaços. Crie uma função que remova todos os espaços de uma frase utilizando `string.whitespace`.
1. Gerando um Token de Sessão Aleatório. Crie uma função que gere um token aleatório de 16 caracteres utilizando `string.printable`.
1. Formatando um Texto em Blocos de 4 Dígitos. Crie uma função que pegue uma sequência de números e formate em blocos de 4 dígitos separados por hífens (ex.: "1234-5678-9012").
1. Verificando se uma String é uma Data Válida. Crie uma função que verifique se uma string contém uma data no formato "dd/mm/yyyy" usando `string.digits` e `string.punctuation`.
1. Criando uma String de Números Sequenciais. Crie uma função que gere uma string contendo todos os números de 0 a 9 em sequência usando `string.digits`.
1. Convertendo um Texto para Código Morse. Crie uma função que converta uma string para código Morse, utilizando `string.ascii_uppercase` e `string.digits` para mapear os caracteres.
1. Formatando uma String com Pontuação e Espaçamento. Utilize `string.capwords()` para formatar uma frase, ajustando os espaços em branco e a capitalização de cada palavra.
1. Criando uma Função de Busca de Palavras. Crie uma função que receba um texto e uma palavra e retorne quantas vezes a palavra aparece no texto, ignorando a pontuação com `string.punctuation`.
1. Verificando se uma String é um Número Binário. Crie uma função que verifique se uma string contém apenas os caracteres '0' e '1', utilizando `string.digits`.
1. Formatando um Texto para Ficar Legível. Use `string.capwords()` para formatar um texto inteiro, capitalizando as primeiras letras de cada palavra.
1. Gerando uma String de Símbolos Aleatórios. Crie uma função que gere uma string de 10 caracteres contendo apenas símbolos de `string.punctuation`.
1. Verificando se uma String é Imprimível. Crie uma função que verifique se todos os caracteres de uma string são imprimíveis, utilizando `string.printable`.
1. Contando Caracteres Não Imprimíveis em uma String. Crie uma função que conte quantos caracteres não imprimíveis existem em uma string, utilizando `string.printable`.
1. Gerando uma Senha Segura. Crie uma função que gere uma senha aleatória contendo letras maiúsculas, minúsculas, números e símbolos, utilizando `string.ascii_letters`, `string.digits`, e `string.punctuation`.
1. Verificando se uma Senha é Segura. Crie uma função que verifique se uma senha contém pelo menos uma letra maiúscula, uma minúscula, um número e um símbolo de pontuação.
1. Contando a Frequência de Letras em uma String. Crie uma função que conte quantas vezes cada letra aparece em uma string utilizando `string.ascii_lowercase` ou `string.ascii_uppercase`.
1. Gerando uma Sequência de Caracteres Alternados. Crie uma função que gere uma string alternando entre letras maiúsculas e minúsculas, utilizando `string.ascii_uppercase` e `string.ascii_lowercase`.
1. Verificando Caracteres Permitidos em Identificadores. Crie uma função que verifique se uma string é um identificador válido (apenas letras, números e underscores), utilizando `string.ascii_letters` e `string.digits`.
1. Removendo Pontuação e Espaços de uma String. Crie uma função que remova todos os espaços e pontuações de uma string, utilizando `string.whitespace` e `string.punctuation`.
1. Verificando se uma String Contém Apenas Letras e Espaços. Crie uma função que verifique se uma string contém apenas letras e espaços, utilizando `string.ascii_letters` e `string.whitespace`.
1. Gerando uma Chave de Produto Aleatória. Crie uma função que gere uma chave de produto no formato "ABCD-EFGH-IJKL", utilizando `string.ascii_uppercase` e `string.digits`.
1. Formatando um Número de Cartão de Crédito. Crie uma função que formate um número de cartão de crédito no formato "XXXX-XXXX-XXXX-XXXX", usando `string.digits`.
1. Verificando se uma String Contém Apenas Caracteres de Controle. Crie uma função que verifique se uma string contém apenas caracteres de controle (não imprimíveis), utilizando `string.whitespace` e verificando com `string.printable`.
1. Substituindo Dígitos por Palavras. Crie uma função que substitua cada dígito em uma string pela respectiva palavra (ex.: "1" por "um", "2" por "dois"), utilizando `string.digits`.
1. Gerando um Código de Desconto Aleatório. Crie uma função que gere um código de desconto de 8 caracteres, utilizando letras maiúsculas e números, com `string.ascii_uppercase` e `string.digits`.
1. Validando um Nome de Usuário. Crie uma função que valide um nome de usuário, verificando se contém apenas letras, números e underscores, utilizando `string.ascii_letters` e `string.digits`.
1. Contando Caracteres de Espaçamento. Crie uma função que conte quantos caracteres de espaçamento existem em uma string, utilizando `string.whitespace`.

</details>

## módulo `math`

O módulo `math` do Python é uma biblioteca padrão que fornece funções matemáticas básicas e avançadas. Ele inclui uma série de operações que vão desde funções trigonométricas, logaritmos, até manipulações de números de ponto flutuante e constantes matemáticas. O `math` é particularmente útil em cálculos científicos e estatísticos.

1. [constantes matemáticas](#constantes-matemáticas)
1. [funções aritméticas](#funções-aritméticas)
1. [funções exponenciais e logarítmicas](#funções-exponenciais-e-logarítmicas)
1. [funções trigonométricas](#funções-trigonométricas)
1. [funções hiperbólicas](#funções-hiperbólicas)
1. [funções de arredondamento](#funções-de-arredondamento)
1. [funções de comparação](#funções-de-comparação)
1. [exemplos práticos do módulo `math`](#exemplos-práticos-do-módulo-math)
1. [índice](#índice)

### constantes matemáticas

- `math.pi` : representa o valor de π (aproximadamente 3.14159);
- `math.e` : representa o valor da constante de euler (aproximadamente 2.71828);
- `math.inf` : representa o valor de infinito;
- `math.nan` : representa um valor que não é um número (not a number);

```python
import math

print(math.pi)  # 3.141592653589793
print(math.e)   # 2.718281828459045
print(math.inf)  # inf
print(math.nan)  # nan
```

### funções aritméticas

- `math.ceil(x)` : retorna o menor número inteiro maior ou igual a `x`;
- `math.floor(x)` : retorna o maior número inteiro menor ou igual a `x`;
- `math.fabs(x)` : retorna o valor absoluto de `x`;
- `math.factorial(x)` : retorna o fatorial de `x` (x!);
- `math.gcd(x, y)` : calcula o maior divisor comum entre `x` e `y`;

```python
print(math.ceil(4.3))    # 5
print(math.floor(4.7))   # 4
print(math.fabs(-5.4))   # 5.4
print(math.factorial(5)) # 120
print(math.gcd(60, 48))  # 12
```

### funções exponenciais e logarítmicas

- `math.exp(x)` : retorna `e` elevado à potência de `x` (e^x);
- `math.log(x)` : retorna o logaritmo natural de `x` (base `e`);
- `math.log10(x)` : retorna o logaritmo de base 10 de `x`;
- `math.pow(x, y)` : retorna `x` elevado à potência de `y` (x^y);
- `math.sqrt(x)` : retorna a raiz quadrada de `x`;

```python
print(math.exp(1))        # 2.718281828459045 (valor de e)
print(math.log(10))       # 2.302585092994046 (logaritmo natural)
print(math.log10(1000))   # 3.0 (log de base 10)
print(math.pow(2, 3))     # 8.0 (2^3)
print(math.sqrt(25))      # 5.0 (raiz quadrada de 25)
```

### funções trigonométricas

- `math.sin(x)` : retorna o seno de `x` (em radianos);
- `math.cos(x)` : retorna o cosseno de `x` (em radianos);
- `math.tan(x)` : retorna a tangente de `x` (em radianos);
- `math.degrees(x)` : converte o valor de `x` de radianos para graus;
- `math.radians(x)` : converte o valor de `x` de graus para radianos;

```python
angle = math.radians(90)  # convertendo 90 graus para radianos
print(math.sin(angle))    # 1.0 (seno de 90 graus)

print(math.degrees(math.pi))  # 180.0 (π radianos é igual a 180 graus)
```

### funções hiperbólicas

- `math.sinh(x)` : retorna o seno hiperbólico de `x`;
- `math.cosh(x)` : retorna o cosseno hiperbólico de `x`;
- `math.tanh(x)` : retorna a tangente hiperbólica de `x`;

```python
print(math.sinh(1))  # 1.1752011936438014
print(math.cosh(1))  # 1.5430806348152437
print(math.tanh(1))  # 0.7615941559557649
```

### funções de arredondamento

- `math.trunc(x)` : remove a parte decimal de `x`, retornando apenas a parte inteira;
- `math.modf(x)` : retorna a parte fracionária e a parte inteira de `x` como uma tupla;

```python
print(math.trunc(4.8))    # 4
print(math.modf(4.8))     # (0.7999999999999998, 4.0)
```

### funções de comparação

- `math.isfinite(x)` : retorna `true` se `x` for um número finito;
- `math.isinf(x)` : retorna `true` se `x` for infinito;
- `math.isnan(x)` : retorna `true` se `x` não for um número (nan);

```python
print(math.isfinite(100))   # True
print(math.isinf(math.inf)) # True
print(math.isnan(float('nan'))) # True
```

### exemplos práticos do módulo `math`

#### calculando a hipotenusa de um triângulo retângulo

Imagine que se conheça os dois catetos de um triângulo retângulo e deseja calcular a hipotenusa. A fórmula da hipotenusa é dada por:

> hipotenusa = (cateto1 ** 2 +  cateto2 ** 2) ** (1/2)

Será usada a fórmula `math.sqrt()` para calcular a raiz quadrada.

```python
import math

cateto1 = 3
cateto2 = 4

hipotenusa = math.sqrt(math.pow(cateto1, 2) + math.pow(cateto2, 2))
print(f"A hipotenusa do triângulo é: {hipotenusa}")
```

**Saída** :
```
A hipotenusa do triângulo é: 5.0
```

#### calculando o logaritmo de base 10 de um número

```python
import math

numero = 1000
logaritmo = math.log10(numero)
print(f"O logaritmo de base 10 de {numero} é {logaritmo}")
```

**Saída** :
```
O logaritmo de base 10 de 1000 é 3.0
```

#### convertendo ângulos de graus para radianos

Muitos cálculos trigonométricos usam ângulos em radianos. Pode-se converter facilmente graus para radianos com `math.radians()`.

```python
import math

graus = 180
radianos = math.radians(graus)
print(f"{graus} graus são {radianos} radianos")
```

**Saída** :
```
180 graus são 3.141592653589793 radianos
```

#### gerando números aleatórios com a distribuição normal

Em muitos casos, pode-se desejar gerar números com base em uma distribuição normal. Isso pode ser feito com `random.gauss()`, mas a biblioteca `math` fornece as funções de probabilidade que pode-se usar para esses cálculos.

```python
import math

mu = 0   # média
sigma = 1  # desvio padrão
valores = [math.exp(mu + sigma * x) for x in range(-3, 4)]
print(valores)
```

## exercícios módulo `math`

<details>
<summary>Lista de Exercícios</summary>

1. Exercícios de Funções Aritméticas
    1. **Arredondamento para Cima** : Dado um número decimal, use `math.ceil()` para arredondá-lo para o próximo número inteiro.
    1. **Arredondamento para Baixo** : Dado um número decimal, use `math.floor()` para arredondá-lo para o número inteiro anterior.
    1. **Valor Absoluto** : Use `math.fabs()` para encontrar o valor absoluto de um número negativo.
    1. **Fatorial** : Dado um número inteiro `n`, calcule o fatorial de `n` usando `math.factorial()`.
    1. **Maior Divisor Comum** : Use `math.gcd()` para encontrar o maior divisor comum entre dois números inteiros.
    1. **Divisão e Módulo** : Dado um número decimal, use `math.modf()` para separá-lo em parte inteira e parte fracionária.
    1. **Truncamento** : Dado um número decimal, use `math.trunc()` para remover a parte decimal.
    1. **Comparação de Valores** : Use `math.isclose()` para comparar dois números com precisão definida (tolerância).
1. Exercícios de Funções Exponenciais e Logarítmicas
    1. **Exponencial** : Use `math.exp()` para calcular o valor de `e` elevado a uma potência.
    1. **Potenciação** : Calcule `x` elevado à potência de `y` usando `math.pow()`.
    1. **Raiz Quadrada** : Dado um número positivo, calcule sua raiz quadrada usando `math.sqrt()`.
    1. **Logaritmo Natural** : Dado um número `n`, calcule o logaritmo natural (base `e`) de `n` usando `math.log()`.
    1. **Logaritmo de Base 10** : Use `math.log10()` para calcular o logaritmo de um número na base 10.
    1. **Logaritmo com Base Arbitrária** : Dado um número `n` e uma base `b`, calcule o logaritmo de `n` na base `b` usando `math.log(x, base)`.
    1. **Crescimento Exponencial** : Escreva uma função que calcule o crescimento exponencial de uma população usando `math.exp()`.
1. Exercícios de Funções Trigonométricas
    1. **Cálculo de Seno** : Dado um ângulo em radianos, calcule o seno do ângulo usando `math.sin()`.
    1. **Cálculo de Cosseno** : Dado um ângulo em radianos, calcule o cosseno do ângulo usando `math.cos()`.
    1. **Cálculo de Tangente** : Dado um ângulo em radianos, calcule a tangente do ângulo usando `math.tan()`.
    1. **Converta Graus para Radianos** : Dado um valor em graus, use `math.radians()` para convertê-lo em radianos.
    1. **Converta Radianos para Graus** : Dado um valor em radianos, use `math.degrees()` para convertê-lo em graus.
    1. **Arco Seno** : Use `math.asin()` para encontrar o arco seno de um valor.
    1. **Arco Cosseno** : Use `math.acos()` para encontrar o arco cosseno de um valor.
    1. **Arco Tangente** : Use `math.atan()` para encontrar o arco tangente de um valor.
    1. **Identidade Trigonométrica** : Verifique a identidade trigonométrica `sin^2(x) + cos^2(x) = 1` para um valor `x`.
1. Exercícios de Funções Hiperbólicas
    1. **Seno Hiperbólico** : Dado um valor `x`, calcule o seno hiperbólico usando `math.sinh()`.
    1. **Cosseno Hiperbólico** : Dado um valor `x`, calcule o cosseno hiperbólico usando `math.cosh()`.
    1. **Tangente Hiperbólica** : Dado um valor `x`, calcule a tangente hiperbólica usando `math.tanh()`.
1. Exercícios de Funções de Comparação
    1. **Verificar se um Número é Finito** : Use `math.isfinite()` para verificar se um número é finito.
    1. **Verificar se um Número é Infinito** : Use `math.isinf()` para verificar se um número é infinito.
    1. **Verificar se um Valor é NaN (Not a Number)** : Use `math.isnan()` para verificar se um valor não é um número.
    1. **Verificar Proximidade entre Números** : Use `math.isclose()` para verificar se dois números são aproximadamente iguais com uma certa tolerância.
1. Exercícios com Constantes
    1. **Valor de Pi** : Calcule a circunferência de um círculo dado seu raio usando `math.pi`.
    1. **Valor de e** : Use a constante `math.e` para calcular o valor de `e` elevado à potência de um número.
    1. **Cálculo com Infinito** : Use `math.inf` para verificar o comportamento de operações com valores infinitos.
    1. **Comparando Infinito com Números Finitos** : Verifique se `math.inf` é maior que um número muito grande.
1. Exercícios de Funções Estatísticas
    1. **Cálculo de Média** : Dada uma lista de números, calcule a média aritmética.
    1. **Cálculo de Variância** : Dada uma lista de números, calcule a variância dos valores.
    1. **Cálculo do Desvio Padrão** : Dada uma lista de números, calcule o desvio padrão dos valores.
1. Exercícios de Aplicações Práticas
    1. **Calculando a Hipotenusa** : Use `math.hypot()` para calcular a hipotenusa de um triângulo retângulo, dado os valores dos catetos.
    1. **Distância Euclidiana** : Dado dois pontos `(x1, y1)` e `(x2, y2)` no plano cartesiano, calcule a distância euclidiana entre eles usando `math.hypot()`.
    1. **Cálculo de Juros Compostos** : Escreva uma função que calcule o montante total após `n` anos com juros compostos, utilizando `math.pow()`.
    1. **Cálculo de Probabilidade Normal** : Use `math.erf()` para calcular a função de distribuição cumulativa de uma variável com distribuição normal.
    1. **Aproximação de Pi com Série de Leibniz** : Use uma fórmula matemática para aproximar o valor de `pi` somando os primeiros `n` termos da série de Leibniz.
    1. **Conversão de Coordenadas Polares para Cartesianas** : Dado um raio `r` e um ângulo `theta` em radianos, converta para coordenadas cartesianas usando funções trigonométricas.
    1. **Conversão de Coordenadas Cartesianas para Polares** : Dado um ponto `(x, y)` no plano cartesiano, converta para coordenadas polares usando `math.atan2()`.
    1. **Cálculo de Volume de uma Esfera** : Calcule o volume de uma esfera dado seu raio, usando a fórmula `4/3 * π * r^3`.
    1. **Equação Quadrática** : Dada uma equação quadrática `ax^2 + bx + c = 0`, calcule as raízes usando a fórmula de Bhaskara e `math.sqrt()`.
    1. **Resolvendo uma Equação Exponencial** : Resolva uma equação exponencial do tipo `e^x = y` usando `math.log()`.
    1. **Cálculo de Proporção** : Dada uma proporção, use `math.log()` para resolver uma equação de proporções entre duas variáveis.
    1. **Aproximação Linear** : Dado um conjunto de pontos, escreva um programa que calcule a melhor linha reta que aproxima os pontos (método dos mínimos quadrados).

</details>

## módulo `json`

O módulo `json` do Python é utilizado para trabalhar com dados no formato JSON (JavaScript Object Notation). O JSON é um formato de intercâmbio de dados amplamente utilizado, especialmente em APIs web, porque é simples e fácil de ler para humanos e máquinas. Com o módulo `json`, é possível converter dados entre objetos Python e strings JSON, o que é conhecido como **serialização** e **desserialização**.

1. [dumping e loading](#dumping-e-loading)
1. [`json.dumps()`](#jsondumps)
1. [`json.loads()`](#jsonloads)
1. [`json.dump()`](#jsondump)
1. [`json.load()`](#jsonload)
1. [índice](#índice)

### dumping e loading

- **serialização (dumping)** : converte objetos Python (listas, dicionários, etc.) em uma string JSON;
- **desserialização (loading)** : converte uma string JSON em objetos Python (tipicamente dicionários e listas);

### `json.dumps()`

Essa função **serializa** um objeto Python em uma string JSON. É usada quando se deseja converter um objeto Python (como um dicionário) em uma string JSON que pode ser armazenada ou enviada para uma API.

- **sintaxe** : `json.dumps(obj, *, skipkeys=False, ensure_ascii=True, indent=None, separators=None, default=None, sort_keys=False)`

    - `obj` : o objeto Python a ser convertido;
    - `skipkeys` : se `True`, chaves não suportadas (como tuplas) são ignoradas;
    - `ensure_ascii` : se `True`, a string resultante conterá apenas caracteres ASCII;
    - `indent` : especifica o número de espaços usados para formatar a saída (em formato indentado);
    - `sort_keys` : se `True`, as chaves dos dicionários serão ordenadas;

**Exemplo**
```python
import json

dados = {
    "nome": "João",
    "idade": 30,
    "cidade": "São Paulo",
    "habilidades": ["Python", "C++", "JavaScript"]
}

json_string = json.dumps(dados, indent=4)  # serializa e adiciona indentação
print(json_string)
```

**Saída**
```json
{
    "nome": "João",
    "idade": 30,
    "cidade": "São Paulo",
    "habilidades": [
        "Python",
        "C++",
        "JavaScript"
    ]
}
```

### `json.loads()`

Essa função **desserializa** uma string JSON em um objeto Python. É usada para interpretar dados JSON (geralmente recebidos de uma API) como dicionários, listas e outros objetos Python.

- **sintaxe** : `json.loads(s, *, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None)`

    - `s`: a string JSON que será convertida;
    - `object_hook`: uma função que pode ser usada para modificar o comportamento da desserialização;

**Exemplo**
```python
import json

json_string = '{"nome": "João", "idade": 30, "cidade": "São Paulo", "habilidades": ["Python", "C++", "JavaScript"]}'
dados = json.loads(json_string)

print(dados)
```

**Saída**
```python
{
    'nome': 'João',
    'idade': 30,
    'cidade': 'São Paulo',
    'habilidades': ['Python', 'C++', 'JavaScript']
}
```

### `json.dump()`

Essa função é semelhante a `json.dumps()`, mas em vez de converter um objeto em uma string JSON, ela grava o JSON diretamente em um arquivo.

- **sintaxe** : `json.dump(obj, fp, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False)`

    - `obj` : o objeto Python que será convertido;
    - `fp` : o objeto de arquivo onde os dados JSON serão gravados;

**Exemplo**
```python
import json

dados = {
    "nome": "João",
    "idade": 30,
    "cidade": "São Paulo",
    "habilidades": ["Python", "C++", "JavaScript"]
}

with open('dados.json', 'w') as arquivo:
    json.dump(dados, arquivo, indent=4)
```

Nesse exemplo, o dicionário `dados` é gravado em um arquivo chamado `dados.json` com formatação indentada.

### `json.load()`

Essa função lê dados JSON de um arquivo e os converte em um objeto Python.

- **sintaxe** : `json.load(fp, *, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None)`

    - `fp` : o arquivo contendo os dados JSON;

**Exemplo**
```python
import json

with open('dados.json', 'r') as arquivo:
    dados = json.load(arquivo)

print(dados)
```

Aqui, o conteúdo do arquivo `dados.json` será carregado em um dicionário Python.

---

## exercícios módulo `json`

<details>
<summary>Lista de Exercícios</summary>

1. Exercícios para o Método `json.dumps()`
    1. **Serialização Simples** : Converta um dicionário Python simples contendo informações de uma pessoa (nome, idade, cidade) em uma string JSON usando `json.dumps()`.
    1. **Lista de Números** : Converta uma lista de números inteiros em uma string JSON usando `json.dumps()`.
    1. **Indentação na Serialização** : Serialize um dicionário Python com o parâmetro `indent=4` para formatar o JSON de maneira legível.
    1. **Serializar com Chaves Ordenadas** : Serialize um dicionário e utilize o parâmetro `sort_keys=True` para garantir que as chaves fiquem em ordem alfabética no JSON.
    1. **Serializar com Caracteres Especiais** : Serialize um dicionário que contém caracteres especiais (acentos, símbolos) e use o parâmetro `ensure_ascii=False` para manter os caracteres como estão.
    1. **Serialização de Tupla** : Tente serializar uma tupla de números e veja como ela é convertida para JSON.
    1. **Ignorar Chaves Inválidas** : Tente serializar um dicionário que contenha uma chave inválida (como uma tupla) e use o parâmetro `skipkeys=True` para ignorar as chaves inválidas.
    1. **Serializar Objetos Aninhados** : Serialize um dicionário que contenha outros dicionários e listas aninhados, usando `json.dumps()`.
    1. **Serializar com Separadores Personalizados** : Use o parâmetro `separators` em `json.dumps()` para personalizar os separadores entre os elementos (exemplo: `', '` para separar os itens da lista e `': '` para separar chaves e valores).
1. Exercícios para o Método `json.loads()`
    1. **Desserializar uma String JSON Simples** : Dada uma string JSON contendo informações de um produto (nome, preço, quantidade), use `json.loads()` para convertê-la em um dicionário Python.
    1. **Desserializar Lista** : Converta uma string JSON contendo uma lista de números em uma lista Python usando `json.loads()`.
    1. **Desserializar uma Lista de Dicionários** : Dada uma string JSON contendo uma lista de dicionários com informações de vários estudantes, use `json.loads()` para convertê-la em uma lista de dicionários Python.
    1. **Erro ao Desserializar** : Dada uma string JSON com erro de sintaxe, tente usá-la com `json.loads()` e capture o erro `JSONDecodeError` adequadamente.
    1. **Desserializar Números com Vírgula Flutuante** : Converta uma string JSON contendo números decimais (como `2.5`, `3.14`) em uma lista de números Python.
    1. **Verificar Tipo após Desserializar** : Após desserializar uma string JSON, verifique o tipo dos dados retornados (exemplo: verificar se é um dicionário ou lista).
    1. **Desserializar Booleanos** : Converta uma string JSON que contenha valores booleanos (`true`, `false`) em um dicionário Python usando `json.loads()`.
    1. **Desserializar Null** : Use `json.loads()` para converter uma string JSON que contenha `null` e verifique como o Python representa esse valor.
1. Exercícios para o Método `json.dump()`
    1. **Serialização para Arquivo** : Converta um dicionário Python para JSON e grave o resultado em um arquivo `dados.json` usando `json.dump()`.
    1. **Salvar Lista em Arquivo** : Salve uma lista de strings como JSON em um arquivo usando `json.dump()`.
    1. **Gravar JSON Formatado** : Converta um dicionário Python em JSON e grave no arquivo `formatado.json` com indentação de 4 espaços para facilitar a leitura.
    1. **Serializar com Separadores Personalizados** : Use o parâmetro `separators` ao gravar JSON em um arquivo para ajustar os separadores entre chaves e valores.
    1. **Ignorar Chaves Inválidas em Arquivo** : Grave um dicionário em um arquivo, ignorando chaves inválidas (como tuplas), utilizando o parâmetro `skipkeys=True`.
    1. **Serializar com Ordenação de Chaves** : Grave um dicionário em um arquivo JSON, ordenando as chaves de forma alfabética com o parâmetro `sort_keys=True`.
    1. **Escrever Múltiplos Objetos em um Arquivo** : Serialize e grave dois objetos Python em um único arquivo JSON (por exemplo, dois dicionários separados por linhas).
    1. **Gravação de JSON com Unicode** : Grave um dicionário com caracteres Unicode em um arquivo, sem que eles sejam escapados, utilizando o parâmetro `ensure_ascii=False`.
    1. **Gravar JSON em Modo de Acrescentar (Append)** : Abra um arquivo JSON existente e adicione mais dados (um novo dicionário) ao final do arquivo, sem sobrescrever o conteúdo original.
1. Exercícios para o Método `json.load()`
    1. **Ler um Arquivo JSON Simples** : Crie um arquivo JSON com informações de uma pessoa e use `json.load()` para carregá-lo como um dicionário Python.
    1. **Ler Lista de Números** : Crie um arquivo JSON contendo uma lista de números inteiros e use `json.load()` para carregá-los em uma lista Python.
    1. **Ler Arquivo JSON Formatado** : Abra um arquivo JSON que contenha dados com indentação e carregue-o usando `json.load()`.
    1. **Tratar Erro ao Ler Arquivo JSON Inválido** : Tente ler um arquivo com JSON inválido e trate o erro `JSONDecodeError` corretamente.
    1. **Ler JSON de Arquivo Grande** : Crie um arquivo JSON com milhares de linhas e use `json.load()` para carregá-lo. Verifique o tempo de execução.
    1. **Modificar e Regravar JSON Lido** : Após carregar um arquivo JSON como um dicionário Python, modifique os valores e grave as mudanças de volta no arquivo usando `json.dump()`.
    1. **Ler Arquivo com Booleanos** : Crie um arquivo JSON que contenha valores booleanos (`true`, `false`) e carregue-o em um dicionário Python.
    1. **Ler Arquivo com Valor Nulo** : Crie um arquivo JSON com valores `null` e use `json.load()` para carregá-lo e verificar como esses valores são representados em Python.
    1. **Ler Dados JSON Aninhados** : Crie um arquivo JSON que contenha um dicionário com outros dicionários e listas aninhadas, e use `json.load()` para carregá-lo.
    1. **Ler e Comparar Tipos** : Após carregar um arquivo JSON com `json.load()`, verifique se o tipo dos dados lidos corresponde ao tipo esperado (exemplo: lista, dicionário).
1. Exercícios Combinando `json.dumps()`, `json.loads()`, `json.dump()`, `json.load()`
    1. **Serializar e Desserializar Ciclo** : Converta um dicionário em JSON usando `json.dumps()`, depois use `json.loads()` para reverter a string JSON de volta para um dicionário.
    1. **Gravar e Ler de Arquivo** : Use `json.dump()` para gravar um dicionário em um arquivo e, em seguida, use `json.load()` para ler esse arquivo de volta para um objeto Python.
    1. **Manipulação Completa de JSON em Arquivo** : Serialize um objeto Python com `json.dumps()`, grave-o em um arquivo usando `json.dump()`, depois carregue-o do arquivo usando `json.load()` e faça uma alteração no objeto, finalizando com a regravação do arquivo.
    1. **Conversão e Verificação** : Converta uma lista de números em JSON, grave em um arquivo, leia novamente com `json.load()` e verifique se a lista lida é idêntica à original.

</details>

## variável `__name__ `

No Python, a variável especial `__name__` é uma variável interna definida automaticamente pelo interpretador sempre que um módulo é executado. Ela é usada para identificar o contexto em que um módulo Python está sendo executado, e seu valor pode mudar dependendo de como o módulo é utilizado.

### como funciona

Existem duas situações principais em que a variável `__name__` pode assumir valores diferentes:

1. **quando o módulo é executado diretamente** :
    - se o arquivo Python é executado diretamente (por exemplo, chamando o script diretamente pelo terminal ou pelo Python), o valor da variável `__name__` será `"__main__"`;
    - isso significa que o código do arquivo está sendo executado como o programa principal;

1. **quando o módulo é importado** :
    - se o arquivo Python é importado em outro arquivo como um módulo, a variável `__name__` recebe o nome do próprio módulo;
    - o nome do módulo é o nome do arquivo sem a extensão `.py`;

- **Exemplo**

Considere o seguinte código num arquivo chamado `funcoes.py`:

```python
# funcoes.py
def exibe_texto():
    print('Esta função foi chamada')
    print(f'{__name__ = }')

if __name__ == "__main__":
    exibe_texto()
```

- executando diretamente o arquivo `funcoes.py`

Quando se executa o arquivo diretamente (por exemplo, com o comando `python funcoes.py`), a variável `__name__` terá o valor `"__main__"`. Portanto, a saída será:

```
Esta função foi chamada
__name__ = '__main__'
```

- importando o módulo em outro arquivo

Agora, suponha que se tenha outro arquivo, chamado `main.py`, que importa o módulo `funcoes.py`:

```python
# main.py
import funcoes

funcoes.exibe_texto()
```

Ao executar `main.py`, a variável `__name__` no arquivo `funcoes.py` terá o valor `"funcoes"` (o nome do módulo). Isso ocorre porque `funcoes.py` está sendo importado como um módulo e não está sendo executado diretamente. A saída será:

```
Esta função foi chamada
__name__ = 'funcoes'
```

### usos comum

O principal motivo para usar a condição `if __name__ == "__main__":` em um script Python é para separar o código que deve ser executado apenas quando o módulo é executado diretamente daquele que deve ser executado quando o módulo é importado.

Essa prática é especialmente útil quando se deseja que um arquivo Python possa ser usado tanto como um script executável quanto como um módulo que pode ser importado por outros scripts sem que o código dentro da condição `if __name__ == "__main__":` seja executado automaticamente.

#### executar código de teste ou funcionalidade principal

Um arquivo Python pode ter múltiplas funções e classes. Ao usar `if __name__ == "__main__":`, pode-se escrever uma **função principal** ou blocos de teste que só serão executados quando o arquivo for rodado diretamente, sem interferir no comportamento quando o arquivo é importado como módulo em outro script.

- **Exemplo**

```python
# calculadora.py

def soma(a, b):
    return a + b

def subtracao(a, b):
    return a - b

if __name__ == "__main__":
    # testando a função quando o arquivo é executado diretamente
    print(soma(10, 5))  # saída: 15
    print(subtracao(10, 5))  # saída: 5
```

Aqui, ao rodar `python calculadora.py`, as funções `soma` e `subtracao` serão testadas, mas quando esse módulo for importado em outro arquivo, como `import calculadora`, esses testes não serão executados.

#### reaproveitar código como biblioteca

Ao dividir seu código em módulos reutilizáveis, pode-se evitar que blocos de código de execução (como testes ou configurações específicas) sejam executados quando esses módulos são importados em outro lugar. Isso permite o reaproveitamento de funções e classes sem efeitos colaterais indesejados.

Por exemplo, se alguém quiser usar apenas a função `soma()` do arquivo `calculadora.py`, ela poderá importá-la sem executar os testes:

```python
from calculadora import soma
resultado = soma(3, 4)
```

### vantagens

#### modularidade

Ao usar essa abordagem, consegue-se manter o código organizado e modular. Isso facilita a criação de bibliotecas ou pacotes onde várias partes do código podem ser importadas e reutilizadas em diferentes scripts, sem executar blocos de teste ou de configuração que são específicos para execução direta.

#### facilita o teste e depuração

É comum usar o bloco `if __name__ == "__main__":` para rodar uma série de testes simples ou demonstrações de como as funções do arquivo funcionam. Isso facilita a verificação rápida do comportamento de um módulo enquanto ele está sendo desenvolvido, sem a necessidade de escrever scripts de teste separados. Além disso, a integração com bibliotecas de testes como `unittest` se torna mais natural.

#### reaproveitamento de código

Como mencionado anteriormente, essa técnica possibilita que o mesmo arquivo seja usado de duas maneiras:
- como um **script executável** que pode rodar diretamente, com funcionalidades testáveis;
- como uma **biblioteca de funções ou classes** que pode ser importada sem rodar o código fora do escopo pretendido;

#### flexibilidade em aplicações mais complexas

Em programas mais complexos, pode-se usar esse padrão para definir comportamentos diferentes para quando o módulo é executado diretamente ou quando é importado em outro contexto. Por exemplo, pode-se ter um arquivo que tanto pode ser um módulo importável quanto um aplicativo completo, dependendo de como ele é invocado.

## exercícios `__name__`

<details>
<summary>Lista de Exercícios</summary>

1. **Exercício básico 1** : Crie um arquivo Python que tenha uma função chamada `saudacao()`, que imprima "Olá, mundo!". Use `if __name__ == "__main__":` para chamar essa função somente se o arquivo for executado diretamente.
1. **Exercício básico 2** : Crie um arquivo com uma função `soma(a, b)` que retorna a soma de dois números. Use `if __name__ == "__main__":` para testar essa função, imprimindo o resultado da soma de 3 e 4.
1. **Exercício de importação 1** : Crie dois arquivos Python. No primeiro, crie uma função `multiplica(a, b)` que retorna a multiplicação de dois números. No segundo arquivo, importe essa função e use-a sem executar nenhum código adicional do primeiro arquivo.
1. **Exercício de importação 2** : No arquivo principal, crie uma função `subtrai(a, b)` e, usando `if __name__ == "__main__":`, teste essa função. Depois, importe essa função em outro arquivo e teste-a novamente.
1. **Executar diretamente** : Crie um arquivo Python que defina uma função `imprime_lista(lista)` que imprime cada elemento de uma lista. Use `if __name__ == "__main__":` para testar a função com uma lista de números de 1 a 5.
1. **Evitar execução ao importar** : Crie um arquivo com uma função `imprime_ola()` que imprime "Olá!". No mesmo arquivo, use `if __name__ == "__main__":` para testar a função. Em outro arquivo, importe a função `imprime_ola()` e certifique-se de que nada mais seja executado ao importá-la.
1. **Múltiplas funções** : Crie um arquivo com duas funções: `dobro(n)` que retorna o dobro de um número e `triplo(n)` que retorna o triplo. Teste ambas as funções no bloco `if __name__ == "__main__":` com os números 2 e 3.
1. **Executar código adicional ao rodar diretamente** : Crie uma função `imprime_nome(nome)` que imprime "Olá, [nome]!". No bloco `if __name__ == "__main__":`, adicione um código que recebe o nome do usuário usando `input()` e o passe para a função `imprime_nome()`.
1. **Teste condicional** : Crie uma função `verifica_par(n)` que retorna `True` se um número for par e `False` se for ímpar. No bloco `if __name__ == "__main__":`, teste a função com o número 10 e imprima o resultado.
1. **Definição de constantes** : Crie um arquivo que defina uma constante `PI = 3.14`. No bloco `if __name__ == "__main__":`, calcule a área de um círculo com raio 5 e imprima o resultado.
1. **Importar e executar código** : Crie dois arquivos. No primeiro, crie uma função `quadrado(n)` que retorna o quadrado de um número e teste-a no bloco `if __name__ == "__main__":`. No segundo, importe e teste a função `quadrado()` sem executar o código adicional do primeiro arquivo.
1. **Verificação de strings** : Crie uma função `verifica_palindromo(palavra)` que retorna `True` se uma palavra for um palíndromo (mesma palavra lida de trás para frente). Use o bloco `if __name__ == "__main__":` para testar a função com a palavra "ana".
1. **Conversão de temperaturas** : Crie duas funções: `celsius_para_fahrenheit(c)` e `fahrenheit_para_celsius(f)`. Use o bloco `if __name__ == "__main__":` para testar as duas funções convertendo 100°C para Fahrenheit e 212°F para Celsius.
1. **Sequência de Fibonacci** : Crie uma função `fibonacci(n)` que imprime os primeiros `n` números da sequência de Fibonacci. No bloco `if __name__ == "__main__":`, peça ao usuário um número e imprima a sequência correspondente.
1. **Tabuada** : Crie uma função `tabuada(n)` que imprime a tabuada de multiplicação de 1 até 10 para o número `n`. No bloco `if __name__ == "__main__":`, peça ao usuário para digitar um número e imprima a tabuada desse número.
1. **Cálculo de fatorial** : Crie uma função `fatorial(n)` que calcula o fatorial de um número. Use o bloco `if __name__ == "__main__":` para testar a função com o número 5 e imprimir o resultado.
1. **Maior número de uma lista** : Crie uma função `maior_numero(lista)` que retorna o maior número de uma lista. No bloco `if __name__ == "__main__":`, crie uma lista de números e teste a função.
1. **Contagem de caracteres** : Crie uma função `conta_caracteres(string)` que retorna o número de caracteres em uma string. Teste essa função no bloco `if __name__ == "__main__":` com a string "Python".
1. **Média de uma lista** : Crie uma função `media(lista)` que retorna a média dos elementos de uma lista. Teste essa função no bloco `if __name__ == "__main__":` com uma lista de 5 números.
1. **Concatenação de strings** : Crie uma função `concatena_strings(s1, s2)` que retorna a concatenação de duas strings. No bloco `if __name__ == "__main__":`, peça ao usuário para digitar duas palavras e imprima a concatenação delas.

</details>

## wildcards

O uso de **wildcards** (`*`) ao importar módulos em Python, como em `from módulo import *`, permite que todas as funções, classes, e variáveis públicas do módulo sejam importadas de uma só vez, sem que seja necessário especificar explicitamente quais elementos você deseja importar.

### vantagens

1. **simplicidade** : facilita a importação quando você precisa de muitos elementos de um módulo, sem a necessidade de listar individualmente cada função ou classe;

    ```python
    from math import *

    print(sqrt(16))  # Não precisa especificar 'math.sqrt'
    ```

1. **conveniente em scripts curtos ou exploração interativa** : em ambientes interativos como o jupyter notebook, é prático quando você quer explorar rapidamente um módulo sem se preocupar com nomes específicos;

---

### desvantagens

1. **colisões de nomes** : ao importar tudo de um módulo, pode-se acabar sobrescrevendo funções ou variáveis que têm o mesmo nome em outros módulos ou no escopo atual do seu código, o que pode gerar erros difíceis de detectar;

    ```python
    from math import *
    from cmath import *

    print(sqrt(-1))  # De qual módulo 'sqrt' está sendo chamado?
    ```

1. **reduz a legibilidade** : quando se usa `import *`, fica difícil para outros desenvolvedores (e até para você mesmo) saber de onde vêm certas funções ou variáveis, especialmente em projetos grandes;

1. **carga desnecessária** : pode-se acabar importando funções ou variáveis que não são utilizadas, o que pode resultar em uma maior utilização de memória;

### por que usar?

- se está escrevendo scripts curtos, testes rápidos ou scripts de automação simples, o uso de `import *` pode ser conveniente para economizar tempo e tornar o código mais curto;
- em ambientes interativos, como no jupyter ou repl, o uso pode acelerar a experimentação;

### por que não usar?

- em projetos maiores ou bibliotecas, o uso de `import *` é desaconselhado porque reduz a clareza do código e aumenta o risco de colisão de nomes;
- torna a manutenção e depuração mais complicadas, especialmente quando múltiplos módulos estão envolvidos;

### alternativa recomendada

Se sabe exatamente quais funções ou classes deseja utilizar, é preferível importar apenas o necessário:

```python
from math import sqrt, pi
```

## exercícios wildcards

<details>
<summary>Lista de Exercícios</summary>

1. `from math import *` : Calcule a raiz quadrada de 49 e o logaritmo natural de 20.
1. `from random import *` : Gere 10 números aleatórios entre 1 e 100 e calcule a média.
1. `from time import *` : Exiba a data e a hora atual, e faça o código esperar 5 segundos antes de continuar.
1. `from os import *` : Crie um novo diretório chamado "exercicios" no sistema de arquivos atual.
1. `from sys import *` : Exiba o caminho do interpretador Python que está sendo usado.
1. `from json import *` : Converta um dicionário Python em uma string JSON e depois reconverta para um dicionário.

</details>

## `datetime`

O módulo `datetime` é fundamental para trabalhar com datas e horas, oferecendo uma ampla gama de funcionalidades para manipulação, formatação e cálculos com objetos de data e hora.

### visão geral

O módulo `datetime` fornece classes para manipular datas e horas de maneira simples e complexa. As principais classes disponíveis são:

1. **`date`** : representa uma data (ano, mês, dia);
1. **`time`** : representa um horário (hora, minuto, segundo, microsegundo);
1. **`datetime`** : combina informações de data e hora;
1. **`timedelta`** : representa a diferença entre duas datas, horas ou ambas;
1. **`tzinfo`** : fornece informações de fuso horário;
1. **`timezone`** : implementação concreta de `tzinfo` para fusos horários fixos;

### classe `date`

A classe `date` representa uma data no calendário gregoriano, composta por ano, mês e dia.

```python
from datetime import date

# data atual
hoje = date.today()
print(hoje)  # exemplo : 2024-04-27

# criando uma data específica
data_especifica = date(2023, 12, 25)
print(data_especifica)  # 2023-12-25
```

#### atributos

- **`year`** : ano (ex.: 2024);
- **`month`** : mês (1-12);
- **`day`** : dia do mês (1-31);

#### métodos comuns

- **`today()`** : retorna a data atual;
- **`fromtimestamp(timestamp)`** : cria uma data a partir de um timestamp POSIX;
- **`weekday()`** : retorna o dia da semana como um inteiro (0=segunda, 6=domingo);
- **`isoformat()`** : retorna a data no formato ISO 8601 (YYYY-MM-DD);

#### exemplo

```python
from datetime import date

# data atual
hoje = date.today()
print(f"Hoje é: {hoje}")

# dia da semana
dia_semana = hoje.weekday()
dias = ['Segunda', 'Terça', 'Quarta', 'Quinta', 'Sexta', 'Sábado', 'Domingo']
print(f"Dia da semana: {dias[dia_semana]}")

# formatação ISO
print("Formato ISO:", hoje.isoformat())
```

### classe `time`

A classe `time` representa um horário, independentemente da data.

```python
from datetime import time

# horário atual (não necessariamente o sistema)
horario = time(14, 30, 45)
print(horario)  # 14:30:45
```

#### atributos

- **`hour`** : hora (0-23);
- **`minute`** : minuto (0-59);
- **`second`** : segundo (0-59);
- **`microsecond`** : microssegundo (0-999999);
- **`tzinfo`** : informações de fuso horário;

#### métodos comuns

- **`isoformat()`** : retorna o horário no formato ISO 8601 (HH:MM:SS.microsegundos);

#### exemplo

```python
from datetime import time

# criando um horário específico
horario = time(9, 15, 30)
print(f"Horário: {horario}")

# formatação ISO
print("Formato ISO:", horario.isoformat())
```

### classe `datetime`

A classe `datetime` combina informações de data e hora em um único objeto.

```python
from datetime import datetime

# data e hora atual
agora = datetime.now()
print(agora)  # exemplo : 2024-04-27 14:30:45.123456

# criando uma data e hora específica
data_hora = datetime(2023, 12, 25, 18, 30, 0)
print(data_hora)  # 2023-12-25 18:30:00
```

#### atributos

- **`year`**, **`month`**, **`day`**;
- **`hour`**, **`minute`**, **`second`**, **`microsecond`**;
- **`tzinfo`**;

#### métodos comuns

- **`now()`** : retorna a data e hora atual.;
- **`utcnow()`** : retorna a data e hora atual em UTC.;
- **`fromtimestamp(timestamp)`** : cria um `datetime` a partir de um timestamp POSIX.;
- **`strftime(formato)`** : formata o `datetime` em uma string de acordo com o formato especificado.;
- **`strptime(string, formato)`** : cria um `datetime` a partir de uma string e um formato.;

#### exemplo

```python
from datetime import datetime

# data e hora atual
agora = datetime.now()
print(f"Agora: {agora}")

# formatação personalizada
formatado = agora.strftime("%d/%m/%Y %H:%M:%S")
print(f"Formatado: {formatado}")

# parsing de string para datetime
data_str = "25/12/2023 18:30:00"
data_convertida = datetime.strptime(data_str, "%d/%m/%Y %H:%M:%S")
print(f"Data convertida: {data_convertida}")
```

### classe `timedelta`

A classe `timedelta` representa uma diferença entre duas datas, horas ou ambos. É útil para realizar cálculos com datas e horas.

```python
from datetime import timedelta

# diferenca de 5 dias
diferenca = timedelta(days=5)
print(diferenca)  # 5 days, 0:00:00

# diferenca de 2 semanas, 3 dias e 4 horas
diferenca_complexa = timedelta(weeks=2, days=3, hours=4)
print(diferenca_complexa)  # 17 days, 4:00:00
```

#### atributos

- **`days`**;
- **`seconds`**;
- **`microseconds`**;
- **`weeks`**, **`hours`**, **`minutes`**, **`milliseconds`**, etc. (passados como argumentos);

#### exemplo

```python
from datetime import datetime, timedelta

# data atual
agora = datetime.now()

# adicionando 10 dias
futuro = agora + timedelta(days=10)
print(f"Futuro: {futuro}")

# subtraindo 2 horas
passado = agora - timedelta(hours=2)
print(f"Passado: {passado}")

# diferença entre duas datas
data1 = datetime(2023, 1, 1)
data2 = datetime(2024, 1, 1)
diferenca = data2 - data1
print(f"Diferença: {diferenca}")  # 365 days, 0:00:00
```

### classes `tzinfo` e `timezone`

A classe `tzinfo` é uma classe abstrata que fornece informações sobre fusos horários. A classe `timezone` é uma implementação concreta de `tzinfo` para fusos horários com deslocamento fixo em relação ao UTC.

#### trabalhando com fusos horários

```python
from datetime import datetime, timezone, timedelta

# UTC
utc = timezone.utc
agora_utc = datetime.now(utc)
print(f"UTC: {agora_utc}")

# Fuso horário com deslocamento de +3 horas
fuso_plus3 = timezone(timedelta(hours=3))
agora_plus3 = datetime.now(fuso_plus3)
print(f"UTC+3: {agora_plus3}")

# Fuso horário com deslocamento de -5 horas
fuso_minus5 = timezone(timedelta(hours=-5))
agora_minus5 = datetime.now(fuso_minus5)
print(f"UTC-5: {agora_minus5}")
```
<!--
#### exemplo Avançado com `pytz`

Para fusos horários mais complexos que envolvem regras de horário de verão, é recomendado usar a biblioteca `pytz` (não faz parte do módulo `datetime` padrão).

```python
from datetime import datetime
import pytz

# Fuso horário de São Paulo
fuso_sp = pytz.timezone('America/Sao_Paulo')
agora_sp = datetime.now(fuso_sp)
print(f"São Paulo: {agora_sp}")

# Fuso horário de Nova York
fuso_ny = pytz.timezone('America/New_York')
agora_ny = datetime.now(fuso_ny)
print(f"Nova York: {agora_ny}")
```

*Nota: Para usar `pytz`, você precisa instalá-lo via `pip install pytz`.* -->

### formatação e parsing

A formatação e parsing de datas e horas são essenciais para converter objetos `datetime` em strings e vice-versa.

#### `strftime` - formatação

O método `strftime` permite formatar objetos `datetime` em strings usando códigos de formatação.

| Código | Descrição                             | Exemplo |
|--------|---------------------------------------|---------|
| `%Y`   | ano com século (e.g., 2024)           | 2024    |
| `%m`   | mês como número decimal (01-12)       | 04      |
| `%d`   | dia do mês (01-31)                     | 27      |
| `%H`   | hora (00-23)                           | 14      |
| `%M`   | minuto (00-59)                         | 30      |
| `%S`   | segundo (00-59)                        | 45      |
| `%f`   | microssegundos (000000-999999)         | 123456  |
| `%A`   | nome completo do dia da semana        | Sábado  |
| `%B`   | nome completo do mês                   | Abril   |

**Exemplo**

```python
from datetime import datetime

agora = datetime.now()
formato = agora.strftime("%d/%m/%Y %H:%M:%S")
print(f"Formatado: {formato}")  # exemplo : 27/04/2024 14:30:45
```

#### `strptime` - parsing

O método `strptime` converte uma string em um objeto `datetime` de acordo com o formato especificado.

**Exemplo**

```python
from datetime import datetime

data_str = "25/12/2023 18:30:00"
formato = "%d/%m/%Y %H:%M:%S"
data_hora = datetime.strptime(data_str, formato)
print(f"Data e Hora: {data_hora}")  # 2023-12-25 18:30:00
```

### operações comuns

#### comparando datas e horas

Objetos `datetime` podem ser comparados diretamente.

```python
from datetime import datetime

data1 = datetime(2023, 1, 1)
data2 = datetime(2024, 1, 1)

if data1 < data2:
    print("data1 é anterior a data2")
else:
    print("data1 não é anterior a data2")
```

#### extraindo componentes

É possível acessar os componentes individuais de um objeto `datetime`.

```python
from datetime import datetime

agora = datetime.now()
print(f"Ano: {agora.year}")
print(f"Mês: {agora.month}")
print(f"Dia: {agora.day}")
print(f"Hora: {agora.hour}")
print(f"Minuto: {agora.minute}")
print(f"Segundo: {agora.second}")
```

#### substituindo componentes

É possível criar um novo objeto `datetime` com alguns componentes alterados usando o método `replace`.

```python
from datetime import datetime

agora = datetime.now()
novo_datetime = agora.replace(year=2025, month=12)
print(novo_datetime)
```

### manipulação avançada com `timedelta`

Além de adicionar ou subtrair `timedelta`, também é possível realizar operações mais complexas.

#### diferença entre datas

```python
from datetime import datetime

data1 = datetime(2024, 4, 27)
data2 = datetime(2023, 12, 25)
diferenca = data1 - data2
print(f"Diferença: {diferenca.days} dias")
```

#### multiplicação e divisão com `timedelta`

```python
from datetime import timedelta

delta = timedelta(days=2, hours=3)
multiplicado = delta * 3
print(multiplicado)  # 6 days, 9:00:00

dividido = delta / 2
print(dividido)  # 1 day, 15:00:00
```

### fusos horários avançados com `zoneinfo` (python 3.9+)

A partir do Python 3.9, o módulo `zoneinfo` foi introduzido para fornecer suporte nativo a fusos horários com base no banco de dados IANA.

#### uso básico

```python
from datetime import datetime
from zoneinfo import ZoneInfo

# fuso horário de São Paulo
fuso_sp = ZoneInfo("America/Sao_Paulo")
agora_sp = datetime.now(fuso_sp)
print(f"São Paulo: {agora_sp}")

# fuso horário de Tóquio
fuso_tokyo = ZoneInfo("Asia/Tokyo")
agora_tokyo = datetime.now(fuso_tokyo)
print(f"Tóquio: {agora_tokyo}")
```

#### conversão entre fusos horários

```python
from datetime import datetime
from zoneinfo import ZoneInfo

# hora atual em UTC
utc = ZoneInfo("UTC")
agora_utc = datetime.now(utc)
print(f"UTC: {agora_utc}")

# convertendo para horário de Nova York
fuso_ny = ZoneInfo("America/New_York")
agora_ny = agora_utc.astimezone(fuso_ny)
print(f"Nova York: {agora_ny}")
```

*Nota: É necessário ter o banco de dados de fusos horários disponível no sistema para que `zoneinfo` funcione corretamente.*

### exemplos práticos

Veja alguns exemplos práticos.

#### exemplo 1: calculando idade

```python
from datetime import date

def calcular_idade(data_nascimento):
    hoje = date.today()
    idade = hoje.year - data_nascimento.year - ((hoje.month, hoje.day) < (data_nascimento.month, data_nascimento.day))
    return idade

nascimento = date(1990, 5, 15)
idade = calcular_idade(nascimento)
print(f"Idade: {idade} anos")
```

#### exemplo 2: agendamento de eventos

```python
from datetime import datetime, timedelta

# data e hora do evento
evento = datetime(2024, 12, 31, 23, 59, 59)
agora = datetime.now()

# tempo restante
tempo_restante = evento - agora
print(f"Tempo restante para o evento: {tempo_restante}")

# verificando se o evento já passou
if agora > evento:
    print("O evento já ocorreu.")
else:
    print("O evento ainda está por vir.")
```

#### exemplo 3: formatação de logs

```python
from datetime import datetime

def log_mensagem(mensagem):
    agora = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    print(f"[{agora}] {mensagem}")

log_mensagem("Iniciando o processo...")
log_mensagem("Processo concluído com sucesso.")
```

#### exemplo 4: calculo julian date

```python
import sys
from datetime import datetime, timedelta

def calcula_julian():
    try:
        dias = int(input('digite o nr dias : '))
    except ValueError as erro:
        print('digite um numero valido')
        print(f'{erro = }')
        sys.exit(0)

    agora = datetime.now()
    ano_atual = agora.year

    inicio = datetime(ano_atual,1,1)

    julian_date = inicio + timedelta(days=dias-1)

    return julian_date

if __name__ == '__main__':
    for _ in range(10):
        julian = calcula_julian()
        print(julian.strftime("%d/%m/%Y"))
```

### Boas Práticas

1. **Sempre usar `datetime.now(tz=timezone.utc)` para armazenar datas e horas em UTC**, facilitando a conversão para outros fusos horários e evitando problemas com horário de verão;
1. **Utilizar o módulo `zoneinfo` (Python 3.9+)`** para manipulação avançada de fusos horários;
1. **Evitar a manipulação manual de strings para datas e horas**, preferindo métodos como `strftime` e `strptime` para garantir consistência;
1. **Utilizar `timedelta` para cálculos de diferenças de tempo**, garantindo precisão e evitando erros comuns em cálculos manuais;

## exercícios `datetime`

<details>
<summary>Lista de Exercícios</summary>

1. Exercícios sobre `date`
    1. Crie um objeto `date` que represente a data do seu aniversário.
    1. Exiba o ano, mês e dia da data atual usando o objeto `date`.
    1. Usando o método `today()`, exiba a data atual no formato `dd/mm/yyyy`.
    1. Crie uma função que receba um ano, mês e dia como argumentos e retorne o dia da semana dessa data.
    1. Utilize o método `fromtimestamp()` para criar uma data a partir do timestamp `1609459200` (representando 1 de janeiro de 2021).
    1. Exiba a data atual no formato ISO 8601 (`yyyy-mm-dd`) utilizando o método `isoformat()`.
    1. Crie uma função que receba duas datas e retorne a diferença entre elas em dias.
    1. Verifique se o dia 25 de dezembro de 2025 será uma sexta-feira.
    1. Crie um programa que pergunte a data de nascimento do usuário e calcule quantos dias faltam até o próximo aniversário.
    1. Escreva uma função que receba uma lista de datas e retorne a mais recente.
1. Exercícios sobre `time`
    1. Crie um objeto `time` que represente o horário 14:35:00.
    1. Exiba as horas, minutos e segundos de um objeto `time` que representa 18:45:30.
    1. Usando o método `isoformat()`, exiba o horário `08:15:45` no formato ISO (`hh:mm:ss`).
    1. Crie uma função que receba duas horas diferentes e retorne a diferença em segundos.
    1. Crie um objeto `time` que inclua microssegundos e exiba-os.
    1. Modifique um objeto `time` para alterar apenas os minutos, sem mudar os outros componentes.
    1. Escreva um programa que pergunte ao usuário a hora atual e exiba a hora em 12 horas (AM/PM).
    1. Verifique se o horário `23:59:59` é anterior ao horário `00:00:00` do dia seguinte.
    1. Crie uma função que receba um horário e adicione 15 minutos a ele.
    1. Exiba o horário atual sem exibir microssegundos.
1. Exercícios sobre `datetime`
    1. Crie um objeto `datetime` que represente 1º de janeiro de 2022 às 12:30:45.
    1. Exiba apenas a data de um objeto `datetime` que contém informações de data e hora.
    1. Utilize o método `now()` para exibir a data e hora atuais no formato `dd/mm/yyyy hh:mm:ss`.
    1. Converta o timestamp `1635724800` para um objeto `datetime`.
    1. Crie uma função que receba uma string no formato `dd/mm/yyyy hh:mm:ss` e converta-a para um objeto `datetime`.
    1. Crie uma função que receba uma data e hora e exiba o dia da semana correspondente.
    1. Adicione 10 dias e 5 horas a um objeto `datetime`.
    1. Crie um programa que pergunte ao usuário uma data e hora e calcule quantos dias faltam até o ano novo.
    1. Verifique se o `datetime(2023, 5, 20, 14, 30)` é anterior ao `datetime(2024, 1, 1, 0, 0)`.
    1. Escreva uma função que, dado um objeto `datetime`, retorne o nome do mês (ex.: Janeiro).
1. Exercícios sobre `timedelta`
    1. Crie um objeto `timedelta` que represente 3 dias, 2 horas e 30 minutos.
    1. Subtraia 7 dias da data atual utilizando `timedelta`.
    1. Crie uma função que receba duas datas e retorne a diferença entre elas em horas.
    1. Multiplique um objeto `timedelta` de 2 horas por 5 e exiba o resultado.
    1. Escreva um programa que calcule a diferença entre o horário atual e o meio-dia de hoje.
    1. Adicione 30 dias a uma data específica utilizando `timedelta`.
    1. Crie uma função que retorne quantos segundos existem em 3 dias, 5 horas e 10 minutos.
    1. Verifique se a diferença entre duas datas é maior que 1 mês, usando `timedelta`.
    1. Subtraia 45 minutos do horário atual e exiba o resultado.
    1. Calcule a diferença entre a meia-noite e o horário atual em minutos.
1. Exercícios sobre `timezone` e `zoneinfo`
    1. Crie um objeto `timezone` para o fuso horário UTC e exiba a hora atual em UTC.
    1. Converta o horário atual de UTC para o fuso horário de `UTC+3`.
    1. Crie uma função que receba uma data e hora e converta para o fuso horário de Nova York usando `zoneinfo`.
    1. Exiba a hora atual no fuso horário de Tóquio utilizando `zoneinfo`.
    1. Verifique a diferença de horas entre São Paulo e Londres usando `zoneinfo`.
    1. Crie um objeto `datetime` que represente a hora atual com o fuso horário UTC e converta-o para o fuso horário de `America/Sao_Paulo`.
    1. Crie uma função que receba duas datas em diferentes fusos horários e retorne qual é anterior.
    1. Converta a data e hora atual do fuso horário `UTC+5` para o fuso horário `UTC-2`.
    1. Crie um programa que pergunte ao usuário a cidade e exiba a hora atual dessa cidade usando `zoneinfo`.
    1. Verifique a diferença de tempo entre duas cidades à sua escolha utilizando `zoneinfo`.
1. Exercícios sobre classes
    1. Crie uma classe `Evento` com os atributos `nome` e `data_inicio` (um objeto `datetime`). Adicione um método que retorne o nome do evento e sua data no formato `dd/mm/yyyy hh:mm`.
    1. Implemente uma classe `Tarefa` que tenha os atributos `descricao`, `data_criacao` (um objeto `date`) e `data_entrega` (outro objeto `date`). Adicione um método que informe quantos dias faltam até a entrega.
    1. Desenvolva uma classe `Relogio` que tenha o atributo `hora_atual` (um objeto `time`). Adicione um método que exiba o horário no formato de 12 horas com AM/PM.
    1. Crie uma classe `Compromisso` com os atributos `descricao`, `data_compromisso` (um objeto `datetime`) e `duracao` (um objeto `timedelta`). Adicione um método que retorne a data de término do compromisso.
    1. Implemente uma classe `EventoRepetido` com os atributos `nome`, `data_inicio` (um objeto `datetime`) e `frequencia` (um objeto `timedelta`). Adicione um método que retorne a próxima data do evento com base na frequência.
    1. Escreva uma classe `JornadaDeTrabalho` com os atributos `hora_inicio` e `hora_fim` (ambos objetos `time`). Adicione um método que calcule a quantidade de horas trabalhadas.
    1. Crie uma classe `AluguelDeCarro` com os atributos `data_inicio`, `data_fim` (objetos `datetime`). Adicione um método que calcule o valor total do aluguel, sabendo que o preço por dia é de R$100.
    1. Desenvolva uma classe `DataFormatada` com um atributo `data` (um objeto `date`). Adicione métodos para retornar a data nos formatos `yyyy-mm-dd` e `dd/mm/yyyy`.
    1. Implemente uma classe `Viagem` com os atributos `destino`, `data_partida` e `data_retorno` (ambos objetos `datetime`). Adicione um método que informe quantos dias a viagem vai durar.
    1. Crie uma classe `Projeto` com os atributos `nome_projeto`, `data_inicio`, `data_prevista_termino` (ambos objetos `date`). Adicione um método que retorne se o projeto está dentro do prazo (comparando a data atual com a data de término).
    1. Desenvolva uma classe `RegistroDePonto` com os atributos `hora_entrada` e `hora_saida` (objetos `datetime`). Adicione um método que calcule a quantidade de horas trabalhadas em um dia.
    1. Escreva uma classe `Aluno` com os atributos `nome`, `data_nascimento` (um objeto `date`). Adicione um método que calcule a idade do aluno.
    1. Crie uma classe `Treinamento` com os atributos `modalidade`, `hora_inicio`, `hora_fim` (objetos `time`). Adicione um método que exiba o tempo total de duração do treinamento.
    1. Implemente uma classe `Lembrete` com os atributos `mensagem`, `data_lembrete` (um objeto `datetime`). Adicione um método que verifique se o lembrete está configurado para uma data no passado ou futuro.
    1. Desenvolva uma classe `ConsultaMedica` com os atributos `paciente`, `data_consulta` (um objeto `datetime`) e `duracao` (um objeto `timedelta`). Adicione um método que exiba o horário de término da consulta.
    1. Crie uma classe `Encontro` com os atributos `local`, `data` (um objeto `date`) e `hora` (um objeto `time`). Adicione um método que exiba a data e hora do encontro no formato: `dd/mm/yyyy às hh:mm`.
    1. Escreva uma classe `Contrato` com os atributos `nome_cliente`, `data_assinatura` (um objeto `date`) e `data_vencimento` (outro objeto `date`). Adicione um método que calcule quantos dias faltam para o vencimento do contrato.
    1. Implemente uma classe `Corrida` com os atributos `distancia`, `hora_inicio` (um objeto `datetime`) e `tempo_estimado` (um objeto `timedelta`). Adicione um método que retorne a previsão de término da corrida.
    1. Desenvolva uma classe `ReservaDeQuarto` com os atributos `numero_quarto`, `data_checkin` e `data_checkout` (objetos `datetime`). Adicione um método que informe quantas noites o hóspede vai ficar no hotel.
    1. Crie uma classe `Feriado` com os atributos `nome`, `data_feriado` (um objeto `date`). Adicione um método que informe quantos dias faltam para o próximo feriado a partir da data atual.

</details>


# namespaces.md

Índice

1. [conceito de namespace](#conceito-de-namespace)
1. [tipos de namespaces](#tipos-de-namespaces)
    1. [1. namespace local](#1-namespace-local)
    1. [2. namespace global](#2-namespace-global)
    1. [3. namespace built-in](#3-namespace-built-in)
1. [hierarquia dos namespaces](#hierarquia-dos-namespaces)
1. [modificando variáveis globais dentro de funções](#modificando-variáveis-globais-dentro-de-funções)
1. [namespaces e módulos](#namespaces-e-módulos)
1. [exercícios](#exercícios)

# namespaces

Namespaces em Python são sistemas que garantem que os nomes de variáveis, funções, classes e outros identificadores usados em um programa sejam únicos e não entrem em conflito uns com os outros. Eles funcionam como contêineres que mapeiam nomes para objetos correspondentes, de forma que diferentes partes de um código possam usar os mesmos nomes sem interferir umas nas outras.

## conceito de namespace

Um namespace é essencialmente uma tabela de símbolos (ou um mapeamento) que relaciona nomes com objetos (valores, funções, classes, etc.). Cada nome é uma chave, e o objeto associado a ele é o valor.

Exemplo :

Imagine que tenha duas variáveis com o mesmo nome em contextos diferentes :

```python
def funcao1():
    variavel = 10
    print(variavel)

def funcao2():
    variavel = 20
    print(variavel)

funcao1()  # saída : 10
funcao2()  # saída : 20
```

Aqui, `variavel` é usada em ambas as funções, mas cada uso pertence a um namespace diferente (o namespace de cada função). Portanto, as duas variáveis `variavel` não entram em conflito, pois estão em namespaces separados.

## tipos de namespaces

Em Python, existem três tipos principais de namespaces:

1. **namespace local**
2. **namespace global**
3. **namespace built-in**

### 1. namespace local

Este é o namespace que é criado cada vez que uma função é chamada. Ele contém os nomes das variáveis locais e outros objetos definidos dentro da função. Quando a função termina, seu namespace local é destruído.

```python
def minha_funcao():
    x = 5  # x está no namespace local de minha_funcao
    print(x)

minha_funcao()  # saída : 5
```

Dentro de `minha_funcao`, `x` pertence ao namespace local da função.

### 2. namespace global

O namespace global é o espaço que contém todos os nomes definidos no nível principal de um script ou módulo. Ele existe desde o início da execução do programa até o seu término. Todas as variáveis, funções e classes definidas fora de qualquer função pertencem ao namespace global.

```python
x = 10  # x está no namespace global

def minha_funcao():
    print(x)

minha_funcao()  # saída : 10
```

Aqui, `x` pertence ao namespace global, e `minha_funcao` pode acessar `x` diretamente, pois ela não tem uma variável `x` no seu namespace local.

### 3. namespace built-in

O namespace built-in é criado pelo próprio Python e contém todas as funções e objetos que estão sempre disponíveis, como `print()`, `len()`, `int()`, entre outros. Este namespace é acessível de qualquer lugar no código.

```python
print(len("Python"))  # len é uma função built-in
```

A função `len()` pertence ao namespace built-in, por isso pode ser usada sem precisar importar ou definir.

### hierarquia dos namespaces

A Python segue uma ordem específica para resolver nomes, conhecida como a regra LEGB :

1. **Local** : o primeiro lugar que Python procura por um nome é no namespace local (dentro de uma função, por exemplo);
2. **Enclosing** : se o nome não é encontrado no namespace local, Python procura no namespace da função que contém outra função (para casos de funções aninhadas);
3. **Global** : se não for encontrado no namespace local ou enclosing, Python procura no namespace global;
4. **Built-in** : finalmente, se o nome não for encontrado em nenhum dos namespaces anteriores, Python procura no namespace built-in;

Exemplo :

```python
x = "global"

def funcao_externa():
    x = "enclosing"

    def funcao_interna():
        x = "local"
        print(x)

    funcao_interna()

funcao_externa()  # saída : local
```

Aqui, a função `funcao_interna` encontra `x` no seu namespace local. Se a linha `x = "local"` fosse removida, ela procuraria `x` no namespace enclosing (o namespace de `funcao_externa`), e assim por diante até encontrar o nome ou gerar um erro.

## modificando variáveis globais dentro de funções

Se quiser modificar uma variável global dentro de uma função, precisa usar a palavra-chave `global`. Caso contrário, Python considerará que está criando uma nova variável local.

```python
x = 10

def modificar_x():
    global x
    x = 20

modificar_x()
print(x)  # saída : 20
```

Aqui, `global x` informa ao Python que `x` dentro da função refere-se à `x` do namespace global.

## namespaces e módulos

Cada módulo em Python tem seu próprio namespace global, que é independente dos namespaces globais de outros módulos. Isso permite que tenha variáveis e funções com os mesmos nomes em diferentes módulos sem que eles entrem em conflito.

Exemplo :

```python
# modulo1.py
x = 10

def mostrar():
    print("Modulo 1:", x)

# modulo2.py
x = 20

def mostrar():
    print("Modulo 2:", x)

# main.py
import modulo1
import modulo2

modulo1.mostrar()  # saída : Modulo 1: 10
modulo2.mostrar()  # saída : Modulo 2: 20
```

Aqui, `modulo1` e `modulo2` têm suas próprias variáveis `x`, e elas não interferem uma na outra porque estão em namespaces separados.

## exercícios

<details>
<summary>Lista de Exercícios</summary>

1. Crie um módulo chamado `animais.py` com uma variável global `especies` e uma função `listar_especies()`. No script principal, importe o módulo e altere a variável `especies` diretamente. Em seguida, use a função `listar_especies()` para imprimir as espécies.
1. Crie um módulo chamado `numeros.py` com uma variável global `n` e uma função `incrementar_n()` que aumenta o valor de `n` em 1. No script principal, importe o módulo e chame `incrementar_n()` duas vezes. Imprima o valor de `n` após cada chamada da função.
1. Crie um módulo chamado `contas.py` com uma variável global `saldo` e uma função `depositar(valor)` que adiciona um valor ao saldo. No script principal, importe o módulo e faça um depósito de `100` e depois de `50`. Imprima o saldo após cada depósito.
1. Crie um módulo chamado `mensagens.py` com uma variável global `mensagem` e uma função `atualizar_mensagem(nova_mensagem)`. No script principal, importe o módulo e atualize a `mensagem` para `"Olá, Mundo!"` e imprima o valor da mensagem após a atualização.
1. Crie um módulo chamado `configuracoes.py` com uma variável global `config` e uma função `alterar_configuracao(chave, valor)`. No script principal, importe o módulo e altere uma configuração específica. Imprima o valor da configuração alterada.
1. Crie um módulo chamado `matematica.py` com uma função `adicionar(a, b)` que retorna a soma de dois números e uma variável global `resultado`. No script principal, importe o módulo e use a função `adicionar()` para calcular a soma de `5` e `7`, e depois imprima o valor da variável `resultado`.
1. Crie um módulo chamado `util.py` com uma função `multiplicar(a, b)` que retorna o produto de dois números e uma variável global `produto`. No script principal, importe o módulo, use a função `multiplicar()` e depois imprima o valor da variável `produto`.
1. Crie um módulo chamado `lista_util.py` com uma função `adicionar_elemento(lista, elemento)` que adiciona um elemento a uma lista e uma variável global `lista`. No script principal, importe o módulo e adicione dois elementos à lista, imprimindo a lista após cada adição.
1. Crie um módulo chamado `calendario.py` com uma função `adicionar_dia(dias)` que adiciona dias à variável global `data` e uma variável global `data`. No script principal, importe o módulo e adicione `10` dias à data. Imprima a data após a adição.
1. Crie um módulo chamado `personagem.py` com uma variável global `nome` e uma função `alterar_nome(novo_nome)`. No script principal, importe o módulo, altere o nome do personagem e imprima o nome alterado.
1. Crie um módulo chamado `valores.py` com uma função `atribuir_valor(chave, valor)` e uma variável global `valores`. No script principal, importe o módulo e atribua valores a várias chaves. Imprima o dicionário `valores` após as atribuições.
1. Crie um módulo chamado `estatisticas.py` com uma função `calcular_media(lista)` que retorna a média dos valores em uma lista e uma variável global `media`. No script principal, importe o módulo e calcule a média de uma lista de números, imprimindo o valor da variável `media`.
1. Crie um módulo chamado `configuracoes_usuario.py` com uma função `definir_preferencias(preferencias)` e uma variável global `preferencias`. No script principal, importe o módulo e defina e imprima preferências de usuário.
1. Crie um módulo chamado `dados_pessoais.py` com uma função `atualizar_dados(nome, idade)` e variáveis globais `nome` e `idade`. No script principal, importe o módulo, atualize e imprima os dados pessoais.
1. Crie um módulo chamado `historia.py` com uma função `adicionar_evento(evento)` que adiciona eventos à lista global `eventos`. No script principal, importe o módulo e adicione três eventos à lista. Imprima a lista após cada adição.
1. Crie um módulo chamado `itens.py` com uma função `adicionar_item(item)` e uma variável global `itens`. No script principal, importe o módulo e adicione três itens à lista. Imprima a lista de itens após cada adição.
1. Crie um módulo chamado `estoque.py` com uma função `adicionar_estoque(item, quantidade)` e uma variável global `estoque`. No script principal, importe o módulo e adicione estoque para dois itens diferentes, imprimindo o estoque após cada adição.
1. Crie um módulo chamado `email.py` com uma função `enviar_email(destinatario, assunto, corpo)` e uma variável global `enviado`. No script principal, importe o módulo e envie um e-mail, alterando o valor da variável `enviado` para `True` após o envio. Imprima o valor da variável.
1. Crie um módulo chamado `jogador.py` com uma função `atualizar_pontuacao(pontuacao)` e uma variável global `pontuacao`. No script principal, importe o módulo e atualize a pontuação do jogador em três etapas. Imprima a pontuação após cada atualização.
1. Crie um módulo chamado `projetos.py` com uma função `adicionar_projeto(nome)` e uma variável global `projetos`. No script principal, importe o módulo e adicione três projetos à lista. Imprima a lista de projetos após cada adição.

</details>


# o-que-eh-logica.md

Índice Introdução à Lógica de Programação

1. [o que é lógica](#o-que-é-lógica)
1. [lógica no dia a dia](#lógica-no-dia-a-dia)
1. [e a lógica de programação](#e-a-lógica-de-programação)
1. [o que é um algoritmo](#o-que-é-um-algoritmo)
1. [algoritmizando a lógica](#algoritmizando-a-lógica)
1. [resumo](#resumo)
1. [atividades](#atividades)

# introdução à lógica de programação

## o que é lógica

O uso corriqueiro da palavra lógica está normalmente relacionado à coerência e à racionalidade. Frequentemente se associa lógica apenas à matemática, não se percebendo sua aplicabilidade e sua relação com as demais ciências, bem como seu emprego cotidiano nas ações do dia a dia, quando alguma decisão é tomada de forma racional.

A lógica pode ser relacionada com a *correção do pensamento*, pois uma de suas preocupações é determinar quais operações são válidas e quais não são. Como filosifia, ela procura saber porque pensamos assim e não de outro jeito. Com arte ou técnica, ela nos ensina a usar corretamente as leis do pensamento.

Pode-se dizer que a lógica é a *arte de bem pensar*, que é a *ciência das formas do pensamento*. Como a forma mais complexa de pensamento é o raciocínio, a lógica estuda a *correção do raciocínio*. Pode-se dizer ainda que a lógica tem em vista a *ordem da razão*. Isso dá a entender que a nossa razão pode funcionar desordenadamente. Por isso, a lógica estuda e ensina a colocar `ordem no pensamento`.

Exemplos :
- Todo mamífero é um animal. Todo cavalo é um mamífero. Portanto, todo cavalo é um animal;
- Kaiton é um país do planeta Stix. Todos os Xinpins são de Kaiton. Logo, todos os Xinpins são Stixianos;

Esses exemplos ilustram silogismos, que no estudo da Lógica Proposicional representam um argumento composto de duas premissas e uma conclusão; e está estabelecendo uma relação, que pode ser válida ou não. Esse é um dos objetivos da lógica, o estudo de técnicas de formalização, dedução e análise que permitam verificar a validade de argumentos. No caso dos exemplos, ambos são válidos.

Vale a pena ressaltar que, apesar da aparente coerência de um encadeamento lógico, ele pode ser válido ou nãp em sua estrutura. Nesse sentido, a lógica também objetiva a criação de uma representação mais formal, contrapondo-se à linguagem natural, que é suscetível a argumentações informais e problemas de interpretação.

Exemplos :
- Todo escorpião é um invertebrado. Algumas pessoas são de escorpião. Logo, algumas pessoas são invertebradas;

## lógica no dia a dia

Sempre que há um pensamento, a lógica ou a ilógica necessariamente acompanha. Quando se escreve ou fala, um pensamento está sendo expressado, logo é necessário usar lógica nessas atividades. Pode-se perceber a importância da lógica na vida, não só na teoria, como na prática. Quando se quer falar, pensar ou agir corretamente, é preciso colocar *ordem no pensamento*, isto é, usar a lógica.

Exemplos :
- A gaveta está fechada. A caneta está dentro da gaveta. É preciso primeiro abrir a gaveta para depois pegar a caneta;
- Anastácia é mais velha que Gioconda. Gioconda é mais velha que Lucineide. Portanto, Anastácia é mais velha que Lucineide;

## e a lógica de programação

Significa o uso correto s leis do pensamento, da *ordem da razão* e de processos de raciocínio e simbolização formais na programação de computadores, objetivando a racionalidade e o desenvolvimento de técnicas que cooperem para a produção de soluções logicamente válidas e coerentes, que resolvam os problemas que se deseja programar.

O raciocínio é algo abstrato. Os seres humanos têm a capacidade de expressá-lo através da palavra falada ou escrita, que por vez, se baseia em um determinado idioma, que segue uma série de padrões. Um mesmo racioncínio pode ser expresso em qualquer um dos idiomas existentes, mas continuará representando o mesmo raciocínio, usando apenas outra convenção.

Algo similar acontece com a Lógica de Programação, que pode ser criada pela mente treinada e pode ser representada em qualquer uma das inúmeras linguagens de programação existentes. Essas, por sua vez, são atreladas a uma grande diversidade de detalhes computacionais, que pouco têm a ver com o raciocínio original. Para escapar desse problema e, ao mesmo tempo, representar mais fielmente o racioncínio da Lógica de Programação, é utilizado os Algoritmos.

## o que é um algoritmo

Um algoritmo pode ser definido como uma sequência finita de passos que visam atingir um objetivo bem definido.

Na medida em que é preciso especificar uma sequência de passos, é necessário *pensar com ordem*, portanto precisa-se utilizar a lógica.

Apesar do nome pouco usual, algoritmos são comuns no cotidiano. Uma receita de bolo, por exemplo. Nela está descrita uma série de ingredientes necessários e uma sequência de passos (ações) que devem ser seguidos para que se consiga fazer o bolo pretendido.

Quando se faz um algoritmo, é ncessário especificar as ações clara e precisamente. A partir de um estado iniciale após um preríodo de tempo finito, será produzido um estado final previsível e bem definido. O algoritmo fixa um padrão de comportamento a ser seguido.

## algoritmizando a lógica

Uma importância da construção dos Algoritmos é que uma vez concebida uma solução algorítmica para um problema, esta pode ser traduzida para qualquer linguagem de programação.

### a lâmpada

Um primeiro algoritmo pode ser escrito utlizando o portuquês coloquial. Ele vai descrever o comportamento na resolução de uma determinada atividade, como trocar uma lâmpada. Mesmo sendo uma atividade óbvia, ela é realizada de maneira inconscientemente, sem se atentar aos detalhes, que são as ações que levam a alcançar o objetivo.

Vamos ao algoritmo.

Algoritmo Troca de Lâmpada v1.0 :
- pegar uma escada;
- colocar a escada embaixo da lâmpada;
- buscar uma lâmpada reserva;
- subir na escada;
- retirar a lâmpada velha;
- colocar a lâmpada reserva;
- jogar fora a lâmpada velha;
- guardar a escada;

Esses são os passos gerais para trocar uma lâmpada. Seguimos esses passos involuntariamente e pode ser usado por qualquer pessoa. Mas, e se a lâmpada não estivesse queimada? A execução dos passos levaria a uma troca, mesmo ela estando ou não queimada, já que essa possibilidade não foi prevista nos passos.

Então, para corrigir isso, será feito um teste para verificar se a lâmpada está ou não queimada. Veja como fica o novo algoritmo.

Algoritmo Troca de Lâmpada v1.1 :
- pegar uma escada;
- colocar a escada embaixo da lâmpada;
- buscar uma lâmpada reserva;
- ligar o interruptor;
- se a lâmpada não ligar, então :
    - subir na escada;
    - retirar a lâmpada velha;
    - colocar a lâmpada reserva;
    - jogar fora a lâmpada velha;
- guardar a escada;

Agora há ações relacionadas à condição da `lâmpada não ligar`, ou seja, se essa condição for verdadeira (a lâmpada estiver queimada) será feita a troca dela seguindo as ações :
- subir na escada;
- retirar a lâmpada velha;
- colocar a lâmpada reserva;
- jogar fora a lâmpada velha;

Se a condição `lâmpada não ligar` for falsa (se a lâmpada estiver funcionando), as ações relativas à troca dela não serão executadas e não será trocada.

Note, também, que a condição de *guardar da escada* só irá acontecer com ou sem a troca da lâmpada. Mas isso também tem um problema, o algoritmo não prevê guardar a lâmpada nova, caso a velha ainda funcione.

O que aconteceu em v1.1 foi a inclusão de um teste seletivo, usando uma condição que determina qual ou quais ações serão executadas se a condição resultar em verdadeiro. Diferente da v1.0, onde tudo era executado.

Apesar do algoritmo funcionar corretamente, ele pode ser melhorado. Qual é o objetivo de pegar a escada e uma nova lâmpada *antes* de verificar se a lâmpada em questão está queimada? Podemos executar as ações de pegar uma escada e lâmpada apenas se a lâmpada não ligar.

Algoritmo Troca de Lâmpada v1.2
- ligar o interruptor;
- se a lâmpada não ligar, então :
    - pegar uma escada;
    - colocar a escada embaixo da lâmpada;
    - buscar uma lâmpada reserva;
    - subir na escada;
    - retirar a lâmpada velha;
    - colocar a lâmpada reserva;
    - jogar fora a lâmpada velha;
    - guardar a escada;

Observer que, agora, a opção de `ligar o interruptor` é a primeira ação do algoritmo. Em seguida, a condição `lâmpada não ligar` já é testada. Agora, as opções de pegar uma lâmpada e a escada dependem da lâmpada estar queimada.

### repetição

Embora a solução de v1.2 seja adequada, ela não considera que a nova lâmpada também esteja queimada e, portanto, não atingir o objetivo do algoritmo. É possível fazer uma melhoria no algoritmo para que se troque a lâmpada diversas vezes, se necessário, até que funcione.

Algoritmo Troca de Lâmpada v1.3
- ligar o interruptor;
- se a lâmpada não ligar, então :
    - pegar uma escada;
    - colocar a escada embaixo da lâmpada;
    - buscar uma lâmpada reserva;
    - subir na escada;
    - retirar a lâmpada velha;
    - colocar a lâmpada reserva;
    - jogar fora a lâmpada velha;
    - se a lâmpada não ligar, então :
        - retirar a lâmpada velha;
        - colocar a lâmpada reserva;
        - jogar fora a lâmpada velha;
        - se a lâmpada não ligar, então :
            - retirar a lâmpada velha;
            - colocar a lâmpada reserva;
            - jogar fora a lâmpada velha;
            - se a lâmpada não ligar, então :
                - retirar a lâmpada velha;
                - colocar a lâmpada reserva;
                - .
                - .
                - ao infinito e além!
    - guardar a escada;

Pode-se ver que o algoritmo não tem fim. Não há como especificar até quando será feito o teste da lâmpada, quando termina. As ações são executadas até a lâmpada ligar, caso contrário ela será testada até o fim dos tempos. Embora essa solução eventualmente atinja o objetivo (colocar uma lâmpada que funcione), há o problema do número exato de testes da lâmpada.

Veja que o teste da lâmpada reserva é efetuado pelo mesmo conjunto de ações :
- se a lâmpada não ligar, então :
    - retirar a lâmpada velha;
    - colocar a lâmpada reserva;

Também, veja que a condição `guardar a escada` só acontecerá após todos os testes das lâmpada funcionar corretamente.

A condição da `lâmpada não ligar` permaneceu e é estabelecido um fluxo repetitivo que só é finalizado quando a condição de parada for falsa (a lâmpada não ligar). Pode-se ver que o número de repetições é *indefinido*, mas é *finito* e que depende apenas da condição estabelecida. Dessa forma, ocorre uma repetição de ações até alcançar o objetivo: trocar a lâmpada queimada por uma que funcione.d

Veja como fica o novo algoritmo :

Algoritmo Troca de Lâmpada v1.4
- ligar o interruptor;
- se a lâmpada não ligar, então :
    - pegar uma escada;
    - colocar a escada embaixo da lâmpada;
    - buscar uma lâmpada reserva;
    - subir na escada;
    - retirar a lâmpada velha;
    - colocar a lâmpada reserva;
    - jogar fora a lâmpada velha;
    - enquanto a lâmpada não ligar, faça :
        - retirar a lâmpada velha;
        - colocar a lâmpada reserva;
        - jogar fora a lâmpada velha;
    - guardar a escada;

Na versão v1.4, é feito um teste de troca de lâmpada e que, enquanto a condição não for verdadeira, ele será repetido indefinidamente.

Até o momento, está sendo testado apenas um ponto de luz, um soquete. E se fosse necessário trocar 10 pontos de luz?

Algoritmo Troca de Lâmpada v1.5
- ligar o `primeiro` interruptor;
- se a lâmpada não ligar, então :
    - pegar uma escada;
    - colocar a escada embaixo da lâmpada;
    - buscar uma lâmpada reserva;
    - subir na escada;
    - retirar a lâmpada velha;
    - colocar a lâmpada reserva;
    - jogar fora a lâmpada velha;
    - enquanto a lâmpada não ligar, faça :
        - retirar a lâmpada velha;
        - colocar a lâmpada reserva;
        - jogar fora a lâmpada velha;
    - guardar a escada;
- ligar o `segundo` interruptor;
- se a lâmpada não ligar, então :
    - pegar uma escada;
    - colocar a escada embaixo da lâmpada;
    - .
    - .
    - .
- ligar o `terceiro` interruptor;
- se a lâmpada não ligar, então :
    - .
    - .
    - .
- ligar o `quarto` interruptor;
    - .
    - .
    - .
- ligar o `quinto` interruptor;
- se a lâmpada não ligar, então :
    - .
    - .
    - .

Repare que o algoritmo v1.5 é apenas um conjunto de 10 repetições da versão v1.4. Como o conjunto de ações repetidas é igual, pode-se alterar o fluxo de sequencial de execução de modo a fazer com que ele voltasse a executar o conjunto de ações relativas a um único ponto de luz (v1.4) o tanto quanto for necessário.

Veja como ficará :

Algoritmo Troca de Lâmpada v1.6
- ir até o interruptor do `primeiro` soquete;
- enquanto a quantidade de soquetes testados for menor que dezesseis, faça :
    - ligar o interruptor;
    - se a lâmpada não ligar, então :
        - pegar uma escada;
        - colocar a escada embaixo da lâmpada;
        - buscar uma lâmpada reserva;
        - subir na escada;
        - retirar a lâmpada velha;
        - colocar a lâmpada reserva;
        - jogar fora a lâmpada velha;
        - enquanto a lâmpada não ligar, faça :
            - retirar a lâmpada velha;
            - colocar a lâmpada reserva;
            - jogar fora a lâmpada velha;
        - guardar a escada;

Quando a condição `quantidade de soquetes testados for menor que dez` for verdadeira, as ações responsáveis pela troca ou não de um único soquete são exexutadas. Caso a condição de parada seja falsa, ou seja, todos os 10 soquetes já tiverem sido testados, nada mais será executado.

## resumo

Todo o exemplo foi desenvolvido a partir do problema de descrever os passos necessários para efetuar a troca de uma lâmpada, ou seja, construir um *algoritmo* para esse fim. Inicialmente, havia um pequeno conjunto de ações que deveriam ser executadas, todas passo a passo, compondo uma ordem sequencial de execução.

Pode-se ver que nem todas as ações previstas deveriam ser executadas. Isso mostrou que um determinado conjunto de ações fosse evitado, selecionado conforme o resultado de uma determinada condição. Dessa forma, era necessário uma *estrutura condicional* através de um *teste condicional* que permitisse ou não que o fluxo de execução passasse por um deterinado conjunto de ações.

Depois, surgiu uma necessidade repetir diversos trechos de código do algoritmo. Para resolver isso, foi alterado o fluxo de execução para que ele passasse diversas vezes pelo mesmo trecho diversas vezes, enquanto a condição não fosse satisfeita. Resolução semelhante que foi usado quando foi necessário realizar a troca de dez pontos de luz. Para ambos os casos, foi usado uma *estrutrua de repetição*.

Vale a pena ressaltar que praticamente qualquer pessoa seria capaz de resolver o problema de trocar uma lâmpada, incluindo se adaptar a qualquer circunstância pitoresca que pudesse surgir. Mas um programa de computador tradicional não tem conhecimento prévio e nem tem a capacidade de raciocínio para encontrar soluções diante de uma situação imprevista. Isso implica que todos os detalhes devem ser determinados em todas as situações que ele deve executar, prevendo os obstáculos e a forma que superá-los, isto é, descrever uma sequência finitas de passos que garantam a solução do problema. Essa atividade é realizada pelos **programadores**.

## atividades

1. Três senhoras, dona Branca, dona Rosa e dona Violeta, passeavam pelo parque quando dona Rosa disse :
    - Não é curioso que estejamos usando vestidos de cores branca, rosa e violeta, embora nenhuma de nós esteja usando um vestido de cor igual ao seu próprio nome?
    - Uma simples coincidência, respondeu a senhora com o vestido violeta. Qual a cor do vestido de cada senhora?

    <details>
    <summary>Resposta</summary>

    Para resolver o problema, precisamos seguir as pistas fornecidas e usar um pouco de lógica dedutiva. Identificando as senhoras e suas cores de vestido. São 3 senhoras, a dona Branca, a dona Rosa e a dona Violeta. Identificando as cores dos vestidos disponíveis: branco, rosa e violeta. Entendendo as pistas, nenhuma das senhoras está usando um vestido da cor que corresponde ao seu nome, a dona Rosa não está usando um vestido rosa, a dona Branca não está usando um vestido branco e dona Violeta não está usando um vestido violeta. Deduções a partir da conversa, quando dona Rosa comenta sobre a coincidência, a senhora com o vestido violeta responde. Logo, a dona Rosa não pode estar usando o vestido rosa, a dona Branca não pode estar usando o vestido branco e a dona Violeta não pode estar usando o vestido violeta. Como a dona Branca é quem fez a primeira afirmação, as únicas que podem ter respondido eram a dona Violeta e a dona Rosa. Como a resposta veio da dona usando o vestido violeta, sabemos que a dona Violeta não pode ter respondido (nenhuma delas está usando o vestido da cor de seu nome). Logo, a resposta só pode ter vindo da dona Rosa usando o vestido violeta. Com isso, ainda falta descobrir quais vestidos a dona Branca e a dona Violeta estão usando entre os vestidos restantes, rosa e branco. Como a dona Branca não pode estar usando o vestido branco, então ela só pode usar o vestido rosa. Logo, a dona Violeta está usando o vestido branco, sendo a única combinação faltante.

    </details>

1. Um homem precisa atravessar um rio com um barco que possui capacidade para carregar apenas ele mesmo e mais uma de suas três cargas, que são : um lobo, um bode e um maço de alfafa. O que o homem deve fazer para conseguir atravessar o rio sem perder suas cargas? As regras são :
    - O bode não pode ficar sozinho com a alfafa;
    - O homem pode viajar sozinho;
    - O lobo não pode ficar sozinho com o bode;

    <details>
    <summary>Resposta</summary>

    Para resolver o problema de atravessar o rio com o lobo, o bode e a alfafa, sem deixar o bode sozinho com a alfafa ou o lobo sozinho com o bode, é preciso planejar cuidadosamente cada travessia. Vamos resolver isso passo a passo. Na primeira viagem, o homem leva o bode para o outro lado do rio e o deixa lá enquanto que o lobo e a alfafa ficam do lado inicial. Na segunda viagem o homem retorna sozinho ao lado inicial e o lobo e a alfafa ainda estão do lado inicial. Na terceira viagem o homem leva o lobo para o outro lado do rio e agora, o bode e o lobo estão juntos do outro lado, mas o homem não pode deixá-los juntos, então, o homem pega o bode e retorna com ele ao lado inicial. Na quarta viagem o homem deixa o bode no lado inicial e leva a alfafa para o outro lado do rio e agora, o lobo e a alfafa estão juntos do outro lado, e o bode está sozinho do lado inicial. Na quinta viagem o homem retorna sozinho ao lado inicial. Na sexta viagem o homem leva o bode para o outro lado do rio.

    </details>

1. Três jesuítas e três canibais precisam atravessar um rio. Para isso, eles têm um barco com capacidade para duas pessoas. Por medida de segurança, não se deve permitir que em alguma margem a quantidade de jesuítas seja inferior à de canibais. Qual a solução para efetuar a travessia com segurança?

    <details>
    <summary>Resposta</summary>

    Para resolver o problema dos três jesuítas e três canibais precisando atravessar o rio sem nunca permitir que os canibais sejam mais numerosos que os jesuítas em qualquer margem, precisamos planejar cuidadosamente cada travessia. Vamos representar os jesuítas como J e os canibais como C. Vamos usar o formato (J, C) para representar a quantidade de jesuítas e canibais em cada margem do rio. Inicialmente, todos estão na margem esquerda (3J, 3C) e (0J, 0C) na margem direita. Na primeira viagem vamos atravessar 2 canibais para a margem direita, ficando (3J, 1C) | (0J, 2C). Na segunda viagem vamos retornar 1 canibal para a margem esquerda, ficando (3J, 2C) | (0J, 1C). Na terceira viagem vamos atravessar 2 canibais para a margem direita novamente, ficando (3J, 0C) | (0J, 3C). Na quarta viagem vamos retornar 1 canibal para a margem esquerda, ficando (3J, 1C) | (0J, 2C). Na quinta viagem vamos atravessar 2 jesuítas para a margem direita, ficando (1J, 1C) | (2J, 2C). Na sexta viagem vamos retornar 1 jesuíta e 1 canibal para a margem esquerda, ficando (2J, 2C) | (1J, 1C). Na sétima viagem atravessam 2 jesuítas para a margem direita novamente, ficando (0J, 2C) | (3J, 1C). Na oitava viagem vamos retornar 1 canibal para a margem esquerda, ficando (0J, 3C) | (3J, 0C). Na nona viagem vamos atravessar 2 canibais para a margem direita, ficando (0J, 1C) | (3J, 2C). Na décima viagem retorna 1 canibal para a margem esquerda, ficando (0J, 2C) | (3J, 1C). Na décima primeira viagem atravessam 2 canibais para a margem direita, ficando (0J, 0C) | (3J, 3C).

    </details>

1. No torneio de atletismo, Carlos, José e Sérgio participaram das provas de 100 metros rasos, salto em distância e arremesso de dardo. Cada um deles conseguiu um primeiro lugar, um segundo e um terceiro. Descubra o que cada um conquistou, sabendo que :
    - José venceu Carlos no salto em distância;
    - Sérgio chegou atrás de José no arremesso de dardo;
    - Carlos não chegou em primeiro nos 100 metros rasos;

1. João tem três barris. No barril A, que está vazio, cabem 8 litros. No barril B cabem 5 litros. No varril C cabem 3 litros. O que deve fazer João para deixar os barris A e B com 4 litros cada e o C vazio?

    <details>
    <summary>Resposta</summary>

    Para resover esse problema, é necessário ficar atento ao portuguës também. O problema diz que o barril A está vazio, mas não diz o mesmo dos barris B e C, então pode-se implicar que estão cheios. Também, como não há outras medidas no barris, não há como dividir o conteúdo de qualquer barril parcialmente, como passar 1 litro do barril C para o barril A, por exemplo. Partindo desse princípio, temos que deixar os barris A e B com 4 litros cada. No começo, estamos com (A, 0L), (B, 5L) e (C, 3L). No primeiro passo, vamos transferir todo o conteúdo do barril C para o barril A, ficando (A, 3L), (B, 5L) e (C, 0L). No segundo passo, vamos passar o conteúdo do barril B para o C, ficando (A, 3L), (B, 2L) e (C, 3L). Agora, no terceiro passo, vamos passar o conteúdo do barril C para o barril A, ficando (A, 6L), (B, 2L) e (C, 0L). No quarto passo, vamos passar o conteúdo do barril B para o barril C, ficando (A, 6L), (B, 0L) e (C, 2L). No quinto passo, vamos passar o conteúdo do barril A para o barril B, ficando (A, 1L), (B, 5L) e (C, 2L). No sexto passo, vamos passar o conteúdo do barril B para o C, ficando (A, 1L), (B, 4L) e (C, 3L). Por fim, no sétimo passo, vamos colocar o líquido do barril C no A, ficando (A, 4L), (B, 4L) e (C, 0L).

    </details>


# operador-ternario.md

Índice

1. [sintaxe](#sintaxe)
1. [exemplos](#exemplos)
1. [cuidados](#cuidados)
1. [comparando](#comparando)
1. [exercícios](#exercícios)

# operador ternário

O operador ternário em Python é uma forma concisa de escrever uma expressão condicional, permitindo que você atribua um valor a uma variável ou execute uma operação com base em uma condição, tudo em uma única linha de código. Em vez de usar a estrutura tradicional `if-else`, o operador ternário simplifica a sintaxe.

## sintaxe

A sintaxe do operador ternário em Python é a seguinte:

```python
<valor_se_verdadeiro> if <condicao> else <valor_se_falso>
```

- **condicao** : a expressão que será avaliada como `True` ou `False`;
- **valor_se_verdadeiro** : o valor ou expressão que será retornado se a condição for `True`;
- **valor_se_falso** : o valor ou expressão que será retornado se a condição for `False`;

## exemplos

### 1. atribuição simples

```python
>>> idade = 18
>>> status = "Maior de idade" if idade >= 18 else "Menor de idade"
>>> print(status)
Maior de idade
>>> |
```

- aqui, a condição `idade >= 18` é verificada;
- se for `True`, a variável `status` recebe o valor `"Maior de idade"`;
- caso contrário, ela recebe `"Menor de idade"`;

### 2. verificação de paridade

```python
>>> numero = 4
>>> paridade = "Par" if numero % 2 == 0 else "Ímpar"
>>> print(paridade)
Par
>>> |
```

- a condição `numero % 2 == 0` verifica se o número é par;
- se for `True`, `paridade` recebe `"Par"`;
- caso contrário, recebe `"Ímpar"`;

### 3. usando o operador ternário com funções

```python
>>> def obter_preco(desconto):
...     return 50 if desconto else 100
...
>>> preco = obter_preco(True)
>>> print(preco)
50
>>> |
```

- a função `obter_preco` retorna 50 se `desconto` for `True`, e 100 caso contrário;
- no exemplo, a função é chamada com `True`, então o preço será 50;

### 4. múltiplas condições

```python
>>> nota = 85
>>> resultado = "Aprovado" if nota >= 60 else "Reprovado"
>>> print(resultado)
Aprovado
>>> |
```

- a condição `nota >= 60` verifica se a nota é suficiente para aprovação;
- se `True`, retorna `"Aprovado"`, caso contrário, `"Reprovado"`;

### 5. encadeamento de operadores ternários

```python
>>> idade = 17
>>> categoria = "Criança" if idade < 13 else "Adolescente" if idade < 18 else "Adulto"
>>> print(categoria)
Adolescente
>>> |
```

- aqui, é verificado várias condições em sequência :
  1. se `idade < 13`, retorna `"Criança"`;
  1. se `idade < 18` (mas não menor que 13), retorna `"Adolescente"`;
  1. se nenhuma das anteriores for verdadeira, retorna `"Adulto"`;

Veja o exemplo acima, mas usando parênteses para melhor visualização de cada bloco :

```python
>>> idade = 17
>>> categoria = ("Criança" if idade < 13 else ("Adolescente" if idade < 18 else "Adulto"))
>>> print(categoria)
Adolescente
>>> |
```

### 6. usando com valores booleanos

```python
>>> x = True
>>> y = False
>>> resultado = "Ambos Verdadeiros" if x and y else "Ao menos um Falso"
>>> print(resultado)
Ao menos um Falso
>>> |
```

- a condição `x and y` é avaliada;
- se ambos `x` e `y` forem `True`, retorna `"Ambos Verdadeiros"`;
- caso contrário, retorna `"Ao menos um Falso"`;

### 7. atribuindo resultados a variáveis

```python
>>> a = 5
>>> b = 10
>>> maior = a if a > b else b
>>> print(maior)
10
>>> |
```

- A condição `a > b` é verificada.
- Se for `True`, `maior` recebe `a`, caso contrário, `b`.

## cuidados

Embora a estrutura ajude a deixar o código mais claro e mais conciso, ela também pode deixar o código bem complicado de ler.

Veja um exemplo abaixo :

```python
>>> nota = 95
>>>
>>> # vários if-else ternários
>>> resultado = 'A+' if nota > 90 else 'A' if nota > 80 else 'B' if nota > 70 else 'C' if nota > 60 else 'D' if nota > 40 else 'Reprovado'
>>> resultado
'A+'
>>>
>>> # mesma estrutura, mas com os parênteses para "melhor" visualização
>>> resultado = ('A+' if nota > 90 else ('A' if nota > 80 else ('B' if nota > 70 else ('C' if nota > 60 else ('D' if nota > 40 else ('Reprovado'))))))
>>> resultado
'A+'
>>>
>>> # agora usando os parênteses e separando em blocos individuais
>>> resultado = (
...     'A+' if nota > 90 else (
...         'A' if nota > 80 else (
...             'B' if nota > 70 else (
...                 'C' if nota > 60 else (
...                     'D' if nota > 40 else (
...                         'Reprovado'
...                     )
...                 )
...             )
...         )
...     )
... )
...
>>> resultado
'A+'
>>> |
```

Embora ela seja prática, o exemplo acima fica **muito** melhor de entender e visualizar se usar o `if-elif-else` tradicional. Veja abaixo como ficaria :

```python
>>> if nota > 90:
...     resultado = 'A+'
... elif nota > 80:
...     resultado = 'A'
... elif nota > 70:
...     resultado = 'B'
... elif nota > 60:
...     resultado = 'C'
... elif nota > 40:
...     resultado = 'D'
... else:
...     resultado = 'Reprovado'
...
>>> resultado
'A+'
>>> |
```

## comparando

Abaixo há diversos exemplos do *mesmo* uso do `if` tradicional e do `if` com operador ternário :

1. verificando positivo e negativo :
    ```python
    >>> numero = -3
    >>>
    >>> # versão tradicional
    >>> if numero > 0:
    ...     resultado = "Positivo"
    ... else:
    ...     resultado = "Negativo ou Zero"
    ...
    >>> print(resultado)
    Negativo ou Zero
    >>>
    >>> # operador ternário
    >>> resultado = "Positivo" if numero > 0 else "Negativo ou Zero"
    >>> print(resultado)
    Negativo ou Zero
    >>> |
    ```

1. verificação de maioridade
    ```python
    >>> idade = 20
    >>>
    >>> # versão tradicional
    >>> if idade >= 18:
    ...     maioridade = True
    ... else:
    ...     maioridade = False
    ...
    >>> print(maioridade)
    True
    >>>
    >>> # operador ternário
    >>> maioridade = True if idade >= 18 else False
    >>> print(maioridade)
    True
    >>> |
    ```

1. verificação de vazio em uma string
    ```python
    >>> texto = ""
    >>>
    >>> # versão tradicional
    >>> if not texto:
    ...     status = "Vazio"
    ... else:
    ...     status = "Contém Texto"
    ...
    >>> print(status)
    Vazio
    >>>
    >>> # operador ternário
    >>> status = "Vazio" if not texto else "Contém Texto"
    >>> print(status)
    Vazio
    >>> |
    ```

1. verificação de paridade com números
    ```python
    >>> numero = 7
    >>>
    >>> # versão tradicional
    >>> if numero % 2 == 0:
    ...     paridade = "Par"
    ... else:
    ...     paridade = "Ímpar"
    ...
    >>> print(paridade)
    Ímpar
    >>>
    >>> # operador ternário
    >>> paridade = "Par" if numero % 2 == 0 else "Ímpar"
    >>> print(paridade)
    Ímpar
    >>> |
    ```

1. seleção de mensagem baseada em horário
    ```python
    >>> hora = 15
    >>>
    >>> # versão tradicional
    >>> if hora < 12:
    ...     mensagem = "Bom dia"
    ... else:
    ...     mensagem = "Boa tarde"
    ...
    >>> print(mensagem)
    Boa tarde
    >>>
    >>> # operador ternário
    >>> mensagem = "Bom dia" if hora < 12 else "Boa tarde"
    >>> print(mensagem)
    Boa tarde
    >>> |
    ```

## exercícios

<details>
<summary>Lista de Exercícios</summary>

> [!TIP]
> para os seguintes execícios :
> - primeiro, crie a versão tradicional do exercício;
> - depois, a partir da primeira, crie a versão de operador ternário;

Exemplo :
```python
>>> # **Verificação Simples**: Dada uma variável `x = 10`, use o operador
>>> # ternário para definir uma variável `resultado` como `"Maior que 5"` se
>>> # `x` for maior que 5, caso contrário `"Menor ou igual a 5"`.
>>> # Imprima `resultado`.
>>>
>>> x = 10
>>>
>>> # usando o if-else tradicional
>>> resultado = ''
>>> if x > 5:
...     resultado = "Maior que 5"
... else:
...     resultado = "Menor ou igual a 5"
...
>>> print(resultado)
Menor ou igual a 5
>>>
>>> # usando operador ternário
>>> resultado = "Maior que 5" if x > 5 else "Menor ou igual a 5"
>>> print(resultado)
Menor ou igual a 5
>>> |
```

1. Nível Simples
    1. **Verificação Simples**: Dada uma variável `x = 10`, use o operador ternário para definir uma variável `resultado` como `"Maior que 5"` se `x` for maior que 5, caso contrário `"Menor ou igual a 5"`. Imprima `resultado`.
    1. **Par ou Ímpar**: Dado um número `n = 7`, use o operador ternário para definir uma variável `paridade` como `"Par"` se `n % 2 == 0`, caso contrário `"Ímpar"`. Imprima `paridade`.
    1. **Verificação de String Vazia**: Dada uma string `s = "Python"`, use o operador ternário para definir uma variável `status` como `"Vazia"` se `s` for vazia, caso contrário `"Não vazia"`. Imprima `status`.
    1. **Maior de Dois Números**: Dadas duas variáveis `a = 8` e `b = 5`, use o operador ternário para definir a variável `maior` como o maior entre `a` e `b`. Imprima `maior`.
    1. **Verificação de Booleano**: Dado um booleano `flag = True`, use o operador ternário para definir uma variável `mensagem` como `"Ativo"` se `flag` for `True`, caso contrário `"Inativo"`. Imprima `mensagem`.
1. Nível Intermediário
    1. **Comprimento de Lista**: Dada uma lista `lst = [1, 2, 3, 4]`, use o operador ternário para definir uma variável `comprimento` como `"Curta"` se a lista tiver menos de 5 elementos, caso contrário `"Longa"`. Imprima `comprimento`.
    1. **Verificação de Tupla**: Dada uma tupla `t = (5, 10)`, use o operador ternário para definir uma variável `tipo` como `"Par"` se a soma dos elementos for par, caso contrário `"Ímpar"`. Imprima `tipo`.
    1. **Multiplicação ou Soma**: Dado um número `x = 3`, use o operador ternário para definir uma variável `resultado` como `x * 2` se `x` for maior que 5, caso contrário `x + 2`. Imprima `resultado`.
    1. **Verificação de String Maiúscula**: Dada uma string `s = "Hello"`, use o operador ternário para definir uma variável `case` como `"Maiúscula"` se `s` estiver em maiúsculas, caso contrário `"Minúscula ou mista"`. Imprima `case`.
    1. **Positivo ou Negativo**: Dado um número `n = -4`, use o operador ternário para definir uma variável `sinal` como `"Positivo"` se `n` for maior ou igual a 0, caso contrário `"Negativo"`. Imprima `sinal`.
1. Nível Avançado
    1. **Verificação de Elemento em Lista**: Dada uma lista `lst = [1, 2, 3]`, use o operador ternário para definir uma variável `presente` como `"Contém 2"` se `2` estiver na lista, caso contrário `"Não contém 2"`. Imprima `presente`.
    1. **Comprimento de String**: Dada uma string `s = "Python"`, use o operador ternário para definir uma variável `comprimento` como `"Curta"` se a string tiver menos de 6 caracteres, caso contrário `"Longa"`. Imprima `comprimento`.
    1. **Verificação de Tupla Vazia**: Dada uma tupla `t = ()`, use o operador ternário para definir uma variável `status` como `"Vazia"` se a tupla estiver vazia, caso contrário `"Não vazia"`. Imprima `status`.
    1. **Verificação de Lista Aninhada**: Dada uma lista `lst = [[1, 2], [3, 4]]`, use o operador ternário para definir uma variável `aninhada` como `"Contém listas"` se o primeiro elemento de `lst` for uma lista, caso contrário `"Não contém listas"`. Imprima `aninhada`.
    1. **Escolha de String Baseada em Comprimento**: Dada uma string `s = "Hello"`, use o operador ternário para definir uma variável `mensagem` como `"Curta"` se `s` tiver 5 caracteres ou menos, caso contrário `"Longa"`. Imprima `mensagem`.
1. Nível Complexo
    1. **Operação Condicional**: Dado um número `n = 15`, use o operador ternário para definir uma variável `resultado` como `n ** 2` se `n` for maior que 10, caso contrário `n / 2`. Imprima `resultado`.
    1. **Verificação de Paridade com Lista**: Dada uma lista `lst = [2, 4, 6]`, use o operador ternário para definir uma variável `paridade` como `"Par"` se a soma dos elementos da lista for par, caso contrário `"Ímpar"`. Imprima `paridade`.
    1. **Verificação de Multiplicidade**: Dado um número `x = 21`, use o operador ternário para definir uma variável `multiplicidade` como `"Multiplo de 7"` se `x` for múltiplo de 7, caso contrário `"Não é múltiplo de 7"`. Imprima `multiplicidade`.
    1. **Verificação de Tupla Aninhada**: Dada uma tupla `t = ((1, 2), (3, 4))`, use o operador ternário para definir uma variável `aninhada` como `"Aninhada"` se o primeiro elemento de `t` for uma tupla, caso contrário `"Não aninhada"`. Imprima `aninhada`.
    1. **Escolha de Lista Baseada em Comprimento**: Dada uma lista `lst = [1, 2, 3, 4, 5, 6]`, use o operador ternário para definir uma variável `tamanho` como `"Curta"` se a lista tiver 5 elementos ou menos, caso contrário `"Longa"`. Imprima `tamanho`.
1. Nível Muito Complexo
    1. **Escolha de Elemento em Lista**: Dada uma lista `lst = [10, 20, 30]`, use o operador ternário para definir uma variável `elemento` como o primeiro elemento da lista se ela tiver mais de 2 elementos, caso contrário o último elemento. Imprima `elemento`.
    1. **Verificação de Substring**: Dada uma string `s = "Python é divertido"`, use o operador ternário para definir uma variável `existe` como `"Contém 'divertido'"` se `"divertido"` estiver presente na string, caso contrário `"Não contém 'divertido'"`. Imprima `existe`.
    1. **Verificação de Comprimento de Tupla**: Dada uma tupla `t = (1, 2, 3, 4)`, use o operador ternário para definir uma variável `quantidade` como `"Mais de 3 elementos"` se a tupla tiver mais de 3 elementos, caso contrário `"3 ou menos elementos"`. Imprima `quantidade`.
    1. **Comparação de Tuplas**: Dadas duas tuplas `t1 = (1, 2)` e `t2 = (3, 4)`, use o operador ternário para definir uma variável `comparação` como `"Tupla 1 maior"` se o primeiro elemento de `t1` for maior que o de `t2`, caso contrário `"Tupla 2 maior"`. Imprima `comparação`.

</details>


# operador-walrus.md

Índice

1. [o que é](#o-que-é)
1. [para que server](#para-que-serve)
1. [como funciona](#como-funciona)
1. [cuidados](#cuidados)
1. [exercícios](#exercícios)

# operador walrus

O operador **Walrus** (`:=`) foi introduzido no Python 3.8 como parte da **PEP 572**. Também conhecido como o operador de "atribuição em expressão", ele permite atribuir valores a variáveis enquanto elas são usadas dentro de expressões. Isso pode tornar o código mais conciso, especialmente em loops ou condições.

## o que é

O operador Walrus é uma forma de **atribuição dentro de uma expressão**. Em Python, antes do operador Walrus, você não podia atribuir um valor a uma variável e ao mesmo tempo utilizá-lo dentro de uma expressão como em um `if`, `while`, `for`, ou até mesmo em compreensões de listas. O operador Walrus resolve esse problema ao permitir que se faça essas duas coisas de uma vez só.

## para que serve

Ele tem diversos usos, e o principal objetivo é tornar o código mais **eficiente e legível** ao permitir:
- evitar a necessidade de fazer uma atribuição em uma linha e usar essa variável em uma condição em outra linha;
- evitar cálculos redundantes quando uma mesma expressão precisa ser calculada várias vezes em uma condição e dentro do bloco de código;
- melhorar a performance em certos cenários, como em loops que dependem de um valor que você só quer calcular uma vez por iteração;

## como funciona

Abaixo há diversos exemplos de como usar e como funciona.

1. **atribuição dentro de um `while`**

Tradicionalmente, ao escrever um loop `while`, o valor usado na condição seria separado da atribuição. Com o operador Walrus, pode-se unificar esses dois passos.

```python
# sem o operador Walrus
n = 0
while n < 10:
    print(n)
    n += 1

# com o operador Walrus
n = 0
while (n := n + 1) < 10:
    print(n)
```

Aqui, o operador Walrus permite que o valor de `n` seja atualizado e utilizado diretamente dentro da condição do `while`.

2. **evitar duplicação de expressões em `if`**

Antes do Python 3.8, se tivesse uma função ou cálculo que precisasse ser utilizado tanto na condição de um `if` quanto dentro do bloco `if`, teria que se chamar a função duas vezes ou armazenar o valor antes de entrar no `if`. O operador Walrus facilita isso:

```python
# sem o operador Walrus
dados = input("Digite algo: ")
if len(dados) > 3:
    print(f"Dado tem {len(dados)} caracteres")

# com o operador Walrus
if (n := len(input("Digite algo: "))) > 3:
    print(f"Dado tem {n} caracteres")
```

Neste exemplo, o uso do operador Walrus evita que a função `len()` seja chamada duas vezes.

3. **compreensões de listas**

O operador Walrus também pode ser útil em compreensões de listas para evitar cálculos repetidos ou criar filtros baseados em valores calculados no meio da compreensão.

```python
# sem o operador Walrus
resultados = []
for i in range(10):
    quadrado = i * i
    if quadrado > 20:
        resultados.append(quadrado)

# com o operador Walrus
resultados = [quadrado for i in range(10) if (quadrado := i * i) > 20]
```

Aqui, a compreensão de lista com o operador Walrus é mais compacta, e o valor `quadrado` é calculado apenas uma vez por iteração.

4. **evitar chamadas de funções repetidas**

Imagine que se tenha uma função cara (que demora para ser processada) e precisa tanto do resultado dela quanto de seu uso para alguma lógica. O Walrus ajuda aqui também:

```python
def pega_dados():
    print("Buscando dados")
    return [1, 2, 3, 4, 5]

# sem o operador Walrus
data = pega_dados()
if data:
    print(f"Dados obtidos: {data}")

# com o operador Walrus
if (data := pega_dados()):
    print(f"Dados obtidos: {data}")
```

Nesse caso, com o operador Walrus, evitamos fazer duas chamadas para `fetch_data()`, economizando processamento.

## cuidados

Embora o operador Walrus possa tornar o código mais eficiente, **ele deve ser usado com cuidado** para não comprometer a legibilidade.

Aqui estão algumas dicas:
- **legibilidade acima de tudo** : não sacrifique a clareza do código apenas para usar o walrus. ele deve melhorar a legibilidade, não complicá-la;
- **use em expressões onde economiza processamento** : se houver um cálculo que será repetido várias vezes em uma expressão, considere usar o walrus para atribuir o valor uma vez e reutilizá-lo;
- **cuidado com expressões complexas** : o operador walrus pode levar a expressões complicadas que são difíceis de depurar. se perceber que o código está ficando muito difícil de entender, divida-o em partes menores;
- **útil em loops e condições** : o maior benefício do walrus geralmente é visto em loops (`for` ou `while`) e condições (`if`), especialmente quando se quer evitar a repetição de cálculos ou verificar condições ao mesmo tempo que atribui valores;

Por exemplo, evite escrever algo como:

```python
if (temp := pega_temperatuda()) and (hum := pega_humidade()) and (pres := pega_pressao()):
    print(f"Condições: {temp}°C, {hum}%, {pres}hPa")
```

Este código é válido, mas pode se tornar difícil de entender rapidamente.

## exercícios

<details>
<summary>Lista de Exercícios</summary>

1. Exercícios Simples
    1. Escreva um programa que leia números do usuário repetidamente, usando um `while`. O loop deve parar se o usuário digitar um número negativo. Use o operador Walrus para armazenar e verificar o número.
    1. Faça um programa que leia uma string do usuário e verifique se o comprimento da string é maior que 5. Se for, imprima a string e seu comprimento. Use o operador Walrus.
    1. Crie um código que leia a idade do usuário e, se a idade for maior que 18, imprima "Maior de idade". Utilize o operador Walrus na condição.
    1. Use o operador Walrus para verificar se um número inserido pelo usuário é divisível por 7. Se for divisível, imprima o número.
    1. Escreva um programa que receba um número e imprima o quadrado desse número, **apenas** se ele for maior que 10. Use o operador Walrus para realizar a atribuição e a verificação.
1. Exercícios de Loops
    1. Implemente um loop `while` que leia a entrada do usuário até que ele digite "sair". Utilize o operador Walrus para armazenar a entrada e verificar a condição de saída.
    1. Crie um programa que receba números do usuário até que um número maior que 100 seja inserido. Utilize o operador Walrus para atribuir e comparar o valor no `while`.
    1. Use o operador Walrus em um loop `while` que leia uma lista de números do usuário, pare ao encontrar um número zero, e imprima todos os números inseridos até o momento.
    1. Faça um código que leia números do usuário e armazene-os em uma lista. O loop deve parar quando o usuário digitar um número menor que 5. Use o Walrus no `while`.
    1. Crie um loop que leia o nome de uma pessoa e, se o nome contiver mais de 8 caracteres, exiba o nome. Utilize o operador Walrus para verificar essa condição e sair do loop quando o nome for "finalizar".
1. Exercícios com Compreensão de Listas
    1. Crie uma lista de quadrados de números de 1 a 10, mas somente se o quadrado for maior que 20. Use o operador Walrus dentro de uma compreensão de listas.
    1. Gere uma lista de números de 1 a 100, filtrando apenas os números que, quando multiplicados por 3, resultam em valores maiores que 50. Use o operador Walrus para realizar a filtragem.
    1. Dada uma lista de números, crie uma nova lista que contenha apenas os números cuja raiz quadrada seja maior que 2. Use o operador Walrus para atribuir e filtrar os valores.
    1. Usando uma compreensão de lista e o operador Walrus, crie uma lista de strings que tenham mais de 4 caracteres a partir de uma lista fornecida.
    1. Crie uma lista de comprimentos de palavras a partir de uma lista de strings, mas só inclua palavras que tenham mais de 6 letras. Use o Walrus para calcular o comprimento e realizar a verificação.
1. Exercícios com Funções e Filtros
    1. Escreva uma função que receba uma lista de números e retorne apenas os números pares cujo valor ao quadrado seja maior que 30. Use o operador Walrus dentro da função.
    1. Use o operador Walrus dentro de uma função `map()` para multiplicar todos os números de uma lista por 2 e filtrar aqueles que resultem em valores maiores que 10.
    1. Escreva uma função que receba uma lista de strings e retorne apenas aquelas que começam com a letra "A" e tenham mais de 5 caracteres. Use o Walrus na verificação.
    1. Faça uma função que receba uma lista de números e retorne a soma dos quadrados dos números que são maiores que 10. Use o Walrus para evitar a repetição de cálculos.
    1. Escreva uma função que retorne o primeiro número de uma lista que seja divisível por 5 e maior que 50. Use o Walrus para realizar a filtragem.
1. Exercícios com Condições
    1. Crie um programa que peça para o usuário digitar um número. Se o número for maior que 50, imprima "Número muito alto" e pare o programa. Use o operador Walrus.
    1. Use o operador Walrus para pedir que o usuário insira um número e, se o número for par, imprima "Número par". Caso contrário, imprima "Número ímpar".
    1. Escreva um código que leia o nome e a idade do usuário, e só imprima o nome se a idade for maior que 30. Use o operador Walrus na verificação.
    1. Crie um programa que receba um valor numérico e verifique se ele é positivo. Se for, imprima "Positivo" e o valor. Use o operador Walrus para atribuir e verificar.
    1. Faça um programa que leia um número do usuário e, se o número for divisível por 3 e maior que 15, imprima "Aceito". Use o Walrus para fazer a verificação na condição do `if`.
1. Exercícios com Manipulação de Dados
    1. Dada uma lista de números, use o operador Walrus para imprimir os números que, quando divididos por 4, resultam em valores maiores que 5. Faça isso dentro de um loop `for`.
    1. Escreva um programa que leia uma lista de strings e imprima apenas as strings que contenham mais de 3 vogais. Use o Walrus para contar as vogais e fazer a verificação.
    1. Crie uma lista de números de 1 a 20. Usando o operador Walrus, filtre e crie uma nova lista com apenas os números que, multiplicados por 2, são menores que 25.
    1. Faça um programa que leia números do usuário e armazene-os em uma lista. O loop deve parar quando o usuário inserir um número negativo. Imprima a soma dos números armazenados usando o Walrus.
    1. Escreva um código que leia a idade de várias pessoas e armazene as idades em uma lista. O loop deve parar quando for inserida uma idade menor que 0. Ao final, imprima a média das idades usando o Walrus para calcular a soma e a contagem de idades.

</details>


# programacao-orientada-objetos.md

Índice

1. [principais conceitos da poo](#principais-conceitos-da-poo)
1. [benefícios da poo](#benefícios-da-poo)
1. [comando `class`](#comando-class)
1. [método `__init__`](#método-__init__)
1. [atributos](#atributos)
    1. [atributos de instância](#atributos-de-instância)
    1. [atributos de classe](#atributos-de-classe)
1. [métodos de instância](#métodos-de-instância)
1. [exercícios](#exercícios)
1. [métodos mágicos](#métodos-mágicos)
1. [método `__str__`](#método-__str__)
1. [método `__repr__`](#método-__repr__)
1. [`__str__` vs `__repr__`](#__str__-vs-__repr__)
1. [exercícios `__str__` e `__repr__`](#exercícios-__str__-e-__repr__)

# programação orientada a objetos

A **Programação Orientada a Objetos (POO)** é um paradigma de desenvolvimento de software que organiza o código em torno de **objetos**, em vez de funções e procedimentos. Esses objetos são instâncias de **classes** (representações abstratas de entidades do mundo real ou de conceitos dentro do sistema), que encapsulam tanto os **dados** (atributos) quanto as **funções** (métodos) que operam sobre esses dados.

## principais conceitos da poo

1. **classe** : uma classe é um modelo ou template que define a estrutura e o comportamento de um conjunto de objetos semelhantes. Ela atua como um molde para criar objetos, especificando os atributos (dados) que cada objeto terá e os métodos (funções) que cada objeto poderá executar.

1. **objeto** : um objeto é uma instância de uma classe. É uma entidade concreta criada a partir do modelo definido pela classe, possuindo seus próprios valores para os atributos e a capacidade de executar os métodos definidos na classe.

1. **encapsulamento** : o encapsulamento é o princípio de ocultar os detalhes internos de um objeto e fornecer uma interface pública para interagir com ele. Isso protege os dados do objeto de acessos e modificações indesejadas, permitindo que o objeto gerencie seu próprio estado de forma controlada.

1. **herança** : a herança é um mecanismo que permite criar novas classes (subclasses ou classes derivadas) a partir de classes existentes (superclasses ou classes base). A subclasse herda os atributos e métodos da superclasse, podendo adicionar novos atributos e métodos ou sobrescrever os existentes, promovendo a reutilização de código e a organização hierárquica das classes.

1. **polimorfismo** : o polimorfismo é a capacidade de objetos de diferentes classes responderem à mesma mensagem (chamada de método) de maneiras diferentes. Isso permite que o código seja mais flexível e adaptável, tratando objetos de diferentes classes de forma uniforme através de uma interface comum.

1. **abstração** : a abstração é o processo de focar nos aspectos essenciais de um objeto e ignorar os detalhes irrelevantes. Isso permite criar modelos simplificados e gerenciáveis de entidades complexas, facilitando o entendimento e a manipulação do sistema.

## benefícios da poo

* **modularidade** : a poo promove a organização do código em módulos (classes) coesos e independentes, facilitando a manutenção e a evolução do sistema;
* **reusabilidade** : a herança e o polimorfismo permitem reutilizar código existente em diferentes contextos, aumentando a produtividade e reduzindo a redundância;
* **flexibilidade** : o encapsulamento e o polimorfismo tornam o código mais flexível e adaptável a mudanças, facilitando a manutenção e a extensão do sistema;
* **escalabilidade** : a poo facilita o desenvolvimento de sistemas complexos e de grande porte, permitindo dividir o problema em partes menores e gerenciáveis;
* **manutenibilidade** : a organização modular e a reutilização de código tornam o sistema mais fácil de manter e atualizar ao longo do tempo;

## comando `class`

O comando `class` em Python é usado para definir uma **classe**.

### sintaxe básica

O comando `class` cria uma nova classe em Python. A sintaxe é a seguinte:

```python
class NomeDaClasse:
    pass
```

Aqui, `NomeDaClasse` é o nome da classe que se está criando. O comando `pass` é um placeholder que significa "não faça nada". Ele é temporariamente usado quando você quer definir uma classe sem especificar nenhum detalhe ainda.

Exemplo:

```python
class Carro:
    pass
```

Neste exemplo, foi criada uma classe chamada `Carro`, mas ela ainda não tem nenhuma característica ou comportamento.

### instâncias

Depois de definir uma classe, é possível criar **instâncias** dessa classe. Uma instância é um objeto criado a partir de uma classe, ou seja, um "exemplar" específico dessa classe.

Usando o exemplo da classe `Carro`, é possível criar uma instância da seguinte forma :

```python
meu_carro = Carro()
```

Aqui, `meu_carro` é uma instância da classe `Carro`. Ele é um objeto real, enquanto a classe `Carro` é apenas o molde ou a definição. É possível criar várias instâncias da mesma classe :

```python
carro1 = Carro()
carro2 = Carro()
```

Aqui, `carro1` e `carro2` são duas instâncias diferentes da mesma classe `Carro`. Elas compartilham a mesma estrutura (porque vêm da mesma classe), mas são objetos separados e podem ter suas próprias características.

### classe vs objeto

- **classe** : é uma definição ou molde, como uma receita de bolo ou a planta de um prédio. Ela descreve como os objetos devem ser, mas não é o objeto em si.
- **objeto (ou instância)** : é o resultado concreto criado a partir da classe. Quando se usa a classe para criar algo real, isso é chamado de objeto ou instância.

### exemplo no mundo real

Pense em uma classe como um **plano de uma casa**. O plano define o número de quartos, banheiros, o tamanho da cozinha, etc. Mas ele não é uma casa de verdade.

- a classe é o plano da casa;
- as casas construídas com base nesse plano são os objetos (ou instâncias);

Pode-se construir várias casas usando o mesmo plano, e cada casa será uma instância diferente, embora todas sigam o mesmo formato geral definido no plano.

## método `__init__`

O `__init__` é um **método especial** (também chamado de **método mágico**) em Python. Ele é o **construtor** de uma classe e é responsável por **inicializar** os atributos de uma instância de uma classe assim que essa instância é criada.

Quando se cria uma instância de uma classe, o Python chama automaticamente o método `__init__` para configurar essa nova instância. Embora o `__init__` pareça um método comum, ele tem uma função especial de configurar os atributos iniciais do objeto.

O `__init__` é definido dentro de uma classe da seguinte maneira:

```python
class NomeDaClasse:
    def __init__(self, parametros):
        # inicializa os atributos da instância
```

- o primeiro parâmetro de `__init__` é sempre `self`, que representa a instância da classe; ele é um opcional obrigatório e permite acessar os atributos e métodos dessa instância;
- além de `self`, ainda é poissível passar outros parâmetros ao método `__init__` para inicializar os atributos da instância com valores personalizados;

- Exemplo simples :

```python
class Carro:
    def __init__(self, marca, modelo):
        self.marca = marca
        self.modelo = modelo
```

Aqui :

- o método `__init__` recebe `marca` e `modelo` como parâmetros e os usa para definir os atributos `self.marca` e `self.modelo` da instância;
- o `self` refere-se à instância que está sendo criada, e os valores passados ao método `__init__` (como `marca` e `modelo`) são usados para inicializar essa instância;

Quando um objeto da classe `Carro` é criado, o Python executa automaticamente o método `__init__`.

```python
carro1 = Carro('Toyota', 'Corolla')
carro2 = Carro('Honda', 'Civic')
```

- para `carro1`, o `__init__` vai definir `self.marca = 'Toyota'` e `self.modelo = 'Corolla'`;
- para `carro2`, o `__init__` vai definir `self.marca = 'Honda'` e `self.modelo = 'Civic'`;

### o construtor de uma classe

Em Python, o método `__init__` é frequentemente chamado de **construtor** da classe, embora tecnicamente o construtor real seja o método `__new__`. No entanto, o `__init__` é o método que **inicializa** o objeto após a criação.

- o construtor, no sentido prático do termo em Python, é o responsável por **preparar** o objeto recém-criado, atribuindo valores iniciais aos seus atributos;

O fluxo de criação de uma instância de classe pode ser descrito assim :

1. o Python chama o método `__new__` para **criar** uma nova instância da classe;
1. em seguida, chama o método `__init__` para **inicializar** os atributos dessa instância;

Para a maioria dos desenvolvedores, o `__init__` é o que importa, pois é onde se define o estado inicial de um objeto. É nele que os **atributos de instância** são configurados.

## atributos

Os **atributos** são variáveis que armazenam informações sobre um objeto. Eles definem as propriedades e o estado de uma instância de uma classe.

Existem dois tipos principais de atributos em Python :

- **atributos de instância**
- **atributos de classe**

### atributos de instância

Os **atributos de instância** são variáveis que pertencem a uma instância específica de uma classe. Cada instância de uma classe pode ter seus próprios valores para esses atributos, permitindo que objetos diferentes da mesma classe tenham características únicas.

Os atributos de instância são definidos dentro do método `__init__` usando a referência `self`. O `self` permite associar os valores passados como parâmetros ao objeto que está sendo criado.

- Exemplo de Atributos de Instância :

No exemplo abaixo, foi criada uma classe `Carro` com atributos de instância como `marca`, `modelo`, e `ano` :

```python
class Carro:
    def __init__(self, marca, modelo, ano):
        self.marca = marca  # atributo de instância
        self.modelo = modelo  # atributo de instância
        self.ano = ano  # atributo de instância
```

Aqui :
- `self.marca`, `self.modelo`, e `self.ano` são os **atributos de instância**;
- Cada instância da classe `Carro` terá seus próprios valores para esses atributos;

Quando se cria diferentes instâncias, cada uma terá seus próprios valores para `marca`, `modelo` e `ano` s:

```python
carro1 = Carro('Toyota', 'Corolla', 2020)
carro2 = Carro('Honda', 'Civic', 2019)

print(carro1.marca)  # Toyota
print(carro2.modelo)  # Civic
print(carro1.ano)  # 2020
```

- o objeto `carro1` terá os atributos `marca='Toyota'`, `modelo='Corolla'`, e `ano=2020`;
- o objeto `carro2` terá os atributos `marca='Honda'`, `modelo='Civic'`, e `ano=2019`;

Esses valores são **específicos** para cada instância de `Carro`, e podem ser diferentes para cada objeto criado.

### atributos de classe

Os **atributos de classe** são compartilhados por **todas** as instâncias de uma classe. Eles são definidos diretamente dentro da classe e fora de qualquer método. Todos os objetos dessa classe acessam e compartilham o mesmo valor para esses atributos, a menos que sejam sobrescritos.

```python
class Carro:
    rodas = 4  # atributo de classe, compartilhado por todas as instâncias

    def __init__(self, marca, modelo, ano):
        self.marca = marca  # atributo de instância
        self.modelo = modelo  # atributo de instância
        self.ano = ano  # atributo de instância
```

Aqui, `rodas` é um **atributo de classe**. Ele é o mesmo para todas as instâncias da classe `Carro` :

```python
carro1 = Carro('Toyota', 'Corolla', 2020)
carro2 = Carro('Honda', 'Civic', 2019)

print(carro1.rodas)  # 4
print(carro2.rodas)  # 4
```

Se um dos objetos mudar o valor de `rodas`, ele só afetará esse objeto se for sobrescrito em nível de instância:

```python
carro1.rodas = 6  # Muda o número de rodas apenas para carro1
print(carro1.rodas)  # 6
print(carro2.rodas)  # 4 (não foi alterado)
```

### atributos de instância vs atributos de classe

Como mencionado antes, os **atributos de instância** pertencem a cada objeto separadamente, enquanto os **atributos de classe** pertencem à classe em si e são compartilhados por todas as instâncias.

```python
class Carro:
    rodas = 4  # atributo de classe (compartilhado por todas as instâncias)

    def __init__(self, marca, modelo, ano):
        self.marca = marca  # atributo de instância (específico para cada instância)
        self.modelo = modelo  # atributo de instância
        self.ano = ano  # atributo de instância
```

Aqui:
- `rodas` é um **atributo de classe**. Todos os carros (instâncias) terão 4 rodas, a menos que seja explicitamente alterado.
- `marca`, `modelo` e `ano` são **atributos de instância**. Eles podem variar de um carro para outro.

## métodos de instância

Os **métodos de instância** são funções definidas dentro de uma classe que operam sobre uma instância específica dessa classe. Ou seja, eles têm acesso e podem modificar os **atributos de instância** — valores únicos para cada objeto criado a partir da classe.

Cada método de instância, por convenção, tem o parâmetro `self` como seu primeiro argumento. O `self` se refere à instância específica da classe sobre a qual o método está sendo chamado e permite que você acesse ou modifique seus atributos.

### estrutura

```python
class MinhaClasse:
    def __init__(self, valor):
        self.valor = valor  # atributo de instância

    def metodo_instancia(self):
        print(f"O valor atual é: {self.valor}")
```

Aqui, `metodo_instancia` é um método de instância. Quando chamamos esse método em uma instância de `MinhaClasse`, ele acessa o atributo `valor` daquela instância em particular.

- **`self`**: É a referência à instância atual da classe. Sempre deve ser o primeiro parâmetro em qualquer método de instância, mas não é necessário passá-lo explicitamente ao chamar o método; o Python o gerencia automaticamente. Ele permite que o método acesse e modifique os atributos e outros métodos de instância.

- **Método de instância**: Qualquer função dentro de uma classe que tem `self` como o primeiro parâmetro.

### exemplos

#### exemplo 1: criando e chamando um método de instância

```python
class Pessoa:
    def __init__(self, nome, idade):
        self.nome = nome  # atributo de instância
        self.idade = idade  # atributo de instância

    def saudacao(self):  # método de instância
        print(f"Olá, meu nome é {self.nome} e tenho {self.idade} anos.")
```

Aqui, o método de instância `saudacao` usa `self` para acessar os atributos `nome` e `idade`.

```python
# Criando uma instância de Pessoa
pessoa1 = Pessoa("Ana", 30)
pessoa1.saudacao()  # Chama o método saudacao
```

**Saída:**

```
Olá, meu nome é Ana e tenho 30 anos.
```

- o método `saudacao` foi chamado na instância `pessoa1`. Ele acessa os atributos `nome` e `idade` através do `self`;

#### exemplo 2: modificando atributos com métodos de instância

```python
class Carro:
    def __init__(self, marca, modelo):
        self.marca = marca  # atributo de instância
        self.modelo = modelo  # atributo de instância

    def mudar_modelo(self, novo_modelo):  # método de instância
        self.modelo = novo_modelo  # Modificando o atributo de instância
        print(f"O modelo do carro foi atualizado para {self.modelo}.")

# Criando uma instância de Carro
meu_carro = Carro("Toyota", "Corolla")
meu_carro.mudar_modelo("Camry")  # Modifica o modelo
```

**Saída:**

```
O modelo do carro foi atualizado para Camry.
```

- o método `mudar_modelo` foi usado para modificar o valor do atributo `modelo` da instância `meu_carro`;

#### exemplo 3: métodos de instância que executam cálculos

```python
class Retangulo:
    def __init__(self, largura, altura):
        self.largura = largura  # atributo de instância
        self.altura = altura  # atributo de instância

    def calcular_area(self):  # método de instância
        return self.largura * self.altura

# Criando uma instância de Retangulo
meu_retangulo = Retangulo(5, 3)
area = meu_retangulo.calcular_area()  # Chamando o método calcular_area
print(f"A área do retângulo é: {area}")
```

**Saída:**

```
A área do retângulo é: 15
```

- aqui, o método `calcular_area` retorna a área do retângulo multiplicando os atributos `largura` e `altura`;

### importância dos métodos de instância

1. **Encapsulamento** : eles permitem encapsular o comportamento específico de uma instância dentro da classe; isso mantém a lógica organizada e evita que o código seja espalhado em várias partes do programa;

1. **Acesso e Modificação de Atributos** : métodos de instância podem acessar, modificar e retornar os valores dos atributos de uma instância específica, facilitando o gerenciamento do estado interno do objeto;

1. **Reutilização** : os métodos de instância permitem reutilizar o comportamento, pois pode criar várias instâncias de uma classe e usar os mesmos métodos em diferentes objetos;

#### exemplo 4: métodos que combinam atributos

```python
class ContaBancaria:
    def __init__(self, titular, saldo):
        self.titular = titular
        self.saldo = saldo  # atributo de instância

    def depositar(self, valor):  # método de instância
        self.saldo += valor
        print(f"Depósito de {valor} realizado com sucesso. Saldo atual: {self.saldo}")

    def sacar(self, valor):  # método de instância
        if valor > self.saldo:
            print("Saldo insuficiente!")
        else:
            self.saldo -= valor
            print(f"Saque de {valor} realizado com sucesso. Saldo atual: {self.saldo}")

# Criando uma instância de ContaBancaria
minha_conta = ContaBancaria("João", 1000)
minha_conta.depositar(500)  # Adiciona dinheiro na conta
minha_conta.sacar(200)  # Remove dinheiro da conta
```

**Saída:**

```
Depósito de 500 realizado com sucesso. Saldo atual: 1500
Saque de 200 realizado com sucesso. Saldo atual: 1300
```

- o método `depositar` modifica o saldo da instância `minha_conta`, e o método `sacar` verifica se há saldo suficiente antes de realizar o saque;

### diferenciando métodos de instância de outros tipos de métodos

Em Python, existem três tipos principais de métodos em classes:

1. **métodos de instância** : já discutidos, são os mais comuns e operam em instâncias individuais de uma classe;

1. **métodos de classe** : usam o decorador `@classmethod` e recebem a própria classe como primeiro argumento, em vez de uma instância;

1. **métodos estáticos** : usam o decorador `@staticmethod` e não recebem nem a instância nem a classe como parâmetro. são usados quando o comportamento do método não depende da instância ou da classe;

Os métodos de **classe** e **estátivco** serão vistos posteriormente.

## exercícios

<details>
<summary>Lista de Exercícios</summary>

1. Exercícios sobre o Método `__init__`
    1. **Classe simples com `__init__`** : Crie uma classe `Animal` com o método `__init__` que inicialize o atributo `especie`.
    1. **Múltiplos parâmetros no `__init__`** : Crie uma classe `Livro` com o método `__init__` que receba os parâmetros `titulo` e `autor`.
    1. **Parâmetros padrão no `__init__`** : Crie uma classe `Produto` com o método `__init__`, onde o atributo `preco` tenha um valor padrão de 100.
    1. **Inicializando listas no `__init__`** : Crie uma classe `Estudante` com o método `__init__` que inicialize o atributo `notas` como uma lista vazia.
    1. **Modificando o `__init__`** : Modifique a classe `Estudante` do exercício anterior para permitir passar uma lista de notas como parâmetro no método `__init__`.
    1. **Verificação no `__init__`** : Crie uma classe `Pessoa` com o método `__init__` que receba a `idade` e garanta que a idade seja sempre maior que 0.
    1. **Atributo opcional no `__init__`** : Crie uma classe `Computador` que tenha um atributo opcional `marca`, cujo valor padrão seja `"Genérica"` no `__init__`.
    1. **Exibindo valores no `__init__`** : Crie uma classe `Filme` e, no método `__init__`, exiba o título do filme assim que a instância for criada.
    1. **Usando variáveis locais dentro do `__init__`** : Crie uma classe `Carro` com os atributos `marca` e `modelo`, onde o método `__init__` use variáveis locais para armazenar os parâmetros antes de inicializar os atributos de instância.
    1. **Criando instâncias dentro do `__init__`** :  Crie uma classe `Equipe` que, no método `__init__`, crie uma lista de membros (strings) fornecida como parâmetro.
1. Exercícios sobre Atributos de Instância
    1. **Acessando atributos de instância** :  Crie uma classe `Aluno` com os atributos de instância `nome` e `idade`. Crie um objeto e imprima o valor de seus atributos.
    1. **Modificando atributos de instância** :  Crie uma classe `Funcionario` com o atributo `salario`. Crie um objeto e imprima o valor de seus atributos.
    1. **Atributos dependentes de outros** :  Crie uma classe `Circulo` com os atributos `raio` e `area`, onde o `area` seja calculado no método `__init__` a partir do `raio`.
    1. **Atributos com valores fornecidos pelo usuário** :  Crie uma classe `Carro` com os atributos `marca` e `ano`. Permita que o usuário forneça os valores desses atributos ao criar a instância.
    1. **Lista de atributos de instância** :  Crie uma classe `Biblioteca` com um atributo `livros`, que seja uma lista de livros (strings) fornecida no método `__init__`.
    1. **Adicionando elementos a um atributo de instância** :  Crie uma classe `CestaDeCompras` com um atributo `produtos` (uma lista vazia). Peça ao usuário diversos itens que são adicionados em `produtos`.
    1. **Atributos de instância como contadores** :  Crie uma classe `Contador` com um atributo `valor`, que seja inicializado como 0 no método `__init__`. Peça para o usuário um número e incremente `valor` até o número escolhido pelo usuário.
    1. **Atributos de instância dependentes de condições** :  Crie uma classe `Candidato` com os atributos `nome` e `aprovado`. Se a nota for maior ou igual a 60, o atributo `aprovado` deve ser `True`, caso contrário, `False`.
    1. **Atributos de instância com valores calculados** :  Crie uma classe `Viagem` com os atributos `distancia` e `tempo`. Adicione um atributo `velocidade_media` que seja calculado dividindo a distância pelo tempo.
    1. **Atributos de instância inicializados como objetos** :  Crie uma classe `Casa` com um atributo de instância `proprietario`, que seja inicializado como uma instância de uma classe `Pessoa`.
1. Exercícios sobre Atributos de Classe
    1. **Atributo de classe simples** :  Crie uma classe `Pessoa` com um atributo de classe `especie` cujo valor seja `"Humano"`.
    1. **Acessando um atributo de classe** :  Crie uma classe `Carro` com o atributo de classe `rodas` igual a 4. Crie uma instância da classe e acesse o valor do atributo `rodas`.
    1. **Modificando um atributo de classe** :  Crie uma classe `Empresa` com um atributo de classe `empregados`. Modifique o valor desse atributo para 50 fora da classe.
    1. **Atributos de classe com valores dinâmicos** :  Crie uma classe `Banco` com o atributo de classe `taxa_juros`. Crie duas instâncias da classe e veja como o atributo de classe pode ser acessado e modificado globalmente.
    1. **Atributos de classe e instância com o mesmo nome** :  Crie uma classe `Animal` com um atributo de classe `especie` e um atributo de instância `especie`. Crie uma instância e veja qual valor prevalece ao acessá-los.
    1. **Contando o número de instâncias de uma classe** :  Crie uma classe `Aluno` com um atributo de classe `numero_de_alunos` que é incrementado sempre que uma nova instância for criada.
    1. **Atributo de classe com valor compartilhado** :  Crie uma classe `Universidade` com o atributo de classe `pais` igual a `"Brasil"`. Verifique que todas as instâncias dessa classe compartilham esse atributo.
    1. **Atributo de classe e `__init__`** :  Crie uma classe `Livro` com um atributo de classe `numero_de_livros` e incremente esse valor sempre que um novo livro for criado.
    1. **Verificando se o atributo é de instância ou de classe** :  Crie uma classe `Fruta` com um atributo de classe `tipo` e um atributo de instância `cor`. Verifique todos os valores dos atributos.
    1. **Atributos de classe versus instância** :  Crie uma classe `Celular` com um atributo de classe `tecnologia` e um atributo de instância `modelo`. Crie uma instância e veja como os atributos de classe e instância coexistem e podem ser acessados separadamente.
1. Exercícios sobre Atributos e Métodos de Instância
    1. **Criação e Exibição de Atributos** : Crie uma classe `Pessoa` com os atributos de instância `nome` e `idade`. Adicione um método `exibir_informacoes` que exiba esses atributos.
    1. **Atualização de Atributo via Método** : Crie uma classe `Carro` com os atributos `marca` e `modelo`. Adicione um método `mudar_modelo` que permita alterar o modelo do carro.
    1. **Cálculo com Atributos de Instância** : Crie uma classe `Retangulo` com os atributos `largura` e `altura`. Adicione um método `calcular_area` que retorne a área do retângulo.
    1. **Verificação de Atributos** : Crie uma classe `ContaBancaria` com os atributos `saldo` e `titular`. Adicione um método `verificar_saldo` que verifique se o saldo é suficiente para realizar uma operação.
    1. **Método que Retorna Atributos** : Crie uma classe `Livro` com os atributos `titulo` e `autor`. Adicione um método `informacoes_livro` que retorne uma string contendo o título e o autor do livro.
    1. **Modificação Condicional de Atributos** : Crie uma classe `Elevador` com o atributo `andar_atual`. Adicione métodos para `subir` e `descer` de andar, verificando se o andar atual está dentro dos limites de um prédio de 10 andares.
    1. **Método que Usa Vários Atributos** : Crie uma classe `Produto` com os atributos `preco` e `quantidade`. Adicione um método `calcular_total` que retorne o valor total do estoque com base no preço e quantidade.
    1. **Modificação e Exibição de Atributos** : Crie uma classe `Jogador` com os atributos `nome`, `pontos`. Adicione um método `ganhar_pontos` que aumente os pontos do jogador e exiba a nova pontuação.
    1. **Método que Modifica Atributos de Várias Instâncias** : Crie uma classe `Amigo` com o atributo `humor`. Adicione um método `animar_amigo` que mude o humor de todos os amigos de uma lista fornecida.
    1. **Método que Define Atributo com Base em Outros** : Crie uma classe `Circulo` com o atributo `raio`. Adicione um método `definir_diametro` que defina o diâmetro com base no raio.
    1. **Método que Modifica Mais de um Atributo** : Crie uma classe `ContaCorrente` com os atributos `saldo` e `limite`. Adicione um método `ajustar_limite` que ajuste o limite com base no saldo atual.
    1. **Método que Zera Atributos** : Crie uma classe `Jogador` com os atributos `nome` e `vidas`. Adicione um método `perder_vidas` que diminua o número de vidas e um método `resetar_vidas` que zere as vidas.
    1. **Método com Operações Matemáticas em Atributos** : Crie uma classe `Vendedor` com os atributos `vendas` e `comissao`. Adicione um método `calcular_comissao` que retorne o valor da comissão baseada nas vendas e uma porcentagem de comissão.
    1. **Método que Atualiza Listas como Atributos** : Crie uma classe `Turma` com um atributo `alunos` (uma lista). Adicione um método `adicionar_aluno` que permita adicionar novos alunos à turma.
    1. **Método que Lida com Atributos Complexos** : Crie uma classe `Funcionario` com o atributo `horas_trabalhadas`. Adicione um método `registrar_horas` que atualize o total de horas trabalhadas e calcule o pagamento com base em uma taxa por hora.
    1. **Método que Verifica e Modifica Atributos Condicionalmente** : Crie uma classe `CarroEletrico` com os atributos `bateria` (em %) e `autonomia`. Adicione um método `carregar_bateria` que aumenta a porcentagem da bateria e ajuste a autonomia com base na carga.
    1. **Método que Faz Comparações entre Atributos** : Crie uma classe `Produto` com os atributos `preco` e `desconto`. Adicione um método `aplicar_desconto` que subtraia o desconto do preço e retorne o preço final.
    1. **Método com Condicionais e Modificações** : Crie uma classe `Aluno` com os atributos `nome`, `notas` (uma lista de notas) e `media`. Adicione um método `calcular_media` que calcule a média das notas e defina se o aluno está aprovado ou não (média >= 7).
    1. **Método que Reconfigura um Atributo** : Crie uma classe `Veiculo` com o atributo `velocidade`. Adicione um método `ajustar_velocidade` que defina um novo valor para a velocidade e exiba a nova velocidade.
    1. **Método que Lida com Atributos Dinâmicos** : Crie uma classe `Cachorro` com os atributos `nome` e `energia`. Adicione métodos `brincar` (que reduz a energia) e `descansar` (que aumenta a energia), com o valor de energia nunca podendo ser menor que 0 ou maior que 100.

</details>

## métodos mágicos

**Métodos mágicos**, também conhecidos como **métodos dunder** (double underscore ou “duplo sublinhado”) em Python, são funções especiais que têm nomes com dois underscores no início e no fim, como `__init__`, `__str__`, `__len__`, entre outros. Esses métodos permitem que se defina comportamentos especiais para suas classes e instâncias, personalizando como os objetos se comportam em diferentes situações, como ao serem criados, comparados, adicionados, multiplicados, ou quando se tenta acessá-los de maneira específica.

A principal função desses métodos é permitir a **sobrecarga de operadores** (como `+`, `-`, `*`, `==`) e comportamentos integrados, ou seja, definir o que acontece quando se tenta utilizar operadores ou funções nativas em suas classes personalizadas. Eles também são usados em casos mais comuns, como :

- inicialização de objetos (`__init__`);
- representação de objetos como strings (`__str__`, `__repr__`);
- comparação entre objetos (`__eq__`, `__lt__`, etc.);
- implementação de coleções customizadas (`__getitem__`, `__setitem__`, etc.);

Esses métodos são automaticamente invocados em várias situações. Eles são um dos pilares da programação orientada a objetos em Python, proporcionando flexibilidade e personalização ao comportamento de objetos.

## método `__str__`

O método `__str__` é utilizado para **definir uma representação "legível" ou amigável** de um objeto. Esse método é chamado automaticamente quando usamos a função `print()` ou `str()` em uma instância de uma classe. A ideia por trás de `__str__` é gerar uma saída que seja útil para o **usuário final**, tornando o objeto mais fácil de entender.

**Exemplo**

```python
class Pessoa:
    def __init__(self, nome, idade):
        self.nome = nome
        self.idade = idade

    def __str__(self):
        return f'{self.nome} tem {self.idade} anos.'

# criação de uma instância
pessoa1 = Pessoa("João", 30)

# utilizando print(), que chama __str__
print(pessoa1)  # saída : João tem 30 anos.
```

Neste exemplo, o método `__str__` foi implementado para que, quando a instância `pessoa1` for impressa, a saída seja uma frase legível para o usuário. Essa frase foi projetada para ser amigável e facilmente compreendida.

## método `__repr__`

O método `__repr__` é utilizado para fornecer uma **representação oficial e mais técnica do objeto**, muitas vezes com o objetivo de ser usada para **depuração** (debugging). A convenção é que `__repr__` tente retornar uma string que, se possível, possa ser utilizada para **recriar** o objeto (ou ao menos fornecer informações detalhadas sobre ele). Seu propósito principal é fornecer uma representação precisa para desenvolvedores.

**Exemplo**

```python
class Pessoa:
    def __init__(self, nome, idade):
        self.nome = nome
        self.idade = idade

    def __repr__(self):
        return f'Pessoa(nome={self.nome!r}, idade={self.idade!r})'

# Criação de uma instância
pessoa1 = Pessoa("João", 30)

# Chamando diretamente __repr__
print(repr(pessoa1))  # saída : Pessoa(nome='João', idade=30)
```

Aqui, o método `__repr__` foi implementado para exibir os valores exatos dos atributos `nome` e `idade`, permitindo que a saída fosse mais detalhada e útil para entender o estado interno do objeto. Isso ajuda em depuração e, se possível, até recriar a instância de maneira precisa.

Dentro de uma `f-string` (formatted string literal), o `!r` é um especificador de formato que instrui o interpretador a usar a função `repr()` no valor da variável que o precede. Em outras palavras, ele garante que a representação da string do valor seja a mesma que seria obtida se chamasse explicitamente `repr()` nesse valor

## `__str__` vs `__repr__`

### finalidade

- **`__str__`** : é voltado para o usuário final, como ao exibir relatórios ou mensagens de log que os usuários verão. O foco está em fornecer uma saída legível e amigável. Ele pode omitir detalhes técnicos e ser mais descritivo;
- **`__repr__`** : é voltado para desenvolvedores. A intenção é fornecer uma representação detalhada e técnica do objeto, idealmente uma que possa ser usada para recriar o objeto. A saída de `__repr__` deve ser mais exata e explícita, especialmente em depuração;

### chamadas automáticas

- **`__str__`** : é chamado quando a função `print()` ou `str()` é usada;
- **`__repr__`** : é chamado quando você usa `repr()`, ou quando se simplesmente digita o nome da instância no prompt do interpretador Python. Se `__str__` não estiver definido, o Python usará `__repr__` como fallback, enquanto o contrário não é verdadeiro (ou seja, se `__repr__` não for definido, Python não utiliza `__str__` para depuração).;

### recriação do objeto

- **`__str__`** : não precisa, e geralmente não deve, tentar recriar o objeto. Seu objetivo é apenas fornecer uma descrição;
- **`__repr__`** : idealmente, a string retornada por `__repr__` deve conter informações suficientes para recriar o objeto;

### exemplo comparativo

Veja a classe `Carro` implementar ambos os métodos para comparar como eles funcionam

```python
class Carro:
    def __init__(self, marca, modelo, ano):
        self.marca = marca
        self.modelo = modelo
        self.ano = ano

    def __str__(self):
        return f"{self.marca} {self.modelo} ({self.ano})"

    def __repr__(self):
        return f"Carro(marca={self.marca!r}, modelo={self.modelo!r}, ano={self.ano!r})"

# criando uma instância
carro1 = Carro("Toyota", "Corolla", 2020)

# usando print(), que chama __str__
print(carro1)  # saída : Toyota Corolla (2020)

# usando repr(), que chama __repr__
print(repr(carro1))  # saída : Carro(marca='Toyota', modelo='Corolla', ano=2020)
```

**Explicação**

- **`__str__`** : a saída `Toyota Corolla (2020)` é concisa e legível. Ela não se preocupa com o fato de que os valores de `marca`, `modelo` e `ano` são strings. Isso é o que um usuário final esperaria ver ao visualizar as informações do carro.

- **`__repr__`** : a saída `Carro(marca='Toyota', modelo='Corolla', ano=2020)` é mais técnica. Ela exibe os valores dos atributos entre aspas e no formato de uma chamada de construtor, facilitando o entendimento do estado interno do objeto. Essa saída seria útil para um desenvolvedor que está inspecionando o objeto durante a depuração.

### em suma

- **`__str__`**:
    - imprimir informações para o usuário final;
    - gerar relatórios;
    - criar uma saída amigável para logs ou interfaces de usuário;

- **`__repr__`**:
    - durante a depuração, para ver os detalhes técnicos do objeto;
    - para testar como os atributos de uma instância foram configurados;
    - em ambientes de desenvolvimento, como ao inspecionar o objeto no terminal do python;

## exercícios `__str__` e `__repr__`

<details>
<summary>Lista de Exercícios</summary>

1. 10 Exercícios para o Método `__str__`
    1. Crie uma classe `Livro` que tenha os atributos `titulo`, `autor` e `ano_publicacao`. Implemente o método `__str__` para que ele retorne uma string no formato: `"Título: <titulo>, Autor: <autor>, Ano: <ano_publicacao>"`. Crie instâncias dessa classe e use `print()` para exibir as informações.
    1. Crie uma classe `Produto` com os atributos `nome` e `preco`. Implemente o método `__str__` para que retorne uma string que diga: `"Produto: <nome>, Preço: R$ <preco>"`. Crie pelo menos 3 instâncias dessa classe e exiba as informações de cada produto usando `print()`.
    1. Faça uma classe `Pessoa` com os atributos `nome`, `idade` e `cidade`. No método `__str__`, mostre uma frase que inclua esses atributos em um formato legível. Instancie a classe e use `print()` para mostrar o resultado.
    1. Crie uma classe `Veiculo` com os atributos `marca`, `modelo` e `ano`. Implemente o método `__str__` para que a saída seja algo como: `"Veículo: <marca> <modelo> - Ano: <ano>"`. Crie algumas instâncias e teste a saída.
    1. Crie uma classe `ContaBancaria` que possua os atributos `titular` e `saldo`. Implemente o método `__str__` para exibir: `"Conta de <titular>, Saldo: R$ <saldo>"`. Use instâncias dessa classe com o comando `print()`.
    1. Crie uma classe `Filme` com os atributos `titulo`, `diretor` e `ano_lancamento`. No método `__str__`, mostre uma frase no formato: `"Filme: <titulo> (Dirigido por <diretor> - <ano_lancamento>)"`. Instancie e teste a classe.
    1. Crie uma classe `Jogo` com os atributos `nome`, `plataforma` e `genero`. Implemente o método `__str__` para que a saída seja no formato: `"Jogo: <nome> - Plataforma: <plataforma> - Gênero: <genero>"`. Crie objetos e exiba as informações usando `print()`.
    1. Faça uma classe `Aluno` com os atributos `nome`, `matricula` e `curso`. Implemente o método `__str__` para exibir as informações em uma frase completa. Crie alguns objetos e exiba-os.
    1. Crie uma classe `Cidade` com os atributos `nome`, `estado` e `populacao`. Use o método `__str__` para gerar uma string no formato: `"Cidade: <nome>, Estado: <estado>, População: <populacao>"`. Instancie e teste.
    1. Crie uma classe `Carro` com os atributos `marca`, `modelo` e `cor`. No método `__str__`, exiba a seguinte mensagem: `"Carro: <marca> <modelo> na cor <cor>"`. Crie instâncias e teste com o `print()`.
1. 10 Exercícios para o Método `__repr__`
    1. Crie uma classe `Livro` com os atributos `titulo`, `autor` e `ano_publicacao`. Implemente o método `__repr__` para retornar: `"Livro(titulo='<titulo>', autor='<autor>', ano_publicacao=<ano_publicacao>)"`. Crie instâncias e chame `repr()` para testar.
    1. Faça uma classe `Produto` com os atributos `nome` e `preco`. Implemente o método `__repr__` para retornar uma string que reproduza a criação do objeto, como: `"Produto(nome='<nome>', preco=<preco>)"`. Teste no terminal do Python.
    1. Crie uma classe `Pessoa` com os atributos `nome`, `idade` e `cidade`. Implemente o método `__repr__` de forma que ele retorne uma string no formato: `"Pessoa(nome='<nome>', idade=<idade>, cidade='<cidade>')"`. Teste com o comando `repr()`.
    1. Crie uma classe `ContaBancaria` com os atributos `titular` e `saldo`. No método `__repr__`, retorne: `"ContaBancaria(titular='<titular>', saldo=<saldo>)"`. Instancie e teste no terminal chamando `repr()`.
    1. Crie uma classe `Carro` com os atributos `marca`, `modelo` e `ano`. Implemente o método `__repr__` de forma que retorne a seguinte string: `"Carro(marca='<marca>', modelo='<modelo>', ano=<ano>)"`. Use `repr()` para verificar.
    1. Crie uma classe `Filme` com os atributos `titulo`, `diretor` e `ano_lancamento`. No método `__repr__`, retorne algo como: `"Filme(titulo='<titulo>', diretor='<diretor>', ano_lancamento=<ano_lancamento>)"`. Teste no terminal chamando `repr()`.
    1. Faça uma classe `Aluno` com os atributos `nome`, `matricula` e `curso`. No método `__repr__`, exiba algo no formato: `"Aluno(nome='<nome>', matricula='<matricula>', curso='<curso>')"`. Instancie objetos e teste com `repr()`.
    1. Crie uma classe `Jogo` com os atributos `nome`, `plataforma` e `genero`. No método `__repr__`, retorne algo como: `"Jogo(nome='<nome>', plataforma='<plataforma>', genero='<genero>')"`. Teste o método `repr()`.
    1. Crie uma classe `Cidade` com os atributos `nome`, `estado` e `populacao`. Implemente o método `__repr__` para retornar: `"Cidade(nome='<nome>', estado='<estado>', populacao=<populacao>)"`. Teste o método.
    1. Crie uma classe `Empresa` com os atributos `nome`, `fundacao` e `localizacao`. No método `__repr__`, retorne: `"Empresa(nome='<nome>', fundacao=<fundacao>, localizacao='<localizacao>')"`. Crie instâncias e chame `repr()`.

</details>

## métodos mágicos de operadores aritméticos

Os métodos mágicos dos operadores aritméticos permitem que se defina como os objetos de uma classe personalizada devem se comportar quando são envolvidos em operações matemáticas, como adição, subtração, multiplicação, etc. Esses métodos são chamados **sobrecarga de operadores** (operator overloading), já que permitem redefinir o comportamento de operadores padrão (como `+`, `-`, `*`, etc.) para tipos definidos pelo usuário.

Uma lista completa deles pode ser encontrada [aqui](https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types).

### lista de alguns métodos mágicos aritméticos

- `__add__(self, other)` : adição (`+`)
- `__sub__(self, other)` : subtração (`-`)
- `__mul__(self, other)` : multiplicação (`*`)
- `__truediv__(self, other)` : divisão (`/`)
- `__floordiv__(self, other)` : divisão inteira (`//`)
- `__mod__(self, other)` : módulo (resto da divisão) (`%`)
- `__pow__(self, other)` : exponenciação (`**`)

Observe que todos esses métodos recebem um segundo argumento chamado `other`. Na maioria dos casos, esse argumento deve ser do mesmo tipo que `self` ou um tipo compatível. Se esse não for o caso, pode-se levantar um erro.

### `__add__()`

O método `__add__(self, other)` define o comportamento para o operador `+`. Ele é chamado quando se tenta adicionar dois objetos.

**Exemplo**

```python
class Numero:
    def __init__(self, valor):
        self.valor = valor

    def __add__(self, outro):
        print('__add__ chamado')
        return Numero(self.valor + outro.valor)

    def __repr__(self):
        return f"Numero({self.valor})"

# criando dois objetos
num1 = Numero(10)
num2 = Numero(20)

# usando o operador de adição
soma = num1 + num2
# __add__ chamado
print(soma)
# saída :
# Numero(30)
```

Neste exemplo, `__add__` define o comportamento do operador `+` para a classe `Numero`, retornando um novo objeto `Numero` com o valor somado.

### `__sub__()`

O método `__sub__(self, other)` define o comportamento para o operador de subtração (`-`).

**Exemplo**

```python
class Numero:
    def __init__(self, valor):
        self.valor = valor

    def __sub__(self, outro):
        print('__sub__ chamado')
        return Numero(self.valor - outro.valor)

    def __repr__(self):
        return f"Numero({self.valor})"

num1 = Numero(30)
num2 = Numero(10)

subtracao = num1 - num2
# __sub__ chamado
print(subtracao)
# saída :
# Numero(20)
```

### `__mul__()`

O método `__mul__(self, other)` define o comportamento para a multiplicação (`*`).

**Exemplo**

```python
class Numero:
    def __init__(self, valor):
        self.valor = valor

    def __mul__(self, outro):
        print('__mul__ chamado')
        return Numero(self.valor * outro.valor)

    def __repr__(self):
        return f"Numero({self.valor})"

num1 = Numero(5)
num2 = Numero(3)

multiplicacao = num1 * num2
# __mul__ chamado
print(multiplicacao)
# saída :
# Numero(15)
```

### `__truediv__()`

O método `__truediv__(self, other)` define o comportamento para a divisão (`/`).

**Exemplo**

```python
class Numero:
    def __init__(self, valor):
        self.valor = valor

    def __truediv__(self, outro):
        print('__truediv__ chamado')
        return Numero(self.valor / outro.valor)

    def __repr__(self):
        return f"Numero({self.valor})"

num1 = Numero(10)
num2 = Numero(2)

divisao = num1 / num2
# __truediv__ chamado
print(divisao)
# saída :
# Numero(5.0)
```

### `__floordiv__()`

O método `__floordiv(self, other)` define o comportamento para a divisão inteira (`//`).

**Exemplo**

```python
class Numero:
    def __init__(self, valor):
        self.valor = valor

    def __floordiv__(self, outro):
        print('__floordiv__ chamado')
        return Numero(self.valor // outro.valor)

    def __repr__(self):
        return f"Numero({self.valor})"

num1 = Numero(10)
num2 = Numero(3)

divisao_inteira = num1 // num2
# __floordiv__ chamado
print(divisao_inteira)
# saída :
# Numero(3.0)
```

### `__mod__()`

O método `__mod__(self, other)` define o comportamento para o operador de módulo (`%`), que retorna o resto da divisão.

**Exemplo**

```python
class Numero:
    def __init__(self, valor):
        self.valor = valor

    def __mod__(self, outro):
        print('__mod__ chamado')
        return Numero(self.valor % outro.valor)

    def __repr__(self):
        return f"Numero({self.valor})"

num1 = Numero(10)
num2 = Numero(3)

modulo = num1 % num2
# __mod__ chamado
print(modulo)  # saída : Numero(1)
# saída :
# Numero(1)
```

### `__pow__()`

O método `__pow__(self, other[, modulo])` define o comportamento para a exponenciação (`**`).

**Exemplo**

```python
class Numero:
    def __init__(self, valor):
        self.valor = valor

    def __pow__(self, outro, modulo=None):
        print('__pow__ chamado')
        if modulo is None:
            return Numero(self.valor ** outro.valor)
        return Numero(pow(self.valor, outro, modulo))

    def __repr__(self):
        return f"Numero({self.valor})"

num1 = Numero(2)
num2 = Numero(3)

exponenciacao = num1 ** num2
# __pow__ chamado
print(exponenciacao)
# saída :
# Numero(8)
```

### operadores reflexivos

Os operadores reflexivos são usados quando o objeto à esquerda da operação não pode realizar a operação e, portanto, o Python tenta chamar a operação inversa no objeto à direita.

- **`__radd__(self, other)`** : reflexivo da adição
- **`__rsub__(self, other)`** : reflexivo da subtração
- **`__rmul__(self, other)`** : reflexivo da multiplicação
- **`__rtruediv__(self, other)`** : reflexivo da divisão
- **`__rfloordiv__(self, other)`** : reflexivo da divisão inteira
- **`__rmod__(self, other)`** : reflexivo do módulo (resto da divisão)
- **`__rpow__(self, other[, modulo])`** : reflexivo da exponenciação

Esses métodos são úteis quando se deseja permitir que operações entre objetos de tipos diferentes sejam realizadas corretamente.

**Exemplo**

```python
class Numero:
    def __init__(self, valor):
        self.valor = valor

    def __add__(self, outro):
        print('__add__ chamado')
        return Numero(self.valor + outro.valor)

    def __radd__(self, outro):
        print("__radd__ chamado")
        return Numero(self.valor + outro)

    def __repr__(self):
        return f"Numero({self.valor})"

# criando dois objetos
num1 = Numero(10)
num2 = Numero(20)

# usando o operador de adição
soma = num1 + num2
# __add__ chamado
print(soma)
# saída :
# Numero(30)

# usando um objeto do tipo inteiro
soma = 2 + num1
# __radd__ chamado
print(soma)
# saída :
# Numero(12)
```

---

### operadores in-place

Os **operadores in-place** são utilizados para modificar o objeto à esquerda em vez de criar um novo. Eles correspondem aos operadores como `+=`, `-=`, `*=`, etc.

- `__iadd__(self, other)` para `self += other`
- `__isub__(self, other)` para `self -= other`
- `__imul__(self, other)` para `self *= other`
- `__itruediv__(self, other)` para `self /= other`
- `__ifloordiv__(self, other)` para `self //= other`
- `__imod__(self, other)` para `self %= other`
- `__ipow__(self, other[, modulo])` para `self **= other`

**Exemplo**

```python
class Numero:
    def __init__(self, valor):
        self.valor = valor

    def __add__(self, outro):
        print('__add__ chamado')
        return Numero(self.valor + outro.valor)

    def __iadd__(self, outro):
        print('__iadd__ chamado')
        self.valor += outro
        return self

    def __repr__(self):
        return f"Numero({self.valor})"

num = Numero(10)
num += 5  # modifica o próprio objeto em vez de criar um novo
# __iadd__ chamado
print(num)  # saída : Numero(15)
```

Neste exemplo, o operador `+=` modifica o valor de `num` diretamente, graças à implementação do método `__iadd__`. Sem ele, a operação `+=` criaria um novo objeto ao invés de modificar o existente.

### exemplo completo

Abaixo há um exemplo completo da aplicação dos três métodos mágicos da soma. O mesmo raciocínio pode ser feito para os demais operadores.

```python
class Numero:
    def __init__(self, valor):
        self.valor = valor

    def __add__(self, outro):
        print('__add__ chamado')
        if isinstance(outro, Numero):
            return Numero(self.valor + outro.valor)
        elif isinstance(outro, int | float):
            return Numero(self.valor + outro)
        else:
            raise TypeError("operação de tipo não suportado para +")

    def __radd__(self, outro):
        print("__radd__ chamado")
        return self.__add__(outro)

    def __iadd__(self, outro):
        print('__iadd__ chamado')
        self.valor += outro
        return self

    def __repr__(self):
        return f"Numero({self.valor})"

# criando dois objetos
num1 = Numero(10)
num2 = Numero(20)

soma = num1 + num2
# __add__ chamado
print(soma, end='\n\n')  # saída : Numero(30)

soma = 2 + num1
# __radd__ chamado
# __add__ chamado
print(soma, end='\n\n')  # saída : Numero(12)

num1 += 5
# __iadd__ chamado
print(num1, end='\n\n')  # saída : Numero(15)

num1 += num2
# __iadd__ chamado
# __radd__ chamado
# __add__ chamado
print(num1, end='\n\n')  # saída : Numero(30)
```

- Repare nas 3 chamadas quando é feita a operação `num1 += num2`.

## exercícios métodos mágicos operadores aritméticos

<details>
<summary>Lista de Exercícios</summary>

1. Exercícios para `__add__`, `__radd__`, e `__iadd__`
    1. Crie uma classe `Numero` que implemente o método mágico `__add__` para somar dois objetos dessa classe.
    1. Modifique a classe `Numero` para que também possa somar um número inteiro ou float a um objeto `Numero` utilizando `__add__`.
    1. Implemente o método mágico `__radd__` na classe `Numero` para permitir que a adição funcione quando um número é somado a um objeto `Numero`.
    1. Crie dois objetos da classe `Numero` e realize a soma utilizando o operador `+`. Observe a saída.
    1. Teste a classe `Numero` somando um número inteiro a um objeto `Numero`. Verifique se `__radd__` foi chamado corretamente.
    1. Modifique a classe `Numero` para implementar o método `__iadd__` e permita que o operador `+=` modifique o objeto original.
    1. Crie um objeto `Numero` e utilize o operador `+=` para adicionar um valor a ele. Verifique se o objeto foi modificado corretamente.
    1. Tente somar dois objetos `Numero` e atribuí-los diretamente a um deles usando o operador `+=`. Verifique o resultado.
    1. Crie uma classe `Fracao` que implemente os métodos `__add__`, `__radd__` e `__iadd__` para somar frações.
    1. Teste a classe `Fracao` somando frações e utilizando o operador `+=` para modificar o objeto original.
1. Exercícios para `__sub__`, `__rsub__`, e `__isub__`
    1. Crie uma classe `Numero` que implemente o método mágico `__sub__` para subtrair dois objetos da classe.
    1. Modifique a classe `Numero` para que também possa subtrair um número inteiro ou float de um objeto `Numero` utilizando `__sub__`.
    1. Implemente o método mágico `__rsub__` na classe `Numero` para permitir que a subtração funcione quando um número é subtraído de um objeto `Numero`.
    1. Crie dois objetos da classe `Numero` e realize a subtração utilizando o operador `-`. Observe a saída.
    1. Teste a classe `Numero` subtraindo um número inteiro de um objeto `Numero`. Verifique se `__rsub__` foi chamado corretamente.
    1. Modifique a classe `Numero` para implementar o método `__isub__` e permita que o operador `-=` modifique o objeto original.
    1. Crie um objeto `Numero` e utilize o operador `-=` para subtrair um valor dele. Verifique se o objeto foi modificado corretamente.
    1. Tente subtrair dois objetos `Numero` e atribuí-los diretamente a um deles usando o operador `-=`. Verifique o resultado.
    1. Crie uma classe `Fracao` que implemente os métodos `__sub__`, `__rsub__` e `__isub__` para subtrair frações.
    1. Teste a classe `Fracao` subtraindo frações e utilizando o operador `-=` para modificar o objeto original.
1. Exercícios para `__mul__`, `__rmul__`, e `__imul__`
    1. Crie uma classe `Numero` que implemente o método mágico `__mul__` para multiplicar dois objetos dessa classe.
    1. Modifique a classe `Numero` para que também possa multiplicar um número inteiro ou float a um objeto `Numero` utilizando `__mul__`.
    1. Implemente o método mágico `__rmul__` na classe `Numero` para permitir que a multiplicação funcione quando um número é multiplicado por um objeto `Numero`.
    1. Crie dois objetos da classe `Numero` e realize a multiplicação utilizando o operador `*`. Observe a saída.
    1. Teste a classe `Numero` multiplicando um número inteiro a um objeto `Numero`. Verifique se `__rmul__` foi chamado corretamente.
    1. Modifique a classe `Numero` para implementar o método `__imul__` e permita que o operador `*=` modifique o objeto original.
    1. Crie um objeto `Numero` e utilize o operador `*=` para multiplicá-lo por um valor. Verifique se o objeto foi modificado corretamente.
    1. Tente multiplicar dois objetos `Numero` e atribuí-los diretamente a um deles usando o operador `*=`. Verifique o resultado.
    1. Crie uma classe `Fracao` que implemente os métodos `__mul__`, `__rmul__` e `__imul__` para multiplicar frações.
    1. Teste a classe `Fracao` multiplicando frações e utilizando o operador `*=` para modificar o objeto original.
1. Exercícios para `__truediv__`, `__rtruediv__`, e `__itruediv__`
    1. Crie uma classe `Numero` que implemente o método mágico `__truediv__` para dividir dois objetos dessa classe.
    1. Modifique a classe `Numero` para que também possa dividir um número inteiro ou float por um objeto `Numero` utilizando `__truediv__`.
    1. Implemente o método mágico `__rtruediv__` na classe `Numero` para permitir que a divisão funcione quando um número é dividido por um objeto `Numero`.
    1. Crie dois objetos da classe `Numero` e realize a divisão utilizando o operador `/`. Observe a saída.
    1. Teste a classe `Numero` dividindo um número inteiro por um objeto `Numero`. Verifique se `__rtruediv__` foi chamado corretamente.
    1. Modifique a classe `Numero` para implementar o método `__itruediv__` e permita que o operador `/=` modifique o objeto original.
    1. Crie um objeto `Numero` e utilize o operador `/=` para dividi-lo por um valor. Verifique se o objeto foi modificado corretamente.
    1. Tente dividir dois objetos `Numero` e atribuí-los diretamente a um deles usando o operador `/=`. Verifique o resultado.
    1. Crie uma classe `Fracao` que implemente os métodos `__truediv__`, `__rtruediv__` e `__itruediv__` para dividir frações.
    1. Teste a classe `Fracao` dividindo frações e utilizando o operador `/=` para modificar o objeto original.
1. Exercícios para `__floordiv__`, `__rfloordiv__`, e `__ifloordiv__`
    1. Crie uma classe `Numero` que implemente o método mágico `__floordiv__` para realizar divisão inteira entre dois objetos dessa classe.
    1. Modifique a classe `Numero` para que também possa realizar divisão inteira entre um número inteiro ou float e um objeto `Numero` utilizando `__floordiv__`.
    1. Implemente o método mágico `__rfloordiv__` na classe `Numero` para permitir que a divisão inteira funcione quando um número inteiro é dividido por um objeto `Numero`.
    1. Crie dois objetos da classe `Numero` e realize a divisão inteira utilizando o operador `//`. Observe a saída.
    1. Teste a classe `Numero` dividindo um número inteiro por um objeto `Numero` usando divisão inteira. Verifique se `__rfloordiv__` foi chamado corretamente.
    1. Modifique a classe `Numero` para implementar o método `__ifloordiv__` e permita que o operador `//=` modifique o objeto original.
    1. Crie um objeto `Numero` e utilize o operador `//=` para realizar divisão inteira nele. Verifique se o objeto foi modificado corretamente.
    1. Tente realizar a divisão inteira entre dois objetos `Numero` e atribuí-los diretamente a um deles usando o operador `//=`. Verifique o resultado.
    1. Crie uma classe `Fracao` que implemente os métodos `__floordiv__`, `__rfloordiv__` e `__ifloordiv__` para realizar divisão inteira entre frações.
    1. Teste a classe `Fracao` realizando divisões inteiras entre frações e utilizando o operador `//=` para modificar o objeto original.
1. Exercícios para `__mod__`, `__rmod__`, e `__imod__`
    1. Crie uma classe `Numero` que implemente o método mágico `__mod__` para calcular o resto da divisão (módulo) entre dois objetos dessa classe.
    1. Modifique a classe `Numero` para que também possa calcular o módulo entre um número inteiro ou float e um objeto `Numero` utilizando `__mod__`.
    1. Implemente o método mágico `__rmod__` na classe `Numero` para permitir que o cálculo do módulo funcione quando um número é dividido por um objeto `Numero`.
    1. Crie dois objetos da classe `Numero` e realize a operação de módulo utilizando o operador `%`. Observe a saída.
    1. Teste a classe `Numero` calculando o módulo de um número inteiro e um objeto `Numero`. Verifique se `__rmod__` foi chamado corretamente.
    1. Modifique a classe `Numero` para implementar o método `__imod__` e permita que o operador `%=` modifique o objeto original.
    1. Crie um objeto `Numero` e utilize o operador `%=` para calcular o módulo dele por outro valor. Verifique se o objeto foi modificado corretamente.
    1. Tente calcular o módulo entre dois objetos `Numero` e atribuí-los diretamente a um deles usando o operador `%=`. Verifique o resultado.
    1. Crie uma classe `Fracao` que implemente os métodos `__mod__`, `__rmod__` e `__imod__` para calcular o módulo entre frações.
    1. Teste a classe `Fracao` calculando o módulo entre frações e utilizando o operador `%=` para modificar o objeto original.
1. Exercícios para `__pow__`, `__rpow__`, e `__ipow__`
    1. Crie uma classe `Numero` que implemente o método mágico `__pow__` para elevar um objeto dessa classe à potência de outro objeto da mesma classe.
    1. Modifique a classe `Numero` para que também possa calcular a potência entre um número inteiro ou float e um objeto `Numero` utilizando `__pow__`.
    1. Implemente o método mágico `__rpow__` na classe `Numero` para permitir que a operação de potência funcione quando um número é elevado à potência de um objeto `Numero`.
    1. Crie dois objetos da classe `Numero` e realize a operação de potência utilizando o operador `**`. Observe a saída.
    1. Teste a classe `Numero` calculando a potência de um número inteiro elevado a um objeto `Numero`. Verifique se `__rpow__` foi chamado corretamente.
    1. Modifique a classe `Numero` para implementar o método `__ipow__` e permita que o operador `**=` modifique o objeto original.
    1. Crie um objeto `Numero` e utilize o operador `**=` para elevar o objeto à potência de outro valor. Verifique se o objeto foi modificado corretamente.
    1. Tente calcular a potência entre dois objetos `Numero` e atribuí-los diretamente a um deles usando o operador `**=`. Verifique o resultado.
    1. Crie uma classe `Fracao` que implemente os métodos `__pow__`, `__rpow__` e `__ipow__` para calcular a potência entre frações.
    1. Teste a classe `Fracao` calculando a potência de frações e utilizando o operador `**=` para modificar o objeto original.

</details>

## herança

**Herança** é um dos principais conceitos da programação orientada a objetos (POO). Ela permite que uma classe herde atributos e métodos de outra classe, promovendo **reutilização de código** e **organização** do sistema. No contexto de Python, a herança ocorre quando uma nova classe (chamada de **classe derivada** ou **subclasse**) é criada a partir de uma classe existente (chamada de **classe base** ou **superclasse**), herdando os seus atributos e métodos.

A principal vantagem da herança é que ela evita a duplicação de código. Ao invés de reescrever métodos ou atributos comuns entre várias classes, podemos defini-los uma vez na classe base e permitir que as subclasses os utilizem diretamente.

### como funciona

Quando uma classe herda de outra, ela recebe todos os atributos e métodos da classe base, e pode utilizar ou invocar esses recursos como se fossem seus próprios. Isso facilita a criação de subclasses mais especializadas que compartilham um comportamento comum.

#### sintaxe básica

Em Python, para definir uma classe que herda de outra, é usada a seguinte sintaxe:

```python
class ClasseBase:
    # atributos e métodos da classe base
    def __init__(self, atributo_base):
        self.atributo_base = atributo_base

    def metodo_base(self):
        return f"Atributo base: {self.atributo_base}"

# Subclasse que herda de ClasseBase
class Subclasse(ClasseBase):
    # atributos e métodos da subclasse
    pass
```

Aqui, `Subclasse` herda de `ClasseBase`. A palavra-chave `pass` indica que a subclasse não tem definições adicionais. Mas, mesmo que não adicionemos novos métodos ou atributos na subclasse, ela ainda terá acesso ao que foi definido na `ClasseBase`.

#### exemplo

Vamos agora ver um exemplo mais concreto:

```python
class Animal:
    def __init__(self, nome):
        self.nome = nome

    def fazer_som(self):
        return f"{self.nome} está fazendo um som."

class Cachorro(Animal):
    pass

# criando uma instância de Cachorro
meu_cachorro = Cachorro("Rex")
print(meu_cachorro.fazer_som())  # saída : Rex está fazendo um som.
```

Neste exemplo:
- A classe `Animal` é a **superclasse**, e a classe `Cachorro` é a **subclasse**.
- A subclasse `Cachorro` herda o comportamento (atributo `nome` e método `fazer_som()`) da classe `Animal`.
- Quando criamos um objeto da classe `Cachorro` (`meu_cachorro`), ele já pode usar o método `fazer_som()` da classe base `Animal`.

Isso ocorre porque o Python, ao tentar acessar um método ou atributo na subclasse, primeiro verifica se o método ou atributo existe diretamente na subclasse. Se não encontrar, ele sobe na hierarquia de classes e busca na superclasse.

### inicialização com o método `__init__`

Uma das características mais comuns na herança é o uso do método especial `__init__()` (construtor). Quando uma subclasse herda de uma superclasse, o método `__init__()` da superclasse não é chamado automaticamente. É preciso invocá-lo manualmente para garantir que a subclasse seja corretamente inicializada.

#### exemplo

```python
class Animal:
    def __init__(self, nome):
        self.nome = nome

    def fazer_som(self):
        return f"{self.nome} está fazendo um som."

class Cachorro(Animal):
    def __init__(self, nome, raca):
        # chamando o __init__ da classe base
        super().__init__(nome)
        self.raca = raca

    def descricao(self):
        return f"{self.nome} é um {self.raca}"

# criando uma instância de Cachorro
meu_cachorro = Cachorro("Rex", "Golden Retriever")
print(meu_cachorro.descricao())  # saída : Rex é um Golden Retriever
print(meu_cachorro.fazer_som())  # saída : Rex está fazendo um som.
```

Aqui, temos o seguinte fluxo:
- a classe `Cachorro` tem um método `__init__()` próprio, que além de receber o nome, também aceita a raça do cachorro;
- dentro do `__init__()` da classe `Cachorro`, usamos `super().__init__(nome)` para chamar o construtor da classe `Animal` e inicializar o atributo `nome`;
- a subclasse `Cachorro` ainda tem acesso ao método `fazer_som()` da classe `Animal` e pode usá-lo normalmente;

### atributos herdados

**Atributos** são variáveis associadas a objetos de uma classe. Quando uma subclasse herda de uma superclasse, ela herda todos os atributos definidos na superclasse. Isso inclui :
- atributos de instância (definidos dentro de métodos, normalmente dentro do `__init__()`);
- atributos de classe (definidos diretamente no corpo da classe, fora de métodos);

#### como funciona?

1. **Atributos de Instância:**

    Quando uma subclasse herda de uma superclasse, os atributos de instância da superclasse também fazem parte das instâncias da subclasse, desde que o construtor da superclasse (`__init__()`) seja chamado adequadamente.

    Exemplo:
    ```python
    class Animal:
        def __init__(self, nome):
            self.nome = nome  # atributo de instância

    class Cachorro(Animal):
        pass

    rex = Cachorro("Rex")
    print(rex.nome)  # saída : Rex
    ```

    - `self.nome` é um **atributo de instância** definido na classe `Animal`;
    - quando um objeto da classe `Cachorro` é criado, ele herda o atributo `nome` da classe `Animal` porque a subclasse `Cachorro` não sobrescreve o `__init__()` da superclasse;

2. **Atributos de Classe:**

    Atributos de classe são compartilhados por todas as instâncias de uma classe, incluindo suas subclasses. Eles são definidos diretamente no corpo da classe e não no construtor.

    Exemplo:
    ```python
    class Animal:
        especie = "Mamífero"  # atributo de classe

    class Cachorro(Animal):
        pass

    rex = Cachorro("Rex")
    print(rex.especie)  # saída : Mamífero
    ```

    - `especie` é um **atributo de classe** definido na superclasse `Animal`;
    - a subclasse `Cachorro` herda esse atributo, portanto qualquer instância da classe `Cachorro` pode acessar `especie`;

#### importante

- **Atributos de Instância** : são definidos para cada instância individualmente. Para que a subclasse herde corretamente os atributos de instância, normalmente é necessário chamar o método `__init__()` da superclasse usando `super()`;
- **Atributos de Classe** : são compartilhados por todas as instâncias da classe e suas subclasses, a menos que sejam sobrescritos;

### métodos herdados

**Métodos** são funções definidas dentro de uma classe, que manipulam os atributos de instância ou realizam outras operações. Quando uma subclasse herda de uma superclasse, ela também herda todos os métodos da superclasse. Isso significa que a subclasse pode chamar diretamente os métodos definidos na superclasse, sem precisar reescrevê-los.

#### como funciona?

Quando um método é chamado em uma instância de uma subclasse, o Python segue a **ordem de resolução de métodos (MRO)**, que significa que:
1. o Python verifica primeiro se o método existe na subclasse;
1. se não encontrar, ele sobe para a superclasse e verifica lá;

Se o método estiver definido na superclasse, a subclasse poderá utilizá-lo automaticamente, como se fosse parte dela.

```python
class Animal:
    def __init__(self, nome):
        self.nome = nome

    def fazer_som(self):
        return f"{self.nome} está fazendo um som."

class Cachorro(Animal):
    pass

# criando um objeto da subclasse Cachorro
rex = Cachorro("Rex")

# chamando o método herdado da superclasse
print(rex.fazer_som())  # saída : Rex está fazendo um som.
```

Neste exemplo:
- a subclasse `Cachorro` herda o método `fazer_som()` da classe `Animal`;
- quando uma instância de `Cachorro` é criada, o objeto `rex` pode chamar o método `fazer_som()` diretamente, sem que ele tenha sido explicitamente definido na classe `Cachorro`;

#### modificações em métodos herdados

Embora a subclasse herde métodos diretamente da superclasse, ela pode:
1. **Usar os métodos da superclasse sem modificações** : como nos exemplos acima;
1. **Sobrescrever os métodos herdados** : a subclasse pode sobrescrever os métodos herdados;
1. **Adicionar novos métodos** : a subclasse pode definir seus próprios métodos, além dos herdados;

    Exemplo:
    ```python
    class Animal:
        def fazer_som(self):
            return "Som genérico de animal"

    class Cachorro(Animal):
        def latir(self):
            return f"{self.nome} está latindo!"

        def fazer_som(self):
            return "Som específico do Cachorro"

    rex = Cachorro("Rex")
    print(rex.fazer_som())  # método herdado, mas sobrescrito
    print(rex.latir())      # método novo da subclasse
    ```

    Aqui, `Cachorro` herda e sobrescreve o método `fazer_som()` da classe `Animal` e, além disso, define um novo método `latir()`.

### sobrecarga de métodos

Em Python, é possível sobrescrever (ou seja, redefinir) métodos de uma superclasse na subclasse. Quando isso acontece, o método da subclasse é chamado, em vez do método da superclasse.

No exemplo anterior, a classe `Cachorro` sobrescreveu o método `emitir_som` da classe base `Animal`. Se quiser ainda assim acessar o método da superclasse dentro da subclasse, pode-se usar `super()`.

```python
class Cachorro(Animal):
    def emitir_som(self):
        # chamando o método da classe base
        super().emitir_som()
        print(f'{self.nome} também está latindo.')
```

### como o python procura atributos e métodos?

Quando um método ou atributo de uma instância é acessado, o Python segue a seguinte ordem de busca:

1. **Subclasse :** primeiro, o Python verifica se o método ou atributo existe na subclasse;
1. **Superclasse :** se não for encontrado na subclasse, ele sobe para a superclasse e verifica lá;
1. **Mais acima (se houver) :** se houver classes acima na hierarquia, ele continua a busca até encontrar o que está sendo procurado ou até esgotar todas as opções;

Essa cadeia de busca é chamada de **MRO** (Method Resolution Order), que basicamente é a ordem de busca que o Python segue para encontrar métodos e atributos.

#### exemplo de MRO

```python
class A:
    def metodo(self):
        print("Método de A")

class B(A):
    pass

class C(B):
    pass

objeto = C()
objeto.metodo()  # saída : Método de A
```

Neste exemplo, o objeto da classe `C` está chamando `metodo()`. Como a classe `C` e a classe `B` não possuem esse método, o Python vai até a classe `A` e o encontra lá.

É possível verificar a ordem de resolução de métodos usando o método `mro()` ou a função `help()`.

```python
print(objeto.mro())
```

Isso mostra a sequência que o Python segue para encontrar o método ou atributo solicitado.

## exercícios herança

<details>
<summary>Lista de Exercícios</summary>

1. Herança Simples
    1. Crie uma classe `Veiculo` com um atributo `marca`. Crie uma subclasse `Carro` que herde de `Veiculo`. Instancie um objeto de `Carro` e defina a marca.
    1. Implemente uma classe `Animal` com um método `fazer_som()` que imprima "Som genérico". Crie uma subclasse `Gato` que herde de `Animal` e teste o método herdado.
    1. Crie uma classe `Pessoa` com um atributo `nome`. Crie uma subclasse `Estudante` que herde de `Pessoa` e instancie um objeto de `Estudante`. Defina o nome e imprima-o.
    1. Crie uma classe `Eletronico` com um método `ligar()`. Crie uma subclasse `Computador` que herde de `Eletronico` e utilize o método `ligar()`.
    1. Crie uma classe `InstrumentoMusical` com um método `tocar()`. Crie uma subclasse `Violao` que herde de `InstrumentoMusical` e utilize o método herdado.
    1. Implemente uma classe `Funcionario` com um método `trabalhar()` que imprime "Trabalhando". Crie uma subclasse `Programador` que herde de `Funcionario` e utilize o método `trabalhar()`.
    1. Desenvolva uma classe `Produto` com um método `informar_preco()` que imprime "Preço não definido". Crie uma subclasse `Eletronico` e teste o método herdado.
    1. Crie uma classe `Bicicleta` com um método `pedalar()`. Crie uma subclasse `MountainBike` que herde de `Bicicleta` e utilize o método `pedalar()`.
    1. Crie uma classe `Telefone` com um método `ligar()`. Crie uma subclasse `Smartphone` e utilize o método herdado.
    1. Desenvolva uma classe `ContaBancaria` com um método `depositar()`. Crie uma subclasse `ContaCorrente` e utilize o método herdado.
1. Herança de Atributos de Instância
    1. Crie uma classe `Pessoa` com os atributos `nome` e `idade`. Crie uma subclasse `Aluno` que herde esses atributos e instancie um objeto de `Aluno`. Defina o nome e a idade e imprima-os.
    1. Implemente uma classe `Veiculo` com os atributos `marca` e `ano`. Crie uma subclasse `Carro` que herde esses atributos. Instancie um objeto de `Carro`, defina os valores dos atributos e imprima-os.
    1. Crie uma classe `Funcionario` com os atributos `nome` e `salario`. Crie uma subclasse `Gerente` que herde esses atributos e instancie um objeto de `Gerente`. Defina o nome e o salário e imprima-os.
    1. Crie uma classe `Animal` com os atributos `nome` e `especie`. Crie uma subclasse `Cachorro` que herde esses atributos. Instancie um objeto de `Cachorro`, defina os atributos e imprima-os.
    1. Implemente uma classe `Produto` com os atributos `nome` e `preco`. Crie uma subclasse `Livro` que herde esses atributos. Instancie um objeto de `Livro`, defina o nome e o preço, e imprima-os.
    1. Desenvolva uma classe `Eletronico` com os atributos `marca` e `modelo`. Crie uma subclasse `Smartphone` que herde esses atributos. Instancie um objeto de `Smartphone`, defina os valores dos atributos e imprima-os.
    1. Crie uma classe `Pessoa` com os atributos `nome` e `endereco`. Crie uma subclasse `Cliente` que herde esses atributos e instancie um objeto de `Cliente`. Defina os valores e imprima-os.
    1. Implemente uma classe `ContaBancaria` com os atributos `titular` e `saldo`. Crie uma subclasse `ContaPoupanca` que herde esses atributos. Instancie um objeto de `ContaPoupanca`, defina o titular e o saldo, e imprima-os.
    1. Desenvolva uma classe `Veiculo` com os atributos `marca` e `velocidade_maxima`. Crie uma subclasse `Moto` que herde esses atributos. Instancie um objeto de `Moto`, defina os atributos e imprima-os.
    1. Crie uma classe `Jogador` com os atributos `nome` e `posicao`. Crie uma subclasse `Atacante` que herde esses atributos e instancie um objeto de `Atacante`. Defina os valores e imprima-os.
1. Herança de Atributos de Classe
    1. Crie uma classe `Pessoa` com um atributo de classe `especie = "Humano"`. Crie uma subclasse `Aluno` que herde esse atributo. Verifique se o atributo é acessível pela subclasse.
    1. Desenvolva uma classe `Veiculo` com um atributo de classe `categoria = "Transporte"`. Crie uma subclasse `Carro` que herde esse atributo e acesse-o através de um objeto da subclasse.
    1. Implemente uma classe `Animal` com um atributo de classe `tipo = "Mamífero"`. Crie uma subclasse `Cachorro` que herde esse atributo e verifique se o objeto da subclasse pode acessá-lo.
    1. Crie uma classe `Produto` com um atributo de classe `tipo = "Mercadoria"`. Crie uma subclasse `Alimento` que herde esse atributo. Instancie um objeto da subclasse e acesse o atributo.
    1. Desenvolva uma classe `Funcionario` com um atributo de classe `empresa = "TechCorp"`. Crie uma subclasse `Engenheiro` que herde esse atributo e acesse-o através de um objeto da subclasse.
    1. Crie uma classe `Eletronico` com um atributo de classe `tipo = "Aparelho"`. Crie uma subclasse `Computador` que herde esse atributo e instancie um objeto para acessá-lo.
    1. Implemente uma classe `ContaBancaria` com um atributo de classe `instituicao = "Banco ABC"`. Crie uma subclasse `ContaCorrente` que herde esse atributo e verifique se o objeto da subclasse pode acessá-lo.
    1. Desenvolva uma classe `Jogador` com um atributo de classe `esporte = "Futebol"`. Crie uma subclasse `Goleiro` que herde esse atributo e acesse-o através de um objeto da subclasse.
    1. Crie uma classe `InstrumentoMusical` com um atributo de classe `categoria = "Cordas"`. Crie uma subclasse `Violao` que herde esse atributo. Instancie um objeto da subclasse e acesse o atributo.
    1. Implemente uma classe `Pessoa` com um atributo de classe `planeta = "Terra"`. Crie uma subclasse `Cientista` que herde esse atributo e acesse-o através de um objeto da subclasse.
1. Herança de Métodos
    1. Crie uma classe `Veiculo` com um método `mover()` que imprime "O veículo está se movendo". Crie uma subclasse `Carro` que herde esse método e teste-o.
    1. Implemente uma classe `Funcionario` com um método `trabalhar()` que imprime "Funcionário está trabalhando". Crie uma subclasse `Gerente` e sobrescreva o método herdado.
    1. Desenvolva uma classe `Produto` com um método `informar_preco()` que imprime "Preço não definido". Crie uma subclasse `Alimento` e utilize o método herdado.
    1. Crie uma classe `Pessoa` com um método `falar()` que imprime "Olá, eu sou uma pessoa". Crie uma subclasse `Aluno` e sobrescreva o método herdado.
    1. Implemente uma classe `Animal` com um método `comer()` que imprime "O animal está comendo". Crie uma subclasse `Leao` e utilize o método herdado.
    1. Desenvolva uma classe `InstrumentoMusical` com um método `tocar()` que imprime "Tocando instrumento". Crie uma subclasse `Guitarra` e sobrescreva o método herdado.
    1. Crie uma classe `Veiculo` com um método `parar()` que imprime "O veículo está parando". Crie uma subclasse `Moto` e utilize o método herdado.
    1. Implemente uma classe `Funcionario` com um método `descansar()` que imprime "Funcionário está descansando". Crie uma subclasse `Programador` e sobrescreva o método herdado.
    1. Desenvolva uma classe `Eletronico` com um método `desligar()` que imprime "Aparelho desligado". Crie uma subclasse `Tablet` e utilize o método herdado.
    1. Crie uma classe `Jogador` com um método `correr()` que imprime "Jogador está correndo". Crie uma subclasse `Atacante` e sobrescreva o método herdado.

</details>

## métodos mágicos de operadores de comparação

Também é possível encontrar que métodos especiais estão por trás dos operadores de comparação. Por exemplo, quando se executa algo como `5 < 2`, Python chama o método mágico `.__lt__()`.

Veja a tabela abaixo desses métodos :

| Operador | Método de Suporte |
|---|---|
| `<` | `.__lt__(self, other)` |
| `<=` | `.__le__(self, other)` |
| `==` | `.__eq__(self, other)` |
| `!=` | `.__ne__(self, other)` |
| `>=` | `.__ge__(self, other)` |
| `>` | `.__gt__(self, other)` |

Veja abaixo a classe `Retangulo` que aplica esses métodos mágicos para comparar a área do objeto.

```python
class retangulo:
    def __init__(self, altura, largura):
        self.altura = altura
        self.largura = largura

    def area(self):
        return self.altura * self.largura

    def __eq__(self, other):
        return self.area() == other.area()

    def __lt__(self, other):
        return self.area() < other.area()

    def __gt__(self, other):
        return self.area() > other.area()
```

A classe possui um método `.area()` que calcula a área do retângulo usando sua altura e largura. Em seguida, há três métodos mágicos necessários para suportar os operadores de comparação pretendidos. Observe que todos eles usam a área do retângulo para determinar o resultado final.

Veja como fica aplicado na prática :

```python
quadra_basquete = Retangulo(15, 28)
quadra_futebol = Retangulo(75, 110)

print(quadra_basquete < quadra_futebol)
# saída : True
print(quadra_basquete > quadra_futebol)
# saída : False
print(quadra_basquete == quadra_futebol)
# saída : False
```

## exercícios métodos mágicos de operadores de comparação

<details>
<summary>Lista de Exercícios</summary>

1. Exercícios para `__lt__(self, other)` (menor que)
    1. **Crie uma classe `Produto`** com um atributo `preco`. Implemente o método `__lt__` para que possa comparar dois produtos com base no preço.
    1. **Implemente a classe `Data`** com atributos `dia`, `mes` e `ano`. Use o método `__lt__` para comparar duas datas e determinar se uma data é anterior à outra.
    1. **Crie uma classe `Pessoa`** com um atributo `idade`. Implemente `__lt__` para que você possa verificar se uma pessoa é mais jovem que outra.
    1. **Desenvolva uma classe `Quadrado`** que tem um atributo `lado`. Implemente `__lt__` para que você possa comparar dois quadrados com base na área.
    1. **Crie uma classe `Nota`** que representa uma nota escolar com um atributo `valor`. Use `__lt__` para determinar se uma nota é menor que outra.
1. Exercícios para `__le__(self, other)` (menor ou igual a)
    1. **Use a classe `Produto`** do exercício anterior e adicione o método `__le__` para permitir a comparação de preços, incluindo igualdade.
    1. **Modifique a classe `Data`** para implementar `__le__`, permitindo que você compare se uma data é anterior ou igual a outra.
    1. **Adicione o método `__le__` à classe `Pessoa`** para que você possa verificar se uma pessoa é mais jovem ou da mesma idade que outra.
    1. **Use a classe `Quadrado`** do exercício anterior e implemente `__le__` para comparar a área de dois quadrados, permitindo igualdade.
    1. **Crie uma classe `Nota`** com o método `__le__` que permite verificar se uma nota é menor ou igual a outra.
1. Exercícios para `__eq__(self, other)` (igual a)
    1. **Crie uma classe `Produto`** que tenha um atributo `codigo`. Implemente `__eq__` para comparar produtos com base no código.
    1. **Desenvolva a classe `Data`** para incluir o método `__eq__`, permitindo verificar se duas datas são iguais.
    1. **Implemente `__eq__` na classe `Pessoa`** para comparar duas pessoas com base no nome e idade.
    1. **Adicione o método `__eq__` à classe `Quadrado`** para que você possa verificar se dois quadrados têm a mesma área.
    1. **Crie uma classe `Nota`** com um atributo `disciplina` e implemente `__eq__` para comparar notas de diferentes disciplinas.
1. Exercícios para `__ne__(self, other)` (diferente de)
    1. **Utilize a classe `Produto`** do primeiro exercício e implemente `__ne__` para verificar se dois produtos são diferentes com base no preço.
    1. **Modifique a classe `Data`** para incluir o método `__ne__`, permitindo que você compare se duas datas são diferentes.
    1. **Adicione o método `__ne__` à classe `Pessoa`** para determinar se duas pessoas são diferentes com base na idade.
    1. **Use a classe `Quadrado`** e implemente `__ne__` para verificar se dois quadrados têm áreas diferentes.
    1. **Crie uma classe `Nota`** com o método `__ne__` para comparar notas e verificar se são diferentes.
1. Exercícios para `__ge__(self, other)` (maior ou igual a)
    1. **Implemente o método `__ge__` na classe `Produto`** para comparar produtos com base no preço, permitindo verificar se um produto é mais caro ou igual a outro.
    1. **Adicione `__ge__` à classe `Data`** para que você possa comparar se uma data é posterior ou igual a outra.
    1. **Modifique a classe `Pessoa`** para implementar `__ge__`, permitindo que você verifique se uma pessoa é mais velha ou da mesma idade que outra.
    1. **Use a classe `Quadrado`** do exercício anterior e implemente `__ge__` para comparar áreas, permitindo verificar se uma área é maior ou igual a outra.
    1. **Crie uma classe `Nota`** e adicione `__ge__` para permitir verificar se uma nota é maior ou igual a outra.
1. Exercícios para `__gt__(self, other)` (maior que)
    1. **Crie uma classe `Produto`** com um atributo `preco` e implemente `__gt__` para comparar produtos com base no preço.
    1. **Implemente a classe `Data`** e use `__gt__` para determinar se uma data é posterior a outra.
    1. **Adicione `__gt__` à classe `Pessoa`** para que você possa verificar se uma pessoa é mais velha que outra.
    1. **Utilize a classe `Quadrado`** e implemente `__gt__` para comparar áreas e verificar se um quadrado é maior que o outro.
    1. **Crie uma classe `Nota`** com o método `__gt__` que permite verificar se uma nota é maior que outra.

</details>

## métodos estáticos

Métodos estáticos são uma forma de definir funções dentro de uma classe que não requerem uma referência a uma instância da classe para serem chamadas. Eles são marcados com o decorador `@staticmethod` e não têm acesso direto ao estado da instância ou à classe.

- **definição** : um método estático é um método que pertence à classe, não a uma instância da classe; isso significa que ela pode ser chamada sem criar um objeto da classe;
- **acesso** : métodos estáticos não têm acesso a `self` (a instância da classe) ou `cls` (a própria classe); eles não podem modificar o estado da instância ou da classe;

### quando usar

Os métodos estáticos são úteis quando:

1. **Encapsulamento de Funções Relacionadas** : se deseja agrupar funções que fazem parte da lógica da classe, mas que não precisam acessar os dados da instância ou da classe;
1. **Organização** : eles ajudam a organizar o código de maneira mais limpa e clara, separando a lógica que não depende do estado da instância;

### como definir

Veja a sintaxe para definir um método estático :

```python
class MinhaClasse:
    @staticmethod
    def meu_metodo_estatico(param):
        return f"Você passou {param}."
```

Veja um exemplo prático :

```python
class Calculadora:

    @staticmethod
    def somar(a, b):
        return a + b

    @staticmethod
    def subtrair(a, b):
        return a - b

    @staticmethod
    def multiplicar(a, b):
        return a * b

    @staticmethod
    def dividir(a, b):
        if b == 0:
            return "Erro: Divisão por zero!"
        return a / b

# chamando métodos estáticos sem criar uma instância da classe
print(Calculadora.somar(5, 3))         # saída : 8
print(Calculadora.subtrair(10, 4))     # saída : 6
print(Calculadora.multiplicar(2, 3))   # saída : 6
print(Calculadora.dividir(8, 2))       # saída : 4.0
print(Calculadora.dividir(8, 0))       # saída : Erro: Divisão por zero!
```

## exercícios métodos estáticos

<details>
<summary>Lista de Exercícios</summary>

1. Crie um método estático em uma classe `Matematica` que calcule e retorne o fatorial de um número.
1. Implemente um método estático `converter_para_maiusculas` em uma classe `Texto` que receba uma string e a retorne em letras maiúsculas.
1. Defina um método estático em uma classe `Utils` que gere um número aleatório entre um intervalo definido.
1. Na classe `Data`, crie um método estático que verifique se um ano é bissexto.
1. Crie um método estático em uma classe `Validador` que valide se um e-mail tem o formato correto.
1. Implemente um método estático `calcular_area_retangulo` em uma classe `Geometria` que receba a largura e a altura e retorne a área.
1. Crie um método estático `formatar_telefone` em uma classe `Contato` que formate um número de telefone para o padrão (XX) XXXXX-XXXX.
1. Na classe `Conversor`, defina um método estático que converta uma temperatura de Celsius para Fahrenheit.
1. Crie um método estático em uma classe `StringUtils` que remova espaços em branco de uma string.
1. Implemente um método estático `gerar_uuid` em uma classe `Identificador` que gere um UUID.
1. Crie um método estático `contar_vogais` em uma classe `AnalisadorDeTexto` que conte o número de vogais em uma string.
1. Na classe `Calculadora`, defina um método estático que calcule a soma de uma lista de números.
1. Crie um método estático em uma classe `ValidadorDeSenha` que verifique se uma senha atende a certos critérios (ex.: tamanho mínimo, presença de números).
1. Implemente um método estático `substituir_espacos` em uma classe `Texto`, que substitua espaços por sublinhados em uma string.
1. Crie um método estático `formatar_data` em uma classe `FormatoData` que formate uma data no padrão DD/MM/AAAA.
1. Na classe `ConversorDeMoeda`, crie um método estático que converta valores entre duas moedas diferentes.
1. Defina um método estático em uma classe `Verificador` que retorne se uma palavra é um palíndromo.
1. Crie um método estático `calcular_media` em uma classe `Estatisticas` que receba uma lista de números e retorne a média.
1. Implemente um método estático `remover_elementos_repetidos` em uma classe `ListaUtils` que retorne uma lista sem elementos duplicados.
1. Na classe `Relogio`, crie um método estático que converta horas de formato 12 horas para 24 horas.

</details>

## métodos de classe

Métodos de classe são uma maneira de definir funções que pertencem à classe em si, e não a uma instância específica da classe. Eles são decorados com o `@classmethod` e recebem a classe como primeiro parâmetro, que é normalmente nomeado como `cls`.

- **definição** : um método de classe é um método que pode ser chamado na própria classe, sem precisar de uma instância. Ele recebe a classe como primeiro argumento, permitindo que você acesse ou modifique atributos da classe;
- **acesso** : ao contrário dos métodos de instância que têm acesso ao estado da instância através de `self`, os métodos de classe têm acesso ao estado da classe através de `cls`;

### quando usar

Métodos de classe são úteis quando:

1. **Manipulação de Atributos de Classe** : se deseja acessar ou modificar atributos que são comuns a todas as instâncias da classe;
1. **Fábricas** : quer implementar métodos que podem criar instâncias da classe de maneiras alternativas (métodos de fábrica);

### como definir

Veja a sintaxe para definir um método estático :

```python
class MinhaClasse:
    @classmethod
    def meu_metodo_de_classe(cls):
        # lógica do método
```

Veja um exemplo prático :

```python
class ContaBancaria:
    taxa_de_juros = 0.05  # atributo da classe

    def __init__(self, saldo):
        self.saldo = saldo

    @classmethod
    def set_taxa_de_juros(cls, nova_taxa):
        cls.taxa_de_juros = nova_taxa

    @classmethod
    def criar_conta(cls, saldo_inicial):
        return cls(saldo_inicial)

    def aplicar_juros(self):
        self.saldo += self.saldo * self.taxa_de_juros

# usando o método de classe para alterar a taxa de juros
print("Taxa de juros atual:", ContaBancaria.taxa_de_juros)  # saída : 0.05
ContaBancaria.set_taxa_de_juros(0.07)
print("Nova taxa de juros:", ContaBancaria.taxa_de_juros)    # saída : 0.07

# usando o método de classe para criar uma nova conta
nova_conta = ContaBancaria.criar_conta(1000)
print("Saldo inicial da nova conta:", nova_conta.saldo)  # saída : 1000

# aplicando juros
nova_conta.aplicar_juros()
print("Saldo após aplicar juros:", nova_conta.saldo)  # saída : 1070.0
```

## exercícios métodos de classe

<details>
<summary>Lista de Exercícios</summary>

1. Crie uma classe `Carro` que tenha um atributo de classe `numero_de_carros` e um método de classe que incremente esse número sempre que um novo carro for criado.
1. Implemente um método de classe `criar_carrinho` em uma classe `CarrinhoDeCompras`, que retorne uma instância de `CarrinhoDeCompras` com uma lista vazia.
1. Defina uma classe `Produto` com um atributo de classe `estoque_total` e um método de classe que retorne o total de produtos em estoque.
1. Crie um método de classe em uma classe `Usuario` que retorne uma lista de todos os usuários cadastrados.
1. Na classe `Conta`, implemente um método de classe `definir_limite` que defina um limite padrão para todas as contas.
1. Crie um método de classe `adicionar_cliente` em uma classe `Banco` que adicione um novo cliente à lista de clientes.
1. Defina um método de classe em uma classe `Funcionario` que conte o número total de funcionários.
1. Crie um método de classe `gerar_id` em uma classe `Registro`, que retorne um ID único cada vez que for chamado.
1. Implemente um método de classe `calcular_media` em uma classe `Notas`, que receba uma lista de notas e retorne a média.
1. Na classe `Livro`, crie um método de classe que retorne uma lista de todos os livros publicados.
1. Crie um método de classe `incrementar_visitas` em uma classe `Pagina`, que incremente o número de visitas a uma página web.
1. Defina um método de classe em uma classe `Equipe` que retorne o número total de membros da equipe.
1. Implemente um método de classe `set_telefone` em uma classe `Contato` que permita atualizar o número de telefone para todos os contatos.
1. Na classe `Transacao`, crie um método de classe que retorne todas as transações de um determinado tipo.
1. Crie um método de classe `criar_arquivo` em uma classe `GeradorDeRelatorios` que crie um novo arquivo de relatório.
1. Defina um método de classe em uma classe `Categoria` que retorne a lista de todas as categorias disponíveis.
1. Implemente um método de classe `adicionar_item` em uma classe `Inventario` que adicione um item ao inventário global.
1. Crie um método de classe `definir_mensagem_padrao` em uma classe `Mensagem` que altere a mensagem padrão para todos os objetos da classe.
1. Na classe `Evento`, crie um método de classe que retorne a lista de todos os eventos agendados.
1. Implemente um método de classe `get_informacoes` em uma classe `Escola` que retorne informações sobre todas as escolas cadastradas.

</details>

## métodos de instância vs estáticos vs de classe

### métodos de instância

1. **Definição**
    - são aqueles que operam em instâncias específicas de uma classe; eles têm acesso ao estado da instância através do parâmetro `self`, que se refere ao objeto atual;

1. **Quando Usar**
    - quando se precisa acessar ou modificar atributos de uma instância específica;
    - quando a lógica do método depende dos dados contidos na instância;

1. **Vantagens**
    - **Acesso ao estado da instância** : podem manipular e acessar dados específicos de cada instância, tornando-os muito flexíveis;
    - **Encapsulamento** : a lógica é organizada em torno da instância, facilitando a leitura e a manutenção do código;

1. **Desvantagens**
    - **Dependência de instância** : necessita de uma instância da classe para ser chamado, o que pode aumentar a sobrecarga de criação de objetos quando não é necessário;
    - **Performance** : acesso a atributos de instância pode ser mais lento em comparação com métodos que não dependem de estado, especialmente em chamadas repetidas;

### métodos de classe

1. **Definição**
    - são métodos que operam na classe como um todo, não em instâncias específicas. Eles são definidos com o decorador `@classmethod` e recebem a classe como primeiro argumento (`cls`);

1. **Quando Usar**
    - quando se precisa manipular ou acessar atributos que pertencem à classe e são compartilhados entre todas as instâncias;
    - para criar métodos de fábrica que instanciam objetos de maneira diferente;

1. **Vantagens**
    - **Acesso ao estado da classe** : podem modificar atributos que são comuns a todas as instâncias, oferecendo um meio de controlar o comportamento da classe como um todo;
    - **Métodos de fábrica** : facilitam a criação de instâncias de maneira mais flexível e centralizada;

1. **Desvantagens**
    - **Menos flexível que métodos de instância** : não têm acesso aos dados específicos de uma instância, o que limita seu uso em alguns contextos;
    - **Possível confusão** : a lógica de negócios pode se tornar confusa se não for bem estruturada, especialmente se muitas operações dependem de atributos de classe;

### métodos estáticos

1. **Definição**
    - são funções definidas dentro do escopo de uma classe que não dependem do estado da instância nem do estado da classe; eles são decorados com `@staticmethod`;

1. **Quando Usar**
    - quando a lógica do método não precisa acessar ou modificar atributos de instância ou de classe;
    - Para agrupar funções que têm uma lógica relacionada à classe, mas que não requerem acesso a `self` ou `cls`;

1. **Vantagens**
    - **Desacoplamento** : não dependem do estado da instância ou da classe, tornando-os mais fáceis de testar e reutilizar;
    - **Organização** : permitem agrupar funções relacionadas à lógica da classe, mantendo o código mais organizado;

1. **Desvantagens**
    - **Sem acesso ao estado** : como não têm acesso a `self` ou `cls`, não podem interagir com atributos de instância ou de classe, limitando seu uso em determinadas situações;
    - **Menos intuitivo** : o uso pode ser menos intuitivo para aqueles que estão acostumados a trabalhar com métodos que interagem com o estado;

### comparação

| Característica         | Métodos de Instância         | Métodos de Classe               | Métodos Estáticos               |
|------------------------|------------------------------|---------------------------------|---------------------------------|
| **Acesso**             | `self` (instância)          | `cls` (classe)                  | Nenhum acesso ao estado         |
| **Quando Usar**        | Manipular dados específicos da instância | Manipular dados da classe ou métodos de fábrica | Lógica que não precisa de estado |
| **Vantagens**          | Flexibilidade e encapsulamento | Controle sobre a classe e seus atributos | Desacoplamento e organização     |
| **Desvantagens**       | Dependência de instância     | Menos flexível em relação a instâncias | Sem acesso ao estado            |

### exemplos

Abaixo há exemplos de criação de classes que abordam os conceitos vistos anteriormente
- [**atributos de instância**](#atributos-de-instância)
- [**atributos de classe**](#atributos-de-classe)
- [**métodos de instância**](#métodos-de-instância)
- [**métodos de classe**](#métodos-de-classe)
- [**métodos estáticos**](#métodos-estáticos)
- [**métodos mágicos**](#métodos-mágicos)

#### Exemplo 1 : Classe `Carro`

**Objetivo**: Um sistema que gerencia veículos, com contador de carros criados e operações entre diferentes carros.

```python
class Carro:
    total_carros = 0

    def __init__(self, marca, modelo, ano, preco):
        self.marca = marca
        self.modelo = modelo
        self.ano = ano
        self.preco = preco
        Carro.total_carros += 1

    def descricao(self):
        return f'{self.marca} {self.modelo} ({self.ano})'

    @classmethod
    def carros_criados(cls):
        return f'Carros criados: {cls.total_carros}'

    @staticmethod
    def depreciacao(preco, anos):
        return preco * (0.9 ** anos)

    def __str__(self):
        return self.descricao()

    def __add__(self, outro_carro):
        return self.preco + outro_carro.preco

    def __lt__(self, outro_carro):
        return self.ano < outro_carro.ano

carro1 = Carro("Toyota", "Corolla", 2020, 90000)
carro2 = Carro("Honda", "Civic", 2019, 85000)

print(carro1)  # Toyota Corolla (2020)
print(carro2)  # Honda Civic (2019)

print(Carro.carros_criados())  # Carros criados: 2
print(Carro.depreciacao(100000, 5))  # 59049.0

print(carro1 + carro2)  # 175000

print(carro1 < carro2)  # False (Corolla é mais novo que Civic)
```

---

#### Exemplo 2 : Classe `Funcionario`

**Objetivo** : Sistema de gerenciamento de funcionários com contagem total e cálculo de salário.

```python
class Funcionario:
    total_funcionarios = 0

    def __init__(self, nome, cargo, salario):
        self.nome = nome
        self.cargo = cargo
        self.salario = salario
        Funcionario.total_funcionarios += 1

    def info(self):
        return f'{self.nome} trabalha como {self.cargo}'

    @classmethod
    def total_funcionarios_cadastrados(cls):
        return f'Total de funcionários: {cls.total_funcionarios}'

    @staticmethod
    def aumento_percentual(salario, percentual):
        return salario * (1 + percentual / 100)

    def __repr__(self):
        return f'Funcionario({self.nome}, {self.cargo}, {self.salario})'

    def __eq__(self, outro_funcionario):
        return self.salario == outro_funcionario.salario

    def __gt__(self, outro_funcionario):
        return self.salario > outro_funcionario.salario

func1 = Funcionario("Alice", "Engenheira", 5000)
func2 = Funcionario("Bob", "Gerente", 6000)

print(func1.info())  # Alice trabalha como Engenheira
print(Funcionario.total_funcionarios_cadastrados())  # Total de funcionários: 2

print(Funcionario.aumento_percentual(5000, 10))  # 5500.0

print(func1 == func2)  # False
print(func1 > func2)  # False
```

---

#### Exemplo 3 : Classe `Livro`

**Objetivo** : Sistema de biblioteca com contagem de livros e operações entre diferentes livros.

```python
class Livro:
    total_livros = 0

    def __init__(self, titulo, autor, paginas):
        self.titulo = titulo
        self.autor = autor
        self.paginas = paginas
        Livro.total_livros += 1

    def detalhes(self):
        return f'{self.titulo} por {self.autor}, {self.paginas} páginas'

    @classmethod
    def total_de_livros(cls):
        return f'Total de livros cadastrados: {cls.total_livros}'

    @staticmethod
    def comparar_paginas(livro1, livro2):
        return livro1.paginas > livro2.paginas

    def __str__(self):
        return self.detalhes()

    def __add__(self, outro_livro):
        return self.paginas + outro_livro.paginas

    def __eq__(self, outro_livro):
        return self.paginas == outro_livro.paginas

livro1 = Livro("1984", "George Orwell", 328)
livro2 = Livro("Brave New World", "Aldous Huxley", 288)

print(livro1)  # 1984 por George Orwell, 328 páginas
print(livro2)  # Brave New World por Aldous Huxley, 288 páginas

print(Livro.total_de_livros())  # Total de livros cadastrados: 2

print(Livro.comparar_paginas(livro1, livro2))  # True

# Soma de páginas
print(livro1 + livro2)  # 616

print(livro1 == livro2)  # False
```

---

#### Exemplo 4 : Classe `Produto`

**Objetivo** : Gerenciamento de produtos com estoque e operações de inventário.

```python
class Produto:
    total_produtos = 0

    def __init__(self, nome, preco, quantidade):
        self.nome = nome
        self.preco = preco
        self.quantidade = quantidade
        Produto.total_produtos += 1

    def info(self):
        return f'{self.nome}: R${self.preco:.2f} (Estoque: {self.quantidade})'

    @classmethod
    def total_estoque(cls):
        return f'Total de produtos cadastrados: {cls.total_produtos}'

    @staticmethod
    def calcular_desconto(preco, desconto):
        return preco - (preco * desconto / 100)

    def __str__(self):
        return self.info()

    def __mul__(self, outro_produto):
        return self.quantidade * self.preco + outro_produto.quantidade * outro_produto.preco

    def __lt__(self, outro_produto):
        return self.preco < outro_produto.preco

produto1 = Produto("Camiseta", 50, 10)
produto2 = Produto("Calça", 80, 5)

print(produto1)  # Camiseta: R$50.00 (Estoque: 10)
print(produto2)  # Calça: R$80.00 (Estoque: 5)

print(Produto.total_estoque())  # Total de produtos cadastrados: 2
print(Produto.calcular_desconto(100, 10))  # 90.0

print(produto1 * produto2)  # 900 (valor total dos produtos em estoque)
print(produto1 < produto2)  # True (Camiseta é mais barata que Calça)
```

---

#### Exemplo 5 : Classe `ContaBancaria`

**Objetivo** : Sistema de contas bancárias com total de contas criadas e operações financeiras.

```python
class ContaBancaria:
    total_contas = 0

    def __init__(self, titular, saldo):
        self.titular = titular
        self.saldo = saldo
        ContaBancaria.total_contas += 1

    def depositar(self, valor):
        self.saldo += valor
        return f'Novo saldo de {self.titular}: R${self.saldo:.2f}'

    @classmethod
    def total_de_contas(cls):
        return f'Total de contas: {cls.total_contas}'

    @staticmethod
    def calcular_juros(saldo, taxa):
        return saldo * (1 + taxa / 100)

    def __str__(self):
        return f'Conta de {self.titular} com saldo de R${self.saldo:.2f}'

    def __sub__(self, outro_conta):
        return self.saldo - outro_conta.saldo

    def __gt__(self, outro_conta):
        return self.saldo > outro_conta.saldo

conta1 = ContaBancaria("Carlos", 1500)
conta2 = ContaBancaria("Ana", 2500)

print(conta1)  # Conta de Carlos com saldo de R$1500.00
print(conta2)  # Conta de Ana com saldo de R$2500.00

print(ContaBancaria.total_de_contas())  # Total de contas: 2
print(ContaBancaria.calcular_juros(1000, 5))  # 1050.0

print(conta2 - conta1)  # 1000
print(conta1 > conta2)  # False
```

---

#### Exemplo 6 : Classe `Pessoa` e Herança com `Funcionario`

**Objetivo** : Criar um sistema que gerencie pessoas e seus derivados, como funcionários, com métodos de fábrica para criação e comparação de idade.

```python
class Pessoa:
    populacao_total = 0

    def __init__(self, nome, idade):
        self.nome = nome
        self.idade = idade
        Pessoa.populacao_total += 1

    def info(self):
        return f'Nome: {self.nome}, Idade: {self.idade}'

    @classmethod
    def from_string(cls, dados):
        nome, idade = dados.split(',')
        return cls(nome, int(idade))

    @staticmethod
    def maior_idade(idade):
        return idade >= 18

    def __str__(self):
        return f'{self.nome}, {self.idade} anos'

    def __add__(self, outra_pessoa):
        return self.idade + outra_pessoa.idade

    def __eq__(self, outra_pessoa):
        return self.idade == outra_pessoa.idade


class Funcionario(Pessoa):
    def __init__(self, nome, idade, salario):
        super().__init__(nome, idade)
        self.salario = salario

    def info(self):
        return f'{super().info()}, Salário: {self.salario}'

    def __gt__(self, outro_funcionario):
        return self.salario > outro_funcionario.salario


pessoa1 = Pessoa("Carlos", 25)
funcionario1 = Funcionario("Ana", 30, 5000)

print(pessoa1.info())  # Carlos, 25 anos
print(funcionario1.info())  # Nome: Ana, Idade: 30, Salário: 5000

# Fábrica
pessoa2 = Pessoa.from_string("João,40")
print(pessoa2)  # João, 40 anos

print(Pessoa.maior_idade(17))  # False
print(pessoa1 + pessoa2)  # 65 (soma das idades)

funcionario2 = Funcionario("Pedro", 35, 7000)
print(funcionario1 > funcionario2)  # False
```

---

#### Exemplo 7 : Classe `Animal` e Herança com `Cachorro`

**Objetivo** : Gerenciar diferentes tipos de animais com métodos de fábrica para criar animais a partir de dados e operações de idade e raça.

```python
class Animal:
    total_animais = 0

    def __init__(self, nome, idade):
        self.nome = nome
        self.idade = idade
        Animal.total_animais += 1

    def som(self):
        return "Som genérico"

    @classmethod
    def cria_a_partir_de_string(cls, dados):
        nome, idade = dados.split(',')
        return cls(nome, int(idade))

    @staticmethod
    def expectativa_vida(tipo):
        return 15 if tipo == "Cachorro" else 10

    def __str__(self):
        return f'Animal: {self.nome}, Idade: {self.idade}'

    def __add__(self, outro_animal):
        return self.idade + outro_animal.idade

    def __eq__(self, outro_animal):
        return self.idade == outro_animal.idade


class Cachorro(Animal):
    def __init__(self, nome, idade, raca):
        super().__init__(nome, idade)
        self.raca = raca

    def som(self):
        return "Latido"

    def __gt__(self, outro_cachorro):
        return len(self.raca) > len(outro_cachorro.raca)


animal1 = Animal("Tigre", 4)
cachorro1 = Cachorro("Rex", 3, "Labrador")

print(animal1.info())  # Animal: Tigre, Idade: 4
print(cachorro1.info())  # Animal: Rex, Idade: 3

animal2 = Animal.cria_a_partir_de_string("Leão,5")
print(animal2)  # Animal: Leão, Idade: 5

print(animal1 + animal2)  # 9

cachorro2 = Cachorro("Spike", 4, "Poodle")
print(cachorro1 > cachorro2)  # False

print(Animal.expectativa_vida("Cachorro"))  # 15
```

---

#### Exemplo 8 : Classe `Produto` e Herança com `Eletronico`

**Objetivo**: Sistema de gerenciamento de produtos com métodos de fábrica para criação de produtos e operações de estoque.

```python
class Produto:
    total_produtos = 0

    def __init__(self, nome, preco):
        self.nome = nome
        self.preco = preco
        Produto.total_produtos += 1

    def info(self):
        return f'Produto: {self.nome}, Preço: R${self.preco:.2f}'

    @classmethod
    def cria_a_partir_de_string(cls, dados):
        nome, preco = dados.split(',')
        return cls(nome, float(preco))

    @staticmethod
    def aplicar_desconto(preco, desconto):
        return preco - (preco * desconto / 100)

    def __str__(self):
        return self.info()

    def __add__(self, outro_produto):
        return self.preco + outro_produto.preco

    def __eq__(self, outro_produto):
        return self.preco == outro_produto.preco


class Eletronico(Produto):
    def __init__(self, nome, preco, garantia):
        super().__init__(nome, preco)
        self.garantia = garantia

    def info(self):
        return f'{super().info()}, Garantia: {self.garantia} anos'

    def __gt__(self, outro_eletronico):
        return self.garantia > outro_eletronico.garantia


produto1 = Produto("Mesa", 300)
eletronico1 = Eletronico("Notebook", 2500, 2)

print(produto1.info())  # Produto: Mesa, Preço: R$300.00
print(eletronico1.info())  # Produto: Notebook, Preço: R$2500.00, Garantia: 2 anos

produto2 = Produto.cria_a_partir_de_string("Cadeira,150")
print(produto2)  # Produto: Cadeira, Preço: R$150.00

print(produto1 + produto2)  # 450.0

eletronico2 = Eletronico("TV", 1800, 3)
print(eletronico1 > eletronico2)  # False

print(Produto.aplicar_desconto(1000, 10))  # 900.0
```


# revisao-parte-1.md

Índice Revisao - Parte 1

1. [tipos primitivos](#tipos-primitvos)
1. [variáveis](#variáveis)
1. [int](#int)
1. [float](#float)
1. [combinando int e float](#combinando-int-e-float)
1. [str](#str)
1. [bool](#bool)
1. [condicional if-elif-else](#condicional-if-elif-else)
1. [exercícios](#exercícios)

# revisão

## tipos primitivos

O Python possui 4 tipos primitivos básicos, são eles :
* **int** : representa os números inteiros negativos, zero e positivos;
* **float** : representa os números de ponto flutuante negativos, zero e positivos;
* **string** : representa tudo que é texto entre as simples e duplas;
* **boolean** : representa o verdadeiro e falso, das comparações;

## variáveis

Variáveis são usadas para armazenar valores dos tipos de Python. É uma boa prática usar nomes de variáveis que façam sentido com seu uso.

Por exemplo :
```python
# números inteiros (int)
idade = 25
anos_de_experiencia = 3
quantidade_de_alunos = 30
numero_de_livros = 10
pontuacao = 85
dias_no_ano = 365
numero_de_irmaos = 2
quantidade_de_copos = 6
anos_de_estudo = 15
numero_do_andar = 4

# números de ponto flutuante (float)
preco = 19.99
altura = 1.75
peso = 68.5
distancia = 12.34
nota_final = 8.7
temperatura = 22.0
salario = 3500.75
media_dos_alunos = 7.4
taxa_de_crescimento = 1.03
velocidade_media = 60.5

# strings (str)
nome = ´João´
cidade = "São Paulo"
pais = "Brasil"
curso = ´Engenharia´
profissao = "médico"
nome_da_empresa = "Oscorp"
modelo_do_carro = "Civic"
marca_do_celular = "Samsung"
cor_favorita = "azul"
time_do_coracao = "Grêmio"

# booleanos (bool)
esta_chovendo = True
tem_aula_hoje = False
janela_aberta = True
luz_acesa = False
internet_funcionando = True
tarefa_completa = False
estudando_python = True
ferias_chegando = False
fim_de_semana = True
trabalho_entregue = False

# constantes
NUMERO_MAXIMO_DE_TENTATIVAS = 5  # int
NOME_DO_PROJETO = "Desenvolvimento de Software"  # str
VELOCIDADE_DA_LUZ = 299792458  # int
NOME_DA_EMPRESA = "Senac Tech"  # str
PI = 3.14159  # float
NUMERO_JOGADORES_CAMPO = 11  # int
COR_DO_INTERNACIONAL = 'vermelho'  # str
HA_VIDA_TERRA = True  # bool
```

Repare que as variáveis acima não possuem qualquer acentuação nos seus nomes (diferente dos textos que possuem), as palavras diferentes são ligadas por um sublinhado e seus nomes fazem referência ao seu conteúdo, para facilitar a leitura e identificação no código.

As variáveis são reconhecidas por terem todas as letras minúsculas (caixa baixa) enquanto que as constantes são reconhecidas por terem seus nomes em letras maiúsculas (caixa alta).

As variáveis tem por característica terem seus valores **ALTERADOS** (podem ou não) durante a execução do programa, enquanto que as constantes tem por característica terem valores **NÃO ALTERÁVEIS** (que não deveriam) durante a execução do programa.

## precedência dos operadores

Há uma precedência fixa entre todos os operadores usados.

Veja a tabela abaixo :

| prioridade | operador símbolo | operador nome | tipo operador |
| :----: | :----: | :----: | :----: |
| 1 | `()` | parênteses | operadores aritméticos |
| 2 | `**` | potência | operadores aritméticos |
| 3 | `*`<br>`/`<br>`//`<br>`%` | multiplicaçao<br>divisão<br>divisão inteira<br>módulo | operadores aritméticos |
| 4 | `+`<br>`-` | soma<br>subtração | operadores aritméticos |
| 5 | `==`<br>`>`<br>`<`<br>`>=`<br>`<=`<br>`!=` | igual a<br>maior que<br>menor que<br>maior ou igual a<br>menor ou igual a<br>diferente de | operadores relacionais |
| 6 | `not` | negação | operadores lógicos |
| 7 | `and` | conjunção | operadores lógicos |
| 8 | `or` | disjunção | operadores lógicos |

## int

O tipo inteiro, com abreviação de `int`, são usados para representar os números negativos (-10, -42, -1), o zero (0) e lembrando que não é usado a representação de -0 e os números positivos (1, 30, 42).

Veja abaixo as operações realizadas com os números inteiros :

```python
# adição de dois inteiros:
a = 5
b = 3
resultado = a + b
print(resultado)  # saída : 8

# subtração de dois inteiros:
x = 10
y = 4
diferenca = x - y
print(diferenca)  # saída : 6

# multiplicação de dois inteiros:
largura = 7
altura = 5
area = largura * altura
print(area)  # saída : 35

# divisão de dois inteiros (divisão inteira):
total = 20
partes = 4
divisao = total // partes
print(divisao)  # saída : 5

# resto da divisão de dois inteiros (módulo):
numero = 17
divisor = 3
resto = numero % divisor
print(resto)  # saída : 2

# potenciação:
base = 2
expoente = 3
potencia = base ** expoente
print(potencia)  # saída : 8

# uso de parênteses para alterar a precedência:
resultado = (5 + 3) * 2
print(resultado)  # saída : 16

# comparação de igualdade:
idade_joao = 18
idade_maria = 18
mesma_idade = idade_joao == idade_maria
print(mesma_idade)  # saída : True

# comparação de diferença:
nota1 = 7
nota2 = 8
notas_diferentes = nota1 != nota2
print(notas_diferentes)  # saída : True

# comparação maior que:
saldo_banco = 1500
saldo_minimo = 1000
acima_do_minimo = saldo_banco > saldo_minimo
print(acima_do_minimo)  # saída : True

# comparação menor que:
velocidade_carro = 80
velocidade_limite = 90
abaixo_limite = velocidade_carro < velocidade_limite
print(abaixo_limite)  # saída : True

# comparação maior ou igual a:
temperatura = 30
temperatura_minima = 30
dentro_do_padrao = temperatura >= temperatura_minima
print(dentro_do_padrao)  # saída : True

# comparação menor ou igual a:
pessoas_na_fila = 10
capacidade_maxima = 15
pode_entrar = pessoas_na_fila <= capacidade_maxima
print(pode_entrar)  # saída : True

# uso de constante:
PI = 3.14
raio = 5
circunferencia = 2 * PI * raio
print(circunferencia)  # saída : 31.400000000000002

# soma com variável e constante:
INCREMENTO = 10
valor = 25
novo_valor = valor + INCREMENTO
print(novo_valor)  # saída : 35

# subtração com variável e constante:
DESCONTO = 5
preco_original = 50
preco_com_desconto = preco_original - DESCONTO
print(preco_com_desconto)  # saída : 45

# expressão complexa com várias operações:
resultado = (4 + 5) * 2 - (3 ** 2) // 2
print(resultado)  # saída : 11

# divisão com resultado decimal:
a = 10
b = 4
divisao_decimal = a / b
print(divisao_decimal)  # saída : 2.5

# uso de variável para armazenar resultado de uma expressão:
numero1 = 15
numero2 = 5
resultado_expressao = (numero1 * 2 + numero2) / 3
print(resultado_expressao)  # saída : 11.666666666666666
```

## float

O tipo ponto flutuante, com abreviação de `float`, são usados para representar os números negativos (-10.9, -42.0, -1.000001), o zero (0.0) e lembrando que não é usado a representação de -0.0 e os números positivos (1.00000000002, 30.123, 42.0).

Veja abaixo as operações realizadas com os números de ponto flutuante :

```python
# adição de dois floats:
a = 5.2
b = 3.1
resultado = a + b
print(resultado)  # saída : 8.3

# subtração de dois floats:
x = 10.5
y = 4.2
diferenca = x - y
print(diferenca)  # saída : 6.3

# multiplicação de dois floats:
largura = 7.5
altura = 5.2
area = largura * altura
print(area)  # saída : 39.0

# divisão de dois floats:
total = 20.0
partes = 4.0
divisao = total / partes
print(divisao)  # saída : 5.0

# resto da divisão de dois floats (módulo):
numero = 17.5
divisor = 3.2
resto = numero % divisor
print(resto)  # saída : 1.8999999999999986

# potenciação:
base = 2.0
expoente = 3.0
potencia = base ** expoente
print(potencia)  # saída : 8.0

# uso de parênteses para alterar a precedência:
resultado = (5.5 + 3.3) * 2.0
print(resultado)  # saída : 17.6

# comparação de igualdade:
preco_produto1 = 18.50
preco_produto2 = 18.50
mesmo_preco = preco_produto1 == preco_produto2
print(mesmo_preco)  # saída : True

# comparação de diferença:
nota1 = 7.5
nota2 = 8.0
notas_diferentes = nota1 != nota2
print(notas_diferentes)  # saída : True

# comparação maior que:
saldo_banco = 1500.75
saldo_minimo = 1000.00
acima_do_minimo = saldo_banco > saldo_minimo
print(acima_do_minimo)  # saída : True

# comparação menor que:
velocidade_carro = 80.5
velocidade_limite = 90.0
abaixo_limite = velocidade_carro < velocidade_limite
print(abaixo_limite)  # saída : True

# comparação maior ou igual a:
temperatura = 30.0
temperatura_minima = 30.0
dentro_do_padrao = temperatura >= temperatura_minima
print(dentro_do_padrao)  # saída : True

# comparação menor ou igual a:
pessoas_na_fila = 10.5
capacidade_maxima = 15.0
pode_entrar = pessoas_na_fila <= capacidade_maxima
print(pode_entrar)  # saída : True

# uso de constante:
PI = 3.14
raio = 5.0
circunferencia = 2 * PI * raio
print(circunferencia)  # saída : 31.400000000000002

# soma com variável e constante:
INCREMENTO = 10.0
valor = 25.5
novo_valor = valor + INCREMENTO
print(novo_valor)  # saída : 35.5

# subtração com variável e constante:
DESCONTO = 5.0
preco_original = 50.0
preco_com_desconto = preco_original - DESCONTO
print(preco_com_desconto)  # saída : 45.0

# expressão complexa com várias operações:
resultado = (4.5 + 5.2) * 2.0 - (3.0 ** 2) // 2.0
print(resultado)  # saída : 11.4

# divisão com resultado decimal:
a = 10.0
b = 4.0
divisao_decimal = a / b
print(divisao_decimal)  # saída : 2.5

# uso de variável para armazenar resultado de uma expressão:
numero1 = 15.5
numero2 = 5.2
resultado_expressao = (numero1 * 2.0 + numero2) / 3.0
print(resultado_expressao)  # saída : 12.066666666666668
```

## combinando int e float

Tanto o tipo inteiro `int` quanto o tipo ponto flutuante `float` são tipos numéricos, então eles podem ser usados juntos para as operações acima.

Veja exemplos :

```python
# adição de um inteiro e um float:
a = 5
b = 3.2
resultado = a + b
print(resultado)  # saída : 8.2

# subtração de um float por um inteiro:
x = 10.5
y = 4
diferenca = x - y
print(diferenca)  # saída : 6.5

# multiplicação de um inteiro por um float:
largura = 7
altura = 5.2
area = largura * altura
print(area)  # saída : 36.4

# divisão de um inteiro por um float:
total = 20
partes = 4.0
divisao = total / partes
print(divisao)  # saída : 5.0

# divisão de um float e um inteiro (divisão inteira):
total = 23.4
partes = 4
divisao = total // partes
print(divisao)  # saída : 5.0

# resto da divisão de um inteiro por um float (módulo):
numero = 17
divisor = 3.2
resto = numero % divisor
print(resto)  # saída : 1.3999999999999986

# potenciação com base float e expoente inteiro:
base = 2.5
expoente = 3
potencia = base ** expoente
print(potencia)  # saída : 15.625

# uso de parênteses para alterar a precedência com inteiro e float:
resultado = (5 + 3.3) * 2
print(resultado)  # saída : 16.6

# comparação de igualdade entre inteiro e float:
idade_joao = 18
idade_maria = 18.0
mesma_idade = idade_joao == idade_maria
print(mesma_idade)  # saída : True

# soma de uma constante inteira com uma variável float:
INCREMENTO = 10
valor = 25.5
novo_valor = valor + INCREMENTO
print(novo_valor)  # saída : 35.5

# expressão complexa com inteiros e floats:
resultado = (4 + 5.5) * 2 - (3 ** 2) // 2.0
print(resultado)  # saída : 10.0
```

## str

O tipo texto, chamado de String `str`, é o tipo usado para representar tudo que é texto e que está entre aspas simples `'...'`, aspas duplas `"..."` e aspas triplas `'''...'''` e `"""..."""`, essa última conhecida como strings literais.

A indexação de strings em Python é uma maneira de acessar caracteres individuais dentro de uma string.

A indexação de strings começa do 0. Isso significa que o primeiro caractere da string está no índice 0, o segundo caractere está no índice 1, e assim por diante.
Por exemplo, para a string "Python", o caractere 'P' está no índice 0, 'y' está no índice 1, 't' está no índice 2, etc.

```python
texto = "Python"
print(texto[0])  # saída : P
print(texto[1])  # saída : y
```

Índices negativos são usados para acessar caracteres a partir do final da string. O índice -1 refere-se ao último caractere, -2 ao penúltimo, e assim por diante.
Por exemplo, para a string "Python", o caractere 'n' está no índice -1 e 'o' está no índice -2.

```python
texto = "Python"
print(texto[-1])  # saída : n
print(texto[-2])  # saída : o
```

O fatiamento permite extrair uma parte da string. A sintaxe é texto[início:fim:passo], onde:
- `início` é o índice onde o fatiamento começa (inclusivo),
- `fim` é o índice onde o fatiamento termina (exclusivo),
- `passo` é o intervalo entre os caracteres que serão incluídos (opcional).

Se o início ou fim não forem fornecidos, o fatiamento usará o início ou o final da string, respectivamente.

```python
texto = "Python"
print(texto[:3])    # saída : Pyt (do início até o índice 2)
print(texto[3:])    # saída : hon (do índice 3 até o final)
print(texto[::2])   # saída : Pto (passo 2, pegando cada segundo caractere)
print(texto[::-1])   # saída : nohtyP (passo -1, inverte a string)
```

Veja alguns exemplos :

```python
# concatenando duas strings:
saudacao = "Olá"
nome = "Mundo"
mensagem = saudacao + " " + nome
print(mensagem)  # saída : Olá Mundo

# concatenando strings com números:
parte1 = "Número"
parte2 = " 42"
resultado = parte1 + parte2
print(resultado)  # saída : Número 42

# multiplicação de uma string:
repeticao = "Ha" * 3
print(repeticao)  # saída : HaHaHa

# uso do caractere de nova linha \n:
mensagem = "Primeira linha\nSegunda linha"
print(mensagem)
# saída :
# Primeira linha
# Segunda linha

# uso do caractere de tabulação \t:
mensagem = "Nome:\tJoão"
print(mensagem)
# saída :
# Nome:    João

# uso da barra invertida \ para escapar caracteres:
caminho = "C:\\Users\\Nome"
print(caminho)  # saída : C:\Users\Nome

# concatenando com \n:
linha1 = "Esta é a primeira linha"
linha2 = "Esta é a segunda linha"
mensagem = linha1 + "\n" + linha2
print(mensagem)
# saída :
# Esta é a primeira linha
# Esta é a segunda linha

# concatenando com \t:
chave = "Chave:"
valor = "12345"
mensagem = chave + "\t" + valor
print(mensagem)
# saída :
# Chave:  12345

# uso de aspas simples dentro de uma string com aspas duplas:
mensagem = "Ela disse: 'Olá!'"
print(mensagem)  # saída : Ela disse: 'Olá!'

# uso de aspas duplas dentro de uma string com aspas simples:
mensagem = 'Ele respondeu: "Bom dia!"'
print(mensagem)  # saída : Ele respondeu: "Bom dia!"

# concatenando com variáveis:
nome = "Ana"
saudacao = "Bom dia, " + nome + "!"
print(saudacao)  # saída : Bom dia, Ana!

# multiplicação de strings com espaços:
ponto = ". "
linha = ponto * 10
print(linha)  # saída : . . . . . . . . . .

# uso do caractere de nova linha para formatação:
lista_compras = "Itens:\n- Maçã\n- Banana\n- Laranja"
print(lista_compras)
# saída :
# Itens:
# - Maçã
# - Banana
# - Laranja

# uso do caractere de tabulação para formatação:
tabela = "Produto\tPreço\nMaçã\t1.50\nBanana\t0.75"
print(tabela)
# saída :
# Produto    Preço
# Maçã       1.50
# Banana     0.75

# uso da barra invertida para incluir aspas duplas:
mensagem = "Ele disse: \"Bom trabalho!\""
print(mensagem)  # saída : Ele disse: "Bom trabalho!"

# uso da barra invertida para incluir aspas simples:
mensagem = 'Ela disse: \'Até logo!\''
print(mensagem)  # saída : Ela disse: 'Até logo!'

# concatenando strings literais:
mensagem = "Python " + "é " + "divertido!"
print(mensagem)  # saída : Python é divertido!

# uso de caracteres especiais em uma string:
texto = "Linha1\nLinha2\tTabbed\nCaminho: C:\\Usuários\\Nome"
print(texto)
# saída :
# Linha1
# Linha2  Tabbed
# Caminho: C:\Usuários\Nome

# concatenando strings com múltiplas linhas:
mensagem = "Olá,\n" + "Este é um exemplo de mensagem\n" + "com múltiplas linhas."
print(mensagem)
# saída :
# Olá,
# Este é um exemplo de mensagem
# com múltiplas linhas.

# multiplicação de strings para criar um padrão:
padrao = "AB" * 5
print(padrao)  # saída : ABABABABAB

# uso de aspas duplas dentro de aspas duplas com escape:
frase = "Ele disse: \"Isso é incrível!\""
print(frase)  # saída : Ele disse: "Isso é incrível!"

# uso de aspas simples dentro de aspas simples com escape:
frase = 'Ela respondeu: \'Sim, estou de acordo.\''
print(frase)  # saída : Ela respondeu: 'Sim, estou de acordo.'

# uso de caracteres de nova linha \n em uma string longa:
mensagem = "Linha 1\nLinha 2\nLinha 3"
print(mensagem)
# saída :
# Linha 1
# Linha 2
# Linha 3

# uso de tabulação \t para alinhar texto:
tabela = "Nome\tIdade\tCidade\nAna\t30\tSão Paulo\nCarlos\t25\tRio de Janeiro"
print(tabela)
# saída :
# Nome    Idade    Cidade
# Ana     30       São Paulo
# Carlos  25       Rio de Janeiro

# uso de barra invertida para escapar uma barra invertida:
caminho = "C:\\Usuários\\Publico"
print(caminho)  # saída : C:\Usuários\Publico

# uso de aspas simples dentro de uma string com aspas duplas sem escape:
mensagem = "O livro se chama 'Python para Iniciantes'"
print(mensagem)  # saída : O livro se chama 'Python para Iniciantes'

# uso de aspas duplas dentro de uma string com aspas simples sem escape:
mensagem = 'Ele disse: "Boa sorte!"'
print(mensagem)  # saída : Ele disse: "Boa sorte!"

# string literal com múltiplas linhas usando aspas triplas:
mensagem = '''Esta é uma string
que ocupa múltiplas linhas,
sem a necessidade de caracteres de nova linha.'''
print(mensagem)
# saída :
# Esta é uma string
# que ocupa múltiplas linhas,
# sem a necessidade de caracteres de nova linha.

# uso de aspas triplas dentro de aspas triplas:
texto = """Ela disse: "Isso é 'fantástico'!"
E ele respondeu: "Concordo completamente."""
print(texto)
# saída :
# Ela disse: "Isso é 'fantástico'!"
# E ele respondeu: "Concordo completamente."

# acessando o primeiro caractere
texto = "Python"
print(texto[0])  # saída : P

# acessando o terceiro caractere
texto = "Python"
print(texto[2])  # saída : t

# acessando o último caractere
texto = "Python"
print(texto[-1])  # saída : n

# acessando o penúltimo caractere
texto = "Python"
print(texto[-2])  # saída : o

# fatiando os primeiros três caracteres
texto = "Python"
print(texto[:3])  # saída : Pyt

# fatiando os caracteres do índice 2 ao 5
texto = "Python"
print(texto[2:6])  # saída : thon

# fatiando a partir do índice 4 até o final
texto = "Python"
print(texto[4:])  # saída : hon

# fatiando até o índice 4
texto = "Python"
print(texto[:4])  # saída : Pyt

# fatiando com passo de 2 caracteres
texto = "Python"
print(texto[::2])  # saída : Pto

# fatiando com passo negativo
texto = "Python"
print(texto[::-1])  # saída : nohtyP

# fatiando com passo de 3 caracteres
texto = "Python"
print(texto[::3])  # saída : Phn

# fatiando com início e fim específicos
texto = "Python"
print(texto[1:5:2])  # saída : ytn

# fatiando uma string com tamanho variável
texto = "Indexação"
print(texto[3:7])  # saída : exaç

# fatiando uma string com caracteres especiais
texto = "Hello, World!"
print(texto[7:])  # saída : World!

# acessando um caractere em uma string de números
texto = "123456"
print(texto[4])  # saída : 5

# fatiando uma string para pegar caracteres de um espaço em branco
texto = "Python Programming"
print(texto[7:11])  # saída : Prog

# fatiando uma string para pegar caracteres de uma palavra específica
texto = "A quick brown fox"
print(texto[2:9])  # saída : quick b

# fatiando uma string para pegar a última palavra
texto = "A quick brown fox"
print(texto[11:])  # saída : brown fox

# fatiando uma string para pegar caracteres com diferentes passos
texto = "abcdefghijk"
print(texto[::4])  # saída : ae
```

## bool

O tipo lógico, chamado de boolean `bool` no Python, é usado quando se quer representar um valor lógico de verdadeiro ou falso. Ele é muito usado nas estruturas de decisões como `if-elif-else` e `while`, por exemplo.

Veja alguns exemplos :

```python
# comparação de igualdade entre inteiros:
a = 5
b = 5
resultado = a == b
print(resultado)  # saída : True

# comparação de diferença entre inteiros:
a = 5
b = 3
resultado = a != b
print(resultado)  # saída : True

# comparação maior que entre inteiros:
a = 10
b = 5
resultado = a > b
print(resultado)  # saída : True

# comparação menor que entre inteiros:
a = 5
b = 10
resultado = a < b
print(resultado)  # saída : True

# comparação maior ou igual entre inteiros:
a = 10
b = 10
resultado = a >= b
print(resultado)  # saída : True

# comparação menor ou igual entre inteiros:
a = 5
b = 10
resultado = a <= b
print(resultado)  # saída : True

# comparação de igualdade entre strings:
palavra1 = "python"
palavra2 = "python"
resultado = palavra1 == palavra2
print(resultado)  # saída : True

# comparação de diferença entre strings:
palavra1 = "python"
palavra2 = "Python"
resultado = palavra1 != palavra2
print(resultado)  # saída : True

# uso do operador and (e lógico):
a = True
b = False
resultado = a and b
print(resultado)  # saída : False

# uso do operador or (ou lógico):
a = True
b = False
resultado = a or b
print(resultado)  # saída : True

# uso do operador not (não lógico):
a = True
resultado = not a
print(resultado)  # saída : False

# combinação de operadores relacionais e lógicos:
a = 10
b = 5
c = 7
resultado = (a > b) and (c < a)
print(resultado)  # saída : True

# comparação entre float e inteiro:
a = 10.0
b = 10
resultado = a == b
print(resultado)  # saída : True

# comparação de strings com diferentes casos:
palavra1 = "pythoN"
palavra2 = "python"
resultado = palavra1 == palavra2
print(resultado)  # saída : False

# verificação se um número é par:
numero = 4
resultado = numero % 2 == 0
print(resultado)  # saída : True

# verificação se um número é ímpar:
numero = 5
resultado = numero % 2 != 0
print(resultado)  # saída : True

# outra forma de verificar se um número é par ou ímpar
numero = 5
valor = numero // 2
valor = valor * 2
resultado = valor == numero
print(resultado)

# combinação de operadores and, or e not:
a = True
b = False
c = True
resultado = (a and b) or (not c)
print(resultado)  # saída : False

# comparação entre variáveis booleanas:
a = True
b = False
resultado = a == b
print(resultado)  # saída : False
```

## condicional if-elif-else

Condicionais são usados para tomar decisões no seu código. Com base em condições (que são expressões que retornam `True` ou `False`), você pode executar diferentes blocos de código.

### condicionais simples

* **`if`** : verifica uma condição. Se a condição for verdadeira (`True`), o bloco de código dentro do if será executado.
    ```python
    if teste_condicional:
        # Código a ser executado se a condição for verdadeira
    ```
* **`elif`** : é uma abreviação de `else if` e verifica uma condição alternativa se a condição anterior (`if`) não for verdadeira. Pode haver múltiplos `elif`.
    ```python
    if teste_condicional1:
        # Código se teste_condicional1 for verdadeira
    elif teste_condicional2:
        # Código se teste_condicional1 for falsa e teste_condicional2 for verdadeira
    ```
* **`else`** :executa um bloco de código se todas as condições anteriores (`if` e `elif`) forem falsas.
    ```python
    if teste_condicional1:
        # Código se teste_condicional1 for verdadeira
    elif teste_condicional2:
        # Código se teste_condicional1 for falsa e teste_condicional2 for verdadeira
    else:
        # Código se todas as condições anteriores forem falsas
    ```

### condicinais aninhadas

Permite decisões mais complexas ao verificar condições adicionais dentro de blocos `if`, `elif` ou `else`.

```python
if teste_condicional1:
    # Código executado se teste_condicional1 for verdadeira
    if teste_condicional2:
        # Código executado se teste_condicional2 for verdadeira e teste_condicional1 for verdadeira
    elif teste_condicional3:
        # Código executado se teste_condicional3 for verdadeira e teste_condicional1 for verdadeira
    else:
        # Código executado se nenhuma teste_condicional2 ou teste_condicional3 for verdadeira, mas condição1 for verdadeira
elif teste_condicional4:
    # Código executado se teste_condicional4 for verdadeira e teste_condicional1 for falsa
else:
    # Código executado se nenhuma das condições anteriores for verdadeira
```

### exemplos

Veja exemplos da condição `if`-`elif`-`else` :

```python
# verificação simples com if:
idade = 18
if idade >= 18:
    print("Você é maior de idade.")

# usando if e else:
idade = 16
if idade >= 18:
    print("Você é maior de idade.")
else:
    print("Você é menor de idade.")

# usando if, elif e else:
nota = 85
if nota >= 90:
    print("Aprovado com Distinção")
elif nota >= 70:
    print("Aprovado")
else:
    print("Reprovado")

# verificação de idade para categoria de ingresso:
idade = 22
if idade < 12:
    print("Ingresso infantil")
elif idade < 18:
    print("Ingresso juvenil")
else:
    print("Ingresso adulto")

# verificação de temperatura:
temperatura = 30
if temperatura < 15:
    print("Está frio.")
elif temperatura < 25:
    print("Está agradável.")
else:
    print("Está quente.")

# verificação de número par ou ímpar:
numero = 7
if numero % 2 == 0:
    print("O número é par.")
else:
    print("O número é ímpar.")

# checando se um número está entre dois valores:
numero = 15
if 10 <= numero <= 20:
    print("O número está entre 10 e 20.")
else:
    print("O número não está entre 10 e 20.")

# verificação de idade para habilitação de dirigir:
idade = 17
if idade >= 18:
    print("Pode obter a carteira de motorista.")
else:
    print("Não pode obter a carteira de motorista.")

# checando se uma variável é igual a um valor específico:
fruta = "maçã"
if fruta == "maçã":
    print("Você escolheu uma maçã.")
elif fruta == "banana":
    print("Você escolheu uma banana.")
else:
    print("Fruta não reconhecida.")

# checando o saldo da conta bancária:
saldo = 100
if saldo >= 0:
    print("Saldo positivo.")
else:
    print("Saldo negativo.")

# verificação de status de login:
usuario_logado = True
if usuario_logado:
    print("Bem-vindo de volta!")
else:
    print("Por favor, faça o login.")

# verificação de idade para desconto em ingresso:
idade = 65
if idade >= 65:
    print("Desconto para idosos.")
else:
    print("Sem desconto.")

# verificação de validade de senha:
senha = "12345"
if len(senha) >= 6:
    print("Senha válida.")
else:
    print("Senha muito curta.")

# determinação do tipo de triângulo:
a = 3
b = 4
c = 5
if a == b == c:
    print("Triângulo equilátero.")
elif a == b or b == c or a == c:
    print("Triângulo isósceles.")
else:
    print("Triângulo escaleno.")

# checando se um valor está fora de um intervalo:
valor = 25
if valor < 10 or valor > 20:
    print("Valor fora do intervalo.")
else:
    print("Valor dentro do intervalo.")

# verificação de número positivo, negativo ou zero:
numero = 0
if numero > 0:
    print("Número positivo.")
elif numero < 0:
    print("Número negativo.")
else:
    print("Número é zero.")

# checando se um número é múltiplo de 3 e 5:
numero = 15
if numero % 3 == 0 and numero % 5 == 0:
    print("O número é múltiplo de 3 e 5.")
elif numero % 3 == 0:
    print("O número é múltiplo de 3.")
elif numero % 5 == 0:
    print("O número é múltiplo de 5.")
else:
    print("O número não é múltiplo de 3 nem de 5.")

# condicionais aninhadas

# verificação de idade e se a pessoa é estudante:
idade = 20
estudante = True
if idade >= 18:
    if estudante:
        print("Você é um estudante adulto.")
    else:
        print("Você é um adulto não estudante.")
else:
    print("Você é menor de idade.")

# verificação de temperatura e umidade:
temperatura = 30
umidade = 70
if temperatura > 25:
    if umidade > 60:
        print("Clima quente e úmido.")
    else:
        print("Clima quente e seco.")
else:
    print("Clima fresco.")

# checagem de aprovação em um curso:
nota = 85
presença = 90
if nota >= 70:
    if presença >= 75:
        print("Aprovado no curso.")
    else:
        print("Reprovado por falta de presença.")
else:
    print("Reprovado por nota.")

# verificação de acesso com senha e nível de usuário:
senha = "admin123"
nivel_usuario = "admin"
if senha == "admin123":
    if nivel_usuario == "admin":
        print("Acesso total concedido.")
    else:
        print("Acesso limitado concedido.")
else:
    print("Senha incorreta.")

# verificação de idade para entrada em evento e se possui convite:
idade = 25
convite = True
if idade >= 18:
    if convite:
        print("Entrada permitida ao evento.")
    else:
        print("Você precisa de um convite para entrar.")
else:
    print("Você não tem idade suficiente para entrar.")

# checagem de valor de desconto e valor total da compra:
valor_total = 150
desconto = 10  # em porcentagem
if valor_total > 100:
    if desconto > 5:
        print("Desconto aplicado.")
    else:
        print("Desconto não suficiente para aplicar.")
else:
    print("Compra abaixo do valor mínimo para desconto.")

# verificação de saldo bancário e status da conta:
saldo = 2000
conta_ativa = True
if conta_ativa:
    if saldo >= 1000:
        print("Conta com saldo suficiente.")
    else:
        print("Saldo insuficiente.")
else:
    print("Conta não está ativa.")

# verificação de idade para compra de bebida alcoólica e estado de residência:
idade = 22
estado = "SP"
if idade >= 21:
    if estado == "SP" or estado == "RJ":
        print("Você pode comprar bebida alcoólica.")
    else:
        print("Restrições de compra no seu estado.")
else:
    print("Você não pode comprar bebida alcoólica.")

# verificação de validade de voucher e valor da compra:
valor_compra = 50
voucher_valido = True
if voucher_valido:
    if valor_compra >= 40:
        print("Voucher aplicado com sucesso.")
    else:
        print("Valor da compra não atende aos requisitos do voucher.")
else:
    print("Voucher inválido.")

# checagem de disponibilidade de produto e status de entrega:
produto_em_estoque = True
status_entrega = "em trânsito"
if produto_em_estoque:
    if status_entrega == "em trânsito":
        print("Produto disponível e em entrega.")
    else:
        print("Produto disponível, mas entrega não iniciada.")
else:
    print("Produto fora de estoque.")
```

## exercícios

<details>
<summary>Lista de Exercícios</summary>

## int e float

1. Exercícios Iniciais
    1. Crie uma variável x com o valor 10 e uma variável y com o valor 5. Imprima a soma de x e y.
    1. Crie uma variável a com o valor 8 e uma variável b com o valor 4. Imprima o resultado da subtração de a por b.
    1. Crie uma variável x com o valor 7 e uma variável y com o valor 3. Imprima o resultado da multiplicação de x por y.
    1. Crie uma variável x com o valor 20 e uma variável y com o valor 4. Imprima o resultado da divisão de x por y.
    1. Crie uma variável x com o valor 10 e outra variável y com o valor 4. Imprima o resto da divisão de x por y.
    1. Crie uma variável a com o valor 15. Imprima o valor de a elevado ao quadrado.
    1. Crie uma variável a com o valor 9 e outra variável b com o valor 2. Imprima a divisão inteira de a por b.
    1. Crie uma variável x com o valor 5.5 e uma variável y com o valor 2.2. Imprima a soma de x e y.
    1. Crie uma variável x com o valor 3.7 e uma variável y com o valor 1.2. Imprima o resultado da subtração de x por y.
    1. Crie uma variável x com o valor 4.5 e uma variável y com o valor 2. Imprima o resultado da multiplicação de x por y.
1. Exercícios Intermediários
    1. Crie uma variável a com o valor 25 e outra variável b com o valor 7. Imprima o resultado da divisão de a por b, com 2 casas decimais.
    1. Crie uma variável x com o valor 6.7 e uma variável y com o valor 3.1. Imprima a soma de x e y, com 1 casa decimal.
    1. Crie uma variável a com o valor 16 e outra variável b com o valor 4. Crie uma terceira variável resultado que armazene a raiz quadrada de a dividida por b. Imprima resultado.
    1. Crie uma variável x com o valor 12.5 e uma variável y com o valor 2.5. Imprima a diferença entre x e y e verifique se é maior que 8.
    1. Crie uma variável a com o valor 3.14 e outra variável b com o valor 2. Crie uma variável resultado que armazene a multiplicação de a por b, e imprima o resultado com 3 casas decimais.
    1. Crie uma variável x com o valor 45.9 e outra variável y com o valor 15.1. Imprima o resultado da divisão de x por y, com 4 casas decimais.
        ```python
        x = 45.9
        y = 15.1

        print('x / y', x / y)
        print('(x/y) * 10000', (x/y)*10000)
        print('((x/y) * 10000) // 1', ((x/y) * 10000) // 1)

        print('(((x/y)*10000)//1)/10000',(((x/y)*10000)//1)/10000)

        print('x/y * 10000 // 1 / 10000', x/y * 10000 // 1 / 10000)
        ```
    1. Crie uma variável a com o valor 0.5 e outra variável b com o valor 0.25. Imprima a soma de a e b, multiplicada por 100.
    1. Crie uma variável x com o valor 8.2 e uma variável y com o valor 3.4. Imprima o resultado da multiplicação de x por y e verifique se é menor que 30.
    1. Crie uma variável a com o valor 17 e outra variável b com o valor 3. Crie uma variável resultado que armazene a soma de a com o resto da divisão de a por b. Imprima resultado.
    1. Crie uma variável x com o valor 5.6 e outra variável y com o valor 2.3. Imprima o resultado da subtração de x por y, arredondado para o inteiro mais próximo.
1. Exercícios Avançados
    1. Crie uma variável x com o valor 9 e uma variável y com o valor 4. Imprima o resultado da expressão (x ** 2 + y ** 2) / (x - y).
    1. Crie uma variável x com o valor 10.5 e uma variável y com o valor 2.7. Imprima o resultado da expressão (x * y) - (x / y).
    1. Crie uma variável a com o valor 12 e uma variável b com o valor 5. Crie uma variável resultado que armazene a soma de a e b, elevada ao quadrado. Imprima resultado.
    1. Crie uma variável x com o valor 6.8 e uma variável y com o valor 2.4. Imprima a soma de x com y, multiplicada pelo resto da divisão de x por y.
    1. Crie uma variável a com o valor 20 e outra variável b com o valor 7. Crie uma variável resultado que armazene a média de a e b. Imprima resultado com 2 casas decimais.
    1. Crie uma variável x com o valor 15.75 e uma variável y com o valor 3.5. Imprima o resultado da expressão x / y somado ao quadrado de y.
    1. Crie uma variável a com o valor 8 e uma variável b com o valor 3. Crie uma variável resultado que armazene a diferença entre a e b, e verifique se o quadrado do resultado é maior que 20. Imprima resultado.
    1. Crie uma variável x com o valor 7.5 e uma variável y com o valor 3.2. Imprima o resultado da expressão (x + y) / (x - y) com 2 casas decimais.
    1. Crie uma variável a com o valor 25 e uma variável b com o valor 5. Crie uma variável resultado que armazene o valor absoluto da diferença entre o quadrado de a e o cubo de b. Imprima resultado.
    1. Crie uma variável x com o valor 10.4 e uma variável y com o valor 3.6. Imprima a expressão (x ** 2 + y ** 2) / (x * y) e verifique se é maior que 5.
    1. Crie uma variável a com o valor 8 e outra variável b com o valor 3. Crie uma variável resultado que armazene a soma de a e b, e imprima o resultado dividido pela raiz quadrada de a.
    1. Crie uma variável x com o valor 11.2 e uma variável y com o valor 5.7. Imprima o resultado da expressão (x - y) * (x + y), com 2 casas decimais.
    1. Crie uma variável a com o valor 30 e outra variável b com o valor 4. Crie uma variável resultado que armazene a diferença entre a e b, elevada ao cubo. Imprima resultado.
    1. Crie uma variável x com o valor 8.5 e uma variável y com o valor 2.3. Imprima a expressão (x * y) + (x / y) e verifique se é menor que 20.
    1. Crie uma variável a com o valor 18 e uma variável b com o valor 7. Crie uma variável resultado que armazene o valor absoluto da diferença entre a e o produto de b por 2. Imprima resultado.
    1. Crie uma variável x com o valor 14.7 e uma variável y com o valor 6.3. Imprima o resultado da expressão (x + y) / (x - y) e verifique se é maior que 2.
    1. Crie uma variável a com o valor 12 e uma variável b com o valor 5. Crie uma variável resultado que armazene a soma de a e b, multiplicada pela raiz quadrada de a. Imprima resultado.
    1. Crie uma variável x com o valor 9.8 e uma variável y com o valor 4.2. Imprima a expressão ((x + y) * 2) / (x - y), com 2 casas decimais.
    1. Crie uma variável a com o valor 7 e outra variável b com o valor 2. Crie uma variável resultado que armazene o valor absoluto do quadrado de a subtraído do cubo de b. Imprima resultado.
    1. Crie uma variável x com o valor 5.5 e uma variável y com o valor 2.2. Crie uma variável resultado que armazene a soma de x e y, e imprima o resultado elevado ao quadrado.
    1. Crie uma variável a com o valor 21 e uma variável b com o valor 3. Crie uma variável resultado que armazene a diferença entre o quadrado de a e o cubo de b, dividido por b. Imprima resultado.
    1. Crie uma variável x com o valor 20.5 e uma variável y com o valor 3.2. Imprima o resultado da expressão (x - y) * (x + y), com 1 casa decimal.
    1. Crie uma variável a com o valor 18 e uma variável b com o valor 7. Crie uma variável resultado que armazene a soma de a com o produto de b e 2. Imprima resultado dividido pela raiz quadrada de a.
    1. Crie uma variável x com o valor 12.4 e uma variável y com o valor 2.5. Imprima a expressão ((x * y) + (x / y)) - (y ** 2), com 2 casas decimais.
    1. Crie uma variável a com o valor 14 e uma variável b com o valor 5. Crie uma variável resultado que armazene o quadrado da soma de a e b, dividido pelo cubo de b. Imprima resultado.
    1. Crie uma variável x com o valor 25.7 e uma variável y com o valor 8.3. Imprima o resultado da expressão (x / y) * ((x + y) / (x - y)), com 2 casas decimais.
    1. Crie uma variável a com o valor 30 e uma variável b com o valor 7. Crie uma variável resultado que armazene o produto de a por b, dividido pela diferença entre a e b. Imprima resultado.
    1. Crie uma variável x com o valor 10.5 e uma variável y com o valor 3.7. Imprima a expressão ((x * y) + (x / y)) - (x ** 2), com 2 casas decimais.
    1. Crie uma variável a com o valor 15 e uma variável b com o valor 4. Crie uma variável resultado que armazene a soma de a e b, elevada ao cubo, e depois subtraia 100. Imprima resultado.
    1. Crie uma variável x com o valor 9.9 e uma variável y com o valor 2.2. Imprima a expressão ((x ** 2) + (y ** 2)) / ((x * y) - y), com 2 casas decimais.

## str

1. Exercícios Simples
    1. Crie duas variáveis str1 e str2 com os valores "Hello" e "World". Imprima a soma das duas strings.
    1. Crie uma variável texto com o valor "Python". Imprima a string "PythonPython" usando a multiplicação de strings.
    1. Crie uma variável frase com o valor "Python Programming". Imprima os primeiros 6 caracteres da string.
    1. Crie uma variável texto com o valor "Hello, World!". Imprima os caracteres da posição 7 até o final da string.
    1. Crie uma variável mensagem com o valor "Python". Imprima os primeiros 3 caracteres.
    1. Crie uma variável palavra com o valor "Data". Imprima a string "DataDataData" usando a multiplicação de strings.
    1. Crie uma variável texto com o valor "Python". Imprima os caracteres do índice 1 ao 4.
    1. Crie duas variáveis prefixo e sufixo com os valores "Hello" e "World". Imprima a soma das duas strings com um espaço entre elas.
    1. Crie uma variável nome com o valor "Alice". Imprima a string "AliceAlice" usando a multiplicação de strings.
    1. Crie uma variável mensagem com o valor "Data Science". Imprima os caracteres do índice 5 até o final da string.
1. Exercícios Intermediários
    1. Crie uma variável texto com o valor "Learn Python". Imprima os caracteres do índice 6 ao 11.
    1. Crie uma variável frase com o valor "Hello World". Imprima a string "HelloHello" usando a multiplicação de strings.
    1. Crie uma variável texto com o valor "Programming". Imprima os primeiros 4 caracteres.
    1. Crie uma variável mensagem com o valor "String Manipulation". Imprima os caracteres do índice 8 ao 15.
    1. Crie duas variáveis part1 e part2 com os valores "Python" e "Rocks". Imprima a soma das duas strings com um espaço entre elas.
    1. Crie uma variável palavra com o valor "Machine Learning". Imprima a string "Machine LearningMachine Learning" usando a multiplicação de strings.
    1. Crie uma variável texto com o valor "Artificial Intelligence". Imprima os caracteres do índice 3 ao 8.
    1. Crie uma variável mensagem com o valor "Data Analysis". Imprima os caracteres do índice 5 ao 10.
    1. Crie uma variável frase com o valor "Learn to Code". Imprima a string "Learn to CodeLearn to Code" usando a multiplicação de strings.
    1. Crie uma variável texto com o valor "Statistics". Imprima os caracteres do índice 4 até o final da string.
1. Exercícios Avançados
    1. Crie uma variável frase com o valor "Welcome to the World of Python". Imprima os caracteres do índice 11 ao 20.
    1. Crie uma variável texto com o valor "Programming is Fun". Imprima a string "ProgrammingProgramming" usando a multiplicação de strings.
    1. Crie uma variável mensagem com o valor "Learn Python Basics". Imprima os caracteres do índice 0 ao 4.
    1. Crie uma variável frase com o valor "Data Science and Machine Learning". Imprima os caracteres do índice 17 ao 30.
    1. Crie duas variáveis str1 e str2 com os valores "Data" e "Science". Imprima a soma das duas strings com um espaço entre elas.
    1. Crie uma variável texto com o valor "Advanced Python Techniques". Imprima a string "Advanced Python TechniquesAdvanced Python Techniques" usando a multiplicação de strings.
    1. Crie uma variável mensagem com o valor "Artificial Intelligence Overview". Imprima os caracteres do índice 14 até o final da string.
    1. Crie uma variável texto com o valor "Introduction to Programming". Imprima os caracteres do índice 5 ao 25.
    1. Crie uma variável frase com o valor "Exploring Data Science" e imprima a string "Exploring Data ScienceExploring Data Science" usando a multiplicação de strings.
    1. Crie uma variável texto com o valor "Big Data Analytics". Imprima os caracteres do índice 3 ao 12.
    1. Crie uma variável mensagem com o valor "Data Visualization Techniques". Imprima os caracteres do índice 10 ao 25.
    1. Crie duas variáveis prefixo e sufixo com os valores "Machine Learning" e " in Python". Imprima a soma das duas strings com um espaço entre elas.
    1. Crie uma variável texto com o valor "Deep Learning Models". Imprima a string "Deep Learning ModelsDeep Learning Models" usando a multiplicação de strings.
    1. Crie uma variável frase com o valor "Data Driven Insights". Imprima os caracteres do índice 4 ao 12.
    1. Crie uma variável texto com o valor "Programming for Data Science". Imprima os caracteres do índice 12 até o final da string.
    1. Crie uma variável mensagem com o valor "Exploring Machine Learning Algorithms". Imprima a string "Exploring Machine Learning AlgorithmsExploring Machine Learning Algorithms" usando a multiplicação de strings.
    1. Crie uma variável texto com o valor "Advanced Data Analytics Techniques". Imprima os caracteres do índice 8 ao 28.
    1. Crie uma variável frase com o valor "Understanding Data Science Principles". Imprima os caracteres do índice 18 ao 35.
    1. Crie duas variáveis parte1 e parte2 com os valores "Introduction" e " to Python". Imprima a soma das duas strings com um espaço entre elas.
    1. Crie uma variável texto com o valor "Machine Learning Fundamentals". Imprima a string "Machine Learning FundamentalsMachine Learning Fundamentals" usando a multiplicação de strings.
    1. Crie uma variável mensagem com o valor "Data Science Applications". Imprima os caracteres do índice 5 ao 20.
    1. Crie uma variável texto com o valor "Artificial Intelligence Applications". Imprima os caracteres do índice 22 até o final da string.
    1. Crie uma variável frase com o valor "Deep Learning for AI". Imprima a string "Deep Learning for AIDeep Learning for AI" usando a multiplicação de strings.
    1. Crie uma variável texto com o valor "Introduction to Machine Learning". Imprima os caracteres do índice 0 ao 15.
    1. Crie uma variável mensagem com o valor "Python for Data Science and Analytics". Imprima os caracteres do índice 10 ao 35.
    1. Crie duas variáveis str1 e str2 com os valores "Deep Learning" e " in Python". Imprima a soma das duas strings com um espaço entre elas.
    1. Crie uma variável texto com o valor "Understanding Data Science Techniques". Imprima a string "Understanding Data Science TechniquesUnderstanding Data Science Techniques" usando a multiplicação de strings.
    1. Crie uma variável frase com o valor "Introduction to Data Visualization". Imprima os caracteres do índice 11 ao 30.
    1. Crie uma variável texto com o valor "Advanced Machine Learning Techniques". Imprima os caracteres do índice 10 ao 35.
    1. Crie uma variável mensagem com o valor "Data Science Fundamentals Overview". Imprima a string "Data Science Fundamentals OverviewData Science Fundamentals Overview" usando a multiplicação de strings.

## if-elif-else

1. Exercícios Simples
    1. Crie uma variável idade com o valor 18. Imprima "Maior de idade" se a idade for maior ou igual a 18. Caso contrário, imprima "Menor de idade".
    1. Crie uma variável preco com o valor 150. Imprima "Carro caro" se o preço for maior que 100, e "Carro barato" caso contrário.
    1. Crie uma variável nota com o valor 7.5. Imprima "Aprovado" se a nota for maior ou igual a 7.0. Caso contrário, imprima "Reprovado".
    1. Crie uma variável temperatura com o valor 22.5. Imprima "Quente" se a temperatura for maior que 25. Caso contrário, imprima "Frio".
    1. Crie uma variável nome com o valor "Ana". Imprima "Olá Ana" se o nome for "Ana", e "Olá desconhecido" caso contrário.
    1. Crie uma variável altura com o valor 1.75. Imprima "Altura adequada" se a altura for maior ou igual a 1.70. Caso contrário, imprima "Altura inadequada".
    1. Crie uma variável produto com o valor "livro". Imprima "Produto disponível" se o produto for "livro", e "Produto não disponível" caso contrário.
    1. Crie uma variável idade com o valor 65. Imprima "Aposentado" se a idade for maior ou igual a 65. Caso contrário, imprima "Não aposentado".
    1. Crie uma variável x com o valor 10. Imprima "Positivo" se x for maior que 0, e "Não positivo" caso contrário.
    1. Crie uma variável n com o valor 4. Imprima "Par" se n for divisível por 2, e "Ímpar" caso contrário.
1. Exercícios Intermediários
    1. Crie uma variável nota com o valor 5. Crie um bloco if-elif-else para imprimir "Aprovado" se a nota for maior ou igual a 7, "Recuperação" se a nota for entre 5 e 6, e "Reprovado" caso contrário.
    1. Crie uma variável idade com o valor 20. Crie um bloco if-elif-else para imprimir "Adulto" se a idade for entre 18 e 60, "Idoso" se a idade for maior que 60, e "Jovem" se a idade for menor que 18.
    1. Crie uma variável salario com o valor 3000. Imprima "Imposto alto" se o salário for maior que 2500, e "Imposto baixo" caso contrário.
    1. Crie uma variável nota com o valor 8.5. Imprima "Excelente" se a nota for maior ou igual a 9, "Bom" se a nota estiver entre 7 e 8.9, e "Suficiente" caso contrário.
    1. Crie uma variável numero com o valor 15. Imprima "Divisível por 3" se numero for divisível por 3, e "Não divisível por 3" caso contrário.
    1. Crie uma variável tempo com o valor 30. Crie um bloco if-elif-else para imprimir "Tempo curto" se o tempo for menor que 20, "Tempo médio" se estiver entre 20 e 40, e "Tempo longo" caso contrário.
    1. Crie uma variável nome com o valor "Carlos". Crie um bloco if-elif-else para imprimir "Nome é Carlos" se o nome for "Carlos", "Nome começa com C" se começar com "C", e "Nome diferente" caso contrário.
    1. Crie uma variável ano com o valor 2024. Imprima "Ano bissexto" se o ano for divisível por 4, mas não por 100, ou se for divisível por 400. Caso contrário, imprima "Ano não bissexto".
    1. Crie uma variável altura com o valor 1.65. Crie um bloco if-elif-else para imprimir "Baixa" se a altura for menor que 1.60, "Média" se estiver entre 1.60 e 1.80, e "Alta" caso contrário.
    1. Crie uma variável idade com o valor 30. Imprima "Jovem adulto" se a idade for entre 20 e 30, "Adulto" se estiver entre 31 e 50, e "Meia-idade" caso contrário.
1. Exercícios Avançados
    1. Crie uma variável dia com o valor "Sábado". Imprima "Fim de semana" se o dia for "Sábado" ou "Domingo", e "Dia de semana" caso contrário.
    1. Crie uma variável idade com o valor 16. Crie um bloco if-elif-else para imprimir "Infantil" se a idade for menor que 12, "Juvenil" se estiver entre 12 e 18, e "Adulto" caso contrário.
    1. Crie uma variável mes com o valor "Julho". Imprima "Verão" se o mês for "Junho", "Julho", ou "Agosto", e "Não é verão" caso contrário.
    1. Crie uma variável temperatura com o valor 10. Imprima "Frio" se a temperatura for menor que 15, "Agradável" se estiver entre 15 e 25, e "Quente" caso contrário.
    1. Crie uma variável nota com o valor 9.5. Crie um bloco if-elif-else para imprimir "Excelente" se a nota for maior ou igual a 9, "Muito bom" se estiver entre 7 e 8.9, e "Suficiente" caso contrário.
    1. Crie uma variável preco com o valor 90. Crie um bloco if-elif-else para imprimir "Desconto alto" se o preço for maior que 100, "Desconto médio" se estiver entre 50 e 100, e "Sem desconto" caso contrário.
    1. Crie uma variável idade com o valor 70. Crie um bloco if-elif-else para imprimir "Idoso" se a idade for maior ou igual a 65, "Adulto" se estiver entre 18 e 64, e "Jovem" caso contrário.
    1. Crie uma variável salario com o valor 4000. Crie um bloco if-elif-else para imprimir "Classe alta" se o salário for maior que 3000, "Classe média" se estiver entre 1500 e 3000, e "Classe baixa" caso contrário.
    1. Crie uma variável x com o valor 8. Crie um bloco if-elif-else para imprimir "Múltiplo de 2" se x for divisível por 2, "Múltiplo de 4" se x for divisível por 4, e "Não é múltiplo" caso contrário.
    1. Crie uma variável nome com o valor "Pedro". Imprima "Bem-vindo Pedro" se o nome for "Pedro", "Nome começando com P" se começar com "P", e "Nome diferente" caso contrário.
    1. Crie uma variável dia com o valor 10. Crie um bloco if-elif-else para imprimir "Início do mês" se o dia for menor ou igual a 10, "Meio do mês" se estiver entre 11 e 20, e "Fim do mês" caso contrário.
    1. Crie uma variável idade com o valor 45. Crie um bloco if-elif-else para imprimir "Meia-idade" se a idade for entre 40 e 60, "Adulto" se estiver entre 20 e 39, e "Jovem" caso contrário.
    1. Crie uma variável velocidade com o valor 90. Crie um bloco if-elif-else para imprimir "Velocidade alta" se a velocidade for maior que 80, "Velocidade média" se estiver entre 50 e 80, e "Velocidade baixa" caso contrário.
    1. Crie uma variável ponto com o valor 10. Crie um bloco if-elif-else para imprimir "Nota máxima" se o ponto for igual a 10, "Nota alta" se estiver entre 7 e 9, e "Nota baixa" caso contrário.
    1. Crie uma variável altura com o valor 1.90. Crie um bloco if-elif-else para imprimir "Muito alto" se a altura for maior que 1.85, "Médio" se estiver entre 1.60 e 1.85, e "Baixo" caso contrário.
    1. Crie uma variável preco com o valor 200. Crie um bloco if-elif-else para imprimir "Caro" se o preço for maior que 150, "Médio" se estiver entre 100 e 150, e "Barato" caso contrário.
    1. Crie uma variável tempo com o valor 60. Crie um bloco if-elif-else para imprimir "Tempo curto" se o tempo for menor que 30, "Tempo médio" se estiver entre 30 e 60, e "Tempo longo" caso contrário.
    1. Crie uma variável senha com o valor "12345". Crie um bloco if-elif-else para imprimir "Senha correta" se a senha for "12345", "Senha curta" se tiver menos de 6 caracteres, e "Senha incorreta" caso contrário.
    1. Crie uma variável percentual com o valor 85. Crie um bloco if-elif-else para imprimir "Excelente" se o percentual for maior ou igual a 90, "Bom" se estiver entre 70 e 89, e "Regular" caso contrário.
    1. Crie uma variável x com o valor 2. Crie um bloco if-elif-else para imprimir "Número primo" se x for 2 ou 3, "Número par" se for divisível por 2, e "Número ímpar" caso contrário.
    1. Crie uma variável dia com o valor "Quarta-feira". Imprima "Dia útil" se o dia for "Segunda-feira", "Terça-feira", "Quarta-feira", "Quinta-feira", ou "Sexta-feira", e "Fim de semana" caso contrário.
    1. Crie uma variável peso com o valor 65. Crie um bloco if-elif-else para imprimir "Peso normal" se o peso estiver entre 50 e 70, "Abaixo do peso" se for menor que 50, e "Acima do peso" caso contrário.
    1. Crie uma variável sabor com o valor "Chocolate". Imprima "Sabor favorito" se o sabor for "Chocolate", "Sabor agradável" se for "Baunilha", e "Sabor não listado" caso contrário.
    1. Crie uma variável ponto com o valor 45. Crie um bloco if-elif-else para imprimir "Nota alta" se o ponto for maior que 40, "Nota média" se estiver entre 20 e 40, e "Nota baixa" caso contrário.
    1. Crie uma variável status com o valor "ativo". Crie um bloco if-elif-else para imprimir "Ativo" se o status for "ativo", "Inativo" se for "inativo", e "Status desconhecido" caso contrário.
    1. Crie uma variável altura com o valor 1.55. Crie um bloco if-elif-else para imprimir "Baixa" se a altura for menor que 1.60, "Média" se estiver entre 1.60 e 1.75, e "Alta" caso contrário.
    1. Crie uma variável distancia com o valor 15. Crie um bloco if-elif-else para imprimir "Curta" se a distância for menor que 10, "Média" se estiver entre 10 e 20, e "Longa" caso contrário.
    1. Crie uma variável idade com o valor 25. Crie um bloco if-elif-else para imprimir "Adulto jovem" se a idade for entre 20 e 30, "Adulto" se estiver entre 31 e 50, e "Meia-idade" caso contrário.
    1. Crie uma variável quantidade com o valor 12. Crie um bloco if-elif-else para imprimir "Quantidade alta" se a quantidade for maior que 15, "Quantidade média" se estiver entre 5 e 15, e "Quantidade baixa" caso contrário.
    1. Crie uma variável temp com o valor 5. Crie um bloco if-elif-else para imprimir "Muito frio" se a temperatura for menor que 10, "Agradável" se estiver entre 10 e 25, e "Quente" caso contrário.
</details>


# revisao-parte-2.md

# revisão

## contador e acumulador

Acumuladores e contadores são muito comuns em estruturas de repetição.

- **contador** é usado para realizar uma determinada contagem na repetição;
- **acumulador** é usado para realizar uma operação onde os valores se acumulam ao longo das repetições;

```python
# declarando as variáveis antes do loop while
contador = 0  # via de regra se inicia em 0, mas não é obrigatório
acumulador = 0  # aqui, terá o comportamento de somar a cada repetição
controlador = 10  # usada para controlar a quando a condição no while será falsa

while controlador < 43:
    # mostra cada valor em cada repetição
    print(f'{contador = }')
    print(f'{acumulador = }')
    print(f'{controlador = }\n')

    // incrementa o acumulador com o valor do contador
    acumulador = acumulador + controlador

    // incrementa o controlador
    controlador = controlador + 3

    // aumenta o contador em 1
    contador = contador + 1

print(f'o while repetiu {contador}x')
print(f'o acumulador somou {acumulador}.')
```

## iterando sobre uma lista

Há diversas formas de se iterar (passar por cada element) sobre uma lista.

Quando se usa o loop `while`, é preciso manualmente definir uma variável de controle de suas repetições. Se é preciso que ele passe por uma lista de 4 palavras (como no exemplo abaixo), então é comum usar uma variável de índice (chamada de `indice` ou apenas `i`) para que, ao mesmo tempo que é usada como condição de parada do `while`, é usada para passar por todos os elementos da lista.

Quando se usa o loop `for`, ele precisa que uma variável seja especificada. Essa variável irá, a cada repetição, receber um valor da lista. Sempre o seguinte. Ele faz isso automaticamente a cada repetição. Dessa forma, torna-se desnecessário criar uma variável de controle, pois o `for` controla quando o final do iterável é atingido.

Entende-se por iterável no Python qualquer tipo de variável onde seja possível passar por seus subelementos individualmente.

```python
lista_palavras = ['uma', 'dois', 'tres', 'quatro']

print('for loop')
for uma_palavra in lista_palavras:
    print(f'{uma_palavra = }')

print('\nwhile loop')
i = 0
while i < len(lista_palavras):
    uma_palavra = lista_palavras[i]
    print(f'{uma_palavra = }')
    i = i + 1
```

Eventualmente, pode ser necessário que o loop seja repetido infinitamente. Então, pode-se usar um `True` na sua condição, mas é necessário que seja criada uma forma de interromper a repetição. No exemplo abaixo, enquando a resposta não for igual a `sim`, a repetição irá acontecer indefinidamente.

```python
sair = False
while not sair:
    resposta = input('quer sair ?')
    if resposta == 'sim':
        sair = True
```

## formas de mostrar o valor das variáveis

Existem várias formas de mostrar o valor de uma variável.
No exemplo abaixo, as formas 1 e 2 são as mais antigas.
- a forma 1, apesar de funcionar perfeitamente, ela não permite muita formatação na hora de exibir o valor de suas variáveis, além de deixar a leitura do código mais complicada, por conta de todas as vírgulas e aspas necessárias entre as strings e variáveis.
- a forma 2, apesar de ainda funcionar, não é mais usada.
- a forma 3 já permite uma maior flexibilidade na hora de exibir os valores das variáveis.
- a forma 4 é a mais moderna de todas. Ela permite uma leitura muito mais fluída do código, além de facilitar saber que variável está indo aonde.

```python
v1 = 10
v2 = 12
v3 = 15

print('v1 =',v1,'\nv2 =',v2,'\nv3 =',v3)  # forma 1
print()
print('v1 = %d\nv2 = %d\nv3 = %d' % (v1,v2,v3))  # forma 2
print()
print('v1 = {}\nv2 = {}\nv3 = {}'.format(v1,v2,v3))  # forma 3
print()
print(f'v1 = {v1}\nv2 = {v2}\nv3 = {v3}')  # forma 4
```

## índices nas strings

As strings nada mais são que agrupamentos de letras (caracteres). Então, é possível iterar sobre elas de modo a obter seus caracteres individualmente.

```python
# posicoes na string
#            01234567890123
sobrenome = 'Schwarzenegger'
i = 0

while i < len(sobrenome):
    letra = sobrenome[i]

    if i in (9, 10):
        print(f'{letra = }')
    else:
        print('nao sei')

    i = i + 1
```


# tipo-dicionario.md

Índice

1. [características](#características)
1. [criando dicionários](#criando-dicionários)
1. [adicionando itens ao dicionário](#adicionando-itens-ao-dicionário)
1. [métodos](#métodos)
    1. [dict.keys()](#dictkeys)
    1. [dict.values()](#dictvalues)
    1. [dict.items()](#dictitems)
1. [exercícios](#exercícios)

# tipo dicionário

Um dicionário em Python é uma estrutura de dados que armazena pares de chave-valor, onde cada chave é única e mapeia para um valor. Essa estrutura é semelhante a um mapa ou tabela de associação, onde a chave atua como um identificador que permite acessar seu valor correspondente de forma rápida e eficiente.

## características

1. **pares chave-valor** : cada elemento em um dicionário é composto por uma chave e um valor associados. Por exemplo, em `{'nome': 'João', 'idade': 25}`, `'nome'` e `'idade'` são chaves, enquanto `'João'` e `25` são os valores associados a essas chaves;

2. **chaves únicas** : as chaves em um dicionário devem ser únicas. Se você tentar adicionar uma chave que já existe, o valor associado a essa chave será sobrescrito;

3. **ordem de inserção** : a partir do Python 3.7, os dicionários mantêm a ordem de inserção dos itens. Isso significa que ao iterar sobre um dicionário, os pares chave-valor aparecerão na ordem em que foram adicionados;

4. **mutabilidade** : os dicionários são mutáveis, ou seja, é possível adicionar, remover ou modificar pares chave-valor após a criação do dicionário;

5. **tipagem mista** : tanto as chaves quanto os valores em um dicionário podem ser de qualquer tipo de dado, desde que as chaves sejam de um tipo imutável (como strings, números ou tuplas). Os valores podem ser de qualquer tipo, incluindo listas, outros dicionários ou até mesmo funções;

## criando dicionários

### criação de um dicionário simples
```python
# criando um dicionário simples
aluno = {
    'nome': 'Maria',
    'idade': 22,
    'curso': 'Engenharia'
}

# acessando valores através das chaves
print(aluno['nome'])   # saída : Maria
print(aluno['idade'])  # saída : 22
```

- **chaves** : no exemplo acima, `'nome'`, `'idade'` e `'curso'` são as chaves. Elas são usadas para identificar cada valor armazenado no dicionário;
- **valores** : `'Maria'`, `22` e `'Engenharia'` são os valores correspondentes às chaves;

### chaves de diferentes tipos
```python
# dicionário com chaves de diferentes tipos
informacoes = {
    'nome': 'Carlos',
    1: [2, 4, 8],
    (3, 4): 'tupla como chave'
}

print(informacoes['nome'])   # saída : Carlos
print(informacoes[1])        # saída : [2, 4, 8]
print(informacoes[(3, 4)])   # saída : tupla como chave
```

Neste exemplo:
- A chave `'nome'` é uma string;
- A chave `1` é um número inteiro;
- A chave `(3, 4)` é uma tupla;

### sobrescrita de valores
```python
# dicionário simples
dados = {
    'cidade': 'São Paulo',
    'populacao': 12000000
}

# sobrescrevendo o valor associado à chave 'populacao'
dados['populacao'] = 12300000

print(dados['populacao'])  # saída : 12300000
```

Neste caso, o valor associado à chave `'populacao'` foi atualizado de `12000000` para `12300000`.

## adicionando itens ao dicionário

Adicionar itens a um dicionário em Python é um processo simples e pode ser feito de várias maneiras.

### utilizando a notação de colchetes

A maneira mais comum de adicionar um item a um dicionário é utilizando a notação de colchetes. Uma nova chave é especificada entre colchetes e atribuida a ela um valor. Se a chave já existir, o valor associado a essa chave será atualizado; se a chave não existir, um novo par chave-valor será adicionado ao dicionário.

```python
# dicionário inicial
dados = {
    'nome': 'Ana',
    'idade': 30
}

# adicionando um novo item
dados['cidade'] = 'Rio de Janeiro'

print(dados)
# saída: {'nome': 'Ana', 'idade': 30, 'cidade': 'Rio de Janeiro'}
```

Neste exemplo:
- Adicionamos a chave `'cidade'` com o valor `'Rio de Janeiro'` ao dicionário `dados`.

### adicionando itens dentro de um loop

Também é possível adicionar itens a um dicionário dentro de um loop, o que é útil quando se está processando uma lista de dados ou precisa construir um dicionário dinamicamente.

```python
# lista de dados
nomes = ['João', 'Maria', 'José']
idades = [25, 22, 30]

# dicionário inicial vazio
dados = {}

# populando o dicionário dentro de um loop
for i in range(len(nomes)):
    dados[nomes[i]] = idades[i]

print(dados)
# Saída: {'João': 25, 'Maria': 22, 'José': 30}
```

Neste exemplo:
- Usamos um loop para adicionar os nomes como chaves e as idades como valores ao dicionário `dados`.

### adicionar itens usando compreensão de dicionários

A compreensão de dicionários é uma maneira concisa de criar e adicionar itens a um dicionário em uma única linha de código, especialmente quando se está transformando ou filtrando dados.

```python
# Lista de dados
nomes = ['Ana', 'Bruno', 'Clara']
idades = [23, 31, 29]

# Usando compreensão de dicionários
dados = {nomes[i]: idades[i] for i in range(len(nomes))}

print(dados)
# Saída: {'Ana': 23, 'Bruno': 31, 'Clara': 29}
```

Neste exemplo:
- Criamos o dicionário `dados` utilizando compreensão de dicionários, onde as chaves são os nomes e os valores são as idades.

## métodos

Os métodos `keys()`, `values()` e `items()` dos dicionários em Python são utilizados para acessar diferentes partes do dicionário de forma organizada e eficiente. Esses métodos são muito úteis quando se precisa iterar sobre as chaves, valores ou pares chave-valor de um dicionário.

### `dict.keys()`

O método `keys()` retorna uma visão (`view`) das chaves do dicionário. Essa visão é um objeto especial que reflete as chaves atuais do dicionário e pode ser usada para iterar sobre elas. Se o dicionário for modificado (por exemplo, se novas chaves forem adicionadas ou removidas), a visão retornada por `keys()` será automaticamente atualizada.

```python
# dicionário exemplo
dados = {
    'nome': 'Alice',
    'idade': 27,
    'cidade': 'Brasília'
}

# usando keys() para obter as chaves
chaves = dados.keys()

print(chaves)
# Saída: dict_keys(['nome', 'idade', 'cidade'])

# iterando sobre as chaves
for chave in chaves:
    print(chave)
# Saída:
# nome
# idade
# cidade
```

Neste exemplo:
- `keys()` retorna um objeto `dict_keys`, que é uma visão das chaves do dicionário.
- Podemos iterar sobre esse objeto para acessar cada chave.

### `dict.values()`

O método `values()` retorna uma visão dos valores contidos no dicionário. Assim como o `keys()`, a visão retornada por `values()` reflete qualquer modificação feita no dicionário, mantendo os valores atualizados.

```python
# dicionário exemplo
dados = {
    'nome': 'Roberto',
    'idade': 34,
    'cidade': 'Salvador'
}

# Usando values() para obter os valores
valores = dados.values()

print(valores)
# Saída: dict_values(['Roberto', 34, 'Salvador'])

# Iterando sobre os valores
for valor in valores:
    print(valor)
# Saída:
# Roberto
# 34
# Salvador
```

Neste exemplo:
- `values()` retorna um objeto `dict_values`, que é uma visão dos valores do dicionário.
- Podemos iterar sobre esse objeto para acessar cada valor armazenado no dicionário.

### `dict.items()`

O método `items()` retorna uma visão dos pares chave-valor do dicionário, onde cada item é representado por uma tupla. Essa tupla contém a chave como o primeiro elemento e o valor associado como o segundo. Assim como nos outros métodos, a visão retornada por `items()` é dinâmica e reflete qualquer modificação feita no dicionário.

```python
# dicionário exemplo
dados = {
    'nome': 'Lucas',
    'idade': 21,
    'cidade': 'Fortaleza'
}

# Usando items() para obter os pares chave-valor
pares = dados.items()

print(pares)
# Saída: dict_items([('nome', 'Lucas'), ('idade', 21), ('cidade', 'Fortaleza')])

# Iterando sobre os pares chave-valor
for chave, valor in pares:
    print(f'{chave}: {valor}')
# Saída:
# nome: Lucas
# idade: 21
# cidade: Fortaleza
```

Neste exemplo:
- `items()` retorna um objeto `dict_items`, que é uma visão dos pares chave-valor do dicionário.
- Podemos iterar sobre esse objeto, onde cada iteração nos dá uma tupla contendo a chave e seu valor associado.

### comparação entre os métodos

| Método     | O que retorna                      | Exemplo de Uso                              |
|------------|------------------------------------|---------------------------------------------|
| `keys()`   | Visão (`dict_keys`) das chaves     | Iterar sobre as chaves ou verificar sua existência |
| `values()` | Visão (`dict_values`) dos valores  | Iterar sobre os valores ou manipular diretamente os dados armazenados |
| `items()`  | Visão (`dict_items`) dos pares chave-valor | Iterar sobre pares chave-valor para operações que envolvem tanto a chave quanto o valor |

## execícios

<details>
<sumamry>Lista de Exercícios</sumamry>

1. Criação e Modificação de Dicionários
    1. **Crie um dicionário** chamado `produto` com as chaves `'nome'`, `'preco'` e `'quantidade'`, atribuindo valores de sua escolha a essas chaves.
    1. **Altere o valor** da chave `'preco'` do dicionário `produto` para um novo valor.
    1. **Adicione uma nova chave** `'categoria'` ao dicionário `produto`, com o valor `'eletrônico'`.
    1. **Remova a chave `'quantidade'`** do dicionário `produto`.
    1. **Crie um dicionário vazio** chamado `aluno` e adicione as chaves `'nome'`, `'idade'` e `'curso'` com valores apropriados.
    1. **Atualize o valor** da chave `'curso'` no dicionário `aluno` para `'Medicina'`.
    1. **Crie um dicionário** chamado `endereco` com as chaves `'rua'`, `'numero'` e `'cidade'`. Altere o valor da chave `'cidade'` para uma nova cidade.
    1. **Crie um dicionário** `carro` com as chaves `'marca'`, `'modelo'`, `'ano'`, e `'cor'`. Adicione a chave `'placa'` com um valor ao dicionário.
    1. **Altere o valor** da chave `'ano'` no dicionário `carro` para o ano atual.
    1. **Crie um dicionário** `pedido` com as chaves `'item'`, `'quantidade'` e `'preco_unitario'`. Adicione uma nova chave `'total'` que multiplica `'quantidade'` por `'preco_unitario'`.
1. Compreensão de Dicionários
    1. **Crie um dicionário** usando compreensão onde as chaves são números de 1 a 5 e os valores são os quadrados desses números.
    1. **Crie um dicionário** usando compreensão onde as chaves são letras de `'a'` a `'e'` e os valores são essas letras em maiúsculo.
    1. **Crie um dicionário** usando compreensão onde as chaves são os primeiros 5 números ímpares e os valores são os cubos desses números.
    1. **Crie um dicionário** usando compreensão onde as chaves são os números de 1 a 10 e os valores são `'par'` ou `'ímpar'`, dependendo do número.
    1. **Crie um dicionário** usando compreensão onde as chaves são os números de 1 a 5 e os valores são strings que descrevem se o número é `'pequeno'`, `'médio'` ou `'grande'` (1-2, 3, 4-5).
    1. **Crie um dicionário** onde as chaves são os nomes de 5 frutas e os valores são os comprimentos desses nomes.
    1. **Crie um dicionário** usando compreensão onde as chaves são os números de 1 a 5 e os valores são as chaves multiplicadas por 10.
    1. **Crie um dicionário** com compreensão onde as chaves são as primeiras 5 letras do alfabeto e os valores são seus respectivos índices (a=1, b=2, etc.).
    1. **Crie um dicionário** onde as chaves são os nomes de 4 cidades e os valores são o número de letras em cada nome.
    1. **Crie um dicionário** onde as chaves são os números de 1 a 10 e os valores são `'positivo'` ou `'negativo'`, dependendo se o número é positivo ou negativo (considerando 1 a 5 como positivos).
1. Métodos `keys()`, `values()` e `items()`
    1. **Crie um dicionário** com três chaves: `'nome'`, `'idade'` e `'cidade'`. Use o método `keys()` para imprimir todas as chaves do dicionário.
    1. **Crie um dicionário** com três chaves: `'produto'`, `'preco'` e `'quantidade'`. Use o método `values()` para imprimir todos os valores do dicionário.
    1. **Crie um dicionário** com três chaves: `'pais'`, `'capital'`, `'populacao'`. Use o método `items()` para imprimir todos os pares chave-valor.
    1. **Crie um dicionário** com cinco pares chave-valor. Use um loop para iterar sobre as chaves do dicionário usando o método `keys()`.
    1. **Crie um dicionário** com cinco pares chave-valor. Use um loop para iterar sobre os valores do dicionário usando o método `values()`.
    1. **Crie um dicionário** com cinco pares chave-valor. Use um loop para iterar sobre os pares chave-valor do dicionário usando o método `items()`.
    1. **Crie um dicionário** com três pares chave-valor. Adicione uma nova chave ao dicionário e observe como o método `keys()` reflete essa alteração.
    1. **Crie um dicionário** com três pares chave-valor. Altere o valor de uma das chaves e observe como o método `values()` reflete essa alteração.
    1. **Crie um dicionário** com três pares chave-valor. Remova uma chave do dicionário e observe como o método `items()` reflete essa alteração.
    1. **Crie um dicionário** com chaves de diferentes tipos (string, número, tupla). Use o método `keys()` para listar as chaves e comente sobre os tipos de dados das chaves.
1. Operações Combinadas
    1. **Crie um dicionário** com três pares chave-valor. Adicione uma nova chave e depois use `items()` para verificar o novo par.
    1. **Crie um dicionário** com cinco pares chave-valor. Use `keys()` para obter as chaves e adicione um novo par chave-valor ao dicionário. Imprima as chaves novamente para verificar a alteração.
    1. **Crie um dicionário** que associa nomes de alunos a suas notas. Adicione uma nova nota para um aluno existente e use `items()` para verificar a alteração.
    1. **Crie um dicionário** com os nomes de três cidades como chaves e suas populações como valores. Use `values()` para calcular a população total.
    1. **Crie um dicionário** com três pares chave-valor. Altere um valor existente e adicione um novo par. Verifique as mudanças usando `items()`.
    1. **Crie um dicionário** com três chaves. Use `keys()` para iterar e alterar os valores associados a essas chaves.
    1. **Crie um dicionário** usando compreensão de dicionários. Use `values()` para verificar os valores gerados.
    1. **Crie um dicionário** onde as chaves são os nomes de alunos e os valores são suas idades. Use `keys()` para imprimir todos os nomes e depois adicione um novo aluno.
    1. **Crie um dicionário** que associa produtos a seus preços. Aumente o preço de cada produto em 10% usando `items()` e um loop.
    1. **Crie um dicionário** onde as chaves são países e os valores são suas capitais. Use `items()` para iterar e imprimir cada país e sua capital no formato "A capital de X é Y".

</details>


# tipo-frozenset.md

Índice

1. [características do frozenset](#características-do-frozenset)
1. [criando um frozenset](#criando-um-frozenset)
1. [operações com frozensets](#operações-com-frozensets)
1. [métodos do frozenset](#métodos-do-frozenset)
    1. [frozenset.copy()](#frozensetcopy)
    1. [frozenset.union()](#frozensetunion)
    1. [frozenset.intersection()](#frozensetintersection)
    1. [frozenset.difference()](#frozensetdifference)
    1. [frozenset.issubset()](#frozensetissubset)
    1. [frozenset.issuperset()](#frozensetissuperset)
    1. [frozenset.isdisjoint()](#frozensetisdisjoint)
1. [aplicações práticas](#aplicações-práticas)
1. [limitações](#limitações)
1. [exercícios](#exercícios)

# `frozenset`

O tipo `frozenset` no Python é uma variação imutável do tipo `set`. Enquanto os conjuntos (`sets`) são coleções de elementos que não permitem duplicatas e cujas ordens não são garantidas, os `frozensets` adicionam a característica de imutabilidade a essa estrutura, tornando os elementos dentro dela impossíveis de serem modificados após sua criação.

## características do `frozenset`

- **imutabilidade** : ao contrário de um `set`, um `frozenset` não pode ser alterado depois de criado. Isso significa que não se pode adicionar, remover ou modificar elementos dentro de um `frozenset` após a sua criação;

- **sem elementos duplicados** : assim como os `sets`, `frozensets` não permitem elementos duplicados. se tentar criar um `frozenset` com elementos repetidos, ele automaticamente removerá as duplicatas;

- **ordenação indefinida** : os elementos dentro de um `frozenset` não têm uma ordem específica. mesmo que os insira em uma determinada ordem, eles podem não ser recuperados nessa mesma ordem;

- **hashable** : como os `frozensets` são imutáveis, eles são hashable. isso significa que um `frozenset` pode ser usado como chave em um dicionário ou como elemento em outro `set`;

## criando um `frozenset`

Pode-se criar um `frozenset` de diferentes maneiras:

1. **a partir de um set ou outro iterável** :
    ```python
    >>> fs = frozenset({1, 2, 3, 4})
    >>> print(fs)
    frozenset({1, 2, 3, 4})
    >>> |
    ```

2. **a partir de uma lista** :
    ```python
    >>> fs = frozenset([1, 2, 3, 3, 4])
    >>> print(fs)
    frozenset({1, 2, 3, 4})
    >>> |
    ```

3. **a partir de uma string** :
    ```python
    >>> fs = frozenset("abracadabra")
    >>> print(fs)
    frozenset({'a', 'r', 'b', 'c', 'd'})
    >>> |
    ```

## operações com `frozensets`

Mesmo sendo imutáveis, ainda pode-se realizar várias operações com `frozensets`, muitas das quais são similares às operações que se pode fazer com `sets`.

- **união (`|`)** :
    Combina todos os elementos de dois `frozensets` sem duplicação.
    ```python
    >>> fs1 = frozenset({1, 2, 3})
    >>> fs2 = frozenset({3, 4, 5})
    >>> fs3 = fs1 | fs2
    >>> print(fs3)
    frozenset({1, 2, 3, 4, 5})
    >>> |
    ```

- **interseção (`&`)** :
    Retorna apenas os elementos que estão presentes em ambos os `frozensets`.
    ```python
    >>> fs1 = frozenset({1, 2, 3})
    >>> fs2 = frozenset({2, 3, 4})
    >>> fs3 = fs1 & fs2
    >>> print(fs3)
    frozenset({2, 3})
    >>> |
    ```

- **diferença (`-`)** :
    Retorna os elementos que estão no primeiro `frozenset`, mas não no segundo.
    ```python
    >>> fs1 = frozenset({1, 2, 3})
    >>> fs2 = frozenset({2, 3, 4})
    >>> fs3 = fs1 - fs2
    >>> print(fs3)
    frozenset({1})
    >>> |
    ```

- **diferença simétrica (`^`)** :
    Retorna os elementos que estão em um `frozenset` ou no outro, mas não em ambos.
    ```python
    >>> fs1 = frozenset({1, 2, 3})
    >>> fs2 = frozenset({2, 3, 4})
    >>> fs3 = fs1 ^ fs2
    >>> print(fs3)
    frozenset({1, 4})
    >>> |
    ```

## métodos do frozenset

Apesar de sua imutabilidade, `frozensets` ainda possuem alguns métodos úteis, tais como:

### `frozenset.copy()`

Retorna uma cópia do `frozenset`.
```python
>>> fs = frozenset({1, 2, 3})
>>> fs_copy = fs.copy()
>>> print(fs_copy)
frozenset({1, 2, 3})
>>> |
```

### `frozenset.union()`

Retorna a união com outros `sets` ou `frozensets`.
```python
>>> fs1 = frozenset({1, 2, 3})
>>> fs2 = frozenset({3, 4, 5})
>>> fs3 = fs1.union(fs2)
>>> print(fs3)
frozenset({1, 2, 3, 4, 5})
>>> |
```

### `frozenset.intersection()`

Retorna a interseção com outros `sets` ou `frozensets`.
```python
>>> fs1 = frozenset({1, 2, 3})
>>> fs2 = frozenset({2, 3, 4})
>>> fs3 = fs1.intersection(fs2)
>>> print(fs3)
frozenset({2, 3})
>>> |
```

### `frozenset.difference()`

Retorna a diferença com outros `sets` ou `frozensets`.
```python
>>> fs1 = frozenset({1, 2, 3})
>>> fs2 = frozenset({2, 3, 4})
>>> fs3 = fs1.difference(fs2)
>>> print(fs3)
frozenset({1})
>>> |
```

### `frozenset.issubset()`

Verifica se o `frozenset` é um subconjunto de outro.
```python
>>> fs1 = frozenset({1, 2})
>>> fs2 = frozenset({1, 2, 3})
>>> print(fs1.issubset(fs2))
True
>>> |
```

### `frozenset.issuperset()`

Verifica se o `frozenset` é um superconjunto de outro.
```python
>>> fs1 = frozenset({1, 2, 3})
>>> fs2 = frozenset({1, 2})
>>> print(fs1.issuperset(fs2))
True
>>> |
```

### `frozenset.isdisjoint()`

Verifica se dois `frozensets` não têm elementos em comum.
```python
>>> fs1 = frozenset({1, 2})
>>> fs2 = frozenset({3, 4})
>>> print(fs1.isdisjoint(fs2))
True
>>> |
```

## aplicações práticas

- **uso como chaves de dicionário** : como `frozensets` são imutáveis e hashable, eles podem ser usados como chaves de dicionários, ao contrário de `sets` comuns.
    ```python
    >>> my_dict = {}
    >>> fs = frozenset({1, 2, 3})
    >>> my_dict[fs] = "valor associado ao frozenset"
    >>> print(my_dict)
    {frozenset({1, 2, 3}): 'valor associado ao frozenset'}
    >>> |
    ```

- **operações que requerem imutabilidade** : sempre que precisa garantir que um conjunto de valores não será alterado, um `frozenset` é uma escolha ideal.

## limitações

Devido à imutabilidade, métodos como `add()`, `remove()`, `pop()`, e outros que alterariam um conjunto não estão disponíveis para `frozensets`.

## exercícios

<details>
<summary>Lista de Exercícios</summary>

1. Exercícios Básicos
    1. **Criando um `frozenset`**: Crie um `frozenset` a partir de uma lista de números `[1, 2, 3, 4, 5]` e imprima-o.
    1. **Eliminando duplicatas**: Crie um `frozenset` a partir da lista `[1, 2, 2, 3, 4, 4, 5]` e mostre o resultado.
    1. **Conversão de string para `frozenset`**: Converta a string `"abracadabra"` em um `frozenset` e imprima-o.
    1. **Verificação de imutabilidade**: Tente adicionar um novo elemento ao `frozenset` `{1, 2, 3}` e observe o que acontece.
    1. **Comparando `sets` e `frozensets`**: Crie um `set` e um `frozenset` com os mesmos elementos e verifique se são iguais.
1. Operações com `frozensets`
    1. **União de `frozensets`**: Crie dois `frozensets`, `{1, 2, 3}` e `{3, 4, 5}`, e faça a união entre eles.
    1. **Interseção de `frozensets`**: Crie dois `frozensets`, `{1, 2, 3}` e `{2, 3, 4}`, e encontre a interseção entre eles.
    1. **Diferença entre `frozensets`**: Crie dois `frozensets`, `{1, 2, 3}` e `{3, 4, 5}`, e calcule a diferença entre eles (`fs1 - fs2`).
    1. **Diferença simétrica**: Crie dois `frozensets`, `{1, 2, 3}` e `{2, 3, 4}`, e calcule a diferença simétrica entre eles.
    1. **União de vários `frozensets`**: Crie três `frozensets`, `{1, 2}`, `{2, 3}` e `{3, 4}`, e faça a união de todos.
1. Verificação e Comparação
    1. **Verificando subconjunto**: Verifique se o `frozenset` `{1, 2}` é um subconjunto de `{1, 2, 3}`.
    1. **Verificando superconjunto**: Verifique se o `frozenset` `{1, 2, 3}` é um superconjunto de `{1, 2}`.
    1. **Conjuntos disjuntos**: Verifique se os `frozensets` `{1, 2}` e `{3, 4}` são disjuntos.
    1. **Comparação de `frozensets`**: Compare os `frozensets` `{1, 2, 3}` e `{3, 2, 1}` e verifique se são iguais.
    1. **Verificando existência de elemento**: Verifique se o número `3` está presente no `frozenset` `{1, 2, 3, 4}`.
1. Aplicações Práticas
    1. **Usando `frozenset` como chave de dicionário**: Crie um dicionário onde as chaves são `frozensets` e os valores são strings. Atribua o valor `"grupo1"` para a chave `frozenset({1, 2, 3})`.
    1. **Criando um `frozenset` a partir de uma lista de tuplas**: Converta uma lista de tuplas `[(1, 2), (2, 3), (3, 4)]` em um `frozenset`.
    1. **Ordenando elementos de um `frozenset`**: Crie um `frozenset` a partir dos números `[4, 1, 3, 2]` e exiba os elementos em ordem crescente.
    1. **Verificando imutabilidade dentro de uma lista**: Crie uma lista que contém um `frozenset` e tente modificar o `frozenset` dentro da lista. O que acontece?
    1. **Criando `frozensets` a partir de diferentes tipos de dados**: Crie `frozensets` a partir de uma string, uma lista e uma tupla, e compare os resultados.
1. Desafios
    1. **Removendo duplicatas de uma lista de listas**: Suponha que você tem uma lista de listas `[[1, 2], [2, 3], [1, 2]]`. Use `frozensets` para eliminar as listas duplicadas.
    1. **Comparando frozensets com subsets**: Dado dois `frozensets`, `{1, 2, 3}` e `{1, 2}`, verifique se o segundo é subconjunto do primeiro e depois faça a união dos dois.
    1. **Verificação de pertença em dicionário**: Dado um dicionário onde as chaves são `frozensets`, verifique se um `frozenset` específico é uma chave no dicionário.
    1. **Frozenset a partir de outra coleção**: Crie um `frozenset` a partir de um `set` que contém os elementos `{1, 2, 3}`. Depois, tente alterar o `set` original e verifique se o `frozenset` foi afetado.
    1. **Comparação entre diferentes coleções**: Crie um `frozenset`, um `set` e uma lista com os mesmos elementos e verifique como eles se comportam em operações como união, interseção e diferença.
    1. **Trabalhando com caracteres únicos**: Converta a string `"banana"` em um `frozenset` e conte quantos caracteres únicos há.
    1. **Analisando frozensets aninhados**: Crie um `frozenset` que contém outros `frozensets` como elementos. Exiba o resultado e discuta o que você observa.
    1. **Uso de `frozenset` em conjunto com `map`**: Use `map()` para aplicar uma função que retorna o quadrado de cada número em um `frozenset`.
    1. **Conversão e comparação de coleções**: Converta uma lista de números `[1, 2, 3, 4]` para um `frozenset`, e compare-o com outro `frozenset` que você cria diretamente.
    1. **Verificação de imutabilidade em operações**: Crie um `frozenset` e realize operações de união e interseção com outros conjuntos. Verifique se o `frozenset` original foi alterado após essas operações.

</details>



# tipo-lista.md

Índice

1. [manipulando a lista](#manipulando-a-lista)
1. [métodos da lista](#métodos-da-lista)
    1. [list.append()](#listappend)
    1. [list.insert()](#listinsert)
    1. [list.remove()](#listremove)
    1. [list.pop()](#listpop)
1. [string e list](#string-e-list)
1. [exercícios lista](#exercícios-lista)

# lista

Uma lista é uma coleção de itens ordenados e mutáveis. Isso significa que podemos adicionar, remover ou alterar os itens de uma lista após a sua criação. No Python, uma lista é representada por colchetes `[]` e os itens dentro dela são separados por vírgulas. O tipo lista é representado por `list`.

## manipulando a lista

A mainpulação da lista pode ser feita sem usar seus métodos. Veja abaixo algumas formas :

### criando uma lista

Você pode criar uma lista simplesmente colocando uma série de valores entre colchetes.

Veja alguns exemplos de criação de lista :

```python
# criando uma lista de números inteiros
numeros = [1, 2, 3, 4, 5]

# criando uma lista de floats
mais_numeros = [3.14, 2.77, 1.00001]

# criando uma lista de strings
planetas = ["Mercúrio", "Vênus", "Terra", "Marte"]

# criando uma lista mista
misto = [42, 3.14, 'uma string', False, "outra string"]

# criando uma lista com outra variáveis dentro
nome = "Arnold"
valor = 42
lista_mista = [42, nome, 'Schwarzenegger', True, "olá", valor]
```

### acessando itens da lista

Cada item de uma lista tem uma posição (ou índice). No Python, os índices começam em 0. Isso significa que o primeiro item tem índice 0, o segundo item tem índice 1, e assim por diante.

Veja abaixo como fica o acesso :

```python
print('Planeta no índice 0 :', planetas[0])  # saída : Mercúrio
print('Planeta no índice 2 :', planetas[2])  # saída : Terra
print('Número no índice 1 :', numeros[1])  # saída : 2
```

### modificando itens da lista

Como as listas são mutáveis, você pode alterar qualquer item da lista usando o índice:

```python
planetas[2] = 'Saturno'
print(planetas)  # saída : ['Mercúrio', 'Vênus', 'Saturno', 'Marte']
```

## métodos da lista

### `list.append()`

Adiciona um item ao **final** da lista.

```python
planetas.append("Plutão")
print(planetas)  # saída : ['Mercúrio', 'Vênus', 'Saturno', 'Marte', 'Plutão']
```

### `list.insert()`

Adiciona um item em uma posição específica.

```python
# insere a string "Júpiter" no índice 1 da lista
planetas.insert(1, "Júpiter")
print(planetas)  # saída : ['Mercúrio', 'Júpiter', 'Vênus', 'Saturno', 'Marte', 'Plutão']
```

Se for usado um índice maior que o tamanho da lista, então ele será adicionado ao final dela.

```python
planetas.insert(100, "Terra")
print(planetas)  # saída : ['Mercúrio', 'Júpiter', 'Vênus', 'Saturno', 'Marte', 'Plutão', 'Terra']
```

### `list.remove()`

Remove a primeira ocorrência de um item específico.

```python
planetas.remove("Plutão")
print(planetas)  # saída : ['Mercúrio', 'Júpiter', 'Vênus', 'Saturno', 'Marte', 'Terra']
```

Se o item removido não estiver na lista, então irá levantar um erro.

### `list.pop()`

Remove um item pela sua posição (índice) e retorna esse item. Se nenhum índice for fornecido, ele remove o último item.

```python
ultimo = planetas.pop()
print(ultimo)  # saída : "Terra"
print(planetas)  # saída : ['Mercúrio', 'Júpiter', 'Vênus', 'Saturno', 'Marte']

especifico = planetas.pop(2)
print(especifico)  # saída : "Vênus"
print(planetas)  # saída : ['Mercúrio', 'Júpiter', 'Saturno', 'Marte']
```

Se o índice passado não existir, então irá ocorrer um erro.

## string e list

Strings e listas tem algumas características em comum, como ambas serem compostas de mais de um item. Uma string é composta por um ou mais caracteres, tão somente. Enquanto que uma lista é composta por diferentes tipos.

Por conta disso, elas possuem alguns comportamentos em comum.

### juntando e multiplicando listas

Assim como nas strings, o operador `+` é usado para juntar (concatenar) duas listas e o operador `*` é usado para multiplicar o conteúdo de uma lista :

```python
lista1 = [1, 2, 3]
lista2 = [4, 5, 6]
junta = lista1 + lista2
print(junta)  # saída : [1, 2, 3, 4, 5, 6]

multiplica = lista1 * 2
print(multiplica)  # saída : [1, 2, 3, 1, 2, 3]
```

### fatiamento

O fatiamento das listas funcionam exatamente como o fatiamento das strings :

```python
print(planetas[::2])  # saída : ['Mercúrio', 'Terra']
print(planetas[1:])  # saída : ['Vênus', 'Terra', 'Marte']
print(planetas[2:4])  # saída : ['Terra', 'Marte']
print(planetas[:3])  # saída : ['Mercúrio', 'Vênus', 'Terra']
```

## cast de listas

Assim como os outros tipos vistos até agora, o tipo lista também possui uma função capaz de converter outros tipos para lista, embora haja algumas particularidades. Para converter, usa-se a função `list()`.

### `list()`
A função `list()` é o principal built-in usado para converter (ou "castar") outros tipos de dados em listas. Ela aceita qualquer **iterável** como argumento e retorna uma nova lista contendo os elementos desse iterável.

Quando você converte uma string em uma lista, cada caractere da string se torna um elemento separado na lista.

```python
sobrenome = 'Schwarzenegger'
lista = list(sobrenome)
print(lista)  # saída : ['S', 'c', 'h', 'w', 'a', 'r', 'z', 'e', 'n', 'e', 'g', 'g', 'e', 'r']
```

Como os tipos `int`, `float`, `bool` não são iteráveis, não é possível converter para uma lista um objeto sozinho desses tipos.

## exercícios lista

<details>
<summary>Lista de Exercícios</summary>

1. Exercícios Simples
    1. Crie uma lista com três números inteiros e exiba o primeiro elemento.
    1. Crie uma lista com três strings e exiba o último elemento.
    1. Crie uma lista com cinco números decimais e exiba o terceiro elemento.
    1. Crie uma lista com quatro valores booleanos e exiba o segundo elemento.
    1. Crie uma lista com três strings e altere o primeiro elemento para "Python".
1. Exercícios Simples com if-elif-else
    1. Crie uma lista com três números inteiros. Se o primeiro elemento for maior que 10, altere o segundo elemento para 20. Caso contrário, altere o segundo elemento para 5.
        ```python
        numeros = [1, 2, 3]
        # numeros = [100, 2, 3]

        print('numeros :', numeros)

        if numeros[0] > 10:
            numeros[1] = 20
        else:
            numeros[1] = 5

        print('numeros :', numeros)
        ```
    1. Crie uma lista com três strings. Se a lista contiver a string "Python", exiba "Encontrado". Caso contrário, exiba "Não encontrado".
    1. Crie uma lista com cinco números decimais. Se o terceiro elemento for maior que 2.5, altere o último elemento para 0. Caso contrário, altere o primeiro elemento para 1.
        ```python
        lista_dec = [1.1, 1.5, 2.6, 2.1, 5.0]
        indice = 0

        print(lista_dec)

        if lista_dec[2] > 2.5:
            lista_dec[-1] = 0
        else:
            lista_dec[0] = 1

        print(lista_dec)
        ```
    1. Crie uma lista com quatro valores booleanos. Se o primeiro elemento for True, altere o segundo elemento para False. Caso contrário, altere o terceiro elemento para True.
    1. Crie uma lista com três strings. Se a lista não contiver a string "Hello", adicione "Hello" no final da lista. Caso contrário, remova o último elemento.
1. Exercícios Intermediários
    1. Crie uma lista com seis números inteiros e exiba a quantidade de elementos na lista.
    1. Crie uma lista com cinco strings e exiba a string no índice 2.
    1. Crie uma lista com sete números decimais e insira o número 3.14 no índice 4.
    1. Crie uma lista com quatro valores booleanos e remova o terceiro elemento.
    1. Crie uma lista com três números inteiros e adicione o número 7 no final da lista.
1. Exercícios Intermediários com if-elif-else
    1. Crie uma lista com seis números inteiros. Se o comprimento da lista for maior que 5, exiba o primeiro e o último elemento. Caso contrário, exiba "Lista pequena".
    1. Crie uma lista com cinco strings. Se a lista contiver a string "Python", altere o último elemento para "Coding". Caso contrário, adicione "Learning" no final da lista.
    1. Crie uma lista com sete números decimais. Se o quarto elemento for maior que 1.5, remova o primeiro elemento. Caso contrário, insira o número 0 no início da lista.
    1. Crie uma lista com quatro valores booleanos. Se a lista contiver o valor True, exiba "True encontrado". Caso contrário, exiba "Nenhum True".
    1. Crie uma lista com três números inteiros. Se a soma dos elementos for maior que 20, adicione o número 5 no final da lista. Caso contrário, remova o último elemento.
1. Exercícios Avançados
    1. Crie uma lista com cinco números inteiros e troque o primeiro e o último elemento de lugar.
    1. Crie uma lista com quatro strings e adicione uma nova string na segunda posição.
    1. Crie uma lista com seis números decimais e remova o número no índice 3.
    1. Crie uma lista com três valores booleanos e adicione o valor True no início da lista.
    1. Crie uma lista com cinco números inteiros e insira o número 10 na penúltima posição.
1. Exercícios Avançados com if-elif-else
    1. Crie uma lista com cinco números inteiros. Se a lista contiver o número 5, remova-o. Caso contrário, adicione o número 5 no final da lista.
    1. Crie uma lista com quatro strings. Se o segundo elemento for "Python", altere o terceiro elemento para "Programação". Caso contrário, insira "Estudo" na terceira posição.
    1. Crie uma lista com seis números decimais. Se a soma dos elementos for maior que 10, remova o último elemento. Caso contrário, adicione o número 1.1 no início da lista.
    1. Crie uma lista com três valores booleanos. Se a lista contiver dois valores True, altere o último elemento para False. Caso contrário, adicione True no final da lista.
    1. Crie uma lista com quatro números inteiros. Se o comprimento da lista for igual a 4, exiba o segundo e o terceiro elemento. Caso contrário, exiba "Lista incorreta".
1. Exercícios Complexos
    1. Crie uma lista com cinco números inteiros e substitua todos os números pares por zero.
    1. Crie uma lista com quatro strings e converta todas as strings para maiúsculas.
    1. Crie uma lista com seis números decimais e insira o número 2.5 após cada número maior que 2.
    1. Crie uma lista com três valores booleanos e adicione um valor booleano alternado após cada elemento.
    1. Crie uma lista com cinco números inteiros e remova todos os números ímpares.
1. Exercícios Complexos com if-elif-else
    1. Crie uma lista com cinco números inteiros. Se todos os números forem positivos, substitua o último número por -1. Caso contrário, adicione -1 no final da lista.
    1. Crie uma lista com quatro strings. Se a lista contiver a string "Python", altere todas as strings para "Code". Caso contrário, adicione "Python" no final da lista.
    1. Crie uma lista com seis números decimais. Se a média dos números for maior que 3, remova o primeiro e o último elemento. Caso contrário, adicione 0.5 no início e no final da lista.
    1. Crie uma lista com três valores booleanos. Se a lista contiver dois valores False, altere o primeiro elemento para True. Caso contrário, insira False no início da lista.
    1. Crie uma lista com quatro números inteiros. Se a soma dos elementos for maior que 15, remova o número no índice 2. Caso contrário, insira o número 7 na posição 1.
1. Exercícios Muito Complexos
    1. Crie uma lista com cinco números inteiros e inverta a ordem dos elementos.
    1. Crie uma lista com quatro strings e remova todas as strings que contêm a letra "a".
        ```python
        palavras = ['aula', 'premia', 'sala', 'movel']
        indice = 0

        while indice < len(palavras):

            if 'a' in palavras[indice]:
                palavras.pop(indice)
            else:
                indice = indice + 1

        print('palavras :', palavras)
        ```
    1. Crie uma lista com seis números decimais e insira um número aleatório após cada elemento.
    1. Crie uma lista com três valores booleanos e remova todos os valores False.
    1. Crie uma lista com cinco números inteiros e substitua cada elemento pelo seu quadrado.
1. Exercícios Muito Complexos com if-elif-else
    1. Crie uma lista com cinco números inteiros. Se a lista contiver números negativos, remova todos eles. Caso contrário, adicione -1 no início e no final da lista.
        ```python
        numeros = [1, 4, 6, 8, 10]

        indice = 0

        while indice < len(numeros):
            if numeros[indice] < 0:
                print('numero negativo :', numeros[indice])

                numeros = []

            print('valor do indice :', indice)
            indice = indice + 1

        if len(numeros) > 0:
            numeros.append(-1)
            numeros.insert(0, -1)

        print('a lista ficou :', numeros)
        print('fim do programa')
        ```
    1. Crie uma lista com quatro strings. Se a lista tiver mais de uma string com a letra "e", remova todas essas strings. Caso contrário, adicione "No e" no final da lista.
    1. Crie uma lista com seis números decimais. Se a soma dos números for menor que 10, insira o número 5.5 no meio da lista. Caso contrário, remova o número no meio da lista.
    1. Crie uma lista com três valores booleanos. Se todos os valores forem True, altere o segundo elemento para False. Caso contrário, adicione True no final da lista.
    1. Crie uma lista com quatro números inteiros. Se a soma dos elementos for maior que 20, remova todos os números pares. Caso contrário, adicione 2 após cada número ímpar.

</details>


# tipo-none.md

# tipo none

O tipo `None` em Python é um tipo de dado especial que representa a ausência de valor ou um valor nulo. Ele é usado em várias situações para indicar que algo está "vazio", "não definido" ou "não possui valor". Em Python, o valor `None` é único e é uma instância da classe `NoneType`.

## características do `none`:

1. **Singleton** : o `None` é um objeto único no Python. Ou seja, em toda a aplicação, existe apenas uma instância do `None`. Isso significa que se você comparar dois objetos `None` usando `is`, eles sempre serão iguais (`True`), pois ambos apontam para o mesmo objeto na memória;

2. **avaliação booleana** : em uma expressão booleana, `None` é avaliado como `False`. Portanto, se usar `None` em uma estrutura de controle como `if`, ele será considerado como `False`;

3. **Utilização Comum** :
   - **Valores de Retorno de Funções** : uma função que não possui uma declaração explícita de retorno (`return`) retorna `None` por padrão;
   - **Inicialização de Variáveis** : o `None` é frequentemente usado para inicializar variáveis que serão atribuídas posteriormente com valores reais;
   - **Placeholder** : em estruturas de dados, como listas ou dicionários, `None` pode ser usado como um valor temporário até que um valor "real" seja atribuído;

### exemplo de uso:

```python
>>> # função que não retorna nada explicitamente
>>> def minha_funcao():
...     pass
...
>>> resultado = minha_funcao()
>>> print(resultado)
None
>>>
>>> # inicializando uma variável com None
>>> variavel = None
>>> if variavel is None:
...     print("A variável não tem valor atribuído.")
...
>>> # uso de None como placeholder
>>> dados = {"nome": None, "idade": None}
>>> dados["nome"] = "Alice"
>>> dados["idade"] = 30
>>> print(dados)
{'nome': 'Alice', 'idade': 30}
>>> |
```

## comparando `None`:
- **usando `is`** : como `None` é um singleton, a comparação correta para verificar se uma variável é `None` é usando o operador `is`, não `==`. Exemplo:
    ```python
    >>> if variavel is None:
    ...     print("É None")
    ...
    >>> |
    ```



# tipo-set.md

Índice

1. [criando um set](#criando-um-set)
1. [métodos do set](#métodos-do-set)
    1. [set.union()](#setunion)
    1. [set.intersection()](#setintersection)
    1. [set.difference()](#setdifference)
    1. [set.symmetric_difference()](#setsymmetric_difference)
    1. [set.copy()](#setcopy)
    1. [set.issubset()](#setissubset)
    1. [set.issuperset()](#setissuperset)
    1. [set.isdisjoint()](#setisdisjoint)
    1. [set.add()](#setadd)
    1. [set.remove()](#setremove)
    1. [set.discard()](#setdiscard)
1. [cast](#cast)
    1. [convertendo tuplas em set](#1-convertendo-tuplas-em-set)
    1. [convertendo listas em set](#1-convertendo-listas-em-set)
    1. [convertendo strings em set](#1-convertendo-strings-em-set)
1. [exercícios](#exercícios)
1. [operadores do set](#operadores-do-set)
1. [exercícios com operadores](#exercícios-com-operadores)

# `set`

O tipo `set` no Python é uma coleção de elementos únicos e desordenados. Isso significa que ele não permite elementos duplicados e a ordem dos elementos não é garantida. Os `sets` são úteis quando se precisa garantir que uma coleção de itens não contenha duplicatas ou quando precisa realizar operações matemáticas de conjuntos, como união, interseção e diferença.

## criando um `set`
Para criar um `set`, é preciso utilizar as chaves `{}` ou a função `set()` :

```python
>>> meu_set = {1, 2, 3, 4}
>>> outro_set = set([4, 5, 6])
```

## métodos do `set`

Veja abaixo alguns métodos importantes do `set` :

### `set.union()`

O método `union()` retorna um novo `set` que contém todos os elementos presentes em ambos os conjuntos, sem duplicatas :

```python
>>> set1 = {1, 2, 3}
>>> set2 = {3, 4, 5}
>>>
>>> resultado = set1.union(set2)
>>> print(resultado)
{1, 2, 3, 4, 5}
>>> |
```

Aqui, o `union()` combina `set1` e `set2`, resultando em um novo `set` que contém todos os elementos dos dois conjuntos.

### `set.intersection()`

O método `intersection()` retorna um novo `set` contendo apenas os elementos que estão presentes em ambos os conjuntos :

```python
>>> set1 = {1, 2, 3}
>>> set2 = {2, 3, 4}
>>>
>>> resultado = set1.intersection(set2)
>>> print(resultado)
{2, 3}
>>> |
```

No exemplo, `intersection()` retorna um `set` com os elementos comuns entre `set1` e `set2`.

### `set.difference()`

O método `difference()` retorna um novo `set` contendo os elementos que estão no primeiro conjunto, mas não no segundo :

```python
>>> set1 = {1, 2, 3}
>>> set2 = {2, 3, 4}
>>>
>>> resultado = set1.difference(set2)
>>> print(resultado)
{1}
>>> |
```

Aqui, `difference()` retorna os elementos de `set1` que não estão em `set2`.

### `set.symmetric_difference()`

O método `symmetric_difference()` retorna um novo `set` contendo os elementos que estão no primeiro e no segundo conjunto, mas não são comuns entre eles :

```python
>>> set1 = {1, 2, 3}
>>> set2 = {2, 3, 4}
>>>
>>> resultado = set1.symmetric_difference(set2)
>>> print(resultado)
{1, 4}
>>> |
```

Aqui, `symmetric_difference()` retorna os elementos de `set1` e `set2` que não são comuns entre eles.

### `set.add()`

O método `add()` adiciona um elemento ao `set`. Como `sets` não permitem duplicatas, se o elemento já estiver presente, nada acontece :

```python
>>> meu_set = {1, 2, 3}
>>> meu_set.add(4)
>>> print(meu_set)
{1, 2, 3, 4}
>>>
>>> meu_set.add(2)
>>> print(meu_set)
{1, 2, 3, 4}
>>> |
```

Neste exemplo, o número `4` é adicionado ao `set`, mas quando tentamos adicionar `2` novamente, o `set` permanece inalterado.

### `set.remove()`

O método `remove()` remove um elemento específico do `set`. Se o elemento não estiver presente, ele gera um erro (`KeyError`) :

```python
>>> meu_set = {1, 2, 3}
>>> meu_set.remove(2)
>>> print(meu_set)
{1, 3}
>>>
>>> meu_set.remove(5)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 5
>>> |
```

Aqui, `remove(2)` retira o `2` do `set`, mas tentar remover o `5`, que não está no `set`, resulta em um erro.

### `set.discard()`

O método `discard()` também remove um elemento do `set`, mas se o elemento não estiver presente, ele simplesmente não faz nada e não gera erro :

```python
>>> meu_set = {1, 2, 3}
>>> meu_set.discard(2)
>>> print(meu_set)
{1, 3}
>>>
>>> meu_set.discard(5)  # Não gera erro
>>> print(meu_set)
{1, 3}
>>> |
```

No exemplo acima, `discard(2)` remove o `2`, mas quando tentamos `discard(5)`, nada acontece, e o `set` permanece o mesmo.

### `set.copy()`

O método `copy()` cria uma cópia superficial do conjunto, retornando um novo conjunto que contém os mesmos elementos do original. A cópia é independente, ou seja, alterações no conjunto copiado não afetam o conjunto original, e vice-versa:

```python
>>> set1 = {1, 2, 3}
>>>
>>> copia = set1.copy()
>>> print(copia)
{1, 2, 3}
>>>
>>> set1.add(4)
>>> print(set1)
{1, 2, 3, 4}
>>> print(copia)
{1, 2, 3}
>>> |
```

Aqui, `copy()` cria uma cópia de `set1` chamada `copia`. Quando `set1` é modificado com a adição do elemento `4`, a cópia (`copia`) permanece inalterada, demonstrando que são conjuntos distintos.

### `set.issubset()`

O método `issubset()` verifica se todos os elementos de um conjunto estão presentes em outro conjunto. Ele retorna `True` se o conjunto é um subconjunto do conjunto passado como argumento, caso contrário, retorna `False`:

```python
>>> set1 = {1, 2, 3}
>>> set2 = {1, 2, 3, 4, 5}
>>>
>>> resultado = set1.issubset(set2)
>>> print(resultado)
True
>>> |
```

Aqui, `issubset()` retorna `True` porque todos os elementos de `set1` estão presentes em `set2`.

### `set.issuperset()`

O método `issuperset()` verifica se todos os elementos de outro conjunto estão presentes no conjunto. Ele retorna `True` se o conjunto contém todos os elementos do conjunto passado como argumento, caso contrário, retorna `False`:

```python
>>> set1 = {1, 2, 3, 4, 5}
>>> set2 = {1, 2, 3}
>>>
>>> resultado = set1.issuperset(set2)
>>> print(resultado)
True
>>> |
```

Aqui, `issuperset()` retorna `True` porque `set1` contém todos os elementos de `set2`.

### `set.isdisjoint()`

O método `isdisjoint()` verifica se dois conjuntos não possuem nenhum elemento em comum. Ele retorna `True` se os conjuntos não compartilham nenhum elemento, caso contrário, retorna `False`:

```python
>>> set1 = {1, 2, 3}
>>> set2 = {4, 5, 6}
>>>
>>> resultado = set1.isdisjoint(set2)
>>> print(resultado)
True
>>> |
```

Aqui, `isdisjoint()` retorna `True` porque `set1` e `set2` não têm elementos em comum.

## cast

O cast para `set` em Python significa converter outros tipos de coleções (como listas, tuplas e strings) em um `set`. Essa conversão é feita usando a função `set()`. A principal característica do `set` é que ele elimina quaisquer elementos duplicados, pois um `set` só pode conter elementos únicos.

### 1. convertendo tuplas em `set`

Tuplas são coleções ordenadas e imutáveis de elementos. Quando uma tupla é comvertida para um `set`, todos os elementos duplicados são removidos e a ordem dos elementos não é preservada.

```python
>>> minha_tupla = (1, 2, 3, 4, 4, 5)
>>> meu_set = set(minha_tupla)
>>> print(meu_set)
{1, 2, 3, 4, 5}
>>> |
```

Aqui, a tupla `(1, 2, 3, 4, 4, 5)` é convertida em um `set`, e os números duplicados são removidos.

### 2. convertendo listas em `set`

Listas são coleções ordenadas e mutáveis de elementos. Assim como com as tuplas, ao converter uma lista em um `set`, os elementos duplicados são eliminados e a ordem original pode ser perdida.

```python
>>> minha_lista = [1, 2, 2, 3, 4, 5, 5]
>>> meu_set = set(minha_lista)
>>> print(meu_set)
{1, 2, 3, 4, 5}
>>> |

```
Aqui, a lista `[1, 2, 2, 3, 4, 5, 5]` é convertida em um `set`, e os elementos duplicados são removidos.

### 3. convertendo strings em `set`

Strings são sequências de caracteres. Quando uma string é convertida em um `set`, cada caractere da string se torna um elemento do `set`, e os caracteres duplicados são removidos. Como em todos os `sets`, a ordem dos elementos pode mudar.

```python
>>> minha_string = "banana"
>>> meu_set = set(minha_string)
>>> print(meu_set)
{'b', 'n', 'a'}
>>> |
```

Aqui, a string `"banana"` é convertida em um `set`. Como o `set` elimina duplicatas, os caracteres repetidos `a` e `n` aparecem apenas uma vez.

### considerações finais

- **eliminação de duplicatas** : a conversão para `set` é útil quando é preciso remover duplicatas de uma coleção;
- **ordem não garantida** : diferente de listas e tuplas, a ordem dos elementos em um `set` não é preservada após a conversão;
- **imutabilidade das tuplas** : apesar de as tuplas serem imutáveis, quando convertidas em `set`, os elementos se tornam mutáveis no contexto do `set`;

## exercícios

<details>
<summary>Lista de Exercícios</summary>

1. Exercícios de Criação e Conversão
    1. Crie um `set` vazio e adicione os números 1, 2 e 3.
    1. Converta a lista `[1, 2, 3, 4, 4, 5]` em um `set` e imprima o resultado.
    1. Dada a tupla `(5, 6, 7, 8, 8, 9)`, converta-a em um `set` e imprima o resultado.
    1. Converta a string `"programming"` em um `set` e imprima os caracteres únicos.
        ```python
        palavra = 'programming'
        palavra_set = set(palavra)
        print(f'{''.join(list(palavra_set)) = }')
        ```
    1. Crie um `set` a partir da lista `[‘apple’, ‘banana’, ‘orange’, ‘apple’]` e imprima o resultado.
    1. Converta a tupla `(1, 1, 2, 2, 3, 3)` em um `set` e imprima o resultado.
    1. Dada a string `"abracadabra"`, converta-a em um `set` e imprima os caracteres únicos.
        ```python
        palavra = 'abracadabra'
        palavra_set = set(palavra)
        for letra in palavra_set:
            print(f'{letra = }')
        ```
    1. Crie um `set` com os elementos da lista `[10, 20, 30, 40, 50, 50, 60]`.
    1. Converta a string `"hello world"` em um `set` e imprima os caracteres únicos.
    1. Crie um `set` a partir da tupla `(100, 200, 200, 300, 400)` e imprima o resultado.
1. Exercícios com Métodos Básicos
    1. Adicione o número `7` ao `set` `{1, 2, 3}` e imprima o resultado.
    1. Remova o número `2` do `set` `{1, 2, 3}` e imprima o resultado.
    1. Tente remover o número `4` do `set` `{1, 2, 3}` usando `remove()`. O que acontece?
    1. Tente remover o número `4` do `set` `{1, 2, 3}` usando `discard()`. O que acontece?
    1. Adicione os elementos `8, 9, 10` ao `set` `{4, 5, 6, 7}` e imprima o resultado.
    1. Remova todos os elementos de um `set` usando `clear()`.
    1. Verifique se o número `5` está presente no `set` `{1, 2, 3, 4, 5}`.
    1. Crie um `set` e adicione a string `"Python"` como um único elemento.
    1. Remova o último elemento do `set` `{10, 20, 30, 40, 50}` (use `pop()`) e imprima o resultado.
    1. Verifique se o caractere `"a"` está presente no `set` criado a partir da string `"alphabet"`.
1. Exercícios com Operações de Conjunto
    1. Crie dois `sets`, `A = {1, 2, 3}` e `B = {3, 4, 5}`, e calcule a união usando `union()`.
    1. Calcule a interseção dos `sets` `{10, 20, 30}` e `{20, 30, 40}`.
    1. Encontre a diferença entre os `sets` `{100, 200, 300}` e `{200, 300, 400}`.
    1. Crie dois `sets`, `A = {‘apple’, ‘banana’}` e `B = {‘banana’, ‘cherry’}`, e calcule a união.
    1. Encontre a interseção entre os `sets` `{‘a’, ‘b’, ‘c’}` e `{‘b’, ‘c’, ‘d’}`.
    1. Calcule a diferença entre os `sets` `{‘red’, ‘blue’, ‘green’}` e `{‘blue’, ‘yellow’}`.
    1. Crie dois `sets`, `A = {2, 4, 6, 8}` e `B = {1, 2, 3, 4}`, e encontre a interseção.
    1. Encontre a união dos `sets` `{5, 10, 15}` e `{15, 20, 25}`.
    1. Calcule a diferença entre os `sets` `{‘dog’, ‘cat’, ‘fish’}` e `{‘fish’, ‘bird’}`.
    1. Crie dois `sets`, `A = {‘x’, ‘y’, ‘z’}` e `B = {‘y’, ‘z’, ‘w’}`, e calcule a diferença.
1. Exercícios Mistos
    1. Verifique se o `set` `{1, 2, 3}` é subconjunto de `{1, 2, 3, 4, 5}`.
    1. Verifique se o `set` `{‘apple’, ‘banana’}` é subconjunto de `{‘apple’, ‘banana’, ‘cherry’}`.
    1. Verifique se `{1, 2}` e `{3, 4}` são conjuntos disjuntos.
    1. Crie um `set` a partir de uma string que contenha caracteres repetidos, como `"mississippi"`, e imprima os caracteres únicos.
    1. Crie um `set` a partir de uma lista com elementos duplicados e verifique se a quantidade de elementos no `set` é menor que na lista original.
    1. Combine dois `sets` usando o operador `|` (ou a operação `union()`).
    1. Encontre os elementos exclusivos de um `set` em comparação com outro usando a operação de diferença.
    1. Crie dois `sets` com elementos totalmente diferentes e verifique se a interseção é vazia.
    1. Verifique se um `set` é subconjunto de si mesmo.
    1. Tente adicionar um elemento já existente a um `set` e observe o comportamento.
1. Desafios
    1. Crie três `sets` diferentes e calcule a interseção de todos eles.
    1. Crie três `sets` diferentes e calcule a união de todos eles.
    1. Dado um `set` de números de 1 a 10, crie um segundo `set` com os números ímpares e calcule a diferença.
    1. Dado um `set` de palavras, crie um segundo `set` com palavras que começam com uma determinada letra e calcule a interseção.
    1. Crie dois `sets` com diferentes tipos de frutas e calcule a união e a diferença simétrica (usando o operador `^`).
    1. Verifique se a interseção de dois `sets` é vazia, ou seja, se eles são disjuntos.
    1. Dado um `set` com caracteres de uma string, adicione um novo caractere ao `set` e verifique se ele já existia.
    1. Crie um `set` a partir de uma lista de números e verifique quantos elementos únicos existem.
    1. Dado um `set` de letras, remova todas as vogais (se existirem).
    1. Crie um `set` a partir de uma frase e calcule a quantidade de letras distintas, ignorando espaços e pontuação.

</details>

## operadores do set

Os operadores `|`, `&`, `-` e `^` em Python são usados para realizar operações comuns de teoria dos conjuntos em objetos do tipo `set`.

### operador `|` (união)

O operador `|` é utilizado para realizar a **união** de dois conjuntos. A união de dois conjuntos resulta em um novo conjunto contendo todos os elementos que estão em qualquer um dos conjuntos ou em ambos.

```python
>>> set1 = {1, 2, 3}
>>> set2 = {3, 4, 5}
>>>
>>> resultado = set1 | set2
>>> print(resultado)
{1, 2, 3, 4, 5}
>>> |
```

**explicação :** a união entre `set1` e `set2` resulta em um conjunto que contém todos os elementos de ambos os conjuntos. Observe que elementos duplicados são incluídos apenas uma vez;

### operador `&` (interseção)

O operador `&` é utilizado para realizar a **interseção** de dois conjuntos. A interseção de dois conjuntos resulta em um novo conjunto contendo apenas os elementos que estão presentes em ambos os conjuntos.

```python
>>> set1 = {1, 2, 3}
>>> set2 = {3, 4, 5}
>>>
>>> resultado = set1 & set2
>>> print(resultado)
{3}
>>> |
```
**explicação :** a interseção entre `set1` e `set2` resulta em um conjunto que contém apenas o elemento `3`, que é o único presente em ambos os conjuntos;

### operador `-` (diferença)

O operador `-` é utilizado para realizar a **diferença** entre dois conjuntos. A diferença entre dois conjuntos resulta em um novo conjunto contendo os elementos que estão no primeiro conjunto, mas não no segundo.

```python
>>> set1 = {1, 2, 3}
>>> set2 = {3, 4, 5}
>>>
>>> resultado = set1 - set2
>>> print(resultado)
{1, 2}
>>> |
```
**explicação :** a diferença entre `set1` e `set2` resulta em um conjunto que contém os elementos `1` e `2`, que estão em `set1` mas não em `set2`;

### operador `^` (diferença simétrica)

O operador `^` é utilizado para realizar a **diferença simétrica** entre dois conjuntos. A diferença simétrica resulta em um novo conjunto contendo os elementos que estão em um dos conjuntos, mas não em ambos. Em outras palavras, ele exclui os elementos comuns.

```python
>>> set1 = {1, 2, 3}
>>> set2 = {3, 4, 5}
>>>
>>> resultado = set1 ^ set2
>>> print(resultado)
{1, 2, 4, 5}
>>> |
```
**explicação :** a diferença simétrica entre `set1` e `set2` resulta em um conjunto que contém os elementos `1`, `2`, `4` e `5`. Esses são os elementos que estão em apenas um dos conjuntos, mas não em ambos;

### atribuição composta dos operadores

Os operadores `|`, `&`, `-` e `^` em Python possuem versões com atribuição composta, que permitem modificar diretamente o conjunto à esquerda do operador.

#### `|=`

A União com Atribuição Composta combina o conjunto à esquerda com o conjunto à direita, e o resultado é armazenado de volta no conjunto à esquerda.

```python
>>> set1 = {1, 2, 3}
>>> set2 = {3, 4, 5}
>>>
>>> set1 |= set2
>>> print(set1)
{1, 2, 3, 4, 5}
>>> |
```

#### `&=`

A Interseção com Atribuição Composta mantém no conjunto à esquerda apenas os elementos que estão presentes também no conjunto à direita.

```python
>>> set1 = {1, 2, 3}
>>> set2 = {3, 4, 5}
>>>
>>> set1 &= set2
>>> print(set1)
{3}
>>> |
```

#### `-=`

A Diferença com Atribuição Compost remove do conjunto à esquerda todos os elementos que também estão presentes no conjunto à direita.

```python
>>> set1 = {1, 2, 3}
>>> set2 = {3, 4, 5}
>>>
>>> set1 -= set2
>>> print(set1)
{1, 2}
>>> |
```

#### `^=`

A Diferença Simétrica com Atribuição Composta atualiza o conjunto à esquerda com os elementos que estão em apenas um dos conjuntos, excluindo os elementos comuns.

```python
>>> set1 = {1, 2, 3}
>>> set2 = {3, 4, 5}
>>>
>>> set1 ^= set2
>>> print(set1)
{1, 2, 4, 5}
>>> |
```

## exercícios com operadores

<details>
<summary>Lista de Exercícios</summary>

1. **União Básica**: Crie dois conjuntos `set1 = {1, 2, 3}` e `set2 = {3, 4, 5}`. Utilize o operador `|` para encontrar a união dos dois conjuntos.
1. **Interseção Básica**: Crie dois conjuntos `set1 = {1, 2, 3}` e `set2 = {3, 4, 5}`. Utilize o operador `&` para encontrar a interseção dos dois conjuntos.
1. **Diferença Básica**: Crie dois conjuntos `set1 = {1, 2, 3}` e `set2 = {3, 4, 5}`. Utilize o operador `-` para encontrar a diferença entre `set1` e `set2`.
1. **Diferença Simétrica Básica**: Crie dois conjuntos `set1 = {1, 2, 3}` e `set2 = {3, 4, 5}`. Utilize o operador `^` para encontrar a diferença simétrica entre os dois conjuntos.
1. **União com Strings**: Crie dois conjuntos de strings: `set1 = {"apple", "banana", "cherry"}` e `set2 = {"banana", "date", "fig"}`. Utilize o operador `|` para unir os dois conjuntos.
1. **Interseção com Strings**: Usando os mesmos conjuntos do exercício anterior, utilize o operador `&` para encontrar as strings comuns entre `set1` e `set2`.
1. **Diferença com Strings**: Crie dois conjuntos de strings: `set1 = {"dog", "cat", "mouse"}` e `set2 = {"cat", "horse"}`. Utilize o operador `-` para encontrar os elementos que estão em `set1` mas não em `set2`.
1. **Diferença Simétrica com Strings**: Usando os conjuntos do exercício anterior, utilize o operador `^` para encontrar os elementos únicos em cada conjunto.
1. **Operação Combinada**: Crie três conjuntos `A = {1, 2, 3}`, `B = {3, 4, 5}` e `C = {5, 6, 7}`. Encontre a união dos conjuntos `A` e `B`, e depois calcule a diferença com o conjunto `C`.
1. **Interseção Vazia**: Crie dois conjuntos `set1 = {1, 2, 3}` e `set2 = {4, 5, 6}`. Verifique se a interseção entre eles é vazia.
1. **União com Conjuntos de Números Flutuantes**: Crie dois conjuntos de números flutuantes `set1 = {1.1, 2.2, 3.3}` e `set2 = {3.3, 4.4, 5.5}`. Utilize o operador `|` para unir os dois conjuntos.
1. **Interseção com Conjuntos de Números Flutuantes**: Usando os conjuntos do exercício anterior, utilize o operador `&` para encontrar os elementos comuns entre eles.
1. **Diferença entre Conjuntos Vários**: Crie três conjuntos `A = {1, 2, 3, 4}`, `B = {3, 4, 5, 6}` e `C = {5, 6, 7, 8}`. Encontre a diferença entre `A` e a união de `B` e `C`.
1. **Diferença Simétrica com Conjuntos Grandes**: Crie dois conjuntos `A` e `B` com 10 números inteiros aleatórios cada. Utilize o operador `^` para encontrar os elementos únicos em ambos os conjuntos.
1. **Operações Sequenciais**: Crie dois conjuntos `X = {10, 20, 30, 40}` e `Y = {30, 40, 50, 60}`. Primeiro, encontre a interseção entre `X` e `Y`, e depois subtraia essa interseção de `X`.
1. **Combinação de Operadores**: Crie três conjuntos `P = {2, 4, 6, 8}`, `Q = {4, 8, 12, 16}`, e `R = {8, 16, 24, 32}`. Calcule `(P | Q) & R`.
1. **Diferença com Listas Convertidas em Sets**: Converta as listas `list1 = [1, 2, 3, 4]` e `list2 = [3, 4, 5, 6]` em conjuntos, e depois encontre a diferença entre `set1` e `set2`.
1. **Diferença Simétrica de Sets Convertidos de Strings**: Converta as strings `str1 = "hello"` e `str2 = "world"` em conjuntos de caracteres, e utilize o operador `^` para encontrar a diferença simétrica entre os dois conjuntos.
1. **Verificação de Resultados**: Crie dois conjuntos `set1 = {1, 2, 3, 4}` e `set2 = {2, 4, 6, 8}`. Verifique se o resultado de `set1 ^ set2` é igual a `(set1 | set2) - (set1 & set2)`.
1. **União de Sets com Elementos Não Repetidos**: Crie dois conjuntos `set1 = {100, 200, 300}` e `set2 = {300, 400, 500}`. Verifique se a união dos conjuntos é igual a um conjunto criado manualmente `{100, 200, 300, 400, 500}`.

</details>


# tipo-string.md

Índice

1. [sintaxe](#sintaxe)
1. [caracteres especiais](#caracteres-especiais)
1. [string crua](#string-crua)
1. [string literal](#string-literal)
1. [exercícios - parte 1](#exercícios---parte-1)
1. [concatenando strings](#concatenando-strings)
1. [multiplicando strings](#multiplicando-strings)
1. [indexando strings](#indexando-strings)
1. [dividindo strings](#dividindo-strings)
1. [exercícios - parte 2](#exercícios---parte-2)
<details>
<summary>métodos da string</summary>

1. [str.upper()](#strupper)
1. [str.lower()](#strlower)
1. [str.capitalize()](#strcapitalize)
1. [str.title()](#strtitle)
1. [str.strip()](#strstrip)
1. [str.lstrip()](#strlstrip)
1. [str.rstrip()](#strrstrip)
1. [str.replace()](#strreplace)
1. [str.split()](#strsplit)
1. [str.join()](#strjoin)
1. [str.find()](#strfind)
1. [str.startswith()](#strstartswith)
1. [str.endswith()](#strendswith)
1. [str.isalpha()](#strisalpha)
1. [str.isdigit()](#strisdigit)
1. [str.isalnum()](#strisalnum)
1. [str.isspace()](#strisspace)
1. [str.isupper()](#strisupper)
1. [str.islower()](#strislower)
1. [str.zfill()](#strzfill)
1. [str.center()](#strcenter)
1. [str.ljust()](#strljust)
1. [str.rjust()](#strrjust)
1. [str.partition()](#strpartition)
1. [str.rpartition()](#strrpartition)

</details>

# tipo string

O Python pode manipular texto (representado pelo tipo `str`, também chamado de `strings`), bem como os números. Isso inclui caracteres `!`, palavras `coelho`, nomes `Paris`, frases `Eu te protejo.`, `Oba! :)` etc.. Eles podem ser colocados entre aspas simples `'...'` ou aspas duplas `"..."` com o mesmo resultado.

```python
>>> 'sou um texto'  # aspas simples
'sou um texto'
>>> "sou outro texto"  # aspas duplas
'sou outro texto'
>>> '1984'  # dígitos e números entre aspas também são strings
'1984'
```

## sintaxe

Para colocar aspas entre aspas, precisamos "escapá-la", precedendo-as com `\`. Alternativamente, podemos usar o outro tipo de aspas:

```python
>>> 'The Kids Aren\'t Alright'  # use \' para escapar as aspas simples...
"The Kids Aren't Alright"
>>> "The Kids Aren't Alright"  # ou use aspas duplas
"The Kids Aren't Alright"
>>>
>>> '"pois não", disse o garçom'
'"pois não", disse o garçom'
>>> "\"pois não\", disse o garçom"
'"pois não", disse o garçom'
>>> |
```

No shell do Python, a definição de string e a string de saída podem parecer diferentes. A função `print()` produz uma saída mais legível, omitindo as aspas delimitadoras e imprimindo caracteres de escape e especiais:
```python
>>> texto = 'linha um\nlinha dois'
>>> texto  # sem o print(), caracteres especiais são incluídos na string
'linha um\nlinha dois'
>>> print(texto)  # com o print, os caracteres especiais são interpretados
linha um
linha dois
>>>
```

## caracteres especiais

Os caracteres especiais são uma forma de mandar para a linguagem de programação comandos a serem executados de dentro da string :

- `\n` : é usado quando se quer criar uma nova linha na exibição do texto;
```python
>>> print('linha 1\nlinha 2\nlinha 3\nlinha 4\n')
linha 1
linha 2
linha 3
linha 4

>>> |
```
- `\t` : é usado quando se quer inserir uma tabulação no texto;
```python
>>> print('sem tabulação\n\tuma tabulação\n\t\tduas tabulações\n\t\t\ttrês tabulações')
sem tabulação
    uma tabulação
        duas tabulações
            três tabulações
>>> |
```

## string crua

Se não quiser que os caracteres precedidos por `\` sejam interpretados como caracteres especiais, pode-se usar strings `raw` ("crua" ou sem processamento de caracteres de escape) adicionando um r antes da primeira aspa ou então colocando duas `\\`:

```python
>>> print('C:\nemo')  # aqui \n indica nova linha!
C:
emo
>>> print(r'C:\nemo')  # note o r antes da aspa
C:\nemo
>>> print('c:\nemo\\nemo')  # repare no uso duplo da \\
c:
emo\nemo
>>> |
```

Há um aspecto sutil nas strings raw: uma string raw não pode terminar em um número ímpar de caracteres `\`.

```python
>>> print(r'C:\nemo\\')
C:\nemo\\
>>>
>>> print(r'C:\nemo\\\')
  File "<stdin>", line 1
    print(r'C:\nemo\\\')
          ^
SyntaxError: unterminated string literal (detected at line 1)

# mais exemplos
print('uma tabulação\\tdois')
print('C:\\usuario\\ted')
>>> |
```

## string literal

As strings literais podem abranger várias linhas. Uma maneira é usar as aspas triplas: `"""..."""` ou `'''...'''`. O fim das linhas é incluído automaticamente na string, mas é possível evitar isso adicionando uma `\` no final.
O seguinte exemplo:
```python
>>> print("""\
... Uso: alguma coisa [opcional]
...     -h                      Mostra esta mensagem.
...     -H hostname             Nome do host para conectar.
... """)
Uso: alguma coisa [opcional]
  -h              Mostra esta mensagem.
  -H hostname     Nome do host para conectar.

>>> |
```

```python
>>> print("""sou uma string
... dividida em apenas \
... duas linhas""")
sou uma string
dividida em apenas duas linhas
>>> |
```

## exercícios - parte 1

<details>
<summary>Lista de Exercícios</summary>

1. Exercícios Simples
    1. Crie uma string com seu nome e imprima-a.
    1. Crie uma string com uma citação famosa e imprima-a.
    1. Use aspas duplas para criar uma string e imprima-a.
    1. Use aspas simples para criar uma string e imprima-a.
    1. Crie uma string com aspas dentro dela, usando aspas duplas e simples, e imprima-a.
    1. Crie uma string que contenha uma nova linha (\n) e imprima-a.
    1. Crie uma string que contenha um tab (\t) e imprima-a.
    1. Crie uma string que contenha tanto \n quanto \t e imprima-a.
    1. Crie uma string que contenha barras invertidas (\\) e imprima-a.
    1. Crie uma string usando raw string (prefixo r) e imprima-a.
1. Exercícios de Nível Intermediário
    1. Crie uma string com várias linhas usando \n e imprima-a.
    1. Crie uma string com várias tabs usando \t e imprima-a.
    1. Crie uma string com um caminho de arquivo usando barras invertidas e imprima-a.
    1. Use raw string para criar um caminho de arquivo e imprima-a.
    1. Combine aspas duplas e simples em uma string e imprima-a.
    1. Crie uma string que contenha aspas simples escapadas e imprima-a.
    1. Crie uma string que contenha aspas duplas escapadas e imprima-a.
    1. Crie uma string com uma citação famosa usando raw string e imprima-a.
    1. Crie uma string que contenha um caractere de nova linha escapado (\\n) e imprima-a.
    1. Crie uma string que contenha um caractere de tab escapado (\\t) e imprima-a.
1. Exercícios Avançados
    1. Crie uma string longa usando múltiplas linhas e o caractere \n e imprima-a.
    1. Crie uma string longa usando múltiplas tabs e o caractere \t e imprima-a.
    1. Crie uma string com várias barras invertidas (\\\\) e imprima-a.
    1. Crie uma string que combine várias linhas, tabs e barras invertidas e imprima-a.
    1. Use raw string para criar uma string com várias linhas e tente imprimi-la.
    1. Use raw string para criar uma string com várias tabs e tente imprimí-la.
    1. Use raw string para criar uma string com várias barras invertidas e imprima-a.
    1. Combine aspas duplas, simples e barras invertidas em uma string e imprima-a.
    1. Crie uma string com uma citação famosa que contenha várias linhas e imprima-a.
    1. Crie uma string com um poema que contenha várias tabs e imprima-a.
1. Exercícios Complexos
    1. Crie uma string que represente uma linha de JSON e imprima-a.
    1. Crie uma string que represente uma linha de script HTML e imprima-a.
    1. Crie uma string que contenha CSS com várias linhas e imprima-a.
    1. Crie uma string que contenha código Python com várias linhas e imprima-a.
    1. Crie uma string com uma mensagem que use aspas duplas, simples, \n e \t, e imprima-a.
    1. Crie uma string que represente um caminho de rede e imprima-a.
    1. Crie uma string que contenha uma citação longa com várias linhas e tabs, e imprima-a.
    1. Use raw string para criar uma string com código Python e imprima-a.
    1. Use raw string para criar uma string com script HTML e imprima-a.
    1. Use raw string para criar uma string com CSS e imprima-a.
1. Exercícios Muito Complexos
    1. Crie uma string que contenha um bloco de código JSON com várias linhas e imprima-a.
    1. Crie uma string que contenha um bloco de código HTML com várias linhas e imprima-a.
    1. Crie uma string que contenha um bloco de código CSS com várias linhas e imprima-a.
    1. Crie uma string que contenha um bloco de código Python com várias linhas e imprima-a.
    1. Combine raw string com uma string que contenha um bloco de código Python e imprima-a.
        '''python
        texto = """
        valor = 10
        print(valor)
        """
        print(r'estou na raw string ',texto)
        '''
    1. Combine raw string com uma string que contenha um bloco de código HTML e imprima-a.
    1. Combine raw string com uma string que contenha um bloco de código CSS e imprima-a.
    1. Crie uma string que contenha um caminho de arquivo complexo e imprima-a.
    1. Crie uma string que combine várias técnicas de formatação (raw string, escapamento, \n, \t) e imprima-a.
    1. Crie uma string que contenha um script completo em qualquer linguagem de programação e imprima-a.

</details>

## concatenando strings

As strings podem ser concatenadas (coladas, "somadas") com o operador `+` ou então apenas deixando um espaço entre elas :
```python
>>> 'Py' + 'thon'
'Python'
>>> 'Arnold' + ' ' + 'Schwarzenegger'
'Arnold Schwarzenegger'
>>> 'Arnold' ' ' 'Schwarzenegger'
'Arnold Schwarzenegger'
>>> 'Arnold ' 'Schwarzenegger'
'Arnold Schwarzenegger'
>>> |
```

Concaternar strings com espaço pode ser útil para quebrar uma longa string e várias linhas :
```python
>>> texto = ('Coloque várias strings dentro de parênteses '
...          'para juntá-las em uma.')
>>> texto
'Coloque várias strings dentro de parênteses para juntá-las em uma.'
>>> |
```

Strings literais não podem ser concatenadas com variáveis dessa forma, mesmo elas também sendo strings.
Para isso funcionar, é necessário usar o operador `+`.

Veja exemplos :
```python
>>> # definindo as variáveis
>>> nome = 'Arnold'
>>> sobrenome = 'Schwarzenegger'
```
```python
>>> # mostrando os erros
>>> nome 'Schwarzenegger'
  File "<stdin>", line 1
    nome 'Schwarzenegger'
         ^^^^^^^^^^^^^^^^
SyntaxError: invalid syntax
>>>
>>> print('Arnold' sobrenome)
  File "<stdin>", line 1
    print('Arnold' sobrenome)
          ^^^^^^^^^^^^^^^^^^
SyntaxError: invalid syntax. Perhaps you forgot a comma?
>>>
>>> nome sobrenome
  File "<stdin>", line 1
    nome sobrenome
         ^^^^^^^^^
SyntaxError: invalid syntax
>>>
>>> print(nome sobrenome)
  File "<stdin>", line 1
    print(nome sobrenome)
          ^^^^^^^^^^^^^^
SyntaxError: invalid syntax. Perhaps you forgot a comma?
```
```python
>>> # mostrando como funciona
>>> nome + 'Schwarzenegger'
'ArnoldSchwarzenegger'
>>> print('Arnold' 'Schwarzenegger')
ArnoldSchwarzenegger
>>> print(nome + ' ' + sobrenome)
Arnold Schwarzenegger
>>> |
```

## multiplicando strings

Também é possível usar o operador de multiplicação `*` para manipular as string.

```python
>>> 5 * nome
'ArnoldArnoldArnoldArnoldArnold'
>>> print(25 * '=-' + '=')
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
>>> print(" + " * 20)
 +  +  +  +  +  +  +  +  +  +  +  +  +  +  +  +  +  +  +  +
>>> |
```

## combinando os operadores

É possível usar ambos os operadores de uma vez :
```python
>>> 3 * nome + ' ' +  sobrenome
'ArnoldArnoldArnold Schwarzenegger'
>>> |
```

## indexando strings

Uma string nada mais é do que uma sucessão de caracteres. Diferente dos números, onde o valor 2.147.483.648 corresponde a apenas um valor, uma palavra é composta por diversos caracteres. Por causa disso, é possível *indexar* uma string com o primeiro caractere iniciando em `zero`.

Veja abaixo :
```python
>>> sobrenome = 'Schwarzenegger'
>>> sobrenome[0]  # caractere na posição 0
'S'
>>> sobrenome[5]  # caractere na posição 5
'r'
```

Também é possível usar números negativos e começar a contagem da direita :
```python
>>> sobrenome[-1]
'r'
>>> sobrenome[-2]
'e'
>>> sobrenome[-7]
'e'
>>> |
```

Repare que, como -0 é a mesma coisa que 0, os índices negativos iniciam em `-1`.

## dividindo strings
Além de indexar, as strings também podem ser *divididas*. Enquanto indexar é usado para obter um caractere, dividir permite obter uma substring a partir da original.

Veja abaixo :
```python
>>> sobrenome[0:5]  # caracteres da posição 0 (incluída) até 5 (excluída)
'Schwa'
>>> sobrenome[5:8]  # caracteres da posição 5 (incluída) até 8 (excluída)
'rze'
>>> |
```

Dividir índices tem alguns padrões interessantes. Se o primeiro índice for omitido, o valor padrão é zero. Se o segundo índice é omitido, o tamanho da string é o valor padrão. Veja :
```python
>>> sobrenome[:6]  # caractere iniciado do início até a posição 6 (excluída)
'Schwar'
>>> sobrenome[8:]  # caracteres da posição 8 (incluída) até o final
'enegger'
>>> sobrenome[-3:]  # caracteres da terceira última posição (incluída) até o final
'ger'
>>> |
```

Repare que o índice inicial é sempre incluído e o último é sempre excluído. Isso é feito dessa maneira para que `sobrenome[:i] + sobrenome[i:]` seja **sempre** igual a `sobrenome` :
```python
>>> sobrenome[:6] + sobrenome[6:]
'Schwarzenegger'
>>>
>>> sobrenome[:9] + sobrenome[9:]
'Schwarzenegger'
>>> |
```

Uma forma de lembrar como a divisão de strings funciona é pensar nos índices como ponteiros entre os caracteres, com a margem esquerda so primeiro caractere iniciando em 0. E a margem da direita do último caractere da string de tamanho *n* tem o índice *n*.

Veja um exemplo :
```
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  | S | c | h | w | a | r | z | e | n | e | g | g | e | r |
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14
-14 -13 -12 -11 -10  -9  -8  -7  -6  -5  -4  -3  -2  -1
```
A primeira linha de números mostra a posição dos índices 0..14 da string. A segunda linha mostra os índices negativos correspondentes. A divisão de `i` a `j` consiste em todos os caracteres entre as margens marcadas com `i` e `j`, respectivamente.

Tentar acessar um índice maior que a string irá levantar um erro, mas se tentar acessar um índice da divisão maior que o tamanho da string, não acontece o erro :
```python
>>> sobrenome = 'Schwarzenegger'
>>> sobrenome[42]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: string index out of range
>>> sobrenome[6:42]
'zenegger'
>>> sobrenome[42:]
''
>>> |
```

## exercícios - parte 2

<details>
    <summary>Lista de Exercícios</summary>

1. Exercícios Simples
    1. Concatene as strings "Olá " e "Mundo".
    1. Concatene as strings "Python" e "Programação".
    1. Multiplique a string "Olá " por 3.
    1. Acesse o primeiro caractere da string "Olá ".
    1. Acesse o último caractere da string "Mundo".
    1. Concatene as strings "Py" e "thon".
    1. Concatene as strings "Senac " e "Tech".
    1. Multiplique a string "Python" por 2.
    1. Acesse o segundo caractere da string "Django".
    1. Acesse o penúltimo caractere da string "Desenvolvimento Web".
1. Exercícios de Nível Intermediário
    1. Concatene as strings "Aprendizado de" e "Máquina".
    1. Multiplique a string "Dados" por 4.
    1. Acesse o terceiro caractere da string "Inteligência".
    1. Acesse o antepenúltimo caractere da string "Artificial".
    1. Concatene as strings "Big" e "Data" e acesse o quinto caractere.
    1. Concatene as strings "Deep" e "Learning".
    1. Multiplique a string "Neural" por 3.
    1. Acesse o quarto caractere da string "Networks".
    1. Acesse o primeiro caractere da string concatenada "LinguagemNatural".
    1. Acesse o último caractere da string concatenada "LinguagemNatural".
1. Exercícios Avançados
    1. Concatene as strings "Olá " e " " e "Mundo".
    1. Acesse o quinto caractere da string "Inteligência Artificial".
    1. Multiplique a string "Big" por 5 e acesse o terceiro caractere.
    1. Concatene as strings "Deep" e " " e "Learning".
    1. Acesse o primeiro caractere da string "Neural" multiplicada por 3.
    1. Acesse o terceiro caractere da string concatenada "Ciência de Dados".
    1. Concatene as strings "Senac" e " " e "Tech" e acesse o último caractere.
    1. Multiplique a string "Máquina" por 2 e acesse o décimo caractere.
    1. Acesse o segundo caractere da string "Aprendizagem Profunda".
    1. Concatene as strings "Linguagem" e "Natural" e acesse o sexto caractere.
1. Exercícios Complexos
    1. Acesse o primeiro e último caractere da string "Programando em Python".
    1. Multiplique a string "Python 3.12" por 4 e acesse o oitavo caractere.
    1. Concatene as strings "Aprendizado" e " " e "Máquina" e acesse o décimo segundo caractere.
    1. Acesse o penúltimo caractere da string "Inteligência Artificial".
    1. Multiplique a string "Aprendizagem Profunda" por 2 e acesse o vigésimo caractere.
    1. Acesse o quinto caractere da string concatenada "BigData".
    1. Concatene as strings "Redes" e " " e "Neurais" e acesse o décimo quinto caractere.
    1. Multiplique a string "LinguagemNatural" por 3 e acesse o vigésimo terceiro caractere.
    1. Acesse o segundo caractere da string "Ciência de Dados".
    1. Concatene as strings "Olá " e "Mundo" e acesse o sexto caractere.
1. Exercícios Muito Complexos
    1. Acesse o primeiro e último caractere da string concatenada "Inteligência Artificial".
    1. Multiplique a string "Linguagem de Progamação Python" por 6 e acesse o trigésimo segundo caractere.
    1. Concatene as strings "Senac Tech" e "Escola de Tecnologia" e acesse o décimo nono caractere.
    1. Acesse o penúltimo caractere da string "Aprendizado Profundo e Redes Neurais".
    1. Multiplique a string "BigData" por 5 e acesse o quadragésimo quinto caractere.
    1. Concatene as strings "Ciência" e "de Dados" e acesse o décimo segundo caractere.
    1. Multiplique a string "Redes Neurais" por 3 e acesse o vigésimo quinto caractere.
    1. Acesse o terceiro caractere da string concatenada "Processamento de Linguagem Natural".
    1. Concatene as strings "Olá " e " " e "Mundo" e acesse o décimo quinto caractere.
    1. Acesse o segundo e último caractere da string "Inteligência Artificial" multiplicada por 2.

</details>

## métodos das strings

As strings em Python são sequências imutáveis de caracteres que possuem vários métodos embutidos, os quais permitem realizar uma ampla variedade de operações.

### `str.upper()`

O método `upper()` converte todos os caracteres alfabéticos de uma string para maiúsculas. Ele não afeta números, espaços em branco ou caracteres especiais.

```python
# Exemplo básico
texto = "hello world"
print(texto.upper())  # saída : "HELLO WORLD"

# Mistura de letras maiúsculas e minúsculas
texto = "Python is Fun!"
print(texto.upper())  # saída : "PYTHON IS FUN!"

# String com números e caracteres especiais
texto = "Python 3.12!"
print(texto.upper())  # saída : "PYTHON 3.12!"
```

### `str.lower()`

O método `lower()` converte todos os caracteres alfabéticos de uma string para minúsculas. Assim como `upper()`, ele não altera números, espaços em branco ou caracteres especiais.

```python
# Exemplo básico
texto = "HELLO WORLD"
print(texto.lower())  # saída : "hello world"

# Mistura de letras maiúsculas e minúsculas
texto = "Python Is Fun!"
print(texto.lower())  # saída : "python is fun!"

# String com números e caracteres especiais
texto = "Python 3.12!"
print(texto.lower())  # saída : "python 3.12!"
```

### `str.capitalize()`

O método `capitalize()` converte o primeiro caractere da string para maiúscula e todos os outros caracteres alfabéticos para minúscula. Se o primeiro caractere já for maiúsculo ou não for uma letra, ele permanece inalterado.

```python
# Exemplo básico
texto = "hello world"
print(texto.capitalize())  # saída : "Hello world"

# Primeira letra maiúscula, mas as demais já estão maiúsculas
texto = "HELLO WORLD"
print(texto.capitalize())  # saída : "Hello world"

# String começando com número
texto = "123 python"
print(texto.capitalize())  # saída : "123 python"
```

### `str.title()`

O método `title()` converte o primeiro caractere de cada palavra na string para maiúscula e o restante para minúscula. Este método considera qualquer caractere não alfabético (como espaços ou pontuação) como delimitador de palavras.

```python
# Exemplo básico
texto = "hello world"
print(texto.title())  # saída : "Hello World"

# Mistura de maiúsculas e minúsculas
texto = "python is FUN!"
print(texto.title())  # saída : "Python Is Fun!"

# String com caracteres especiais
texto = "welcome to python's world!"
print(texto.title())  # saída : "Welcome To Python'S World!"
```

### `str.strip()`

O método `strip()` remove os espaços em branco do início e do final da string. Além dos espaços em branco, você pode especificar caracteres adicionais a serem removidos.

```python
# Exemplo básico
texto = "   hello world   "
print(texto.strip())  # saída : "hello world"

# Removendo caracteres específicos
texto = "***hello world***"
print(texto.strip('*'))  # saída : "hello world"

# Removendo múltiplos caracteres específicos
texto = "!!!hello world###"
print(texto.strip('!#'))  # saída : "hello world"
```

### `str.lstrip()`

O método `lstrip()` remove os espaços em branco do início da string (lado esquerdo). Ele também pode remover caracteres específicos se forem fornecidos.

```python
# Exemplo básico
texto = "   hello world   "
print(texto.lstrip())  # saída : "hello world   "

# Removendo caracteres específicos
texto = "***hello world***"
print(texto.lstrip('*'))  # saída : "hello world***"

# Removendo múltiplos caracteres específicos
texto = "!!!hello world###"
print(texto.lstrip('!#'))  # saída : "hello world###"
```

### `str.rstrip()`

O método `rstrip()` remove os espaços em branco do final da string (lado direito). Ele também pode remover caracteres específicos se forem fornecidos.

```python
# Exemplo básico
texto = "   hello world   "
print(texto.rstrip())  # saída : "   hello world"

# Removendo caracteres específicos
texto = "***hello world***"
print(texto.rstrip('*'))  # saída : "***hello world"

# Removendo múltiplos caracteres específicos
texto = "!!!hello world###"
print(texto.rstrip('!#'))  # saída : "!!!hello world"
```

### `str.replace()`

O método `replace(old, new[, count])` substitui todas as ocorrências de uma substring por outra dentro da string. Se o argumento `count` for fornecido, ele limitará o número de substituições.

```python
# Substituindo todas as ocorrências
texto = "hello world"
print(texto.replace("world", "Python"))  # saída : "hello Python"

# Limitando o número de substituições
texto = "banana"
print(texto.replace("a", "o", 2))  # saída : "bonona"

# Substituindo uma sequência de caracteres por outra
texto = "abra kadabra"
print(texto.replace("abra", "magic"))  # saída : "magic kadmagic"
```

### `str.split()`

O método `split(separator[, maxsplit])` divide uma string em uma lista de substrings com base em um separador específico. Se `separator` não for especificado, espaços em branco serão usados por padrão. O argumento `maxsplit` limita o número de divisões.

```python
# Exemplo básico com separador padrão (espaço em branco)
texto = "hello world python"
print(texto.split())  # saída : ['hello', 'world', 'python']

# Dividindo com um separador específico
texto = "hello,world,python"
print(texto.split(','))  # saída : ['hello', 'world', 'python']

# Limitando o número de divisões
print(texto.split(',', 1))  # saída : ['hello', 'world,python']

# Dividindo com múltiplos espaços
texto = "hello   world   python"
print(texto.split())  # saída : ['hello', 'world', 'python']
```

### `str.join()`

O método `join(iterable)` combina elementos de um iterável (como listas ou tuplas) em uma única string, usando a string original como separador. Este método é frequentemente usado para converter listas de strings em uma única string.

```python
# Exemplo básico com espaço como separador
lista = ['hello', 'world', 'python']
print(' '.join(lista))  # saída : "hello world python"

# Usando outro separador
print(','.join(lista))  # saída : "hello,world,python"

# Usando uma string vazia como separador
print(''.join(lista))  # saída : "helloworldpython"

# Unindo elementos de uma lista de números (convertidos para strings)
numeros = ['1', '2', '3', '4']
print('-'.join(numeros))  # saída : "1-2-3-4"
```

### `str.find()`

O método `find(sub[, start[, end]])` retorna o índice da primeira ocorrência da substring `sub` na string. Se a substring não for encontrada, ele retorna `-1`. Os parâmetros `start` e `end` são opcionais e podem limitar a busca a um intervalo específico.

```python
# Encontrando a primeira ocorrência
texto = "hello world"
print(texto.find('world'))  # saída : 6

# Buscando a partir de um índice específico
print(texto.find('l', 4))  # saída : 9

# Quando a substring não é encontrada
print(texto.find('Python'))  # saída : -1

# Buscando em um intervalo específico
texto = "abracadabra"
print(texto.find('abra', 1, 7))  # saída : 7
```

### `str.rfind()`

O método `rfind(sub[, start[, end]])` é similar ao `find()`, mas busca pela última ocorrência da substring `sub` na string. Se a substring não for encontrada, ele retorna `-1`. Os parâmetros `start` e `end` são opcionais.

```python
# Encontrando a última ocorrência
texto = "abracadabra"
print(texto.rfind('abra'))  # saída : 7

# Buscando a partir de um índice específico
print(texto.rfind('a', 0, 5))  # saída : 3

# Quando a substring não é encontrada
print(texto.rfind('Python'))  # saída : -1

# Buscando em um intervalo específico
print(texto.rfind('bra', 2, 7))  # saída : -1
```

### `str.startswith()`

O método `startswith(prefix[, start[, end]])` verifica se a string começa com a substring `prefix`. Ele retorna `True` se a string começar com o prefixo e `False` caso contrário. Os parâmetros `start` e `end` podem limitar a verificação a um intervalo específico.

```python
# Verificando se começa com determinado prefixo
texto = "hello world"
print(texto.startswith('hello'))  # saída : True

# Verificando com um intervalo específico
print(texto.startswith('world', 6))  # saída : True

# Quando não começa com o prefixo
print(texto.startswith('Python'))  # saída : False

# Verificando com múltiplos prefixos
print(texto.startswith(('hello', 'Hi')))  # saída : True
```

### `str.endswith()`

O método `endswith(suffix[, start[, end]])` verifica se a string termina com a substring `suffix`. Ele retorna `True` se a string terminar com o sufixo e `False` caso contrário. Os parâmetros `start` e `end` podem limitar a verificação a um intervalo específico.

```python
# Verificando se termina com determinado sufixo
texto = "hello world"
print(texto.endswith('world'))  # saída : True

# Verificando com um intervalo específico
print(texto.endswith('hello', 0, 5))  # saída : True

# Quando não termina com o sufixo
print(texto.endswith('Python'))  # saída : False

# Verificando com múltiplos sufixos
print(texto.endswith(('world', 'Python')))  # saída : True
```

### `str.isalpha()`

O método `isalpha()` retorna `True` se todos os caracteres da string forem letras do alfabeto e a string não estiver vazia. Se houver números, espaços ou caracteres especiais, ele retorna `False`.

```python
# Todos os caracteres são letras
texto = "hello"
print(texto.isalpha())  # saída : True

# Contém números
texto = "hello123"
print(texto.isalpha())  # saída : False

# Contém espaços
texto = "hello world"
print(texto.isalpha())  # saída : False

# String vazia
texto = ""
print(texto.isalpha())  # saída : False
```

### `str.isdigit()`

O método `isdigit()` retorna `True` se todos os caracteres da string forem dígitos (0-9) e a string não estiver vazia. Se houver letras, espaços ou caracteres especiais, ele retorna `False`.

```python
# Todos os caracteres são dígitos
texto = "123456"
print(texto.isdigit())  # saída : True

# Contém letras
texto = "123abc"
print(texto.isdigit())  # saída : False

# Contém espaços
texto = "123 456"
print(texto.isdigit())  # saída : False

# String vazia
texto = ""
print(texto.isdigit())  # saída : False
```

### `str.isalnum()`

O método `isalnum()` retorna `True` se todos os caracteres da string forem letras ou dígitos e a string não estiver vazia. Se houver espaços ou caracteres especiais, ele retorna `False`.

```python
# Todos os caracteres são alfanuméricos
texto = "hello123"
print(texto.isalnum())  # saída : True

# Contém espaço
texto = "hello 123"
print(texto.isalnum())  # saída : False

# Contém caracteres especiais
texto = "hello@123"
print(texto.isalnum())  # saída : False

# String vazia
texto = ""
print(texto.isalnum())  # saída : False
```

### `str.isspace()`

O método `isspace()` retorna `True` se todos os caracteres da string forem espaços em branco (incluindo tabulações, quebras de linha, etc.) e a string não estiver vazia. Se houver qualquer outro caractere, ele retorna `False`.

```python
# Todos os caracteres são espaços em branco
texto = "   "
print(texto.isspace())  # saída : True

# Contém um caractere não branco
texto = "   a"
print(texto.isspace())  # saída : False

# String com quebra de linha
texto = "\n\t"
print(texto.isspace())  # saída : True

# String vazia
texto = ""
print(texto.isspace())  # saída : False
```

### `str.isupper()`

O método `isupper()` retorna `True` se todos os caracteres alfabéticos na string forem maiúsculos. Se houver caracteres minúsculos ou a string estiver vazia, ele retorna `False`.

```python
# Todos os caracteres alfabéticos são maiúsculos
texto = "HELLO"
print(texto.isupper())  # saída : True

# Contém caracteres minúsculos
texto = "Hello"
print(texto.isupper())  # saída : False

# String com números e maiúsculas
texto = "123 HELLO"
print(texto.isupper())  # saída : True

# String vazia
texto = ""
print(texto.isupper())  # saída : False
```

### `str.islower()`

O método `islower()` retorna `True` se todos os caracteres alfabéticos na string forem minúsculos. Se houver caracteres maiúsculos ou a string estiver vazia, ele retorna `False`.

```python
# Todos os caracteres alfabéticos são minúsculos
texto = "hello"
print(texto.islower())  # saída : True

# Contém caracteres maiúsculos
texto = "Hello"
print(texto.islower())  # saída : False

# String com números e minúsculas
texto = "123 hello"
print(texto.islower())  # saída : True

# String vazia
texto = ""
print(texto.islower())  # saída : False
```

### `str.zfill()`

O método `zfill(width)` retorna uma cópia da string original preenchida com zeros à esquerda para alcançar um determinado comprimento (`width`). Se a string for maior ou igual ao comprimento especificado, ela será retornada sem alterações.

```python
# Preenchendo com zeros
texto = "42"
print(texto.zfill(5))  # saída : "00042"

# String já maior que o comprimento especificado
texto = "12345"
print(texto.zfill(3))  # saída : "12345"

# Aplicando em uma string negativa
texto = "-42"
print(texto.zfill(5))  # saída : "-0042"

# Aplicando em uma string de caracteres
texto = "abc"
print(texto.zfill(5))  # saída : "00abc"
```

### `str.center()`

O método `center(width[, fillchar])` retorna uma nova string de comprimento `width`, onde a string original é centralizada. Se o `fillchar` for fornecido, ele será usado para preencher os espaços em volta; caso contrário, o espaço será usado.

```python
# Centralizando com espaços
texto = "hello"
print(texto.center(10))  # saída : "  hello   "

# Centralizando com um caractere de preenchimento
print(texto.center(10, '*'))  # saída : "**hello***"

# Comprimento menor que a string original
print(texto.center(4))  # saída : "hello"
```

### `str.ljust()`

O método `ljust(width[, fillchar])` retorna uma nova string de comprimento `width`, onde a string original é justificada à esquerda. Se o `fillchar` for fornecido, ele será usado para preencher o espaço à direita; caso contrário, o espaço será usado.

```python
# Justificando à esquerda com espaços
texto = "hello"
print(texto.ljust(10))  # saída : "hello     "

# Justificando à esquerda com um caractere de preenchimento
print(texto.ljust(10, '-'))  # saída : "hello-----"

# Comprimento menor que a string original
print(texto.ljust(4))  # saída : "hello"
```

### `str.rjust()`

O método `rjust()` retorna uma nova string de comprimento `width`, onde a string original é justificada à direita. Se o `fillchar` for fornecido, ele será usado para preencher o espaço à esquerda; caso contrário, o espaço será usado.

```python
# Justificando à direita com espaços
texto = "hello"
print(texto.rjust(10))  # saída : "     hello"

# Justificando à direita com um caractere de preenchimento
print(texto.rjust(10, '-'))  # saída : "-----hello"

# Comprimento menor que a string original
print(texto.rjust(4))  # saída : "hello"
```

### `str.partition()`

O método `partition(sep)` divide a string em uma tupla de três elementos: a parte antes do separador `sep`, o próprio separador, e a parte após o separador. Se o separador não for encontrado, a tupla conterá a string original e duas strings vazias.

```python
# Separando com um delimitador presente
texto = "hello world python"
print(texto.partition('world'))  # saída : ('hello ', 'world', ' python')

# Separando com um delimitador ausente
print(texto.partition('Python'))  # saída : ('hello world python', '', '')

# Separando no início da string
print(texto.partition('hello'))  # saída : ('', 'hello', ' world python')
```

### `str.rpartition()`

O método `rpartition(sep)` é similar ao `partition()`, mas a divisão ocorre na última ocorrência do separador `sep`.

```python
# Separando com um delimitador presente
texto = "hello world world"
print(texto.rpartition('world'))  # saída : ('hello world ', 'world', '')

# Separando com um delimitador ausente
print(texto.rpartition('Python'))  # saída : ('', '', 'hello world world')

# Separando no início da string
texto = "hello world"
print(texto.rpartition('hello'))  # saída : ('', 'hello', ' world')
```

## execícios

<details>
<summary>Lista de Exercícios</summary>

### 1. `str.upper()`
1. Crie uma variável com uma frase e converta-a para letras maiúsculas usando `str.upper()`.
2. Receba uma string do usuário e exiba-a totalmente em maiúsculas.
3. Converta o nome de uma cidade para maiúsculas e exiba-o.
4. Converta a palavra "python" para maiúsculas e exiba o resultado.
5. Crie uma lista com várias palavras e converta cada uma para maiúsculas, exibindo o resultado.
6. Receba uma frase do usuário e converta apenas a primeira palavra para maiúsculas.
7. Armazene uma mensagem em uma variável e exiba-a em maiúsculas.
8. Receba o nome de um filme do usuário e exiba-o em maiúsculas.
    ```python
    nome_filme = input('digite o nome de um filme : ')

    print(nome_filme.upper())
    ```
9. Converta o título de um livro para maiúsculas e exiba-o.

### 2. `str.lower()`
1. Crie uma variável com uma frase e converta-a para letras minúsculas usando `str.lower()`.
2. Receba uma string do usuário e exiba-a totalmente em minúsculas.
3. Converta o nome de uma cidade para minúsculas e exiba-o.
4. Converta a palavra "PYTHON" para minúsculas e exiba o resultado.
5. Crie uma lista com várias palavras e converta cada uma para minúsculas, exibindo o resultado.
    ```python
    palavras = ['carro', 'Moto', 'Jacarezinho', 'AVIAO']

    i = 0

    while i < len(palavras):
        print(palavras[i].lower())
        i = i + 1
    ```
6. Receba uma frase do usuário e converta apenas a primeira palavra para minúsculas.
    ```python
    frase = input('digite uma frase qualquer : ')

    # valida se recebeu algo
    if frase:
        lista = frase.split(' ')
        lista[0] = lista[0].upper()
        print(' '.join(lista))
    else:
        print('digite algo na proxima vez')
    ```
7. Armazene uma mensagem em uma variável e exiba-a em minúsculas.
8. Receba o nome de um filme do usuário e exiba-o em minúsculas.
9. Converta o título de um livro para minúsculas e exiba-o.

### 3. `str.capitalize()`
1. Crie uma variável com uma frase em letras minúsculas e use `str.capitalize()` para capitalizar a primeira letra.
2. Receba uma string do usuário e exiba-a com a primeira letra em maiúscula.
3. Converta a palavra "python" para "Python" usando `str.capitalize()`.
4. Crie uma lista com várias palavras e capitalize a primeira letra de cada uma, exibindo o resultado.
5. Receba uma frase do usuário e capitalize apenas a primeira palavra.
    ```python
    frase = input('digite uma frase : ')
    lista = frase.split(' ')

    lista[0] = lista[0].capitalize()

    frase = ' '.join(lista)

    print(frase)

    ```
6. Armazene uma mensagem em uma variável e exiba-a com a primeira letra em maiúscula.
7. Receba o nome de um filme do usuário e exiba-o com a primeira letra em maiúscula.
8. Capitalize o título de um livro e exiba-o.
9. Receba o nome de uma cidade e capitalize a primeira letra.

### 4. `str.title()`
1. Crie uma variável com uma frase e use `str.title()` para capitalizar a primeira letra de cada palavra.
2. Receba uma string do usuário e exiba-a com a primeira letra de cada palavra em maiúscula.
3. Converta a frase "learning python is fun" para "Learning Python Is Fun" usando `str.title()`.
4. Crie uma lista de frases e aplique `str.title()` em cada uma, exibindo o resultado.
5. Receba uma frase do usuário e capitalize a primeira letra de cada palavra.
6. Armazene uma frase em uma variável e exiba-a com `str.title()`.
    ```python
    frase = 'eu sou uma grade frase'
    print(frase.title())

    ```
7. Receba o título de um filme e converta-o para `title case`.
8. Capitalize as palavras de um título de livro e exiba-o.
9. Receba uma frase e exiba-a com cada palavra iniciada com letra maiúscula.

### 5. `str.strip()`
1. Crie uma variável com uma string contendo espaços em branco no início e no final. Use `str.strip()` para removê-los.
2. Receba uma string do usuário com espaços extras e exiba-a sem esses espaços.
3. Remova espaços em branco de uma frase armazenada em uma variável.
4. Receba uma string de texto com espaços e pontuação extra, e use `str.strip()` para removê-los.
5. Crie uma lista de strings com espaços em branco e remova-os usando `str.strip()`.
6. Receba uma string com caracteres específicos no início e no fim e remova-os usando `str.strip()`.
7. Armazene uma frase com espaços e exiba-a sem os espaços no início e no final.
8. Receba uma string de texto e remova qualquer pontuação extra no início e no fim.
9. Receba uma frase do usuário e remova todos os espaços extras e caracteres especiais do início e fim.
    ```python
    frase = input('digite uma frase : ')

    frase = frase.strip()

    bichados = '!@#$%&*?'
    i = 0
    while i < len(bichados):
        frase = frase.strip(bichados[i])
        i = i + 1

    print(frase)
    ```

### 6. `str.lstrip()`
1. Crie uma variável com uma string contendo espaços em branco no início. Use `str.lstrip()` para removê-los.
2. Receba uma string do usuário com espaços extras no início e exiba-a sem esses espaços.
3. Remova espaços em branco do início de uma frase armazenada em uma variável.
4. Receba uma string de texto com espaços extras no início e use `str.lstrip()` para removê-los.
5. Crie uma lista de strings com espaços em branco no início e remova-os usando `str.lstrip()`.
6. Receba uma string com caracteres específicos no início e remova-os usando `str.lstrip()`.
7. Armazene uma frase com espaços no início e exiba-a sem esses espaços.
8. Receba uma string de texto e remova qualquer pontuação extra no início.
9. Receba uma frase do usuário e remova todos os espaços extras e caracteres especiais do início.

### 7. `str.rstrip()`
1. Crie uma variável com uma string contendo espaços em branco no final. Use `str.rstrip()` para removê-los.
2. Receba uma string do usuário com espaços extras no final e exiba-a sem esses espaços.
3. Remova espaços em branco do final de uma frase armazenada em uma variável.
4. Receba uma string de texto com espaços extras no final e use `str.rstrip()` para removê-los.
5. Crie uma lista de strings com espaços em branco no final e remova-os usando `str.rstrip()`.
6. Receba uma string com caracteres específicos no final e remova-os usando `str.rstrip()`.
7. Armazene uma frase com espaços no final e exiba-a sem esses espaços.
8. Receba uma string de texto e remova qualquer pontuação extra no final.
9. Receba uma frase do usuário e remova todos os espaços extras e caracteres especiais do final.

### 8. `str.replace(old, new[, count])`
1. Crie uma string e substitua todas as ocorrências de "a" por "o" usando `str.replace()`.
2. Receba uma frase do usuário e substitua todas as ocorrências de uma palavra específica por outra.
3. Substitua todos os espaços em uma string por hífens usando `str.replace()`.
4. Crie uma lista de frases e substitua uma palavra específica em todas elas usando `str.replace()`.
5. Receba uma string e substitua todas as vírgulas por pontos.
6. Substitua todas as ocorrências da palavra "Python" por "programação" em uma string.
7. Receba uma frase e substitua apenas as primeiras 3 ocorrências de uma palavra específica.
8. Crie uma string com várias ocorrências de uma palavra e substitua-a por outra, limitando o número de substituições.
9. Substitua todos os números em uma string por "#" usando `str.replace()`.
    ```python
    frase = 'sou uma 123 grande 123 frase com 1287 diversos nume1230os'
    print(frase)

    i = 0

    while i  < 10:
        frase = frase.replace(str(i),'#')
        i = i + 1

    print(frase)
    ```
10. Receba uma frase do usuário e substitua todas as ocorrências de uma letra específica, limitando o número de substituições.

### 9. `str.split(separator[, maxsplit])`
1. Crie uma string com várias palavras separadas por espaços e divida-a em uma lista de palavras usando `str.split()`.
2. Receba uma frase do usuário e divida-a em palavras usando espaços como separador.
3. Divida uma frase em uma lista de palavras usando vírgulas como separador.
4. Crie uma lista de frases e divida cada uma delas em palavras usando `str.split()`.
5. Receba uma string e divida-a em uma lista, limitando o número de divisões para 3.
6. Divida uma frase em palavras usando um caractere específico como separador.
7. Crie uma string com números separados por vírgulas e divida-a em uma lista de números.
    ```python
    texto = '33,121,11234,0981234,88282'
    print(texto)

    lista = texto.split(',')
    print(lista)

    i = 0
    while i < len(lista):
        lista[i] = int(lista[i])
        i = i + 1
    print(lista)
    ```
8. Receba uma frase do usuário e divida-a em palavras, limitando o número de divisões para 2.
9. Divida uma string em partes, usando espaços como separador e limitando o número de divisões.
10. Receba uma frase e divida-a em palavras usando um separador específico, limitando o número de divisões.

### 10. `str.join(iterable)`
1. Crie uma lista de palavras e una-as em uma única string, separando-as por espaços usando `str.join()`.
2. Receba uma lista de palavras do usuário e una-as em uma única string com hífens como separador.
3. Una os elementos de uma lista de números em uma string, separando-os por vírgulas.
4. Crie uma lista de frases e una-as em uma única string, separando-as por espaços.
5. Receba uma lista de palavras e una-as em uma string com um caractere específico como separador.
6. Una os elementos de uma lista de palavras em uma string, separando-os por " - ".
7. Receba uma lista de nomes e una-os em uma string com vírgulas como separador.
    ```python
    lista = []

    count = 5
    while count > 0:
        nome = input('digite um nome : ')
        lista.append(nome)
        count = count - 1

    print(lista)
    texto = ','.join(lista)
    print(texto)
    ```
8. Crie uma lista de palavras e una-as em uma string, separando-as por " | ".
9. Receba uma lista de frases e una-as em uma única string com pontos finais entre elas.
10. Crie uma lista de números e una-os em uma string com espaços como separador.

### 11. `str.find(sub[, start[, end]])`
1. Crie uma string e encontre a posição da primeira ocorrência de uma letra específica usando `str.find()`.
2. Receba uma frase do usuário e encontre a posição da primeira ocorrência de uma palavra específica.
3. Encontre a posição da primeira ocorrência de "Python" em uma string.
4. Crie uma lista de frases e encontre a posição de uma palavra específica em cada uma delas usando `str.find()`.
5. Receba uma string e encontre a posição da primeira ocorrência de uma letra específica, começando a busca em um índice específico.
6. Encontre a posição da primeira ocorrência de um número em uma string.
7. Receba uma frase e encontre a posição da primeira ocorrência de uma palavra específica, dentro de um intervalo específico.
8. Crie uma string e encontre a posição da primeira ocorrência de uma letra específica, buscando apenas em uma parte da string.
9. Receba uma frase do usuário e encontre a posição da primeira ocorrência de um caractere específico.
10. Encontre a posição da primeira ocorrência de uma palavra em uma string, começando a busca em um índice específico.

### 12. `str.rfind(sub[, start[, end]])`
1. Crie uma string e encontre a posição da última ocorrência de uma letra específica usando `str.rfind()`.
2. Receba uma frase do usuário e encontre a posição da última ocorrência de uma palavra específica.
3. Encontre a posição da última ocorrência de "Python" em uma string.
4. Crie uma lista de frases e encontre a posição da última ocorrência de uma palavra específica em cada uma delas usando `str.rfind()`.
5. Receba uma string e encontre a posição da última ocorrência de uma letra específica, começando a busca em um índice específico.
6. Encontre a posição da última ocorrência de um número em uma string.
7. Receba uma frase e encontre a posição da última ocorrência de uma palavra específica, dentro de um intervalo específico.
8. Crie uma string e encontre a posição da última ocorrência de uma letra específica, buscando apenas em uma parte da string.
9. Receba uma frase do usuário e encontre a posição da última ocorrência de um caractere específico.
10. Encontre a posição da última ocorrência de uma palavra em uma string, começando a busca em um índice específico.

### 13. `str.startswith(prefix[, start[, end]])`
1. Crie uma string e verifique se ela começa com uma letra específica usando `str.startswith()`.
2. Receba uma frase do usuário e verifique se ela começa com uma palavra específica.
3. Verifique se a string "Python is awesome" começa com a palavra "Python".
4. Crie uma lista de frases e verifique se cada uma começa com uma palavra específica usando `str.startswith()`.
5. Receba uma string e verifique se ela começa com uma letra específica, começando a verificação em um índice específico.
6. Verifique se uma string começa com um número específico.
7. Receba uma frase e verifique se ela começa com uma palavra específica, dentro de um intervalo específico.
8. Crie uma string e verifique se ela começa com uma letra específica, buscando apenas em uma parte da string.
9. Receba uma frase do usuário e verifique se ela começa com um caractere específico.
10. Verifique se uma string começa com uma palavra específica, começando a verificação em um índice específico.

### 14. `str.endswith(suffix[, start[, end]])`
1. Crie uma string e verifique se ela termina com uma letra específica usando `str.endswith()`.
2. Receba uma frase do usuário e verifique se ela termina com uma palavra específica.
3. Verifique se a string "Python is awesome" termina com a palavra "awesome".
4. Crie uma lista de frases e verifique se cada uma termina com uma palavra específica usando `str.endswith()`.
5. Receba uma string e verifique se ela termina com uma letra específica, começando a verificação em um índice específico.
6. Verifique se uma string termina com um número específico.
7. Receba uma frase e verifique se ela termina com uma palavra específica, dentro de um intervalo específico.
8. Crie uma string e verifique se ela termina com uma letra específica, buscando apenas em uma parte da string.
9. Receba uma frase do usuário e verifique se ela termina com um caractere específico.
10. Verifique se uma string termina com uma palavra específica, começando a verificação em um índice específico.

### 15. `str.isalpha()`
1. Crie uma string contendo apenas letras e verifique se `str.isalpha()` retorna `True`.
2. Receba uma string do usuário e verifique se ela contém apenas letras.
3. Verifique se a string "Python3" contém apenas letras usando `str.isalpha()`.
4. Crie uma lista de palavras e verifique se cada uma delas contém apenas letras.
5. Receba uma string e verifique se ela contém apenas letras, sem espaços ou caracteres especiais.
    ```python
    >>> texto = input('Digite um texto qualquer : ')
    Digite um texto qualquer : aqui tem um texto qualquer
    >>> texto
    'aqui tem um texto qualquer'
    >>>
    >>> if texto.isalpha():
    ...     print('o conteúdo dessa variável só tem caracteres alfabéticos')
    ... else:
    ...     print('essa string tem outras coisas além dos caracteres alfabéticos')
    ...
    essa string tem outras coisas além dos caracteres alfabéticos
    >>> |
    ```
6. Verifique se uma string composta por várias palavras contém apenas letras.
7. Receba uma frase do usuário e verifique se todas as palavras contêm apenas letras.
8. Verifique se uma string que contém um nome completo tem apenas letras.
9. Receba uma palavra do usuário e verifique se ela contém apenas letras, sem números ou símbolos.

### 16. `str.isdigit()`
1. Crie uma string contendo apenas números e verifique se `str.isdigit()` retorna `True`.
2. Receba uma string do usuário e verifique se ela contém apenas números.
3. Verifique se a string "12345" contém apenas números usando `str.isdigit()`.
4. Crie uma lista de strings e verifique se cada uma delas contém apenas números.
5. Receba uma string e verifique se ela contém apenas números, sem espaços ou caracteres especiais.
6. Verifique se uma string composta por um número de telefone contém apenas números.
7. Receba uma string do usuário e verifique se ela é um código postal válido (apenas números).
8. Verifique se uma string que contém a idade de uma pessoa tem apenas números.
9. Receba uma string do usuário e verifique se ela contém apenas números, sem letras ou símbolos.

### 17. `str.isalnum()`
1. Crie uma string contendo apenas letras e números e verifique se `str.isalnum()` retorna `True`.
2. Receba uma string do usuário e verifique se ela contém apenas letras e números.
3. Verifique se a string "Python3" contém apenas letras e números usando `str.isalnum()`.
4. Crie uma lista de strings e verifique se cada uma delas contém apenas letras e números.
5. Receba uma string e verifique se ela contém apenas letras e números, sem espaços ou caracteres especiais.
6. Verifique se uma string composta por um nome de usuário contém apenas letras e números.
7. Receba uma string do usuário e verifique se ela contém apenas letras e números, sem símbolos.
8. Verifique se uma string que contém uma senha tem apenas letras e números.
9. Receba uma string do usuário e verifique se ela contém apenas letras e números, sem espaços.

### 18. `str.isspace()`
1. Crie uma string contendo apenas espaços em branco e verifique se `str.isspace()` retorna `True`.
2. Receba uma string do usuário e verifique se ela contém apenas espaços.
3. Verifique se uma string composta por tabulações e espaços contém apenas espaços usando `str.isspace()`.
4. Crie uma lista de strings e verifique se cada uma delas contém apenas espaços.
5. Receba uma string e verifique se ela contém apenas espaços, sem letras ou números.
6. Verifique se uma string que aparenta estar vazia contém apenas espaços.
7. Receba uma string do usuário e verifique se ela contém apenas tabulações e espaços.
8. Verifique se uma string que contém múltiplos espaços consecutivos contém apenas espaços.
9. Receba uma string do usuário e verifique se ela contém apenas espaços, sem outros caracteres.

### 19. `str.isupper()`
1. Crie uma string em maiúsculas e verifique se `str.isupper()` retorna `True`.
2. Receba uma string do usuário e verifique se ela está totalmente em maiúsculas.
3. Verifique se a string "PYTHON" está totalmente em maiúsculas usando `str.isupper()`.
4. Crie uma lista de palavras e verifique se cada uma delas está em maiúsculas.
5. Receba uma string e verifique se ela está em maiúsculas, sem letras minúsculas.
6. Verifique se uma string que contém uma frase está toda em maiúsculas.
7. Receba uma string do usuário e verifique se ela contém apenas letras maiúsculas.
8. Verifique se uma string que contém o nome de uma cidade está em maiúsculas.
9. Receba uma string do usuário e verifique se ela está completamente em maiúsculas, sem caracteres minúsculos.

### 20. `str.islower()`
1. Crie uma string em minúsculas e verifique se `str.islower()` retorna `True`.
2. Receba uma string do usuário e verifique se ela está totalmente em minúsculas.
3. Verifique se a string "python" está totalmente em minúsculas usando `str.islower()`.
4. Crie uma lista de palavras e verifique se cada uma delas está em minúsculas.
5. Receba uma string e verifique se ela está em minúsculas, sem letras maiúsculas.
6. Verifique se uma string que contém uma frase está toda em minúsculas.
7. Receba uma string do usuário e verifique se ela contém apenas letras minúsculas.
8. Verifique se uma string que contém o nome de uma cidade está em minúsculas.
9. Receba uma string do usuário e verifique se ela está completamente em minúsculas, sem caracteres maiúsculos.

### 21. `str.zfill(width)`
1. Crie uma string numérica e use `str.zfill()` para preenchê-la com zeros à esquerda, completando um total de 10 caracteres.
2. Receba um número do usuário e complete-o com zeros à esquerda, usando `str.zfill()` para ter 8 dígitos.
3. Preencha um número de telefone com zeros à esquerda até ter um total de 12 caracteres.
4. Crie uma lista de números e preencha cada um com zeros à esquerda, até atingir 6 dígitos.
5. Receba uma string numérica do usuário e complete-a com zeros à esquerda para um total de 5 dígitos.
6. Use `str.zfill()` para garantir que um número de pedido tenha exatamente 10 dígitos, preenchendo com zeros à esquerda se necessário.
7. Receba um código postal e preencha-o com zeros à esquerda até ter 7 dígitos.
8. Preencha um número de série com zeros à esquerda até atingir 15 caracteres.
9. Receba um código de produto e complete-o com zeros à esquerda até ter 10 caracteres.

### 22. `str.center(width[, fillchar])`
1. Crie uma string e centralize-a em uma largura de 20 caracteres, preenchendo os espaços com traços (-).
    ```python
    >>> nome = 'Arnold'
    >>> nome = nome.center(20,'-')
    >>> print(nome)
    -------Arnold-------
    ```
2. Receba uma palavra do usuário e centralize-a em uma largura de 30 caracteres, usando asteriscos como preenchimento.
3. Centralize a frase "Python Rocks!" em uma largura de 40 caracteres, preenchendo os espaços com pontos (.).
4. Crie uma lista de palavras e centralize cada uma delas em uma largura de 15 caracteres, usando traços como preenchimento.
5. Receba uma string e centralize-a em uma largura de 25 caracteres, preenchendo os espaços com espaços em branco.
6. Use `str.center()` para centralizar um título de 10 caracteres em uma largura de 20, preenchendo com hífens (-).
7. Receba uma palavra do usuário e centralize-a em uma largura de 50 caracteres, preenchendo os espaços com iguais (=).
8. Centralize uma frase em uma largura de 60 caracteres, preenchendo os espaços com traços duplos (==).
9. Receba um título do usuário e centralize-o em uma largura de 35 caracteres, preenchendo os espaços com pontos de exclamação (!).

### 23. `str.ljust(width[, fillchar])`
1. Crie uma string e alinhe-a à esquerda em uma largura de 20 caracteres, preenchendo os espaços com traços (-).
2. Receba uma palavra do usuário e alinhe-a à esquerda em uma largura de 30 caracteres, usando asteriscos (*) como preenchimento.
3. Alinhe a frase "Python Rocks!" à esquerda em uma largura de 40 caracteres, preenchendo os espaços com pontos (.).
4. Crie uma lista de palavras e alinhe cada uma delas à esquerda em uma largura de 15 caracteres, usando traços como preenchimento.
5. Receba uma string e alinhe-a à esquerda em uma largura de 25 caracteres, preenchendo os espaços com espaços em branco.
6. Use `str.ljust()` para alinhar um título de 10 caracteres à esquerda em uma largura de 20, preenchendo com hífens (-).
7. Receba uma palavra do usuário e alinhe-a à esquerda em uma largura de 50 caracteres, preenchendo os espaços com iguais (=).
8. Alinhe uma frase à esquerda em uma largura de 60 caracteres, preenchendo os espaços com traços duplos (==).
9. Receba um título do usuário e alinhe-o à esquerda em uma largura de 35 caracteres, preenchendo os espaços com pontos de exclamação (!).

### 24. `str.rjust(width[, fillchar])`
1. Crie uma string e alinhe-a à direita em uma largura de 20 caracteres, preenchendo os espaços com traços (-).
2. Receba uma palavra do usuário e alinhe-a à direita em uma largura de 30 caracteres, usando asteriscos (*) como preenchimento.
3. Alinhe a frase "Python Rocks!" à direita em uma largura de 40 caracteres, preenchendo os espaços com pontos (.).
4. Crie uma lista de palavras e alinhe cada uma delas à direita em uma largura de 15 caracteres, usando traços como preenchimento.
5. Receba uma string e alinhe-a à direita em uma largura de 25 caracteres, preenchendo os espaços com espaços em branco.
6. Use `str.rjust()` para alinhar um título de 10 caracteres à direita em uma largura de 20, preenchendo com hífens (-).
7. Receba uma palavra do usuário e alinhe-a à direita em uma largura de 50 caracteres, preenchendo os espaços com iguais (=).
8. Alinhe uma frase à direita em uma largura de 60 caracteres, preenchendo os espaços com traços duplos (==).
9. Receba um título do usuário e alinhe-o à direita em uma largura de 35 caracteres, preenchendo os espaços com pontos de exclamação (!).

### 25. `str.partition(sep)`
1. Crie uma string contendo uma frase e separe-a em três partes usando `str.partition()`, com o separador sendo um espaço.
2. Receba uma frase do usuário e use `str.partition()` para separar a primeira palavra do restante.
3. Use `str.partition()` para dividir uma string em três partes, com o separador sendo uma vírgula.
4. Crie uma lista de frases e use `str.partition()` em cada uma para separar a primeira palavra do restante.
5. Receba uma string e use `str.partition()` para dividir a string em três partes, usando um hífen como separador.
6. Use `str.partition()` para separar uma frase em três partes, com o separador sendo o primeiro espaço encontrado.
7. Crie uma string com múltiplas palavras e use `str.partition()` para dividir a string na primeira ocorrência de uma palavra específica.
8. Receba uma string do usuário e use `str.partition()` para separar a string em três partes, usando um ponto final como separador.
9. Use `str.partition()` para dividir uma string de números em três partes, com o separador sendo um ponto (.)
10. Receba uma frase do usuário e use `str.partition()` para separar a frase na primeira ocorrência de uma palavra específica.

</details>


# tipo-tupla.md

# tipo tupla

As **tuplas** (ou *tuples* em inglês) são um tipo de dado em Python que representam uma coleção ordenada de elementos. Assim como as listas, as tuplas podem armazenar múltiplos itens em uma única variável. No entanto, diferentemente das listas, as tuplas são **imutáveis**, ou seja, uma vez criadas, seus valores não podem ser alterados.

## características

1. **imutabilidade** : depois que uma tupla é criada, não é possível modificar, adicionar ou remover elementos dela. isso garante que o conteúdo da tupla permaneça constante ao longo do tempo;

2. **ordenadas** : as tuplas mantêm a ordem dos elementos. isso significa que, ao acessar os elementos de uma tupla, eles sempre serão obtidos na mesma ordem em que foram definidos;

3. **armazenamento de diferentes tipos de dados** : uma tupla pode conter itens de diferentes tipos de dados, como inteiros, floats, strings, listas, outras tuplas, etc;

4. **indexação e fatiamento** : assim como as listas, os elementos de uma tupla podem ser acessados usando índices, e é possível fatiar uma tupla para acessar subconjuntos de seus elementos;

## criando tuplas

Tuplas são criadas colocando-se os elementos separados por vírgulas dentro de parênteses `()`.

```python
>>> # exemplo de uma tupla com diferentes tipos de dados
>>> tupla_exemplo = (1, "Python", 3.14, [10, 20, 30], (40, 50, 60))
>>>
>>> print(tupla_exemplo)
(1, 'Python', 3.14, [10, 20, 30], (40, 50, 60))
>>> |
```

Neste exemplo, `tupla_exemplo` é uma tupla que contém:
- um número inteiro (`1`)
- uma string (`"Python"`)
- um número float (`3.14`)
- uma lista (`[10, 20, 30]`)
- outra tupla (`(40, 50, 60)`)

## acessando elementos de uma tupla

Os elementos de uma tupla podem ser acessados por meio de seus índices, que começam em `0` para o primeiro elemento, `1` para o segundo, e assim por diante.

```python
>>> # acessando elementos individuais
>>> primeiro_elemento = tupla_exemplo[0]
>>> segundo_elemento = tupla_exemplo[1]
>>>
>>> print(primeiro_elemento)
1
>>> print(segundo_elemento)
Python
>>> |
```

## fatiamento (slicing)

É possível obter sub-tuplas de uma tupla usando a notação de fatiamento (slicing).

```python
>>> # fatiamento básico
>>> sub_tupla = tupla_exemplo[1:4]
>>>
>>> print(sub_tupla)
('Python', 3.14, [10, 20, 30])
>>> |
```

Neste exemplo, `tupla_exemplo[1:4]` retorna uma sub-tupla que inclui os elementos do índice `1` ao `3` (o índice final `4` não é incluído).

## tuplas com um único elemento

Para criar uma tupla com apenas um elemento, é necessário adicionar uma vírgula após o elemento dentro dos parênteses, caso contrário, Python interpretará os parênteses como um agrupamento de expressões.

```python
>>> # Tupla com um único elemento
>>> tupla_unica = (42,)
>>>
>>> print(type(tupla_unica))
<class 'tuple'>
>>> |
```

Sem a vírgula, Python consideraria `tupla_unica` como um número inteiro e não como uma tupla.

## imutabilidade

Uma das principais diferenças entre tuplas e listas é que as tuplas são imutáveis. Isso significa que, depois de criada, uma tupla não pode ser modificada. Não é possível alterar, adicionar ou remover elementos de uma tupla.

```python
>>> # tentando alterar um elemento da tupla
>>> try:
>>>     tupla_exemplo[0] = 100
>>> except TypeError as e:
>>>     print(e)
'tuple' object does not support item assignment
>>> |
```

## usos comuns das tuplas

1. **agrupamento de dados** : tuplas são frequentemente usadas para agrupar dados que logicamente pertencem juntos, como coordenadas `(x, y)` ou informações de contato;

1. **retorno de múltiplos valores de funções** : as funções em python podem retornar múltiplos valores encapsulados em uma tupla;
    ```python
    >>> def dividir_e_resto(dividendo, divisor):
    >>>     quociente = dividendo // divisor
    >>>     resto = dividendo % divisor
    >>>     return quociente, resto
    >>>
    >>> resultado = dividir_e_resto(10, 3)
    >>> print(resultado)
    (3, 1)
    >>> |
    ```
    Neste exemplo, a função `dividir_e_resto` retorna uma tupla com o quociente e o resto da divisão.

1. **tuplas aninhadas**: tuplas podem conter outras tuplas como elementos, criando uma estrutura aninhada;
    ```python
    >>> tupla_aninhada = (1, (2, 3), (4, (5, 6)))
    >>>
    >>> print(tupla_aninhada)  # Saída: (1, (2, 3), (4, (5, 6)))
    ```

4. **chaves imutáveis em dicionários**: tuplas podem ser usadas como chaves em dicionários porque são imutáveis.
    ```python
    >>> coordenadas = {}
    >>> coordenadas[(10, 20)] = "Ponto A"
    >>> coordenadas[(30, 40)] = "Ponto B"
    >>>
    >>> print(coordenadas)
    {(10, 20): 'Ponto A', (30, 40): 'Ponto B'}
    >>> |
    ```

### métodos e funções úteis para tuplas

Embora as tuplas sejam imutáveis, Python oferece algumas funções e métodos que podem ser usados com elas:

- **`len(tupla)`** : retorna o número de elementos na tupla;
- **`min(tupla)` e `max(tupla)`** : retornam o menor e o maior elemento da tupla, respectivamente;
- **`tupla.index(valor)`** : retorna o índice do primeiro elemento com o valor especificado;
- **`tupla.count(valor)`** : retorna o número de vezes que o valor aparece na tupla;

```python
>>> numeros = (3, 2, 8, 6, 2, 7)
>>>
>>> print(len(numeros))
5
>>> print(min(numeros))
2
>>> print(max(numeros))
8
>>> print(numeros.index(2))
1
>>> print(numeros.count(2))
2
```

### convertendo entre listas e tuplas

É possível converter uma lista em uma tupla e vice-versa usando as funções `tuple()` e `list()`.

```python
>>> lista = [1, 2, 3]
>>> tupla_convertida = tuple(lista)
>>> print(tupla_convertida)
(1, 2, 3)
>>>
>>> tupla = (4, 5, 6)
>>> lista_convertida = list(tupla)
>>> print(lista_convertida)
[4, 5, 6]
>>> |
```

## exercícios

<details>
<summary>Lista de Exercícios</summary>

1. nível simples
    1. **Acessando Elementos**: Crie uma tupla com 5 números inteiros. Escreva um loop `for` que percorra a tupla e imprima cada elemento.
    1. **Índices e Elementos**: Crie uma tupla com 4 strings. Escreva um loop `while` que percorra a tupla e imprima o índice e o valor de cada elemento.
    1. **Verificação de Presença**: Crie uma tupla com alguns números. Escreva um loop `for` que verifica se o número 7 está presente na tupla e, se estiver, imprima "Número encontrado".
    1. **Contando Elementos**: Crie uma tupla com 6 números inteiros. Use um loop `for` para contar quantos números na tupla são maiores que 10.
    1. **Tupla de Tuplas**: Crie uma tupla contendo outras tuplas dentro dela. Escreva um loop `for` que percorra cada sub-tupla e imprima seus elementos.
1. nível intermediário
    1. **Comparando Tuplas**: Crie duas tuplas de números inteiros. Escreva um loop `while` que compare elemento por elemento as duas tuplas e imprima qual tupla tem o maior número naquele índice.
    1. **Soma de Elementos**: Crie uma tupla com 5 números inteiros. Use um loop `for` para calcular e imprimir a soma de todos os elementos da tupla.
    1. **Verificação de Índices**: Crie uma tupla com 8 elementos. Use um loop `while` para verificar se o terceiro e o sexto elementos são iguais. Imprima "Iguais" ou "Diferentes" conforme o caso.
    1. **Busca em Tupla**: Crie uma tupla com 6 strings. Escreva um loop `for` que percorra a tupla e, se encontrar a string "Python", imprima "Linguagem encontrada!" e pare o loop.
    1. **Filtros com If**: Crie uma tupla de números inteiros. Escreva um loop `for` que percorra a tupla e imprima apenas os números pares.
1. nível avançado
    1. **Tuplas com Condicionais**: Crie uma tupla com 5 números inteiros. Escreva um loop `for` que verifique se cada número é maior que 10. Se for, imprima "Maior que 10", caso contrário, imprima "Menor ou igual a 10".
    1. **Contagem de Itens**: Crie uma tupla com vários números, alguns deles repetidos. Escreva um loop `while` que percorra a tupla e conte quantas vezes o número 3 aparece.
    1. **Tupla de Strings**: Crie uma tupla de strings. Escreva um loop `for` que percorra a tupla e, para cada string, verifique se ela começa com a letra "A". Se sim, imprima "Começa com A".
    1. **Busca com Condicional**: Crie uma tupla com números inteiros. Escreva um loop `while` que percorra a tupla e verifique se há algum número negativo. Se encontrar, imprima "Número negativo encontrado" e termine o loop.
    1. **Verificação de Maior Número**: Crie uma tupla com 5 números. Escreva um loop `for` que encontre e imprima o maior número da tupla.
1. nível complexo
    1. **Comparando Duas Tuplas**: Crie duas tuplas de números. Escreva um loop `while` que percorra ambas as tuplas e imprima qual número é maior em cada índice correspondente.
    1. **Tuplas Aninhadas**: Crie uma tupla que contenha outras tuplas dentro. Escreva um loop `for` que percorra cada sub-tupla e verifique se o primeiro elemento é maior que o segundo. Imprima "Sim" ou "Não" conforme o caso.
    1. **Verificação de Todos os Elementos**: Crie uma tupla de números inteiros. Escreva um loop `for` que verifique se todos os elementos são positivos. Se algum número for negativo, imprima "Número negativo encontrado" e interrompa o loop.
    1. **Tuplas e Condicionais**: Crie uma tupla com números e escreva um loop `while` que percorra a tupla. Se o número for maior que 20, multiplique-o por 2 e imprima o resultado.
    1. **Acessando Sub-Tuplas**: Crie uma tupla de 3 sub-tuplas, cada uma contendo 2 números. Escreva um loop `for` que percorra cada sub-tupla e some os números de cada uma, imprimindo o resultado.
1. nível muito complexo
    1. **Comparação de Listas e Tuplas**: Crie uma lista e uma tupla com números inteiros. Escreva um loop `for` que percorra ambos e imprima qual estrutura tem o maior número em cada índice correspondente.
    1. **Filtragem em Tuplas**: Crie uma tupla com vários números. Escreva um loop `while` que percorra a tupla e crie uma nova tupla contendo apenas os números pares.
    1. **Tupla e Contador**: Crie uma tupla de números inteiros. Escreva um loop `for` que percorra a tupla e use um contador para contar quantos números são maiores que 15.
    1. **Análise de Dados**: Crie uma tupla com temperaturas registradas durante uma semana. Escreva um loop `while` que percorra a tupla e identifique quantos dias tiveram temperatura acima de 30 graus.
    1. **Tuplas e Índices**: Crie uma tupla de números. Escreva um loop `for` que percorra a tupla e imprima apenas os números que estão em índices pares.
    1. **Busca de Substrings**: Crie uma tupla de strings. Escreva um loop `for` que percorra a tupla e imprima apenas as strings que contêm a substring "py".
    1. **Verificação de Múltiplos de 5**: Crie uma tupla com números inteiros. Escreva um loop `while` que percorra a tupla e verifique se cada número é múltiplo de 5. Imprima "Múltiplo de 5" ou "Não é múltiplo de 5" conforme o caso.
    1. **Contagem de Vogais**: Crie uma tupla de strings. Escreva um loop `for` que percorra cada string na tupla e conte quantas vogais há em cada uma, imprimindo o resultado.
    1. **Tupla de Pares e Ímpares**: Crie uma tupla de números. Escreva um loop `while` que percorra a tupla e crie duas novas tuplas, uma contendo apenas os números pares e outra contendo apenas os ímpares.
    1. **Comparação de Sub-Tuplas**: Crie uma tupla de sub-tuplas, onde cada sub-tupla contém dois números. Escreva um loop `for` que percorra cada sub-tupla e verifique se a soma dos dois números é maior que 10. Imprima "Sim" ou "Não" conforme o caso.

</details>


# tipos-int-float.md

# tipos int e float

## operação de atribuição composta

A operação de atribuição composta no Python é uma maneira concisa de combinar uma operação aritmética ou lógica com a atribuição de valor a uma variável. Em vez de escrever a operação completa de forma explícita, é possível usar um operador de atribuição composto, que realiza a operação e, ao mesmo tempo, atribui o resultado à mesma variável.

A sintaxe geral para uma operação de atribuição composta é :

```python
variável operador= valor
```

Isso é equivalente a:
```python
variável = variável operador valor
```

### exemplos

Aqui estão alguns exemplos de operadores de atribuição compostos e como eles funcionam :

1. **Adição composta `+=`**
    ```python
    x = 5
    x += 3  # equivale a x = x + 3
    print(x)  # saída : 8
    ```

1. **Subtração composta `-=`**
    ```python
    x = 5
    x -= 2  # equivale a x = x - 2
    print(x)  # saída : 3
    ```

1. **Multiplicação composta `*=`**
    ```python
    x = 4
    x *= 3  # equivale a x = x * 3
    print(x)  # saída : 12
    ```

1. **Divisão composta `/=`**
    ```python
    x = 10
    x /= 2  # equivale a x = x / 2
    print(x)  # saída : 5.0
    ```

1. **Módulo composto `%=`**
    ```python
    x = 10
    x %= 3  # equivale a x = x % 3
    print(x)  # saída : 1
    ```

1. **Exponenciação composta `**=`**
    ```python
    x = 2
    x **= 3  # equivale a x = x ** 3
    print(x)  # saída : 8
    ```

1. **Divisão inteira composta `//=`**
    ```python
    x = 10
    x //= 3  # equivale a x = x // 3
    print(x)  # saída : 3
    ```

<!-- 1. **Operador bitwise AND composto `&=`**
    ```python
    x = 5  # 0b0101
    x &= 3  # 0b0011, equivale a x = x & 3
    print(x)  # saída : 1 (0b0001)
    ``` -->

<!-- 1. **Operador bitwise OR composto `|=`**
    ```python
    x = 5  # 0b0101
    x |= 2  # 0b0010, equivale a x = x | 2
    print(x)  # saída : 7 (0b0111)
    ``` -->

<!-- 1. **Operador bitwise XOR composto `^=`**
    ```python
    x = 5  # 0b0101
    x ^= 3  # 0b0011, equivale a x = x ^ 3
    print(x)  # saída : 6 (0b0110)
    ``` -->

### vantagens

- **código mais conciso** : reduz a repetição, tornando o código mais limpo e fácil de ler;
- **desempenho** : em algumas situações, operações compostas podem ser ligeiramente mais eficientes, embora a diferença geralmente seja mínima;


# tipos-mutaveis-imutaveis.md

# tipos mutáveis e imutáveis

## tipos imutáveis

Os tipos **imutáveis** em Python são aqueles cujos valores não podem ser alterados após sua criação. Quando se altera um valor, o Python cria um novo objeto em vez de modificar o objeto existente. Isso tem implicações importantes para a maneira como se lida com variáveis e objetos no Python.

Os principais tipos imutáveis em Python são :

1. **números (inteiros e ponto flutuante)**
1. **strings (`str`)**
1. **tuplas (`tuple`)**
1. **frozensets (`frozenset`)**

### 1. números

Os tipos numéricos imutáveis em Python incluem inteiros (`int`), números de ponto flutuante (`float`), e números complexos (`complex`).

Exemplos :

```python
>>> x = 10  # inteiro
>>> y = 3.14  # ponto flutuante
>>> z = 1 + 2j  # número complexo
```

Se alterar o valor de uma variável numérica, um novo objeto é criado. O objeto antigo permanece inalterado, e a variável passa a referenciar o novo objeto.

```python
>>> x = 10
>>> x = 20
>>> # x agora referencia um novo objeto (20)
```

Qualquer operação que pareça alterar o valor de um número cria um novo objeto e não modifica o objeto original.

### 2. strings (`str`)

Strings são sequências imutáveis de caracteres. Elas são definidas usando aspas simples `'` ou duplas `"`.

Exemplo :

```python
>>> s = "Olá, Mundo!"
```

Operações como concatenação, repetição, ou substituição de caracteres criam novas strings em vez de alterar a string original.

```python
>>> s = "Olá"
>>> s = s + " Mundo"
>>> # cria uma nova string "Olá Mundo"
```

Strings não podem ser alteradas após a criação. Qualquer operação que pareça modificar a string resultará em uma nova string.

### 3. tuplas (`tuple`)

Tuplas são coleções ordenadas e imutáveis de elementos. São definidas usando parênteses `()` e os elementos são separados por vírgulas.

Exemplo :

```python
>>> t = (1, 2, 3, "quatro")
```

Não se pode alterar os elementos de uma tupla uma vez que ela é criada. Se precisar modificar uma tupla, terá que criar uma nova.

```python
>>> t = (1, 2, 3)
>>> # t[1] = 4  # isso resultaria em um erro
>>> t = (1, 4, 3)  # cria uma nova tupla
```

Qualquer tentativa de alterar os elementos da tupla ou sua estrutura resulta em um erro.

### 4. frozensets (`frozenset`)

Frozensets são conjuntos imutáveis. Ao contrário dos conjuntos normais, eles não permitem alterações após sua criação.

Exemplo

```python
>>> fs = frozenset([1, 2, 3, 4])
```

Não se pode adicionar, remover ou modificar elementos em um frozenset após sua criação. Qualquer tentativa de alteração resulta em um erro.

```python
>>> fs = frozenset([1, 2, 3])
>>> # fs.add(4)  # Isso resultaria em um erro
```

Frozensets são úteis quando se precisa de um conjunto cujos elementos não mudem ao longo do tempo e é importante que o conjunto possa ser usado como chave em um dicionário ou elemento em outro conjunto.

## tipos mutáveis

Em Python, um **tipo mutável** é um tipo de dado cujos valores podem ser alterados após sua criação. Diferente dos tipos imutáveis, onde qualquer alteração resulta na criação de um novo objeto, os tipos mutáveis permitem modificações diretas nos dados sem a necessidade de criar um novo objeto.

Os principais tipos mutáveis em Python são:

1. **listas (`list`)**
1. **dicionários (`dict`)**
1. **conjuntos (`set`)**

### 1. listas (`list`)

Listas são coleções ordenadas de elementos que podem ser de tipos variados. São definidas usando colchetes `[]` e os elementos são separados por vírgulas.

Exemplo :

```python
>>> minha_lista = [1, 2, 3, "quatro"]
```

Podese alterar um elemento específico da lista, por exemplo:

```python
>>> minha_lista[2] = "três"
```

Pode-se adicionar novos elementos com métodos como `append()` e `extend()`:

```python
>>> minha_lista.append(5)
>>> minha_lista.extend([6, 7])
```

Pode-se remover elementos com métodos como `remove()` e `pop()`:

```python
>>> minha_lista.remove("quatro")
>>> elemento = minha_lista.pop()
```

Alterar uma lista altera o próprio objeto lista, e todas as referências a essa lista verão as mudanças.

### 2. dicionários (`dict`)

Dicionários são coleções de pares chave-valor. São definidos usando chaves `{}` e os pares chave-valor são separados por vírgulas.

Exemplo :

```python
>>> meu_dict = {"nome": "Ana", "idade": 25}
```

Pode-se alterar o valor associado a uma chave existente:

```python
>>> meu_dict["idade"] = 26
```

Podese adicionar novos pares usando a chave:

```python
>>> meu_dict["cidade"] = "São Paulo"
```

Pode-se remover pares com `del` ou o método `pop()`:

```python
>>> del meu_dict["cidade"]
>>> idade = meu_dict.pop("idade")
```

Alterar um dicionário altera o próprio objeto dicionário. Todas as referências ao dicionário verão as mudanças.

### 3. conjuntos (`set`)

Conjuntos são coleções não ordenadas de elementos únicos. São definidos usando chaves `{}` e não permitem elementos duplicados.

Exemplo :

```python
>>> meu_set = {1, 2, 3}
```

Pode-se adicionar novos elementos com `add()`:

```python
>>> meu_set.add(4)
```

Pode-se remover elementos com `remove()` e `discard()`:

```python
>>> meu_set.remove(2)
>>> meu_set.discard(5)  # Não gera erro se o elemento não estiver presente
```

- **operações conjuntivas :** pode fazer operações como união, interseção e diferença:

```python
>>> outro_set = {3, 4, 5}
>>> uniao = meu_set.union(outro_set)
>>> intersecao = meu_set.intersection(outro_set)
>>> diferenca = meu_set.difference(outro_set)
```

Alterar um conjunto altera o próprio objeto conjunto. Todas as referências ao conjunto verão as mudanças.


# tipos-primitivos.md

Índice Tipos Primitivos

1. [informação](#informação)
1. [constantes](#constantes)
1. [variáveis](#variáveis)
1. [declarando variáveis](#declarando-variáveis)
1. [expressões aritméticas](#expressões-aritméticas)
1. [parênteses](#parênteses)
1. [prioridades](#prioridades)
1. [expressões lógicas](#expressões-lógicas)
1. [comandos de atribuição](#comandos-de-atribuição)

# tipos primitivos

## informação

Para entender os tipos primitivos, tem que estar atentos para um conceito muito importante, *a informação*.

Existe uma diferença sutil entre dado e informação. Ao citar uma data, por exemplo, 20 de setembro. Essa data sozinha, representa apenas um dado, mas ao dizer que é a data de início da Revolução Farroupilha, está sendo agregado um valor ao dado da data, apresentando uma informação.

Aproximando a maneira que o computador manipula as informações, pode-se dividir em quatro tipos primitivos, que são os tipos básicos que serão usados na construção de algoritmos.

- `inteiro` : é toda e qualquer informação numérica que pertença ao conjunto dos números inteiros (positivos, negativos e nulo). Exemplos :
    - ele tem 3 gatos;
    - eu tenho 10 dedos;
    - eu tinha 2 pulmões;
- `real` : é toda e qualquer informação numérica que pertença ao conjunto dos números reais (positivos, negativos e nulo). Exemplos :
    - o PI valor 3.1415926535;
    - o número de Euler vale 2.71828;
    - peguei 0.853 gramas de guisado;
- `caracter` : é toda e qualquer informação composta de um conjunto de caracteres numéricos  (0...9), alfabéticos (A...Z, a...z) e especiais (!@#$%,.). Esse tipo de dado está sempre entre aspas simples ou duplas. Exemplos :
    - minha senha é "s)Lf]\?[G8A$aQM:Fnr'/Orw;%qg$<*9";
    - o nome é "Arnold Schwarzenegger";
    - ela disse que "a resposta é 42";
- `lógico` : é toda e qualquer informação que pode assumir apenas duas situações. Exemplos :
    - a porta está **aberta** ou **fechada**;
    - a pessoa está **viva** ou **morta**;
    - a lâmpada está **ligada** ou **desligada**;

<details>
    <summary>Lista de Exercícios</summary>

Determine o tipo primitivo de cada uma das sentenças abaixo :

1. Eu vi 12 pássaros no parque.
    ```
    inteiro
    ```
1. A temperatura média do corpo humano é 36.5 graus Celsius.
    ```
    real
    ```
1. O nome do meu cachorro é "Buddy".
    ```
    caracter
    ```
1. A janela está aberta ou fechada?
    ```
    lógico
    ```
1. A altura da Torre Eiffel é 324 metros.
    ```
    inteiro
    ```
1. Minha senha é "A1b2C3d4!".
    ```
    caracter
    ```
1. Ele tem 4 filhos.
    ```
    inteiro
    ```
1. O número de Euler vale 2.71828.
    ```
    real
    ```
1. A porta está trancada ou destrancada?
    ```
    lógico
    ```
1. Eu tenho 5 irmãos.
    ```
    inteiro
    ```
1. A profundidade do oceano é 10.994 metros.
    ```
    real
    ```
1. O nome da cidade é "São Paulo".
    ```
    caracter
    ```
1. O computador está ligado ou desligado?
    ```
    lógico
    ```
1. O preço do litro de gasolina é 5.49 reais.
    ```
    real
    ```
1. Meu endereço de e-mail é "meuemail@exemplo.com".
    ```
    caracter
    ```
1. Quantos dedos há nas suas duas mãos?
    ```
    inteiro
    ```
1. O número de telefone é "123-456-7890".
    ```
    caracter
    ```
1. Você está feliz ou triste?
    ```
    lógico
    ```
1. A distância entre as duas cidades é 300 quilômetros.
    ```
    inteiro
    ```
1. Meu filme favorito é "O Senhor dos Anéis".
    ```
    caracter
    ```
1. O sinal está verde ou vermelho?
    ```
    lógico
    ```
1. A raiz quadrada de 64 é 8.
    ```
    inteiro
    ```
1. O nome da sua escola é "Escola Primária ABC".
    ```
    caracter
    ```
1. A lâmpada está ligada ou desligada?
    ```
    lógico
    ```
1. Eu bebi 1.5 litros de água hoje.
    ```
    real
    ```
1. A frase "Carpe Diem" é do latim.
    ```
    caracter
    ```
1. O céu está limpo ou nublado?
    ```
    lógico
    ```
1. Ele ganhou 15 pontos no jogo.
    ```
    inteiro
    ```
1. A área do círculo é 78.5 centímetros quadrados.
    ```
    real
    ```
1. A senha é "P@ssw0rd!".
    ```
    caracter
    ```
1. A música está tocando ou parada?
    ```
    lógico
    ```
1. Eu tenho 3 cachorros.
    ```
    inteiro
    ```
1. O valor de Pi é 3.1415926535.
    ```
    real
    ```
1. A janela está aberta ou fechada?
    ```
    lógico
    ```
1. O nome do autor é "J.K. Rowling".
    ```
    caracter
    ```
1. O carro está em movimento ou parado?
    ```
    lógico
    ```
1. A massa do objeto é 4.5 quilogramas.
    ```
    real
    ```
1. O número da sua conta bancária é "12345678".
    ```
    caracter
    ```
1. A comida está pronta ou crua?
    ```
    lógico
    ```
1. O dia está ensolarado ou chuvoso?
    ```
    lógico
    ```
1. O livro tem 350 páginas.
    ```
    inteiro
    ```
1. O peso do bebê é 3.2 quilogramas.
    ```
    real
    ```
1. O título do livro é "O Alquimista".
    ```
    caracter
    ```
1. O telefone está silencioso ou tocando?
    ```
    lógico
    ```
1. O preço do pão é 2.75 reais.
    ```
    real
    ```
1. A frase "Olá, mundo!" é comum na programação.
    ```
    caracter
    ```
1. A luz está acesa ou apagada?
    ```
    lógico
    ```
1. A soma de 5 e 3 é 8.
    ```
    inteiro
    ```
1. O nome do filme é "Matrix".
    ```
    caracter
    ```
1. Você está acordado ou dormindo?
    ```
    lógico
    ```
1. O comprimento do rio é 6.650 quilômetros.
    ```
    real
    ```
1. O endereço é "Rua das Flores, 123".
    ```
    caracter
    ```
1. O computador está ligado ou desligado?
    ```
    lógico
    ```
1. A profundidade do lago é 15 metros.
    ```
    inteiro
    ```
1. O valor da resistência é 10 ohms.
    ```
    inteiro
    ```
1. O nome do seu animal de estimação é "Fido".
    ```
    caracter
    ```
1. A janela está aberta ou fechada?
    ```
    lógico
    ```
1. O saldo da conta é 1023.75 reais.
    ```
    real
    ```
1. A frase "A prática leva à perfeição" é um provérbio.
    ```
    caracter
    ```
1. O céu está limpo ou nublado?
    ```
    lógico
    ```
1. O prédio tem 20 andares.
    ```
    inteiro
    ```
1. O peso do pacote é 2.3 quilogramas.
    ```
    real
    ```
1. O nome do jogo é "Minecraft".
    ```
    caracter
    ```
1. A luz está acesa ou apagada?
    ```
    lógico
    ```
1. A área da sala é 45 metros quadrados.
    ```
    inteiro
    ```
1. A sequência de caracteres é "!@#$%^&*()".
    ```
    caracter
    ```
1. O telefone está tocando ou silencioso?
    ```
    lógico
    ```
1. O número de páginas lidas é 200.
    ```
    inteiro
    ```
1. A densidade do material é 7.85 g/cm³.
    ```
    real
    ```
1. O nome da rua é "Avenida Paulista".
    ```
    caracter
    ```
1. A porta está aberta ou fechada?
    ```
    lógico
    ```
1. O valor da pressão é 101.3 kPa.
    ```
    real
    ```
1. O título da música é "Bohemian Rhapsody".
    ```
    caracter
    ```
1. A comida está quente ou fria?
    ```
    lógico
    ```
1. O comprimento do campo é 100 metros.
    ```
    inteiro
    ```
1. A palavra "Python" é uma linguagem de programação.
    ```
    caracter
    ```
1. O carro está em movimento ou parado?
    ```
    lógico
    ```
1. O valor da nota é 9.5.
    ```
    real
    ```
1. O nome da banda é "The Beatles".
    ```
    caracter
    ```
1. A janela está aberta ou fechada?
    ```
    lógico
    ```
1. A quantidade de açúcar é 250 gramas.
    ```
    inteiro
    ```
1. O número do apartamento é "302".
    ```
    caracter
    ```
1. A luz está acesa ou apagada?
    ```
    lógico
    ```
1. O tempo de corrida foi 2.5 horas.
    ```
    real
    ```
1. O nome do software é "Microsoft Word".
    ```
    caracter
    ```
1. O carro está ligado ou desligado?
    ```
    lógico
    ```
1. A distância até a lua é 384400 quilômetros.
    ```
    inteiro
    ```
1. O nome do livro é "1984".
    ```
    caracter
    ```
1. A temperatura da água é 25 graus Celsius.
    ```
    inteiro
    ```
1. O peso do peixe é 1.7 quilogramas.
    ```
    real
    ```
1. A frase "A resposta é 42" é do livro "Guia do Mochileiro das Galáxias".
    ```
    caracter
    ```
1. O computador está ligado ou desligado?
    ```
    lógico
    ```
1. O número de folhas é 100.
    ```
    inteiro
    ```
1. A massa do planeta é 5.97 x 10^24 quilogramas.
    ```
    real
    ```
1. O nome da cor é "Azul".
    ```
    caracter
    ```
1. A porta está trancada ou destrancada?
    ```
    lógico
    ```
1. O valor da corrente é 0.5 amperes.
    ```
    real
    ```
1. O título do artigo é "Impacto das Mudanças Climáticas".
    ```
    caracter
    ```
1. A lâmpada está ligada ou desligada?
    ```
    lógico
    ```
1. O número de série é "SN12345678".
    ```
    caracter
    ```

</details>

## constantes

Entende-se um dado como constante quando seu valor não sofre qualquer variação no decorrer do tempo, ou seja, o valor é constante do início ao fim da execução do algoritmo. Ele pode ser usado para representar um valor conhecidamente imutável, como o valor 3.14159265 do PI, ou quando não se quer que ele seja alterado durante a execução do algoritmo, como especificar o nome de um autor (J. R. R. Tolkien) de um livro (O Hobbit).

## variáveis

Um dado é classificado como variável quando tem a possibilidade de ser alterado a qualquer momento durante a execução do algoritmo. Por exemplo, calcular a média de uma turma somando todas as notas e depois dividindo pela quantidade de alunos, ou usar um contador para contar quantas vezes é realizada uma repetição de alguma coisa, como o quicar de uma bola no chão.

Um exemplo prático de ambos os casos (variáveis e constantes) seria o uso de uma fórmula matemática. O cálculo da área do círculo é dado por pi vezes o raio ao quadrado. O pi é o valor constante da fórmula, ele jamais vai mudar. Enquanto que o raio é a variável, onde a cada execução ele poderá ter um valor diferente.

## declarando variáveis

No ambiente computacional, as informações variáveis são guardadas em dispositivos eletrônicos chamados de **memória**. Pode-se imaginar que essa memória é como um armário repleto de gavetas, que são usadas para armazenar objetos.

Esse armário tem diversas gavetas, então é necessário diferenciar uma da outra. Isso é feito com indentificadores, etiquetas, rótulos. Cada gaveta (variável) pode guardar apenas um dado, um objeto de cada vez.

> [!NOTE]
> o Python, diferente de outras linguagens como C, C++, Java, não possui variáveis restritas a um tipo primitivo; uma variável pode ser hora inteiro, hora uma lista, hora uma string;

Portanto, é preciso definir nomes para determinadas gavetas especificando qual o material dos objetos que lá estão armazenados. Declarar variáveis é usado para identificar dados.

Por exemplo :
- nome = "Arnold"
- idade = 76
- altura = 1.88

### nomes

Para declarar uma variável, é necessário seguir algumas regras :
- elas devem começar por um caractere alfabético;
- podem ser seguidos por mais caracteres alfanuméricos e sublinhado;
- não podem ser usados caracteres especias;
- não pode haver espaço entre as palavras de identificação das variáveis;
- exemplo :
    - nomes válidos : nome, idade, id4d3, nome_completo, imc;
    - nomes inválidos : 1nome, 4_altura, !passagem, nome completo;

Também há algumas boas práticas para serem seguidas :
- não usar acentuação nos nomes de variáveis;
- usar o padrão de nomenclatura [*snake_case*](https://www.alura.com.br/artigos/convencoes-nomenclatura-camel-pascal-kebab-snake-case#snake-case) para as variáveis, constantes, funções;
- usar o padrão SCREAMING_SNAKE_CASE para constantes;

O Python usa essas convenções de boas práticas para facilitar a legibilidade dos códigos e padronizar. Também é necessário que se faça um nome para as variáveis que faça sentido com o dado que ela armazenará.

- usar `x = "Schwarzenegger` não é claro quanto a que a variável armazena;
- usar `sobrenome = "Schwarzenegger` torna muito mais claro que tipo de dado aquela variável guarda;

<details>
    <summary>Lista de Exercícios</summary>

Identifique quais são e o porquê dos nomes de variáveis serem válidos ou inválidos :

1. variavel1
1. 2variavel
1. var_iavel
1. var-iavel
1. variavel nome
1. #variavel
1. variavel_
1. var@iavel
1. variavel!
1. variavel#
1. variavel
1. variável
1. vari_avel
1. var*
1. var&
1. variavel.
1. variavel,
1. variavel;
1. variavel:
1. variavel?
1. variavel<
1. variavel>
1. variavel=
1. variavel+
1. variavel-
1. variavel/
1. variavel\\
1. variavel|
1. variavel~
1. variavel$
1. variavel%
1. variavel^
1. variavel(
1. variavel)
1. variavel[
1. variavel]
1. variavel{
1. variavel}
1. variavel"1
1. variavel'1
1. variavel1'
1. variavel 1
1. variavel
1. variavel
1. var__iavel
1. (variavel)
1. -var_iavel
1. variavel___
1. variavel__
1. variavel_1_

</details>

## expressões aritméticas

É denominado expressão aritmética aquela cujos operadores são aritméticos e cujos operandos são constantes ou variáveis do tipo inteiro ou real.

Os operadores, por sua vez, são o conjunto de símbolos que representa as operações básicas da matemática.

| Operador | Função | Exemplo |
| ---- | ---- | ---- |
| `+` | Adição | `30 + 12`, `X + 12` |
| `-` | Subtração | `2 - 3`, `Y - 12` |
| `*` | Multiplicação | `7 * 3`, `A * Z` |
| `/` | Divisão | `10 / 5`, `n1 / n2` |
| `**` | Potenciação | `2 / 10`, `n2 ** n2` |

> [!TIP]
> Lembre que, uma operação de radiciação (tirar a raiz), nada mais é do que uma operação de potência.
>
> Exemplo : a raiz quadrada de 5 pode ser escreta como `5 ** (1/2)`;

<details>
  <summary>Lista de Exercícios</summary>

Para os exercícios abaixo, use variáveis e constantes quando achar necessário.

1. Exercícios Simples
    1. Calcule a soma de 5 e 3.
        ```
        5 + 3
        ```
    1. Subtraia 8 de 15.
        ```
        15 - 8
        ```
    1. Multiplique 4 por 6.
        ```
        4 * 6
        ```
    1. Divida 20 por 4.
        ```
        20 / 4
        ```
    1. Calcule 2 elevado à potência de 3.
        ```
        2 ** 3
        2 ^ 3
        ```
    1. Calcule a soma de 7, 3 e 2.
        ```
        7 + 3 + 2
        ```
    1. Subtraia 5 de 10 e depois subtraia 3.
        ```
        (10 - 5) - 3
        ```
    1. Multiplique 3, 2 e 4.
        ```
        3 * 2 * 4
        ```
    1. Divida 25 por 5 e depois por 2.
        ```
        (25 / 5) / 2
        ```
    1. Calcule 5 elevado à potência de 2 e subtraia 3.
        ```
        (5 ** 2) - 3
        ```
1. Exercícios de Nível Intermediário
    1. Calcule a soma de 4, 5 e 6 e depois multiplique o resultado por 2.
        ```
        (4 + 5 + 6) * 2
        ```
    1. Subtraia 10 de 25, depois divida o resultado por 3.
        ```
        (25 - 10) / 3
        ```
    1. Calcule 3 elevado à potência de 2 e depois adicione 7.
        ```
        (3 ** 2) + 7
        ```
    1. Multiplique 8 por 3, depois subtraia 10.
        ```
        (8 * 3) - 10
        ```
    1. Divida 36 por 6, depois adicione 2 e multiplique por 3.
        ```
        ((36 / 6) + 2) * 3
        ```
    1. Calcule 2 elevado à potência de 4 e depois subtraia 5.
        ```
        (2 ** 4) - 5
        ```
    1. Calcule a soma de 6 e 7, depois divida o resultado por 2.
        ```
        (6 + 7) / 2
        ```
    1. Subtraia 14 de 28, depois multiplique o resultado por 3.
        ```
        (28 - 14) * 3
        ```
    1. Calcule 4 elevado à potência de 3 e depois adicione 5.
        ```
        (4 ** 3) + 5
        ```
    1. Multiplique 9 por 4, depois subtraia 15 e divida o resultado por 3.
        ```
        ((9 * 4) - 15) / 3
        ```
1. Exercícios Avançados
    1. Calcule a soma de 5, 8 e 12, depois multiplique o resultado por 2 e subtraia 10.
        ```
        ((5 + 8 + 12) * 2) - 10
        ```
    1. Subtraia 15 de 45, depois divida o resultado por 5 e adicione 7.
        ```
        ((45 - 12) / 5) + 7
        ```
    1. Calcule 2 elevado à potência de 5 e depois subtraia 9 e multiplique por 2.
        ```
        ((2 ** 5) - 9) * 2
        ```
    1. Multiplique 7 por 6, depois adicione 10 e divida por 4.
        ```
        ((7 * 6) + 10) / 4
        ```
    1. Divida 72 por 8, depois adicione 5 e multiplique por 3.
        ```
        ((72 / 8) + 5) * 3
        ```
    1. Calcule 3 elevado à potência de 3 e depois subtraia 8 e divida por 2.
        ```
        ((3 ** 3) - 8) / 2
        ```
    1. Calcule a soma de 9 e 14, depois multiplique por 3 e subtraia 5.
        ```
        ((9 + 14) * 3) - 5
        ```
    1. Subtraia 20 de 60, depois divida por 4 e adicione 7.
        ```
        ((60 - 20) / 4) + 7
        ```
    1. Calcule 4 elevado à potência de 4 e depois subtraia 20 e multiplique por 2.
        ```
        ((4 ** 4) - 20) * 2
        ```
    1. Multiplique 10 por 5, depois adicione 8 e divida por 6.
        ```
        ((10 * 5) + 8) / 6
        ```
1. Exercícios Complexos
    1. Calcule a soma de 12, 8 e 5, depois multiplique o resultado por 3, subtraia 15 e divida por 2.
        ```
        (((12 + 8 + 5) * 3) - 15) / 2
        ```
    1. Subtraia 18 de 50, depois divida por 4, adicione 7 e multiplique por 3.
        ```
        (((50 - 18) / 4) + 7) * 3
        ```
    1. Calcule 5 elevado à potência de 3, depois subtraia 10, multiplique por 2 e adicione 8.
        ```
        (((5 ** 3) - 10) * 2) + 8
        ```
    1. Multiplique 6 por 7, depois adicione 12, divida por 3 e subtraia 4.
        ```
        (((6 * 7) + 12) / 3) - 4
        ```
    1. Divida 81 por 9, depois adicione 5, multiplique por 4 e subtraia 10.
        ```
        (((81 / 9) + 5) * 4) - 10
        ```
    1. Calcule 2 elevado à potência de 6, depois subtraia 20, divida por 2 e multiplique por 3.
        ```
        (((2 ** 6) - 20) / 2) * 3
        ```
    1. Calcule a soma de 7, 13 e 18, depois multiplique por 4, subtraia 25 e divida por 5.
        ```
        (((7 + 13 + 18) * 4) - 25) / 5
        ```
    1. Subtraia 30 de 90, depois divida por 5, adicione 9 e multiplique por 2.
        ```
        (((90 - 30) / 5) + 9) * 2
        ```
    1. Calcule 3 elevado à potência de 4, depois subtraia 50, multiplique por 3 e adicione 20.
        ```
        (((3 ** 4) - 50) * 3) + 20
        ```
    1. Multiplique 8 por 9, depois adicione 20, divida por 7 e subtraia 3.
        ```
        (((8 * 9) + 20) / 7) - 3
        ```
1. Exercícios Muito Complexos
    1. Calcule a soma de 15, 9 e 7, depois multiplique por 2, subtraia 10, divida por 3 e adicione 5.
        ```
        ((((15 + 9 + 7) * 2) - 10) / 3) + 5
        ```
    1. Subtraia 25 de 100, depois divida por 5, adicione 8, multiplique por 3 e subtraia 7.
        ```
        ((((100 - 25) / 5) + 8) * 3) - 7
        ```
    1. Calcule 4 elevado à potência de 3, depois subtraia 15, multiplique por 2, adicione 10 e divida por 5.
        ```
        ((((4 ** 3) - 15) * 2) + 10) / 5
        ```
    1. Multiplique 11 por 6, depois adicione 30, divida por 4, subtraia 8 e multiplique por 2.
        ```
        ((((11 * 6) + 30) / 4) - 8) * 2
        ```
    1. Divida 144 por 12, depois adicione 7, multiplique por 3, subtraia 20 e divida por 2.
        ```
        ((((144 / 12) + 7) * 3) - 20) / 3
        ```
    1. Calcule 5 elevado à potência de 4, depois subtraia 30, divida por 2, multiplique por 3 e adicione 10.
        ```
        ((((5 ** 4) - 30) / 2) * 3) + 10
        ```
    1. Calcule a soma de 8, 14 e 22, depois multiplique por 5, subtraia 40, divida por 4 e adicione 6.
        ```
        ((((8 + 14 + 22) * 5) - 40) / 4) + 6
        ```
    1. Subtraia 50 de 200, depois divida por 10, adicione 15, multiplique por 2 e subtraia 5.
        ```
        ((((200 - 50) / 10)/ + 15) * 2) - 5
        ```
    1. Calcule 6 elevado à potência de 3, depois subtraia 40, multiplique por 4, adicione 25 e divida por 3.
        ```
        ((((6 ** 3) - 40) * 4) + 25) / 3
        ```
    1. Multiplique 9 por 7, depois adicione 50, divida por 5, subtraia 10, multiplique por 3 e adicione 15.
        ```
        (((((9 * 7) + 50) / 5) - 10) * 3) + 15
        ```

</details>

Ainda há alguns operadores aritméticos não usuais, mas que são muito úteis na construção de algoritmos. São eles o `resto` da divisão inteira e o `quociente` da divisão inteira. Cada um traz como resultado o que é especificado.

| Operador | Função | Exemplo |
| ---- | ---- | ---- |
| `%` | Resto | `12 % 3`, `X % 11` |
| `//` | Quociente | `10 // 3`, `X // 20` |

Por exemplo :
- `11 % 3` irá retornar o resto da divisão, que será `2`;
- `11 // 3` irá retornar o quociente da divisão, que será `3`;

Os operadores de resto e quociente inteiros são úteis em diversos cenários, entre os quais categorizar números ou separar seus algarismos.

Por exemplo, para verificar se um número é par ou ímpar, basta verificar o resto da divisão por 2. Os restos possíveis para essa divisão são apenas 2, `1` ou `0`. Números pares sempre irão gerar resto igual a zero, enquanto que números ímpares sempre irão gerar um resto igual a um.

- `12 % 2` terá como resto 0;
- `11 % 2` terá como resto 1;

Ele também pode ser usado para separar um número inteiro. Para isso, basta realizar divisões sucessivas por 10 para obter seus algarismos.

Por exemplo :
- `1947 % 10` terá como resto 7 (unidade);
- `194 % 10` terá como resto 4 (dezena);
- `19 % 10` terá como resto 9 (centena);
- `1 % 10` terá como resto 1 (milhas);

## parênteses

Diferente da matemática, onde se usam parênteses `()`, colchetes `[]` e chaves `{}` para representar diferentes níveis de uma equação, na programação usa-se apenas parênteses `()`, em todos os níveis. Veja uma comparação abaixo :
- na `matemática` : 7 * {4 - [2 / (1 + 2)] * 10}
- na `programação` : 7 * (4 - (2 / (1 + 2)) * 10)

Isso permite criar níveis muito profundos de uso de parênteses :
- 7 + (4 * 1 + (3 / (2 - (9 * 4) - (1 * 1) / 3) + (2 * 21)) + 10)

## prioridades

Na resolução das expressões aritméticas, as operações guardam uma hierarquia entre si

| prioridade | operadores |
| :----: | :----: |
| 1 | parênteses mais internos |
| 2 | ** |
| 3 | * / % // |
| 4 | + - |

Em caso de empate (operadores de mesma prioridade), deve-se resolver da esquerda para a direita, conforme a sequência da própria expressão. Se for necessário alterar essa prioridade, usa-se parênteses. Veja alguns exemplos :
```
5 + 9 + 3 / 2
5 + 9 + 1.5
14 + 1.5
15.5
```

```
5 + (9 + 3) / 2
5 + 12 / 2
5 + 6
11
```

<details>
  <summary>Mais Exercícios</summary>

1. Exercícios Simples
    1. Calcule o resto da divisão de 15 por 4.
        ```
        15 % 4 = 3
        ```
    1. Encontre o quociente da divisão inteira de 20 por 3.
        ```
        20 // 3 = 6
        ```
    1. Calcule 25 % 6 + 8.
        ```
        25 % 6 + 8
        1 + 8 = 9
        ```
    1. Encontre o quociente da divisão de 45 por 7 e adicione 3.
        ```
        45 // 7 + 3
        6 + 3 = 9
        ```
    1. Calcule o resto da divisão de 30 por 5 e multiplique por 4.
        ```
        30 % 5 * 4
        0 * 4 = 0
        ```
1. Exercícios de Nível Intermediário
    1. Encontre o quociente da divisão de 50 por 8 e subtraia 2.
        ```
        (50 // 8) - 2
        6 - 2 = 4
        ```
    1. Calcule 18 % 5 + 3 * 2.
        ```
        (18 % 5) + (3 * 2)
        3 + 6 = 9
        ```
    1. Encontre o quociente da divisão de 35 por 4 e multiplique por 2.
        ```
        35 // 4 * 2
        8 * 2 = 16
        ```
    1. Calcule o resto da divisão de 40 por 9 e adicione 7.
        ```
        40 % 9 + 7
        4 + 7 = 11
        ```
    1. Encontre o quociente da divisão de 60 por 11 e adicione o resto da divisão de 27 por 4.
        ```
        60 // 11 + 27 % 4
        5 + 3 = 8
        ```
1. Exercícios Avançados
    1. Calcule 48 % 10 + 6 // 3.
        ```
        48 % 10 + 6 // 3
        8 + 2 = 10
        ```
    1. Encontre o quociente da divisão de 81 por 9 e subtraia 5 % 2.
        ```
        81 // 9 - 5 % 2
        9 - 1 = 8
        ```
    1. Calcule 9 ** 2 % 7 + 4.
        ```
        81 % 7 + 4
        4 + 4 = 8
        ```
    1. Encontre o quociente da divisão de 100 por 15 e multiplique por 3 % 4.
        ```
        100 // 15 * 3 % 4
        6 * 3 % 4
        18 % 4 = 2
        ```
    1. Calcule o resto da divisão de 64 por 8 e adicione 36 // 6.
        ```
        64 % 8 + 36 // 6
        0 + 6 = 6
        ```
1. Exercícios Complexos
    1. Encontre o quociente da divisão de 49 por 6 e subtraia 14 % 5.
        ```
        49 // 6 - 14 % 5
        8 - 4 = 4
        ```
    1. Calcule 72 % 10 + 7 // 2 * 3.
        ```
        2 + 3 * 3
        2 + 9 = 11
        ```
    1. Encontre o quociente da divisão de 95 por 8 e adicione 25 % 6.
        ```
        95 // 8 + 25 % 6
        11 + 1 = 12
        ```
    1. Calcule 3 ** 3 % 4 + 20 // 3.
        ```
        27 % 4 + 6
        3 + 6 = 9
        ```
    1. Encontre o quociente da divisão de 120 por 11 e subtraia 44 % 7.
        ```
        120 // 11 - 44 % 7
        10 - 2 = 8
        ```
1. Exercícios Muito Complexos
    1. Calcule 150 % 11 + 18 // 4 * 2.
        ```
        7 + 4 * 2
        7 + 8 = 15
        ```
    1. Calcule 6 ** 2 % 5 + 88 // 9.
        ```
        36 % 5 + 9
        1 + 9 = 10
        ```
    1. Calcule o resto da divisão de 220 por 15 e adicione 100 // 7.
        ```
        220 % 15 + 100 // 7
        10 + 14 = 24
        ```
    1. Encontre o quociente da divisão de 140 por 12 e multiplique por 50 % 8.
        ```
        140 // 12 * 50 % 8
        11 * 50 % 8
        550 % 8 = 6
        ```
    1. Encontre o quociente da divisão de 200 por 17 e adicione 60 % 9.
        ```
        200 // 17 + 60 % 9
        11 + 6 = 17
        ```

</details>

## expressões lógicas

É entendido como expressão lógica aquela cujos operadores são lógicos ou relacionais e cujos operadores são relações ou variáveis ou constantes do tipo lógico.

### operadores relacionais

Usa-se `operadores relacionais` para realizar comparações entre dois valores de mesmo tipo primitivo, que podem ser representados como constantes, ou variáveis ou expressões aritméticas. Eles são usados para construir equações.

| Operador | Função | Exemplo |
| :----: | :----: | :----: |
| `==` | igual a | `3 == 2`, `"a" == "a"` |
| `>` | maior que | `5 > 4`, `X > Y` |
| `<` | menor que | `5 < 4`, `A < Z` |
| `>=` | maior ou igual a | `12 >= 5`, `C >= A` |
| `<=` | menor ou igual a | `12 <= 5`, `C <= A` |
| `!=` | diferente de | `2 != 10`, `n2 != n2` |

O resultado obetido de uma relação é sempre um valor **lógico**. Por exemplo, analisando a relação numérica `X + Y == Z`, o resultado será verdade ou falso à medida que o valor da expressão aritmética `X + Y` seja igual ou diferente do conteúdo da variável `C`.

### operadores lógicos

Existem três `operadores lógicos` básicos que são usados para a formação de novas proposições lógicas compostas a partir de outras proposições lógicas simples.

| Operador | Função |
| :----: | :----: |
| `not` | negação |
| `and` | conjunção |
| `or` | disjunção |

### tabelas-verdade

Tabela-verdade é o conjunto de todas as possibilidades combinatórias entre os valores de diversas variáveis lógicas, as quais se encontram em apenas duas situações (True para verdadeiro ou False para falso), e um conjunto de operadores lógicos.

Veja as tabelas verdades :

- Operação de negação

| A | not A |
| :----: | :----: |
| `True` | `False` |
| `False` | `True` |

- Operação de conjunção

| A | B | A and B |
| :----: | :----: | :----: |
| `True` | `True` | `True` |
| `True` | `False` | `False` |
| `False` | `True` | `False` |
| `False` | `False` | `False` |

- Operação de disjunção

| A | B | A or B |
| :----: | :----: | :----: |
| `True` | `True` | `True` |
| `True` | `False` | `True` |
| `False` | `True` | `True` |
| `False` | `False` | `False` |

Alguns exemplos práticos :
- Se chover `e` trovejar, eu fico em casa.
    - Como é possível ver, usou-se o conectivo `e` (que no Python é usado como `and`) para verificar se a proposição *ficar em casa* será satisfeita. A pessoa ficará em casa apenas se chover **E** trovejar, se ambas forem verdade ao mesmo tempo.<br><br>
- Se chover `ou` trovejar, eu fico em casa.
    - Agora, usando o operadore `ou` (que no Python é usado como `or`) indica que a pessoa ficará vem casa se chover **OU** se trovejar, aumentando as chaves de não sair de casa.<br><br>
```python
2 < 5 and 15/3 == 6
 True and 5 == 6
 True and False
     False
```
```python
2 < 5 or 15/3 == 6
 True or 5 == 6
 True or False
     True
```
```python
False or 20 // (18 / 3) != (21 / 3) // 2
False or 20 // 6 != 7 // 2
False or 3 != 3
False or False
    False
```
```python
not True or (3 ** 2) / 3 < 15 - 35 % 7
not True or 9 / 3 < 15 - 0
not True or 3 < 15
not True or True
   False or True
        True
```

### prioridades

Vaja na tabela abaixo a prioridade entre os operadores lógicos :

| prioridade | operadores |
| :----: | :----: |
| 1 | not |
| 2 | and |
| 3 | or |

E por fim, veja a prioridade entre todos os operadores :

| prioridade | operadores |
| :----: | :----: |
| 1 | parênteses mais internos |
| 2 | operadores aritméticos |
| 3 | operadores relacionais |
| 4 | operadores lógicos |

<details>
  <summary>Lista de Exercícios</summary>

1. Exercícios Simples
    1. Verifique se 5 + 3 é igual a 8.
        ```
        5 + 3 == 8
        True
        ```
    1. Verifique se 10 - 4 é diferente de 5.
        ```
        10 - 4 != 5
        True
        ```
    1. Verifique se 7 * 2 é maior que 13.
        ```
        7 * 2 > 13
        True
        ```
    1. Verifique se 16 / 4 é menor ou igual a 4.
        ```
        16 / 4 <= 4
        True
        ```
    1. Verifique se 3 ** 2 é maior ou igual a 9.
        ```
        3 ** 2 >= 9
             9 >= 9
              True
        ```
1. Exercícios de Nível Intermediário
    1. Verifique se 12 % 5 é igual a 2 e 3 * 4 é maior que 11.
        ```
        12 % 5 == 2 and 3 * 4 > 11
             2 == 2 and 12 > 11
               True and True
                   True
        ```
    1. Verifique se 15 // 2 é diferente de 7 ou 8 + 2 é menor que 11.
        ```
        15 // 2 != 7 or 8 + 2 < 11
        True
        ```
    1. Verifique se 18 % 4 é igual a 2 e 9 / 3 é igual a 3.
        ```
        18 % 4 == 2 and 9 / 3 == 3
        True
        ```
    1. Verifique se 5 ** 2 é menor que 30 ou 6 - 1 é maior que 4.
        ```
        5 ** 2 < 30 or 6 - 1 > 4
        True
        ```
    1. Verifique se 20 // 3 é maior ou igual a 6 e 7 + 8 é igual a 15.
        ```
        20 // 3 >= 6 and 7 + 8 == 15
        True
        ```
1. Exercícios Avançados
    1. Verifique se 25 % 7 é menor que 4 e 3 ** 2 é igual a 9.
        ```
        25 % 7 < 4 and 3 ** 2 == 9
             4 < 4 and 9 == 9
             False and True
                  False
        ```
    1. Verifique se 14 // 5 é maior que 2 ou 10 / 2 é diferente de 5.
        ```
        14 // 5 > 2 or 10 / 2 != 5
        False
        ```
    1. Verifique se 30 % 8 é igual a 6 e 5 * 2 é menor ou igual a 10.
        ```
        30 % 8 == 6 and 5 * 2 <= 10
        True
        ```
    1. Verifique se 27 // 4 é menor que 7 ou 4 ** 2 é igual a 16.
        ```
        27 // 4 < 7 or 4 ** 2 == 16
        True
        ```
    1. Verifique se 21 % 6 é diferente de 3 e 12 / 4 é maior ou igual a 3.
        ```
        21 % 6 != 3 and 12 / 4 >= 3
        False
        ```
1. Exercícios Complexos
    1. Verifique se 35 % 9 é menor que 8 e 6 // 2 é igual a 3.
        ```
        35 % 9 < 8 and 6 // 2 == 3
        False
        ```
    1. Verifique se 40 // 7 é maior que 5 ou 9 ** 2 é diferente de 81.
        ```
        40 // 7 > 5 or 9 ** 2 != 81
        True
        ```
    1. Verifique se 48 % 11 é igual a 4 e 10 * 2 é maior que 19.
        ```
        48 % 11 ==F 4 and 10 * 2 > 19
              4 == 4 and 20 > 19
                True and True
                    True
        ```
    1. Verifique se 50 // 6 é menor ou igual a 8 ou 12 / 3 é igual a 4.
        ```
        50 // 6 <= 8 or 12 / 3 == 4
        True
        ```
    1. Verifique se 33 % 7 é maior que 3 e 14 - 6 é menor ou igual a 8.
        ```
        33 % 7 > 3 and 14 - 6 <= 8
        True
        ```
1. Exercícios Muito Complexos
    1. Verifique se 100 % 12 é diferente de 4 e 11 * 3 é menor que 34.
    1. Verifique se 12 * 5 é maior que 59 and 20 // 5 é igual a 4.
    1. Verifique se 15 % 4 é igual a 3 and 9 ** 2 é maior que 80.
    1. Verifique se 18 % 7 é igual a 4 or 32 / 4 é maior que 8.
    1. Verifique se 18 / 3 é diferente de 6 and 12 * 2 é maior que 22.
    1. Verifique se 20 + 10 é igual a 30 or 15 // 3 é menor ou igual a 5.
    1. Verifique se 24 / 4 é maior que 5 and 11 - 6 é diferente de 5.
    1. Verifique se 25 - 5 é igual a 20 or 14 + 6 é menor que 21.
    1. Verifique se 27 % 4 é igual a 3 or 7 ** 2 é menor ou igual a 49.
    1. Verifique se 28 + 7 é diferente de 35 or 21 // 7 é menor que 4.
    1. Verifique se 30 + 15 é maior que 44 or 27 // 9 é igual a 3.
    1. Verifique se 30 // 5 é maior que 5 and 9 + 6 é igual a 15.
    1. Verifique se 33 // 5 é maior ou igual a 6 and 18 - 9 é igual a 9.
    1. Verifique se 35 - 7 é diferente de 28 or 16 / 4 é igual a 4.
    1. Verifique se 36 / 6 é igual a 6 and 7 ** 2 é diferente de 50.
    1. Verifique se 40 % 7 é menor que 6 or 12 * 2 é igual a 24.
    1. Verifique se 40 // 5 é maior que 7 and 8 ** 2 é igual a 64.
        ```
        40 // 5 > 7 and 8 ** 2 == 64
              8 > 7 and 64 == 64
               True and True
                   True
        ```
    1. Verifique se 45 % 8 é menor que 6 and 14 * 2 é igual a 28.
    1. Verifique se 50 - 20 é maior que 29 or 25 + 6 é igual a 31.
    1. Verifique se 55 // 6 é maior que 9 and 22 + 8 é igual a 30.
    1. Verifique se 60 % 13 é igual a 8 e 15 // 4 é diferente de 3.
    1. Verifique se 60 - 25 é diferente de 34 or 10 ** 2 é igual a 100.
    1. Verifique se 70 // 8 é menor que 9 ou 8 ** 2 é igual a 64.
    1. Verifique se 75 + 25 é igual a 100 or 45 % 6 é menor que 4.
    1. Verifique se 8 ** 2 é maior que 63 and 14 % 3 é igual a 2.
    1. Verifique se 80 - 30 é maior ou igual a 50 and 6 ** 3 é diferente de 216.
    1. Verifique se 81 % 10 é menor ou igual a 1 e 18 / 2 é maior que 8.
    1. Verifique se 9 + 3 é maior que 11 and 15 - 7 é igual a 8.
    1. Verifique se 90 // 11 é maior que 8 ou 20 - 5 é igual a 15.
    1. Verifique se 99 - 11 é diferente de 88 or 18 / 3 é igual a 6.

</details>

## comando de atribuição

Um comando de atribuição permite armazenar um valor em uma variável (ainda usando a analogia do armário, equivalente a guardar na gaveta). Para o comando de atribuição funcionar, é usado o sinal de igual `=`.

Veja exemplos :
- `numero = 10`
- `nome_completo = 'Arnold Schwarzenegger'`

A ordem de atribuição será sempre da direita para a esquerda, isto é, a variável `nome` está recebendo a string `'Arnold Schwarzenegger'` para ser armazenada dentro dela. Tenha em mente que, se outro nome for atribuído à variáve, o valor antigo será perdido para todo sempre.

Sempre use nome de variáveis que sejam compatíveis com o que ela vai armazenar, isso facilita a ligibilidade do código.


# tipos-python.md

Índice Tipos Python

1. [tipos int e float](#tipos-int-e-float)
1. [variáveis](#variáveis)
1. [tipo strings](#tipo-strings)
1. [manipulando strings](#manipulando-strings)
1. [indexando strings](#indexando-strings)
1. [dividindo strings](#dividindo-strings)
1. [tipo lógico](#tipo-lógico)

# tipos do python

Veja agora alguns dos tipos do Python.

## int e float

O interpretador funciona como uma calculadora simples. A expressão que for digitada será executada e a resposta será apresentada. Os operadores usados são os mesmos da matemática.
- `+` para adição;
- `-` para subtração;
- `*` para multiplicação;
- `/` para divisão;

Veja alguns exemplos :
```python
>>> 1 + 1
2
>>> 50 - 8
42
>>> 3 * 5
15
>>> 4 / 2
2.0
>>> |
```

Assim como na matemática, os parênteses podem ser usados para mudar a ordem de execução dos operadores. Se for necessário, mais parênteses internos podem ser adicionados.

```python
>>> 10 * 4 + 2
42
>>> 10 * (4 + 2)
60
>>>
>>> # o IMC é calculado usando o peso divido pelo quadrado da altura
>>> 90 / (1.8 * 1.8)
27.777777777777775
>>>
>>> 10 / 3 + 2 - 5 * -2 * 1
15.333333333333334
>>> (10 / (3 + 2) - 5 * (-2 * 1))
12.0
>>> |
```

Repare que o resultado da divisão foi o que apresentou maior diferença em todas as respostas. Surgiu um `.0` junto ao dois, no primeiro exemplo. Isso acontece por haver distinção entre os tipos numéricos.

Os **números inteiros** são aqueles que não apresentação valor fracionário (2, 3, 5, 7, 12, 42). São representados pela sigla `int`.

Os números que possuem a parte fracionária, são chamados de **números de ponto flutuante** (3.14, 1.81, 2.0). São representados pela sigla `float`. Os números do tipo float são especificados com um ponto `.` em vez da vírgula `,` como é usado no Brasil. Isso acontece porque a vírgula é usada para separar itens. Se fizer `3,14`, o Python irá interpretar como sendo dois números de uma tupla (veremos o que é mais adiante), o número 3 seguido do número 14.

Uma divisão **SEMPRE** irá retornar um valor do tipo float, mesmo se o resultado tiver uma parte fracionária zerada (3.000000000000). Para realizar uma divisão e captar apenas a parte inteira (o quociente), usa-se o operador `//`. Para recuperar apenas o resto da divisão, usa-se o operador `%`. Em termos de precedência dos operadores, eles são equivalentes da multiplicação e divisão.

Veja abaixo alguns exemplos :
```python
>>> 76 / 5  # divisão tradicional sempre retorna um float, dividendo / divisor
15.2000
>>> 76 // 5  # o operador // retorna a parte inteira da divisão, o quociente
15
>>> 76 % 5  # o operador % retorna o resto da divisão
1
>>> 15 * 5 + 1  # quociente * divisor + resto = dividendo
76
>>> |
```
<img
    src="https://matematicafacil.mat.br/cursos/ensinofundamental/4aserie/blog6741.jpg"
    alt="imagem dos elementos da divisão"
    width="65%">

Com o Python, é possível usar o operador `**` para calcular potências e raízes :
```python
>>> 5 ** 2  # 5 ao quadrado
25
>>> 2 ** 7  # 2 elevado na potência 7
128
>>> 36 ** (1/2)  # raiz quadrada de 36
6.0
>>> |
```

E assim como na matemática, os operadores também tem sua ordem de execução :
1. `()`
1. `**`
1. `*` `/` `//` `%`
1. `+` `-`

Além de `int` e `float`, o Python também suporta outros tipos de números, como `Decimal` e `Fraction` usando pacotes específicos. E, também, há suporte nativo a números complexos, usando os sufixos `j` ou `J` para indicar a parte imaginária.

```python
>>> 3+5j
(3+5j)
>>>
>>> 3+5j - 2-3j
(1+2j)
>>> |
```

## variáveis
Nos exemplos acima, todos os valores usados, uma vez que foram calculados, eram perdidos. O resultado da equação `2 ** 7` vai ser mostrado e descartado. É necessário que toda linguagem de programação seja capaz de aceitar, armazenar e nomear dados.

Um programa deve ser capaz de receber dados do teclado (ou de outra parte do seu programa) e associar a um nome aquele dado. Este dado pode ser um valor simples ou múltiplos valores que são associados a um nome. Dados que são associados a um nome e que guarda dado é chamada de *variável*. Pense na variável como uma caixa com um nome do lado de fora dela e que pode colocar o que quiser dentro.

O Python possui muitas formas diferentes de armazenar listas de dados. É conveniente associar nomes aos dados. O sinal de igual `=` é usado para atribuir um valor a uma variável.
```python
>>> idade = 76
>>> nome = 'Arnold Schwarzenegger'
>>>
>>> idade
61
>>> nome
'Arnold Schwarzenegger'
>>> 2024 - idade
1948
>>> |
```

Caso tente-se usar uma variável não definida, irá levantar um erro :
```python
>>> numero
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'numero' is not defined
>>> |
```

Com o uso de variáveis, é possível armazenar o valor para usar posteriormente.

### pep 8 - variáveis
<details>
  <summary>Detalhes</summary>

Quando você escreve código, é necessário dar nome para muitas coisas: variáveis, funções, classes, pacotes e por aí vai. Escolher nomes corretos irá poupar seu tempo e energia mais tarde.

Por exemplo, é uma péssima prática usar l, O ou I como nome de variáveis. Dependendo da fonte usada, essas letras podem se passar e serem confundidas com 1 e 0.
```python
>>> O = 2  # não é recomendado
>>> O  # isso seria um zero ou a letra o maíuscula?
2
>>> |
```
Fazendo isso, parece que se está tentando salvar o valor 2 no valor zero, o que é impossível.

#### nomes das variáveis
As variáveis devem iniciar com o primeiro caractere sendo uma letra (há outro caractere permitido, mas será visto bem mais tarde). Depois do primeiro, pode-se usar números também. Espaços não são permitidos para os nomes, então é usado o sublinhado `_` para separar as palavras. Variáveis também não podem possuir acentuações ou cedilhas nos nomes.

Lembrando que esse tipo de nomenclatura é conhecida como [*snake_case*](https://www.alura.com.br/artigos/convencoes-nomenclatura-camel-pascal-kebab-snake-case#snake-case).

```python
>>> # variáveis com nomes permitidos
>>> resposta = 42
>>> resposta
42
>>> valor1 = 12
>>> valor1
12
>>> valor_2 = 20
>>> valor_2
20
>>> primeiro_nome = 'Arnold'
>>> primeiro_nome
'Arnold'
>>> # nomes de variáveis que não são recomendados ou que geram erro
>>> ação = 'atacar'
>>> ação
'atacar'
>>> 2_dois = 2
  File "<stdin>", line 1
    2_dois = 2
     ^
SyntaxError: invalid decimal literal
>>> primeiro nome = 'Arnold'
  File "<stdin>", line 1
    primeiro nome = 'Arnold'
             ^^^^
SyntaxError: invalid syntax
>>> |
```

#### nomes proibidos
O Python possui diversas palavras-chave que não podem ser usadas como nomes de variáveis. Se algum valor for tentado associar a ela, irá levantar um erro de sintaxe :

```python
>>> if = 10
  File "<stdin>", line 1
    if = 10
       ^
SyntaxError: invalid syntax
>>> and = 50
  File "<stdin>", line 1
    and = 50
    ^^^
SyntaxError: invalid syntax
>>> while = 1
  File "<stdin>", line 1
    while = 1
          ^
SyntaxError: invalid syntax
>>> for = 10
  File "<stdin>", line 1
    for = 10
        ^
SyntaxError: invalid syntax
>>> return = 20
  File "<stdin>", line 1
    return = 20
           ^
SyntaxError: invalid syntax
>>>
>>> # Mais algumas palavras reservadas :
>>> # pass if elif else while for break continue and or not in is import from
>>> # as try except raise finally with del print def return yield del global
>>> # class exec lambda assert
```

</details>

## exercícios de números

<details>
  <summary>Lista de Exercícios</summary>

Para os exercícios abaixo, use variáveis e comentários quando achar necessário.

Apesar de serem exercícios com muitos cálculos matemáticos, o objetivo deles não é a resposta em si, mas como transformar uma fómula matemática em um algoritmo para ser usado com Python.

Por exemplo, considere a fórmula do círculo.

<img
    src="https://s3.static.brasilescola.uol.com.br/be/2023/06/formula-da-area-do-circulo.jpg"
    alt="imagem dos elementos da divisão"
    width="45%">

Para transformar em algoritmo, pode se fazer de várias formas :

```python
>>> # método 1
>>> print(3.14 * 10 ** 2)
314.0
>>>
>>> # método 2
>>> raio = 10
>>> pi = 3.14
>>> print(pi * raio ** 2)
314.0
>>>
>>> # método 3
>>> raio = 10
>>> pi = 3.14
>>> area = pi * raio * raio
>>> print(area)
314.0
>>>
```

1. Exercícios Simples
    1. Calcule a área de um quadrado de lado 5.
        ```python
        lado = 5
        area = lado * lado  # método 1
        area = lado * 2  # método 2
        print('a área do quadrado é')
        print(area)
        print(lado * lado)
        ```
    1. Calcule a área de um retângulo de base 8 e altura 6.
        ```python
        base = 8
        altura = 6
        area = base * altura
        print('a área do retângulo é')
        print(area)
        ```
    1. Calcule o perímetro de um triângulo equilátero de lado 7.
        ```python
        lado = 7
        perimetro = lado + lado + lado  # método 1
        perimetro = lado * 3  # método 2
        print(perimetro)
        ```
    1. Calcule o volume de um cubo de lado 3.
        ```python
        lado = 3
        volume = lado * lado * lado  # método 1
        volume = lado ** 3  # método 2
        print(volume)
        ```
    1. Calcule a área de um círculo de raio 4 (use π = 3.14).
        ```python
        PI = 3.14
        raio = 4
        area = pi * raio ** 2
        print(area)
        ```
    1. Calcule a hipotenusa de um triângulo retângulo com catetos 3 e 4.
        ```python
        cateto1 = 3
        cateto2 = 4
        cat1_mais_cat2 = (cateto1 ** 1) + (cateto2 ** 2)
        hipotenusa = cat1_mais_cat2 ** (1/2)  # método 1
        hipotenusa = cat1_mais_cat2 ** 0.5  # método 2
        print(hipotenusa)
        ```
    1. Calcule a área de um triângulo de base 10 e altura 5.
        ```python
        base = 10
        altura = 5
        area = (base * altura) / 2
        print(area)
        ```
    1. Calcule o perímetro de um retângulo de base 9 e altura 4.
        ```python
        base = 9
        altura = 4
        perimetro = base * 2 + altura * 2
        print(perimetro)
        ```
    1. Calcule a área de um losango com diagonais 8 e 6.
        ```python
        diagonal1 = 8
        diagonal2 = 6
        area = diagonal1 * diagonal2 / 2
        print(area)
        ```
    1. Calcule o volume de um paralelepípedo de arestas 2, 3 e 5.
        ```python
        aresta1 = 2
        aresta2 = 3
        aresta3 = 5
        volume = aresta1 * aresta2 * aresta3
        print(volume)
        ```
1. Exercícios de Nível Intermediário
    1. Calcule a área de um trapézio com bases 7 e 5 e altura 4.
    1. Calcule o volume de uma esfera de raio 3 (use π = 3.14).
    1. Calcule a área lateral de um cilindro de raio 3 e altura 7 (use π = 3.14).
    1. Calcule o volume de um cone de raio 4 e altura 9 (use π = 3.14).
    1. Calcule a distância entre os pontos (1, 2) e (4, 6).
    1. Resolva a equação quadrática x² - 5x + 6 = 0 usando a fórmula de Bhaskara.
    1. Calcule a área de um hexágono regular de lado 6.
    1. Calcule o perímetro de um pentágono regular de lado 8.
    1. Calcule a área de um setor circular de raio 5 e ângulo 60° (use π = 3.14).
    1. Calcule o volume de um prisma de base triangular com lados 3, 4, 5 e altura 10.
1. Exercícios Avançados
    1. Calcule a área de um octógono regular de lado 7.
    1. Calcule a área total de um cilindro de raio 4 e altura 10 (use π = 3.14).
    1. Calcule o volume de uma pirâmide quadrangular de base 6 e altura 9.
    1. Calcule o comprimento da diagonal de um retângulo de lados 6 e 8.
    1. Calcule a área de um triângulo equilátero de lado 12.
    1. Calcule o volume de um tetraedro regular de aresta 5.
    1. Resolva a equação quadrática 2x² - 4x - 6 = 0 usando a fórmula de Bhaskara.
    1. Calcule a área de um polígono regular de 10 lados com lado 4.
    1. Calcule o volume de um cilindro de raio 5 e altura 12 (use π = 3.14).
    1. Calcule a distância entre os pontos (3, 5) e (9, 12).
1. Exercícios Complexos
    1. Calcule a área de um dodecágono regular de lado 8.
    1. Calcule o volume de uma esfera de raio 7 (use π = 3.14).
    1. Calcule a área de um triângulo isósceles de lados 10, 10 e 12.
    1. Calcule o volume de um tronco de cone com raios 5 e 3 e altura 8 (use π = 3.14).
    1. Resolva a equação quadrática 3x² - 12x + 9 = 0 usando a fórmula de Bhaskara.
    1. Calcule a área de um círculo inscrito em um triângulo de lados 6, 8 e 10 (use π = 3.14).
    1. Calcule o perímetro de um triângulo equilátero inscrito em um círculo de raio 6 (use π = 3.14).
    1. Calcule o volume de um prisma hexagonal de base 4 e altura 15.
    1. Calcule a área de um paralelogramo de base 9 e altura 6.
    1. Calcule a área total de um cone de raio 5 e geratriz 13 (use π = 3.14).
1. Exercícios Muito Complexos
    1. Calcule a área de um decágono regular de lado 10.
    1. Calcule o volume de uma pirâmide hexagonal de base 6 e altura 10.
    1. Calcule a área de um triângulo retângulo inscrito em um semicírculo de raio 8 (use π = 3.14).
        ```python
        # referência : http://www.osfantasticosnumerosprimos.com.br/005-texto-017-triangulos-pitagoricos-inscrito-semicircunferencia.html
        # todo triângulo retângulo inscrito em um semicírculo terá ângulos de 30, 60 e 90 graus.
        # SOHCAHTOA = sen=op/hip cos=ad/hip tan=op/ad
        # sen 30 graus = 1/2
        cat_op = (1/2) * 8
        cat_ad = ((3 ** (1/2)) / 2) * 8
        area = (cat_op * cat_ad) / 2
        print(area)
        ```
    1. Calcule o volume de um cilindro inscrito em um cubo de lado 10 (use π = 3.14).
    1. Resolva a equação quadrática x² - 4x - 12 = 0 usando a fórmula de Bhaskara.
    1. Calcule a área de um círculo circunscrito a um triângulo de lados 7, 24 e 25 (use π = 3.14).
    1. Calcule o volume de um dodecaedro regular de aresta 3.
    1. Calcule a área de um setor circular com raio 10 e ângulo 45° (use π = 3.14).
    1. Calcule a distância entre os pontos (2, -3) e (-4, 5).
    1. Calcule a área total de um cilindro inscrito em um cubo de lado 12 (use π = 3.14).

</details>

## tipo lógico

O tipo lógico, no Python, é conhecido como **Boolean**, que é representado por `bool`. Ele só pode ter dois valores, `True` e `False`, que são usados para representar a verdade ou falsidade de uma condição

| Operadores Lógicos |
| :----: |
| `not` |
| `and` |
| `or` |

| Operadores Relacionais | Função |
| :----: | :----: |
| `==` | igual a |
| `>` | maior que |
| `<` | menor que |
| `>=` | maior ou igual a |
| `<=` | menor ou igual a |
| `!=` | diferente de |

Veja abaixo alguns exemplos :

```python
print('not True = ', not True)
print('not False =', not False)

print('5 == 5 =', 5 == 5)
print('42 < 16 =', 42 < 16)
print('42 > 16 =', 42 > 16)
print('42 <= 42 =', 42 <= 42)
print('42 >= 43 =', 42 >= 43)
print('42 != 42 =', 42 != 42)

# usando para calcular média
media = (3 + 7 + 9) / 3
passou_de_ano = media >= 7
print('A aluno passou de ano?', passou_de_ano)
```



# tkinter.md

# índice

1. [para que serve](#para-que-serve)
1. [instalando](#instalando)
1. [como funciona](#como-funciona)
1. [classe `tk`](#classe-tk)
1. [elementos tkinter](#elementos-tkinter)
1. [`Label`](#label)
    1. [exercícios `Label`](#exercícios-label)
1. [`Button`](#button)
    1. [exercícios `Button`](#exercícios-button)
1. [`Entry`](#entry)
    1. [exercícios `Entry`](#exercícios-entry)
1. [`Text`](#text)
    1. [exercícios `Text`](#exercícios-text)
1. [`Listbox`](#listbox)
    1. [exercícios `Listbox`](#exercícios-listbox)
1. [`Checkbutton`](#checkbutton)
    1. [exercícios `Checkbutton`](#exercícios-checkbutton)
1. [`Radiobutton`](#radiobutton)
    1. [exercícios `Radiobutton`](#exercícios-radiobutton)
1. [gerenciadores de layout](#gerenciadores-de-layout)
    1. [exercícios gerenciadores de layout](#exercícios-gerenciadores-de-layout)
1. [variáveis](#variáveis)
    1. [exercícios variáveis](#exercícios-variáveis)
1. [callback](#callback)
1. [tkinter e `lambda`](#tkinter-e-lambda)
    1. [exercícios tkinter e `lambda`](#exercícios-tkinter-e-lambda)



# tkinter

O **Tkinter** é a biblioteca padrão do Python para a criação de interfaces gráficas (GUIs - Graphical User Interfaces). Ele fornece um conjunto de ferramentas para construir janelas, botões, caixas de texto, menus e outros elementos visuais que permitem a interação do usuário com o programa.

Essa biblioteca é uma interface para o toolkit gráfico **Tk**, que é multiplataforma. Isso significa que os programas criados com Tkinter funcionam em diferentes sistemas operacionais, como Windows, macOS e Linux, sem a necessidade de modificações no código.

## para que serve

O Tkinter é usado para criar aplicações com uma interface visual, permitindo que os usuários interajam com o programa de maneira mais intuitiva. Diferente dos programas baseados em linha de comando, onde o usuário digita comandos, as interfaces gráficas permitem cliques, inserções de texto, seleções de menus, etc.

Exemplos de programas que podem ser feitos com Tkinter incluem:
- calculadoras simples;
- gerenciadores de arquivos;
- ferramentas de anotação de texto;
- jogos simples;
- painéis de controle para automação de processos;

## instalando

O Tkinter já vem instalado na maioria das distribuições do Python, então, em muitos casos, não é necessário fazer uma instalação manual. Contudo, em alguns sistemas, especialmente em distribuições Linux, pode ser necessário instalar o Tkinter separadamente.

Antes de qualquer instalação, é possível verificar se o Tkinter já está disponível no seu Python. Basta rodar o seguinte comando em um terminal :

```bash
python -m tkinter
```

Se o Tkinter estiver instalado, uma janela será aberta. Caso contrário, uma mensagem de erro será exibida, indicando que o Tkinter não está presente.

### como instalar

#### Windows

No Windows, o Tkinter geralmente já vem junto com a instalação do Python, então não há a necessidade de instalar manualmente. No entanto, se estiver usando uma versão customizada do Python que não inclua o Tkinter, pode ser necessário reinstalar o Python a partir do site oficial ([python.org](https://www.python.org/)) e certificar-se de selecionar a opção "Tkinter" durante a instalação.

#### macOS

No macOS, o Tkinter também costuma vir pré-instalado com o Python. Contudo, se o Python que usado foi instalado via um gerenciador de pacotes como o Homebrew, pode ser necessário instalá-lo separadamente.

Para instalar o Python com suporte ao Tkinter pelo Homebrew, use os seguintes comandos :

```bash
brew install python-tk
```

#### Linux

Em muitas distribuições Linux, o Tkinter não vem incluído com o Python e precisa ser instalado separadamente. Os comandos variam dependendo da distribuição:

- **Ubuntu/Debian**

    ```bash
    sudo apt-get install python3-tk
    ```

- **Fedora**

    ```bash
    sudo dnf install python3-tkinter
    ```

- **Arch Linux**

    ```bash
    sudo pacman -S tk
    ```

#### Conda (Anaconda/Miniconda)

Se estiver usando o Anaconda ou Miniconda, o Tkinter pode ser instalado usando o seguinte comando no ambiente conda :

```bash
conda install -c anaconda tk
```

### testando

Após a instalação, para garantir que o Tkinter está funcionando corretamente, basta executar o mesmo comando testado anteriormente:

```bash
python -m tkinter
```

Se uma janela aparecer sem erros, a instalação foi bem-sucedida.

## como funciona

O Tkinter opera em um modelo de programação baseado em eventos. Isso significa que a aplicação "espera" por interações do usuário (como cliques ou entradas de teclado) e responde a essas interações de forma apropriada.

A estrutura básica de um programa com Tkinter envolve:
1. **Criação da janela principal :** o ponto de partida é a criação de uma janela principal (o "janela" ou "janela"), onde os elementos da interface serão colocados;
1. **Adição de widgets :** widgets são os componentes da interface gráfica, como botões, labels, caixas de entrada, etc; esses widgets são inseridos dentro da janela;
1. **Configuração de eventos :** cada widget pode responder a eventos específicos, como um clique de mouse ou uma tecla pressionada; o programador define o que deve acontecer quando um evento ocorre, associando funções a esses eventos;
1. **Loop de execução :** a aplicação Tkinter precisa estar em um loop contínuo, aguardando e processando eventos do usuário; isso é feito com o método `mainloop()`;

Veja um exemplo simples :

```python
# importa o módulo Tkinter
import tkinter as tk

# cria a janela principal (janela)
janela = tk.Tk()

# adiciona um rótulo (label) à janela
label = tk.Label(janela, text="Olá, Turma!")
label.pack()  # posiciona o rótulo na janela

# inicia o loop de eventos da janela
janela.mainloop()
```

Neste exemplo:
- é criada uma janela principal (`janela`);
- é adicionado um widget de rótulo (`Label`) com o texto "Olá, Mundo!";
- o método `pack()` é usado para posicionar o rótulo na janela;
- por fim, iniciamos o loop de eventos com `janela.mainloop()`;

## classe `tk`

A classe `Tk()` representa a **janela principal** de uma aplicação Tkinter. Ela é responsável por iniciar o loop de eventos e controlar todos os widgets que serão adicionados à interface. Ao criar uma instância de `Tk()`, se está essencialmente criando a janela principal de um aplicativo.

Veja um exemplo básico :

```python
# importa o módulo Tkinter
import tkinter as tk

# cria uma nova instância da classe Tk (a janela principal)
janela = tk.Tk()

# configura o título da janela
janela.title("Minha segunda janela com Tkinter")

# define o tamanho inicial da janela (largura x altura)
janela.geometry("400x300")

# inicia o loop de eventos da janela
janela.mainloop()
```

O que está acontecendo acima :

1. **Importação do módulo Tkinter** :
    - o Tkinter precisa ser importado antes de ser utilizado; aqui, `import tkinter as tk` é usado para tornar o código mais conciso, mas também poderia ser usado `import tkinter` diretamente;

2. **Criação da instância `Tk()`** :
    - o objeto `janela` é uma instância da classe `Tk()`, que representa a janela principal do programa; toda aplicação Tkinter precisa dessa instância como ponto de partida;
    - isso cria uma janela vazia que, por enquanto, não faz nada até que widgets sejam adicionados;

3. **Configuração do título da janela** :
    - usa-se `janela.title("Minha segunda janela com Tkinter")` para dar um título à janela, que aparecerá na barra superior;

4. **Configuração do tamanho da janela** :
    - a função `janela.geometry("400x300")` define as dimensões iniciais da janela, onde `"400x300"` indica que a janela terá 400 pixels de largura e 300 pixels de altura;

5. **Loop de eventos (`mainloop()`)** :
    - a chamada `janela.mainloop()` é essencial e serve para iniciar o loop de eventos do Tkinter; este loop aguarda interações do usuário (como cliques ou inserção de dados) e mantém a janela aberta até que o usuário a feche; sem esse loop, a janela desapareceria imediatamente após sua criação;

### métodos da instância `tk()`

Uma instância da classe `Tk()` possui diversos métodos que são usados para configurar a aplicação.

Veja a tabela abaixo :

| Nome do Método | Parâmetros | Descrição |
|----|----|----|
| `title()` | `title (str)` | define o título da janela |
| `geometry()` | `geometry_string (str)` | define o tamanho e a posição da janela no formato `"largura"x"altura"+"posição_x"+"posição_y"`. Exemplo: `"400x300+100+200"` |
| `resizable()` | `width (bool), height (bool)` | controla se a janela pode ser redimensionada horizontalmente (largura) e verticalmente (altura) |
| `minsize()` | `min_width (int), min_height (int)` | define o tamanho mínimo permitido da janela |
| `maxsize()` | `max_width (int), max_height (int)` | define o tamanho máximo permitido da janela |
| `iconbitmap()` | `bitmap_path (str)` | define o ícone da janela (somente no Windows) a partir de um arquivo `.ico` |
| `attributes()` | `-alpha (float)` | define a transparência da janela. O valor varia de `0` (completamente transparente) a `1` (completamente opaco) |
| `destroy()` | nenhum | Fecha a janela e encerra o loop de eventos |
| `mainloop()` | nenhum | Inicia o loop de eventos da aplicação, mantendo a janela aberta até que seja fechada |
| `configure()` | `**options` | modifica diversas opções de configuração da janela, como a cor de fundo (`bg`), borda, entre outras |
| `update()` | nenhum | Atualiza a janela, processando eventos pendentes.|
| `update_idletasks()` | nenhum | Processa apenas as tarefas pendentes que não exigem interação do usuário, como a renderização de widgets |
| `after()` | `time (int), func, *args` | executa a função `func` após o tempo especificado em milissegundos. Pode ser usado para agendar eventos futuros |
| `bind()` | `event (str), handler (func)` | associa um evento (como cliques ou pressionamento de teclas) a uma função. Exemplo: associar `<Button-1>` para detectar cliques com o mouse |
| `deiconify()` | nenhum | Restaura uma janela que foi minimizada |
| `withdraw()` | nenhum | Oculta a janela sem fechá-la |
| `lift()` | nenhum | Traz a janela para a frente de todas as outras janelas no sistema |
| `lower()` | nenhum | Envia a janela para trás de todas as outras janelas no sistema |
| `protocol()` | `name (str), func` | associa uma função ao fechamento da janela, por exemplo, capturando o evento de fechar a janela com `"WM_DELETE_WINDOW"` |

## elementos tkinter

### widgets

| Nome do Widget | Parâmetros Comuns | Explicação |
|---|---|---|
| [`Label`](#label) | `text`, `font`, `bg`, `fg`, `width`, `height` | exibe texto ou imagens |
| [`Button`](#button) | `text`, `command`, `width`, `height`, `bg`, `fg` | cria um botão clicável |
| [`Entry`](#entry) | `width`, `bg`, `fg`, `show` | permite a entrada de texto de uma única linha |
| [`Text`](#text) | `width`, `height`, `bg`, `fg`, `wrap` | permite a entrada e exibição de texto multilinha |
| [`Listbox`](#listbox) | `width`, `height`, `bg`, `fg`, `selectmode` | exibe uma lista de itens que podem ser selecionados |
| [`Checkbutton`](#checkbutton) | `text`, `variable`, `onvalue`, `offvalue`, `command` | cria uma caixa de seleção (checkbox) |
| [`Radiobutton`](#radiobutton) | `text`, `variable`, `value`, `command` | cria um botão de opção (radio button) dentro de um grupo |
| `Scale` | `from_`, `to`, `orient`, `length`, `tickinterval`, `resolution`, `command` | cria um controle deslizante (slider) para selecionar um valor numérico |
| `Scrollbar` | `orient`, `command` | cria uma barra de rolagem para navegar em conteúdo maior que a área visível |
| `Frame` | `bg`, `relief`, `bd` | cria um contêiner para organizar outros widgets |
| `Toplevel` | `bg`, `title` | cria uma nova janela de nível superior (semelhante à janela principal) |
| `Menu` || Cria uma barra de menus |
| `Menubutton` | `text`, `menu` | cria um botão que abre um menu suspenso |
| `Canvas` | `width`, `height`, `bg` | cria uma área para desenhar gráficos e formas |
| `Spinbox` | `from_`, `to`, `increment`, `values`, `wrap`, `command` | cria uma caixa de entrada com setas para cima e para baixo para selecionar um valor de uma lista ou intervalo |
| `PanedWindow` | `orient`, `showhandle`, `sashrelief`, `sashwidth` | cria uma janela com painéis redimensionáveis |
| `LabelFrame` | `text`, `bg`, `relief`, `bd` | cria um frame com um rótulo |
| `Message` | `text`, `bg`, `fg`, `width`, `aspect`, `justify`, `relief`, `bd` | exibe texto multilinha que se ajusta automaticamente à área disponível |
| `OptionMenu` | `variable`, `*values` | cria um menu suspenso para selecionar uma opção de uma lista |

### variáveis

| Nome da Variável | Parâmetros | Explicação |
|----|----|----|
| [`StringVar`](#stringvar)  | `value=None`  | armazena e gerencia valores do tipo `str`. Usada para associar widgets de texto, como `Entry` e `Label` |
| [`IntVar`](#intvar) | `value=None` | armazena e gerencia valores inteiros (`int`). Usada com widgets como `Radiobutton` e `Checkbutton` |
| [`DoubleVar`](#doublevar) | `value=None` | armazena e gerencia valores de ponto flutuante (`float`). Usada para valores numéricos, como em entradas ou cálculos |
| [`BooleanVar`](#booleanvar) | `value=None` | armazena e gerencia valores booleanos (`True` ou `False`). Usada para associar widgets como `Checkbutton` |

- `value`: O valor inicial que a variável irá armazenar. Por padrão, é `None` para `StringVar`, `IntVar`, `DoubleVar` e `BooleanVar`.

## `Label`

O **Label** é um widget simples usado para exibir textos ou imagens estáticas em uma janela. Ele é normalmente utilizado para rótulos, mensagens ou títulos em uma interface gráfica.

```python
label = tk.Label(parent, options...)
```

### parâmetros mais comuns

- **`parent`** (`Tk`, `Frame`) : a janela ou frame onde o rótulo será colocado (geralmente a instância `Tk()` ou um `Frame()`);
- **`text`** (`str`) : define o texto a ser exibido no rótulo;
- **`bg`** (`str`) : define a cor de fundo;
- **`fg`** (`str`) : define a cor do texto;
- **`font`** (`tuple`) : define a fonte, estilo e tamanho do texto;
- **`image`** (`PhotoImage`) : exibe uma imagem em vez de texto;
- **`padx`, `pady`** (`int`) : define o espaçamento horizontal e vertical ao redor do rótulo;

### exemplo

```python
import tkinter as tk

# criação da janela principal
janela = tk.Tk()
janela.title("Exemplo de Label")
janela.geometry("300x200")

# criando um rótulo (Label)
label = tk.Label(
    janela,
    text="Olá, Mundo!",
    font=("Arial", 20, "bold"),
    bg="lightblue",
    fg="#FFFFFF" # código hexadecimal para cor preta
)
# adicionando com padding
label.pack(padx=20, pady=20)

# iniciando o loop de eventos
janela.mainloop()
```

- **`text="Olá, Mundo!"`** : define o texto exibido;
- **`font=("Arial", 20)`** : define a fonte como Arial e o tamanho 20;
- **`bg="lightblue"` e `fg="black"`** : define a cor de fundo e a cor do texto;
- **`pack()`** : adiciona o rótulo à janela com espaçamento ao redor;

## exercícios `Label`

<details>
<summary>Lista de Exercícios</summary>

1. **Exibindo Texto Simples** : Crie uma janela com um `Label` que exiba o texto "Olá, Mundo!". Personalize o tamanho da janela e o tamanho da fonte do texto.
1. **Modificando Texto de um Label** : Crie um programa que contenha um botão e um `Label`. Ao clicar no botão, o texto do `Label` deve ser alterado para "Texto modificado!".
1. **Labels com Várias Fontes** : Crie três `Labels`, cada um exibindo o texto "Fonte A", "Fonte B" e "Fonte C", com diferentes estilos de fonte, tamanhos e cores.
1. **Exibindo Imagens em um Label** : Use o widget `Label` para exibir uma imagem (formato PNG ou JPG). Certifique-se de redimensionar a janela de acordo com a imagem.
1. **Label Dinâmico com Variável** : Crie um programa com uma `StringVar` e um `Label`. Modifique o valor da `StringVar` dinamicamente a cada 2 segundos para exibir diferentes mensagens no `Label`.
1. **Criando Labels com Fundo e Borda** : Crie dois `Labels` com textos diferentes. Um deve ter uma cor de fundo (background) personalizada e o outro deve ter uma borda (borderwidth) configurada.
1. **Label com Texto Longo e Quebra de Linha** : Crie um `Label` que exiba um texto longo e configure o widget para que o texto seja quebrado automaticamente em múltiplas linhas, ajustando a largura do widget.
1. **Centralizando um Label** : Crie um `Label` que seja centralizado horizontalmente e verticalmente dentro da janela. Use o método de layout `pack()` ou `grid()` para centralizar o widget.
1. **Interação entre Entry e Label** : Crie um programa com um `Entry` e um `Label`. O texto digitado no `Entry` deve aparecer em tempo real no `Label`, conforme o usuário digita.
1. **Alterando o Texto do Label com Radiobuttons** : Crie três `Radiobuttons`, cada um com uma cor como opção (vermelho, verde e azul). Quando o usuário selecionar uma das cores, o texto do `Label` deve mudar para "Você escolheu: [cor]".

</details>

---

## `Button`

O **Button** cria um botão interativo que pode realizar uma ação quando clicado. Ele pode exibir texto, uma imagem ou executar uma determinada ação.

```python
button = tk.Button(parent, options...)
```

### parâmetros mais comuns

- **`parent`** (`Widget`) : a janela ou frame onde o botão será colocado (geralmente uma instância `Tk()` ou `Frame()`);
- **`text`** (`str`) : define o texto exibido no botão;
- **`command`** (`function`) : define a função a ser chamada quando o botão for clicado (função sem parênteses, pois será chamada no evento de clique);
- **`bg`** (`str`) : define a cor de fundo do botão (nome da cor ou código hexadecimal);
- **`fg`** (`str`) : define a cor do texto no botão (nome da cor ou código hexadecimal);
- **`font`** (`tuple`) : define a fonte, estilo e tamanho do texto no botão (ex: `("Arial", 12, "bold")`);
- **`state`** (`str`) : define o estado do botão, como `"normal"` (ativo) ou `"disabled"` (desativado);

### exemplo

```python
import tkinter as tk

def on_click():
    label.config(text="Botão clicado!")

# criação da janela principal
janela = tk.Tk()
janela.title("Exemplo de Button")
janela.geometry("300x200")

# criando um rótulo (Label)
label = tk.Label(
    janela,
    text="Clique no botão",
    font=("Arial", 16))
label.pack(padx=10, pady=10)

# criando um botão (Button)
button = tk.Button(
    janela,
    text="Clique aqui",
    command=on_click,
    font=("Arial", 16),
    bg="lightgreen")
button.pack(padx=10, pady=10)

# iniciando o loop de eventos
janela.mainloop()
```

- **`command=on_click`** : especifica que, ao clicar no botão, a função `on_click()` será chamada;
- **`label.config()`** : atualiza o texto do rótulo dinamicamente quando o botão é clicado;
- **`bg="lightgreen"`** : define a cor de fundo do botão;

## exercícios `Button`

<details>
<summary>Lista de Exercícios</summary>

1. **Botão Simples** : Crie uma janela com um único botão que, quando clicado, exibe a mensagem "Botão Clicado!" no terminal (usando a função `print()`).
1. **Desabilitando e Habilitando o Botão** : Crie um programa com um botão que começa habilitado. Quando clicado, ele deve ser desativado (desabilitado). Adicione outro botão que reative o botão anterior.
1. **Botão que Muda o Texto de um Label** : Crie uma interface com um botão e um `Label`. Ao clicar no botão, o texto do `Label` deve mudar para "Botão Pressionado!".
1. **Botão com Cores Personalizadas** : Crie três botões, cada um com uma cor de fundo (background) e uma cor de texto (foreground) personalizada. Ao clicar em qualquer botão, exiba uma mensagem no terminal indicando qual botão foi clicado.
1. **Botão que Fecha a Janela** : Crie um programa com um botão que, ao ser clicado, fecha a janela do Tkinter (usando o método `destroy()`).
1. **Botão com Tamanho Ajustado** : Crie um botão com largura e altura definidas manualmente (usando os parâmetros `width` e `height`). Quando clicado, exiba uma mensagem no terminal indicando o tamanho do botão.
1. **Botão com Imagem** : Use o widget `Button` para criar um botão com uma imagem (formato PNG ou JPG) ao invés de texto. Quando o botão for clicado, exiba uma mensagem no terminal.
1. **Botão que Inicia e Para um Temporizador** : Crie um programa com dois botões: um para iniciar um temporizador que incrementa um contador a cada segundo e exibe o valor em um `Label`, e outro botão para parar o temporizador.
1. **Botão de Alternância (Toggle Button)** : Crie um botão que alterne entre dois estados: "ON" e "OFF". Quando estiver "ON", o botão deve exibir "Desligar" e, quando estiver "OFF", deve exibir "Ligar". Ao clicar, ele deve alternar entre os estados.
1. **Botão com Funções Diferentes para Clique Simples e Duplo** : Crie um programa com um botão que execute uma função ao ser clicado uma vez e outra função ao ser clicado duas vezes (usando os eventos `<Button-1>` para clique simples e `<Double-1>` para clique duplo).

</details>

---

## `Entry`

O **Entry** é um widget de entrada de texto de linha única, usado para coletar informações como nomes, senhas ou qualquer tipo de dado que caiba em uma única linha.

```python
entry = tk.Entry(parent, options...)
```

### parâmetros mais comuns

- **`parent`** (`Widget`) : a janela ou frame onde o campo de entrada será colocado (geralmente uma instância `Tk()` ou `Frame()`);
- **`textvariable`** (`Variable`) : associado a uma variável do tipo `StringVar()`, permite obter ou alterar o texto do campo dinamicamente;
- **`show`** (`str`) : define um caractere para ser exibido no lugar do texto digitado (geralmente usado para senhas);
- **`bg`** (`str`) : define a cor de fundo do campo de entrada;
- **`fg`** (`str`) : define a cor do texto dentro do campo de entrada;
- **`font`** (`tuple`) : define a fonte, estilo e tamanho do texto (ex: `("Arial", 12, "bold")`);
- **`state`** (`str`) : define o estado do campo de entrada, como `"normal"` (ativo) ou `"disabled"` (desativado);
- **`justify`** (`str`) : define o alinhamento do texto dentro do campo, como `"left"`, `"center"` ou `"right"`;
- **`width`** (`int`) : define a largura do campo de entrada em número de caracteres;

### métodos úteis

- **`get()`** : obtém o texto atual do campo;
- **`delete(start, end)`** (`int`, `int` ou `str`) : apaga o texto entre as posições `start` e `end`
    - se `end` for omitido, apaga a partir de `start` até o final;
    - também pode usar `"end"` para representar o final do texto;
- **`insert(index, string)`** (`int` ou `str`, `str`) : insere o texto (`string`) na posição especificada por `index`;
    - o `index` pode ser um número inteiro ou `"end"` para inserir no final do texto;

### exemplo

```python
import tkinter as tk

def mostra_digitado():
    digitado = entry.get()  # obtém o texto do campo
    label.config(text=f"Você digitou: {digitado}")

# criação da janela principal
janela = tk.Tk()
janela.title("Exemplo de Entry")
janela.geometry("300x150")

# criando um rótulo (Label)
label = tk.Label(janela, text="Digite algo:", font=("Arial", 12))
label.pack(padx=10, pady=10)

# criando um campo de entrada (Entry)
entry = tk.Entry(janela, font=("Arial", 12), bg="lightyellow")
entry.pack(padx=10, pady=10)

# botão para exibir o texto digitado
button = tk.Button(
    janela,
    text="Mostrar Texto",
    command=mostra_digitado,
    font=("Arial", 12))
button.pack(padx=10, pady=10)

# iniciando o loop de eventos
janela.mainloop()
```

- **`get()`** : obtém o valor atual do campo `Entry`;
- **`label.config()`** : atualiza o texto do rótulo com o valor obtido do campo;

## exercícios `Entry`

<details>
<summary>Lista de Exercícios</summary>

1. **Entrada Simples** : Crie uma janela com um widget `Entry` e um botão. Quando o botão for clicado, o texto inserido no `Entry` deve ser exibido no terminal (usando `print()`).
1. **Limpar Entrada** : Crie uma interface com um widget `Entry` e dois botões: um para exibir o conteúdo da entrada no terminal e outro para limpar o texto digitado no `Entry`.
1. **Entrada de Texto com Placeholder** : Crie um `Entry` que exiba um texto padrão (placeholder) quando vazio, como "Digite seu nome". O texto deve desaparecer quando o usuário começar a digitar.
1. **Verificar o Tamanho do Texto** : Crie um programa com um `Entry` e um botão. Quando o botão for clicado, o programa deve verificar se o texto inserido tem mais de 5 caracteres e, se for o caso, exibir "Texto válido" em um `Label`, ou "Texto muito curto" caso contrário.
1. **Entrada de Senha (Password Entry)** : Crie um `Entry` que oculte os caracteres digitados, como em um campo de senha. Exiba o valor inserido em um `Label` ao clicar em um botão.
1. **Entrada Numérica** : Crie um `Entry` que só permita a entrada de números inteiros (use validação ou o método `validatecommand`). Quando o valor for inserido, exiba-o em um `Label`.
1. **Entrada com Texto Capitalizado Automaticamente** : Crie um `Entry` onde o texto digitado seja automaticamente convertido para letras maiúsculas enquanto o usuário digita. Exiba o valor em um `Label`.
1. **Verificar se o Campo de Entrada Está Vazio** : Crie uma interface com um `Entry` e um botão. Quando o botão for clicado, o programa deve verificar se o campo de entrada está vazio e, se estiver, exibir uma mensagem de erro em um `Label`.
1. **Entrada com Limite de Caracteres** : Crie um `Entry` com um limite máximo de 10 caracteres. Se o usuário tentar digitar mais, impeça que os caracteres adicionais sejam adicionados. Exiba a contagem de caracteres restantes em tempo real em um `Label`.
1. **Exibir Texto Digitado em Tempo Real** : Crie um `Entry` e um `Label`. À medida que o usuário digita no `Entry`, o texto deve ser exibido em tempo real no `Label`, sem a necessidade de pressionar um botão.

</details>

---

## `Text`

O **Text** é um widget que permite a entrada e exibição de múltiplas linhas de texto, sendo bastante utilizado em caixas de texto onde o usuário pode escrever ou visualizar blocos de texto.

```python
text = tk.Text(parent, options...)
```

### parâmetros mais comuns

- **`parent`** (`Widget`) : a janela ou frame onde o campo de texto será colocado (geralmente uma instância `Tk()` ou `Frame()`);
- **`width`** (`int`) : define a largura do widget em número de caracteres;
- **`height`** (`int`) : define a altura do widget em número de linhas;
- **`bg`** (`str`) : define a cor de fundo do campo de texto (nome da cor ou código hexadecimal);
- **`fg`** (`str`) : define a cor do texto no campo de texto (nome da cor ou código hexadecimal);
- **`font`** (`tuple`) : define a fonte, estilo e tamanho do texto no campo de texto (ex: `("Arial", 12, "bold")`);
- **`state`** (`str`) : define o estado do campo de texto, como `"normal"` (ativo), `"disabled"` (desativado), ou `"readonly"` (somente leitura).

### métodos úteis

- **`get(start, end)`** (`str`, `str`) : obtém o texto do widget entre as posições `start` e `end`;
    - as posições podem ser índices no formato de string (ex: `"1.0"` para linha 1, coluna 0), ou palavras-chave como `"end"`;
- **`insert(position, text)`** (`str`, `str`) : insere o texto (`text`) no widget na posição especificada por `position`;
    - o `position` pode ser um índice no formato de string (ex: `"1.0"`) ou a palavra-chave `"end"`;
- **`delete(start, end)`** (`str`, `str`) : remove o texto entre as posições `start` e `end`;
    - as posições seguem o mesmo formato do método `get()`, podendo ser índices ou palavras-chave como `"end"`;


### exemplo

```python
import tkinter as tk

def mostra_texto():
    # obtém o texto do campo de texto
    texto_usuario = text_box.get("1.0", tk.END)
    # exibe o texto no rótulo
    label.config(text=texto_usuario)

# criação da janela principal
janela = tk.Tk()
janela.title("Exemplo de Text")
janela.geometry("400x300")

# criando um rótulo (Label)
label = tk.Label(
    janela,
    text="Digite algo abaixo:",
    font=("Arial", 14))
label.pack(padx=10, pady=10)

# criando um campo de texto (Text)
text_box = tk.Text(
    janela,
    width=40,
    height=5,
    font=("Arial", 12))
text_box.pack(padx=10, pady=10)

# criando um botão (Button) para exibir o texto digitado
button = tk.Button(
    janela,
    text="Exibir texto",
    command=mostra_texto,
    font=("Arial", 14),
    bg="lightblue")
button.pack(padx=10, pady=10)

# iniciando o loop de eventos
janela.mainloop()
```

- **`text_box.get("1.0", tk.END)`** : obtém todo o texto do campo, começando da linha 1, caractere 0 (`1.0`), até o fim (`tk.END`);
- **`text_box.insert()`** : pode ser usado para adicionar texto programaticamente ao widget;
- **`text_box.delete()`** : pode ser usado para apagar partes ou todo o conteúdo do widget;
- **`label.config()`** : atualiza o texto do rótulo para mostrar o conteúdo do campo de texto;

## exercícios `Text`

<details>
<summary>Lista de Exercícios</summary>

1. **Text Widget Básico** : Crie uma janela com um widget `Text` e um botão. Quando o botão for clicado, o conteúdo digitado no `Text` deve ser exibido no terminal (usando `print()`).
1. **Limpar Conteúdo do Text Widget** : Crie um widget `Text` com dois botões: um para exibir o conteúdo digitado e outro para limpar o conteúdo do widget.
1. **Contagem de Caracteres no Text Widget** : Crie um `Text` e um botão. Quando o botão for clicado, exiba a quantidade de caracteres inseridos no widget `Text` em um `Label`.
1. **Text Widget com Barra de Rolagem** : Crie um `Text` que possa exibir grandes blocos de texto e adicione uma barra de rolagem para permitir a navegação vertical do conteúdo.
1. **Busca de Texto no Widget** : Crie um programa com um `Text` e um `Entry`. Quando o usuário digitar uma palavra no `Entry` e pressionar um botão, destaque todas as ocorrências da palavra dentro do widget `Text`.
1. **Inserir Texto Programaticamente** : Crie um programa onde um botão insere um texto predefinido no `Text` sempre que clicado. O texto deve ser inserido no final do conteúdo já existente.
1. **Formatação de Texto (Negrito, Itálico)** : Crie um `Text` e dois botões: um para aplicar negrito e outro para aplicar itálico ao texto selecionado. Use tags do `Text` para alterar o estilo.
1. **Desabilitar Edição no Text Widget** : Crie um `Text` com um botão. O botão deve alternar entre habilitar e desabilitar a edição no `Text`, permitindo ou bloqueando o usuário de alterar o texto.
1. **Salvar Conteúdo do Text em um Arquivo** : Crie um programa com um `Text` e um botão "Salvar". Quando o botão for clicado, o conteúdo digitado no `Text` deve ser salvo em um arquivo de texto no disco.
1. **Contagem de Palavras no Text Widget** : Crie um programa que exiba a contagem de palavras inseridas no widget `Text` em tempo real, conforme o usuário digita. Exiba o número de palavras em um `Label`.

</details>

---

## `Listbox`

O **Listbox** exibe uma lista de itens, e o usuário pode selecionar um ou mais deles. Ele é útil para mostrar listas de opções, como listas de arquivos, opções de escolha múltipla, etc.

```python
listbox = tk.Listbox(parent, options...)
```

### parâmetros mais comuns

- **`parent`** (`Widget`) : a janela ou frame onde o widget será colocado (geralmente uma instância `Tk()` ou `Frame()`);
- **`selectmode`** (`str`) : define o modo de seleção; valores comuns são `"SINGLE"` para seleção única e `"MULTIPLE"` para seleção múltipla;
- **`height`** (`int`) : define o número de linhas visíveis no Listbox;
- **`bg`** (`str`) : define a cor de fundo do Listbox (nome da cor ou código hexadecimal);
- **`fg`** (`str`) : define a cor do texto no Listbox (nome da cor ou código hexadecimal);
- **`font`** (`tuple`) : define a fonte, estilo e tamanho do texto no Listbox (ex: `("Arial", 12, "bold")`);

### métodos úteis

- **`insert(index, *elements)`** (`int` ou `str`, `*str`) : insere os itens (`elements`) no Listbox na posição especificada por `index`;
    - o `index` pode ser um número inteiro ou `"end"` para inserir no final;
- **`delete(start, end)`** (`int`, `int` ou `str`) : remove itens entre as posições `start` e `end`;
    - o `end` pode ser omitido para deletar apenas um item, ou usar `"end"` para remover até o último item;
- **`get(start, end)`** (`int`, `int` ou `str`) : obtém os itens entre as posições `start` e `end`;
    - o `end` pode ser `"end"` para pegar até o último item;
- **`curselection()`** (`tuple`) : retorna uma tupla com os índices dos itens selecionados no Listbox.

### exemplo

```python
import tkinter as tk

def mostra_selecionados():
    indices_selecionados = listbox.curselection()  # Obtém os índices dos itens selecionados
    itens_selecionados = [listbox.get(i) for i in indices_selecionados]  # Converte índices em itens
    label.config(text=f"Selecionado: {', '.join(itens_selecionados)}")

# criação da janela principal
janela = tk.Tk()
janela.title("Exemplo de Listbox")
janela.geometry("300x200")

# criando uma lista de itens
listbox = tk.Listbox(
    janela,
    selectmode="SINGLE",
    font=("Arial", 12),
    height=5)
listbox.pack(padx=10, pady=10)
for item in ["Item 1", "Item 2", "Item 3", "Item 4", "Item 5"]:
    listbox.insert(tk.END, item)

# criando um rótulo (Label)
label = tk.Label(
    janela,
    text="Selecione um item",
    font=("Arial", 12))
label.pack(padx=10, pady=10)

# botão para exibir a seleção
button = tk.Button(
    janela,
    text="Mostrar Seleção",
    command=mostra_selecionados,
    font=("Arial", 12))
button.pack(padx=10, pady=10)

# iniciando o loop de eventos
janela.mainloop()
```

- **`curselection()`** : obtém os índices dos itens selecionados;
- **`get()`** : converte os índices em valores para exibir os itens selecionados no rótulo;

## exercícios `Listbox`

<details>
<summary>Lista de Exercícios</summary>

1. **Listbox Simples** : Crie uma janela com um `Listbox` contendo uma lista de frutas (como maçã, banana e laranja). Exiba a fruta selecionada em um `Label` quando o usuário clicar em um botão.
1. **Adicionar Itens ao Listbox** : Crie um `Listbox` vazio e um `Entry`. Quando o usuário digitar um texto no `Entry` e clicar em um botão "Adicionar", o texto deve ser adicionado como um novo item no `Listbox`.
1. **Remover Itens do Listbox** : Crie um `Listbox` com cinco itens e um botão "Remover". Quando o botão for clicado, o item selecionado deve ser removido da lista.
1. **Selecionar Múltiplos Itens** : Crie um `Listbox` que permita a seleção de múltiplos itens (usando a opção `selectmode=MULTIPLE`). Quando um botão for clicado, exiba os itens selecionados em um `Label`.
1. **Mover Itens Entre Dois Listboxes** : Crie dois `Listboxes` lado a lado e dois botões ">>" e "<<". O botão ">>" deve mover o item selecionado do primeiro `Listbox` para o segundo, e o botão "<<" deve fazer o inverso.
1. **Contar Itens no Listbox** : Crie um `Listbox` e um botão "Contar". Quando o botão for clicado, exiba o número total de itens no `Listbox` em um `Label`.
1. **Listbox com Barra de Rolagem** : Crie um `Listbox` com 20 itens e adicione uma barra de rolagem para navegar pelos itens.
1. **Modificar o Texto de um Item Selecionado** : Crie um `Listbox` e um botão "Modificar". Quando um item for selecionado e o botão for clicado, o texto do item selecionado deve ser modificado para "Item Modificado".
1. **Limpar Todo o Conteúdo do Listbox** : Crie um `Listbox` com 5 itens e um botão "Limpar". Quando o botão for clicado, todos os itens devem ser removidos do `Listbox`.
1. **Mover Item Selecionado para Cima ou para Baixo** : Crie um `Listbox` com cinco itens e dois botões: "Mover Para Cima" e "Mover Para Baixo". O botão "Mover Para Cima" deve mover o item selecionado para uma posição acima na lista, e o botão "Mover Para Baixo" deve movê-lo para uma posição abaixo.

</details>

---

## `Checkbutton`

O **Checkbutton** cria uma caixa de seleção que permite ao usuário marcar ou desmarcar uma opção. Ele é frequentemente utilizado em formulários onde múltiplas escolhas podem ser feitas.

```python
checkbutton = tk.Checkbutton(parent, options...)
```

### parâmetros mais comuns

- **`parent`** (`Widget`) : a janela ou frame onde o widget será colocado (geralmente uma instância `Tk()` ou `Frame()`);
- **`text`** (`str`) : define o texto associado ao Checkbutton;
- **`variable`** (`IntVar()` ou `BooleanVar()`) : uma variável do tipo `IntVar()` ou `BooleanVar()` que rastreia o estado (marcado ou desmarcado) do Checkbutton;
- **`onvalue`** (`int` ou `bool`) : define o valor que a variável assume quando o Checkbutton está marcado (geralmente `1` ou `True`);
- **`offvalue`** (`int` ou `bool`) : define o valor que a variável assume quando o Checkbutton está desmarcado (geralmente `0` ou `False`).

### exemplo

```python
import tkinter as tk

def mostra_selecionados():
    label.config(text=f"Opção marcada: {opcao.get()}")

# criação da janela principal
janela = tk.Tk()
janela.title("Exemplo de Checkbutton")
janela.geometry("300x150")

# variável associada ao Checkbutton
opcao = tk.IntVar()

# criando um Checkbutton
checkbutton = tk.Checkbutton(
    janela,
    text="Aceitar Termos",
    variable=opcao,
    onvalue=1,
    offvalue=0)
checkbutton.pack(padx=10, pady=10)

# criando um rótulo (Label)
label = tk.Label(janela, text="Opção marcada: 0", font=("Arial", 12))
label.pack(padx=10, pady=10)

# botão para exibir o estado
button = tk.Button(
    janela,
    text="Mostrar Seleção",
    command=mostra_selecionados,
    font=("Arial", 12))
button.pack(padx=10, pady=10)

# iniciando o loop de eventos
janela.mainloop()
```

- **`variable=opcao`** : a variável `opcao` armazena o estado do Checkbutton (marcado ou desmarcado);
- **`onvalue=1` e `offvalue=0`** : define os valores quando o Checkbutton está marcado ou desmarcado;

## exercícios `Checkbutton`

<details>
<summary>Lista de Exercícios</summary>

1. **Checkbutton Simples** : Crie um programa com um `Checkbutton` que, ao ser marcado ou desmarcado, exibe o estado atual ("Marcado" ou "Desmarcado") em um `Label`.
1. **Checkbutton com Variável de Controle** : Crie um `Checkbutton` associado a uma variável `IntVar`. Quando o `Checkbutton` for alterado, exiba o valor da variável (`1` para marcado, `0` para desmarcado) em um `Label`.
1. **Vários Checkbuttons Independentes** : Crie três `Checkbuttons` independentes para selecionar "Pizza", "Hambúrguer" e "Sushi". Ao clicar em um botão "Exibir Seleção", mostre quais opções estão marcadas em um `Label`.
1. **Checkbuttons com Estado Inicial** : Crie dois `Checkbuttons` com estado inicial, um marcado e outro desmarcado. Permita que o usuário altere os estados e exiba os novos estados em um `Label`.
1. **Checkbutton que Habilita e Desabilita Outros Widgets** : Crie um `Checkbutton` que, quando marcado, habilita um `Entry` para que o usuário possa digitar. Quando desmarcado, o `Entry` deve ser desabilitado (usando o método `config(state=DISABLED)`).
1. **Alternando Texto de um Checkbutton** : Crie um `Checkbutton` com o texto "Ativar". Quando ele for marcado, o texto deve mudar para "Desativar". Quando desmarcado, o texto deve voltar para "Ativar".
1. **Selecionar e Desmarcar Todos os Checkbuttons** : Crie cinco `Checkbuttons` com opções variadas (por exemplo, "Opção 1", "Opção 2", etc.) e dois botões: "Selecionar Todos" e "Desmarcar Todos". Ao clicar nesses botões, todos os `Checkbuttons` devem ser marcados ou desmarcados, respectivamente.
1. **Checkbuttons com Contagem de Seleção** : Crie três `Checkbuttons`. Quando o usuário marcar ou desmarcar qualquer um deles, exiba em um `Label` quantos `Checkbuttons` estão atualmente marcados.
1. **Checkbutton que Controla a Cor de Fundo** : Crie três `Checkbuttons`, cada um associado a uma cor (vermelho, verde e azul). Quando o `Checkbutton` for marcado, a cor correspondente deve ser aplicada como cor de fundo da janela.
1. **Checkbutton para Ativar/Desativar Funcionalidade** : Crie um `Checkbutton` que, quando marcado, ative uma função de temporizador que exibe a hora atual em um `Label` a cada segundo. Quando desmarcado, o temporizador deve ser desativado.

</details>

---

## `Radiobutton`

O **Radiobutton** permite a seleção de apenas uma opção entre várias. É usado quando o usuário deve escolher uma única opção em um grupo.

```python
radiobutton = tk.Radiobutton(parent, options...)
```

### parâmetros mais comuns

- **`parent`** (`Widget`) : a janela ou frame onde o widget será colocado (geralmente uma instância `Tk()` ou `Frame()`);
- **`text`** (`str`) : define o texto associado ao Radiobutton;
- **`variable`** (`IntVar()`) : uma variável do tipo `IntVar()` que armazena o valor da opção selecionada;
    - todos os `Radiobuttons` de um grupo devem compartilhar a mesma variável;
- **`value`** (`int`) : o valor atribuído à variável quando o Radiobutton está selecionado;
    - cada `Radiobutton` em um grupo deve ter um valor diferente;

### exemplo

```python
import tkinter as tk

def mostra_selecionados():
    label.config(text=f"Opção selecionada: {radio_var.get()}")

# criação da janela principal
janela = tk.Tk()
janela.title("Exemplo de Radiobutton")
janela.geometry("300x200")

# variável associada aos Radiobuttons
radio_var = tk.IntVar()

# criando Radiobuttons
radiobutton1 = tk.Radiobutton(janela, text="Opção 1", variable=radio_var, value=1)
radiobutton2 = tk.Radiobutton(janela, text="Opção 2", variable=radio_var, value=2)
radiobutton3 = tk.Radiobutton(janela, text="Opção 3", variable=radio_var, value=3)

radiobutton1.pack(padx=10, pady=5)
radiobutton2.pack(padx=10, pady=5)
radiobutton3.pack(padx=10, pady=5)

# criando um rótulo (Label)
label = tk.Label(janela, text="Nenhuma opção selecionada", font=("Arial", 12))
label.pack(padx=10, pady=10)

# botão para exibir a seleção
button = tk.Button(
    janela,
    text="Mostrar Seleção",
    command=mostra_selecionados,
    font=("Arial", 12))
button.pack(padx=10, pady=10)

# iniciando o loop de eventos
janela.mainloop()
```

- **`variable=radio_var`** : a variável `radio_var` armazena o valor da opção selecionada;
- **`value=1`, `value=2`, `value=3`** : define os valores associados a cada Radiobutton;

## exercícios `Radiobutton`

<details>
<summary>Lista de Exercícios</summary>

1. **Radiobutton Simples** : Crie três `Radiobuttons` com opções de cores ("Vermelho", "Verde", "Azul"). Exiba a cor selecionada em um `Label` quando qualquer um dos `Radiobuttons` for clicado.
1. **Radiobutton com Variável de Controle** : Crie quatro `Radiobuttons` (por exemplo, "Opção A", "Opção B", "Opção C" e "Opção D") vinculados a uma variável `IntVar`. Quando o usuário selecionar uma opção, exiba o valor correspondente em um `Label`.
1. **Radiobutton que Controla o Texto de um Label** : Crie três `Radiobuttons` com diferentes opções de saudação ("Bom dia", "Boa tarde", "Boa noite"). Quando o usuário selecionar uma saudação, o texto de um `Label` deve ser atualizado com a saudação escolhida.
1. **Formulário de Seleção de Gênero** : Crie um formulário com dois `Radiobuttons` para selecionar o gênero (por exemplo, "Masculino" e "Feminino"). Quando um botão "Enviar" for clicado, exiba a escolha em um `Label`.
1. **Radiobuttons Desativados e Habilitados Dinamicamente** : Crie três `Radiobuttons`, mas deixe-os inicialmente desativados (usando `state=DISABLED`). Adicione um `Checkbutton` que, quando marcado, habilite os `Radiobuttons`.
1. **Seleção de Opções de Tamanho** : Crie um conjunto de três `Radiobuttons` que permita selecionar tamanhos de camisetas ("Pequeno", "Médio", "Grande"). Exiba o tamanho selecionado em um `Label` e mostre uma mensagem de "Seleção inválida" caso nenhum tamanho tenha sido escolhido.
1. **Mudar a Cor de Fundo com Radiobutton** : Crie quatro `Radiobuttons` com opções de cores. Quando o usuário selecionar uma cor, altere a cor de fundo da janela para a cor correspondente.
1. **Radiobutton com Imagens** : Crie três `Radiobuttons`, cada um associado a uma imagem (como ícones de frutas: maçã, banana, uva). Ao selecionar um `Radiobutton`, exiba a imagem correspondente em um `Label`.
1. **Radiobutton que Controla Outras Funções** : Crie dois `Radiobuttons`, "Ativar" e "Desativar". Quando "Ativar" for selecionado, um `Entry` deve ser habilitado. Quando "Desativar" for selecionado, o `Entry` deve ser desabilitado.
1. **Radiobuttons com Função de Enquete** : Crie uma interface com cinco `Radiobuttons` representando diferentes faixas etárias (ex: "Menos de 18", "18-25", "26-35", "36-50", "Mais de 50"). Quando o usuário clicar em "Submeter", exiba a faixa etária selecionada em um `Label`.

</details>

---

## gerenciadores de layout

No Tkinter, há três principais gerenciadores de layout usados para posicionar widgets dentro de uma janela ou de um frame: **`pack()`**, **`grid()`** e **`place()`**. Cada um oferece diferentes formas de controle sobre a disposição dos widgets, permitindo desde layouts mais automáticos até configurações mais personalizadas.

### `pack`

O método **`pack()`** (um layout baseado em direção) organiza widgets em blocos, de acordo com a direção especificada. Ele é mais automático e simples, ideal quando se quer que os widgets sejam dispostos de maneira sequencial, um após o outro.

```python
widget.pack(options...)
```

#### parâmetros mais comuns

- **`side`** (`str`) : define de que lado da janela o widget será empacotado;
    - pode ser `"TOP"`, `"BOTTOM"`, `"LEFT"`, ou `"RIGHT"`;
    - o valor padrão é `"TOP"`;
- **`fill`** (`str`) : define como o widget vai preencher o espaço disponível;
    - pode ser `"NONE"` (não preenche), `"X"` (preenche horizontalmente), `"Y"` (preenche verticalmente) ou `"BOTH"` (preenche em ambas as direções);
- **`expand`** (`bool`) : define se o widget deve expandir para ocupar o espaço disponível;
    - quando `True`, o widget pode se expandir para preencher o espaço da janela;
- **`padx`** (`int`) : define a quantidade de espaço (em pixels) adicionado ao redor do widget, horizontalmente;
- **`pady`** (`int`) : define a quantidade de espaço (em pixels) adicionado ao redor do widget, verticalmente;

#### exemplo

```python
import tkinter as tk

# criação da janela principal
janela = tk.Tk()
janela.title("Exemplo de pack")
janela.geometry("300x200")

# widgets empacotados com diferentes lados
label_top = tk.Label(janela, text="Topo", bg="lightblue")
label_top.pack(side=tk.TOP, fill=tk.X)

label_bottom = tk.Label(janela, text="Embaixo", bg="lightgreen")
label_bottom.pack(side=tk.BOTTOM, fill=tk.X)

label_left = tk.Label(janela, text="Esquerda", bg="lightcoral")
label_left.pack(side=tk.LEFT, fill=tk.Y)

label_right = tk.Label(janela, text="Direita", bg="lightyellow")
label_right.pack(side=tk.RIGHT, fill=tk.Y)

# iniciando o loop de eventos
janela.mainloop()
```

- os widgets são empacotados em torno dos lados da janela, um após o outro, com base no parâmetro **`side`**;
- o parâmetro **`fill`** controla como os widgets se expandem dentro do eixo especificado;

#### todas opções

O código abaixo realiza praticamente todas as opções possíveis de layout usando o método `pack()`.

```python
import tkinter as tk

janela = tk.Tk()
janela.geometry()

for e, expand in enumerate([False, True]):
    for f, fill in enumerate([None, tk.X, tk.Y, tk.BOTH]):
        for s, side in enumerate([tk.TOP, tk.LEFT, tk.BOTTOM, tk.RIGHT]):
            posicao = f'+{s * 205 + 100 + e * 820}+{f * 235 + 100}'

            tpl_janela = tk.Toplevel(janela)
            tpl_janela.geometry('200x200'+posicao)

            texto = f"side='{side}'\nfill='{fill}'\nexpand={str(expand)}"

            lbl_etiqueta = tk.Label(
                tpl_janela,
                text=texto,
                bg=['#FF5555', '#55FF55'][e])
            lbl_etiqueta.pack(side=side, fill=fill, expand=expand)

janela.mainloop()
```

[Código Fonte Original](https://stackoverflow.com/questions/28089942/difference-between-fill-and-expand-options-for-tkinter-pack-method)

### `grid`

O método **`grid()`** (um layout baseado em grade) organiza os widgets em uma grade, semelhante a uma tabela. Cada widget é posicionado em uma célula específica (linha e coluna), e pode-se definir o alinhamento e o tamanho das células.

```python
widget.grid(row, column, options...)
```

#### parâmetros mais comuns

- **`row`** (`int`) : define a linha onde o widget será colocado (começando do índice `0`);
- **`column`** (`int`) : define a coluna onde o widget será colocado (começando do índice `0`);
- **`rowspan`** (`int`) : define quantas linhas o widget deve abranger;
- **`columnspan`** (`int`) : define quantas colunas o widget deve abranger;
- **`padx`** (`int`) : define a quantidade de espaço (em pixels) adicionada horizontalmente ao redor do widget;
- **`pady`** (`int`) : define a quantidade de espaço (em pixels) adicionada verticalmente ao redor do widget;
- **`sticky`** (`str`) : define o alinhamento dentro da célula;
    - pode usar combinações de direções (`"N"`, `"S"`, `"E"`, `"W"`), que se referem a Norte (cima), Sul (baixo), Leste (direita) e Oeste (esquerda);

#### exemplo

```python
import tkinter as tk

# criação da janela principal
janela = tk.Tk()
janela.title("Exemplo de grid")
janela.geometry("300x200")

# widgets organizados em uma grade
label1 = tk.Label(janela, text="Linha 0, Coluna 0", bg="lightblue")
label1.grid(row=0, column=0, padx=10, pady=10)

label2 = tk.Label(janela, text="Linha 0, Coluna 1", bg="lightgreen")
label2.grid(row=0, column=1, padx=10, pady=10)

label3 = tk.Label(janela, text="Linha 1, Coluna 0-1", bg="lightyellow")
label3.grid(row=1, column=0, columnspan=2, sticky="ew", padx=10, pady=10)

# iniciando o loop de eventos
janela.mainloop()
```

- o parâmetro **`row`** e **`column`** especificam a posição na grade;
- **`columnspan=2`** indica que o widget abrange duas colunas;
- **`sticky="ew"`** alinha o widget horizontalmente (preenchendo de leste a oeste);

### `place`

O método **`place()`** (um layout absoluto) permite que se defina a posição exata (em pixels) do widget dentro da janela ou do frame. Ele oferece o controle mais detalhado sobre o layout, ideal quando é necessário um posicionamento absoluto e preciso.

```python
widget.place(x, y, options...)
```

#### parâmetros mais comuns

- **`x`** (`int`) : define a posição horizontal do widget (em pixels a partir da borda esquerda);
- **`y`** (`int`) : define a posição vertical do widget (em pixels a partir da borda superior);
- **`relx`** (`float`) : define a posição horizontal relativa na janela, onde `0.0` é o início (esquerda) e `1.0` é o fim (direita);
- **`rely`** (`float`) : define a posição vertical relativa na janela, onde `0.0` é o início (topo) e `1.0` é o fim (fundo);
- **`anchor`** (`str`) : define qual parte do widget estará ancorada na posição especificada;
    - por exemplo, `"n"` para o topo, `"center"` para o centro, etc;
    - os valores podem ser uma combinação das direções (`"n"`, `"s"`, `"e"`, `"w"`, etc.);
- **`width`** (`int`) : define a largura do widget (em pixels);
- **`height`** (`int`) : define a altura do widget (em pixels).

#### exemplo

```python
import tkinter as tk

# criação da janela principal
janela = tk.Tk()
janela.title("Exemplo de place")
janela.geometry("300x200")

# widgets posicionados em coordenadas absolutas
label1 = tk.Label(janela, text="Posição (50, 50)", bg="lightblue")
label1.place(x=50, y=50)

label2 = tk.Label(janela, text="Posição (150, 100)", bg="lightgreen")
label2.place(x=150, y=100)

label3 = tk.Label(janela, text="Posição relativa", bg="lightyellow")
# centraliza o label
label3.place(relx=0.5, rely=0.5, anchor="center")

# iniciando o loop de eventos
janela.mainloop()
```

- **`x=50` e `y=50`** colocam o primeiro widget a 50 pixels da borda esquerda e superior;
- **`relx=0.5` e `rely=0.5`** colocam o terceiro widget no centro da janela, já que 0.5 corresponde a 50% da largura/altura;

### comparação

| Método   | Vantagens                                  | Desvantagens                                                   |
|----------|--------------------------------------------|----------------------------------------------------------------|
| **pack** | simples de usar, ideal para layouts lineares| pouca flexibilidade no controle fino do layout                 |
| **grid** | organiza widgets como uma grade, flexível   | um pouco mais complexo que `pack()`, não mistura bem com `pack()`|
| **place**| total controle sobre a posição dos widgets  | pode ser mais trabalhoso e menos responsivo em janelas redimensionadas|

Cada método tem seus pontos fortes e fracos. **`pack()`** é ótimo para layouts simples, **`grid()`** oferece uma estrutura de grade poderosa, e **`place()`** é ideal para controle absoluto de posicionamento.

## exercícios gerenciadores de layout

<details>
<summary>Lista de Exercícios</summary>

1. Exercícios com `pack`
    1. **Posicionamento Vertical Simples** : Crie três `Labels` com textos diferentes e posicione-os verticalmente usando o método `pack`.
    1. **Preenchimento Horizontal (fill=X)** : Crie um `Label` que ocupe toda a largura da janela (preenchimento horizontal) usando o parâmetro `fill=X` com o método `pack`.
    1. **Alinhamento à Esquerda e à Direita** : Crie dois `Labels`, um alinhado à esquerda e outro à direita da janela, utilizando o parâmetro `side` no método `pack`.
    1. **Expansão de Widgets (expand=True)** : Crie um `Label` que se expanda para preencher a janela ao ser redimensionada, utilizando o parâmetro `expand=True` no método `pack`.
    1. **Widgets sobrepostos** : Crie dois `Labels` e sobreponha-os na mesma posição, um sobre o outro, usando o método `pack`.
    1. **Margens Internas (pady, padx)** : Crie três `Buttons` com margens internas (`padx`, `pady`) e posicione-os verticalmente usando o método `pack`.
    1. **Widgets Horizontais (side=LEFT)** : Crie três `Buttons` dispostos horizontalmente, um ao lado do outro, utilizando `pack(side=LEFT)`.
    1. **Posicionamento com `anchor`** : Crie um `Label` que seja posicionado no canto inferior direito da janela usando `pack` com o parâmetro `anchor=SE`.
    1. **Alternando entre Vertical e Horizontal** : Crie cinco `Labels`, onde os três primeiros sejam dispostos verticalmente e os dois últimos horizontalmente, usando o método `pack`.
    1. **Centralização com Preenchimento** : Crie um `Label` centralizado horizontalmente e verticalmente com preenchimento usando `pack` e os parâmetros `fill=BOTH` e `expand=True`.
1. Exercícios com `grid`
    1. **Grid Básico** : Crie uma interface com três `Labels` posicionados em uma grade de 3x1 (três linhas e uma coluna) utilizando o método `grid`.
    1. **Múltiplos Widgets em Diferentes Linhas** : Crie três `Buttons` dispostos em três linhas separadas e uma coluna, usando `grid(row, column)`.
    1. **Colunas e Linhas Combinadas** : Crie uma interface com quatro `Labels`, onde dois `Labels` ocupem uma linha cada e os outros dois ocupem uma única linha (em duas colunas diferentes).
    1. **Colspan (Mesclar Colunas)** : Crie uma interface com três `Labels` e utilize o parâmetro `columnspan` para fazer um `Label` ocupar duas colunas.
    1. **Rowspan (Mesclar Linhas)** : Crie uma tabela de 3x3 usando `Labels` e faça o `Label` do meio (da segunda linha) ocupar duas linhas usando o parâmetro `rowspan`.
    1. **Espaçamento Interno com `padx` e `pady`** : Crie três `Labels` dispostos horizontalmente em uma única linha e adicione espaçamento interno utilizando `padx` e `pady`.
    1. **Espaçamento Externo com `ipadx` e `ipady`** : Crie três `Buttons` dispostos verticalmente e adicione espaçamento interno utilizando `ipadx` e `ipady` para aumentar o espaço dentro dos botões.
    1. **Alinhamento em Células** : Crie um grid de 2x2 com `Labels` e utilize o parâmetro `sticky` para alinhar os `Labels` em diferentes direções (norte, sul, leste, oeste).
    1. **Expandir Widgets em Linhas e Colunas** : Crie um layout 2x2 e faça os widgets preencherem suas células, expandindo conforme o redimensionamento da janela, utilizando `sticky="nsew"`.
    1. **Grid com Margens Internas e Externas** : Crie uma tabela de 2x2 com widgets `Button` e adicione espaçamento entre as células e dentro dos botões usando `padx`, `pady`, `ipadx` e `ipady`.
1. Exercícios com `place`
    1. **Posicionamento Absoluto Simples** : Crie três `Labels` e posicione-os em coordenadas absolutas específicas dentro da janela utilizando o método `place` com `x` e `y`.
    1. **Redimensionamento com Relativo (`relx`, `rely`)** : Crie um `Button` e posicione-o na metade exata da largura e altura da janela utilizando o método `place` com coordenadas relativas (`relx=0.5`, `rely=0.5`).
    1. **Posicionamento Relativo com Tamanho Relativo** : Crie um `Label` que ocupe 50% da largura e da altura da janela, utilizando `relwidth` e `relheight` no método `place`.
    1. **Posicionamento com Ancoragem (`anchor`)** : Crie um `Label` e posicione-o no canto inferior direito da janela utilizando o método `place` com o parâmetro `anchor=SE`.
    1. **Movendo Widgets Relativamente** : Crie três `Labels` que sejam dispostos um ao lado do outro em uma linha, cada um com `relx` aumentado progressivamente (0.1, 0.3, 0.5), usando `place`.
    1. **Widgets Sobrepostos com `place`** : Crie dois `Labels` e sobreponha-os na mesma posição na janela utilizando o método `place`.
    1. **Botão Centralizado na Janela** : Crie um `Button` que permaneça sempre centralizado na janela, mesmo quando a janela for redimensionada, utilizando `place(relx=0.5, rely=0.5, anchor=CENTER)`.
    1. **Posicionamento Relativo e Absoluto Juntos** : Crie um `Label` que seja posicionado horizontalmente de forma relativa (`relx=0.3`), mas verticalmente com uma posição absoluta (`y=100`), usando `place`.
    1. **Posicionar Widget no Topo com Altura Fixa** : Crie um `Button` que esteja sempre fixo no topo da janela (0 de altura absoluta) e que ocupe toda a largura da janela, independentemente do redimensionamento, usando `place(relwidth=1, y=0)`.
    1. **Redimensionar e Reposicionar Widgets com `place`** : Crie três widgets (`Button`, `Label` e `Entry`) que mudem de posição e tamanho ao redimensionar a janela, utilizando valores relativos para `relx`, `rely`, `relwidth` e `relheight` com o método `place`.

</details>

---

## variáveis

No Tkinter, além de usar variáveis Python normais, há um conjunto especial de **variáveis de controle** que são projetadas para armazenar e rastrear valores que são associados a widgets interativos. Essas variáveis são necessárias quando se quer vincular o estado de um widget com um valor dinâmico (como entradas de texto, seleção de botões de rádio, checkbuttons, etc.). Essas variáveis são subclasses do tipo especial `Variable`, projetado para facilitar a interação entre o código e os widgets.

O Tkinter fornece quatro principais tipos de variáveis de controle, cada uma projetada para lidar com diferentes tipos de dados:

1. **`StringVar`** : variável para armazenar strings (texto);
1. **`IntVar`** : variável para armazenar inteiros;
1. **`DoubleVar`** : variável para armazenar números de ponto flutuante (float);
1. **`BooleanVar`** : variável para armazenar valores booleanos (`True` ou `False`);

Cada uma dessas variáveis possui métodos que permitem obter e definir o valor associado, e elas são comumente usadas com widgets que precisam manter um valor dinâmico, como `Entry`, `Checkbutton`, `Radiobutton`, e outros.

### `StringVar`

A variável `StringVar` (String Variable) é usada para armazenar e gerenciar valores de texto. É útil para widgets como `Entry`, `Label`, e `OptionMenu`.

- **`get()`** : retorna o valor armazenado;
- **`set(value)`** : define um novo valor para a variável;

#### exemplo

```python
import tkinter as tk

# criando a janela principal
janela = tk.Tk()
janela.title("Exemplo com StringVar")
janela.geometry("300x200")

# criando um StringVar
nome_var = tk.StringVar()

# função que será chamada ao pressionar o botão
def exibir_nome():
    print("Nome:", nome_var.get())  # Obtém o valor da StringVar

# criando um Entry ligado ao StringVar
entry_nome = tk.Entry(janela, textvariable=nome_var)
entry_nome.pack(pady=10)

# botão que exibe o valor inserido
btn_mostrar = tk.Button(janela, text="Exibir Nome", command=exibir_nome)
btn_mostrar.pack(pady=10)

# iniciando o loop de eventos
janela.mainloop()
```

- **`textvariable=nome_var`** : liga o valor digitado no widget `Entry` à variável `nome_var`; qualquer alteração no `Entry` também modifica o valor da `StringVar`, e vice-versa;
- **`nome_var.get()`** : obtém o valor atual da variável, que neste caso, é o texto inserido no campo de entrada;

### `IntVar`

A variável `IntVar` (Integer Variable) é usada para armazenar valores inteiros. É comumente utilizada em widgets como `Radiobutton` e `Checkbutton`.

- **`get()`** : retorna o valor armazenado;
- **`set(value)`** : define um novo valor para a variável;

#### exemplo

```python
import tkinter as tk

# criando a janela principal
janela = tk.Tk()
janela.title("Exemplo com IntVar")
janela.geometry("300x200")

# criando uma IntVar
opcao_var = tk.IntVar()

# função que exibe a opção selecionada
def exibir_opcao():
    print("Opção selecionada:", opcao_var.get())

# criando Radiobuttons associados ao IntVar
radio1 = tk.Radiobutton(janela, text="Opção 1", variable=opcao_var, value=1)
radio1.pack(pady=5)
radio2 = tk.Radiobutton(janela, text="Opção 2", variable=opcao_var, value=2)
radio2.pack(pady=5)

# botão que exibe a opção selecionada
btn_exibir = tk.Button(janela, text="Exibir Opção", command=exibir_opcao)
btn_exibir.pack(pady=10)

# iniciando o loop de eventos
janela.mainloop()
```

- **`variable=opcao_var`** : liga a variável `IntVar` ao grupo de `Radiobuttons`; o valor da variável é alterado quando um botão de rádio é selecionado;
- **`value=1`, `value=2`** : cada `Radiobutton` tem um valor associado, que será atribuído a `opcao_var` quando o botão for selecionado;

### `DoubleVar`

A variável `DoubleVar` (Double Variable) é usada para armazenar números de ponto flutuante (números decimais).

- **`get()`** : retorna o valor armazenado;
- **`set(value)`** : define um novo valor para a variável;

#### exemplo

```python
import tkinter as tk

# criando a janela principal
janela = tk.Tk()
janela.title("Exemplo com DoubleVar")
janela.geometry("300x200")

# criando uma DoubleVar
valor_var = tk.DoubleVar(value=1.0)

# função para exibir o valor
def exibir_valor():
    print("Valor atual:", valor_var.get())

# etiqueta exibindo o valor inicial
label = tk.Label(janela, textvariable=valor_var)
label.pack(pady=10)

# botão para exibir o valor no terminal
btn_exibir = tk.Button(janela, text="Exibir Valor", command=exibir_valor)
btn_exibir.pack(pady=10)

# Iniciando o loop de eventos
janela.mainloop()
```

- **`DoubleVar()`** : armazena valores flutuantes; é possível inicializar a variável passando um valor como argumento (por exemplo, `1.0`);
- **`textvariable=valor_var`** : o `Label` exibe o valor armazenado na variável, que pode ser atualizado em tempo real;

### `BooleanVar`

A variável `BooleanVar` (Boolean Variable) armazena valores booleanos (`True` ou `False`). É útil para widgets como `Checkbutton`.

- **`get()`** : retorna `True` ou `False`;
- **`set(value)`** : define o valor para `True` ou `False`;

#### exemplo

```python
import tkinter as tk

# criando a janela principal
janela = tk.Tk()
janela.title("Exemplo com BooleanVar")
janela.geometry("300x200")

# criando uma BooleanVar
opcao = tk.BooleanVar()

# função para exibir o estado do checkbox
def exibir_estado():
    print("Checkbox está selecionado?", opcao.get())

# criando o Checkbutton ligado à BooleanVar
check_button = tk.Checkbutton(janela, text="Aceitar Termos", variable=opcao)
check_button.pack(pady=10)

# botão que exibe o estado do checkbox
btn_verificar = tk.Button(janela, text="Verificar", command=exibir_estado)
btn_verificar.pack(pady=10)

# iniciando o loop de eventos
janela.mainloop()
```

- **`variable=opcao`** : liga o estado do `Checkbutton` à variável `BooleanVar`. Quando o botão é marcado, o valor de `opcao` é `True`; caso contrário, é `False`;
- **`opcao.get()`** : retorna o estado atual do `Checkbutton`;

## exercícios variáveis

<details>
<summary>Lista de Exercícios</summary>

1. Exercícios com `StringVar`
    1. **Exibição Simples de Texto** : Crie um programa onde o texto de um `Label` seja controlado por uma `StringVar`. O `Label` deve atualizar automaticamente ao modificar o valor da variável.
    1. **Entrada de Texto Dinâmica** : Crie um programa com um `Entry` e um `Label`. Use uma `StringVar` para conectar o texto do `Entry` ao `Label`, de forma que o `Label` atualize conforme o texto é digitado.
    1. **Combinação de Texto** : Crie dois `Entry` widgets para o primeiro e o último nome. Use duas variáveis `StringVar` para capturar o conteúdo, combiná-los e exibir o nome completo em um `Label`.
    1. **Validação de Entrada** : Crie um `Entry` conectado a uma `StringVar`. Sempre que o texto for modificado, verifique se o valor inserido é um nome válido (sem números) e exiba uma mensagem de erro em um `Label`.
    1. **Alteração de Texto ao Clicar em um Botão** : Crie um `Button` que, quando clicado, altere o valor de uma `StringVar` e atualize um `Label` com o novo valor.
    1. **Atualização Condicional** : Crie dois `Entry` widgets e uma `StringVar` para cada um. Quando ambos os campos forem preenchidos, mostre um `Label` com uma mensagem de boas-vindas usando os dois nomes combinados.
    1. **Concatenação de Valores** : Crie três `Entry` widgets (nome, sobrenome e cidade) com três variáveis `StringVar`. Exiba um `Label` que mostre uma frase concatenando esses valores.
    1. **Troca de Valores entre Widgets** : Crie dois `Entry` widgets com uma `StringVar` para cada. Adicione um botão que troque os valores entre os dois `Entry`.
    1. **Manipulação com Expressões Regulares** : Crie um `Entry` com uma `StringVar` para capturar um número de telefone. Valide o número inserido em tempo real, exibindo uma mensagem de erro se o formato estiver incorreto (por exemplo, "(XX) XXXX-XXXX").
    1. **Interagir com Menu** : Crie um menu suspenso (`OptionMenu`) que exibe uma lista de opções. Use uma `StringVar` para armazenar a opção selecionada e mostre a escolha em um `Label`.
1. Exercícios com `IntVar`
    1. **Exibição Simples de Número** : Crie um `Label` que exibe o valor de uma `IntVar`. Quando o valor da variável mudar, o `Label` deve ser atualizado automaticamente.
    1. **Contador com Botões** : Crie dois `Buttons` para incrementar e decrementar o valor de uma `IntVar`. Mostre o valor atual em um `Label`.
    1. **Controle de Volume Simples** : Crie uma interface que simule um controle de volume com um `Scale` horizontal. Use uma `IntVar` para capturar o valor e exiba o nível de volume em um `Label`.
    1. **Controle de Números Impares e Pares** : Crie dois `Radiobuttons` com valores de uma `IntVar`. Um deve selecionar números ímpares e o outro números pares. Ao clicar, exiba uma lista de números ímpares ou pares em um `Label`.
    1. **Somador de Valores** : Crie três `Entry` widgets, cada um conectado a uma `IntVar`. Mostre a soma dos três valores em um `Label` e atualize o resultado em tempo real.
    1. **Verificador de Par ou Ímpar** : Crie um `Entry` onde o usuário insere um número inteiro. Utilize uma `IntVar` para capturar o valor e exiba em um `Label` se o número é par ou ímpar.
    1. **Seleção de Opções Numéricas** : Crie um conjunto de cinco `Radiobuttons`, cada um representando um número de 1 a 5. Utilize uma `IntVar` para armazenar a seleção e exiba o valor escolhido em um `Label`.
    1. **Atualização Automática de Números** : Crie uma interface com um `Scale` e um `Label`. Use uma `IntVar` para conectar o `Scale` ao `Label` e exiba o valor do `Scale` conforme ele é movido.
    1. **Calculadora de Fatorial** : Crie um `Entry` para inserir um número inteiro e um `Button` que, ao ser clicado, calcule e exiba o fatorial do número usando uma `IntVar`.
    1. **Controle de Alternância com Checkbuttons** : Crie quatro `Checkbuttons` cada um ligado a uma `IntVar`. Adicione um botão que exiba o valor numérico resultante da combinação dos `Checkbuttons` marcados.
1. Exercícios com `DoubleVar`
    1. **Exibição Simples de Valor Decimal** : Crie um `Label` que exibe o valor de uma `DoubleVar`. O `Label` deve ser atualizado automaticamente ao alterar a variável.
    1. **Conversão de Moeda** : Crie um `Entry` onde o usuário insere um valor em dólares. Use uma `DoubleVar` para capturar o valor e exiba a conversão em reais usando uma taxa de câmbio fictícia.
    1. **Calculadora de Desconto** : Crie um `Entry` para inserir o preço original de um produto e um `Scale` para ajustar o percentual de desconto. Use uma `DoubleVar` para capturar esses valores e exibir o preço final com desconto.
    1. **Cálculo de IMC (Índice de Massa Corporal)** : Crie dois `Entry` widgets para o usuário inserir peso (em kg) e altura (em metros). Use `DoubleVar` para capturar esses valores e calcular o IMC, exibindo o resultado em um `Label`.
    1. **Controle de Precisão Decimal** : Crie um `Scale` que permite selecionar valores decimais entre 0.0 e 10.0. Use uma `DoubleVar` para armazenar o valor e exiba-o com 2 casas decimais em um `Label`.
    1. **Conversor de Temperatura** : Crie uma interface com um `Entry` para o usuário inserir uma temperatura em Celsius. Use uma `DoubleVar` para converter o valor para Fahrenheit e exibi-lo em um `Label`.
    1. **Calculadora de Juros Simples** : Crie três `Entry` widgets para inserir o valor principal, taxa de juros anual e número de anos. Use `DoubleVar` para capturar esses valores e calcular o valor total após os juros.
    1. **Medidor de Distância** : Crie uma interface com um `Entry` onde o usuário insere uma distância em quilômetros. Converta esse valor para milhas utilizando uma `DoubleVar` e exiba o resultado em um `Label`.
    1. **Multiplicação Automática** : Crie dois `Entry` widgets para o usuário inserir dois números decimais. Use `DoubleVar` para multiplicá-los e exiba o resultado em um `Label`.
    1. **Simulador de Investimento** : Crie uma interface onde o usuário insere o valor inicial e a taxa de crescimento anual. Use uma `DoubleVar` para calcular o valor acumulado após 5 anos e exibi-lo em um `Label`.
1. Exercícios com `BooleanVar`
    1. **Checkbutton Simples** : Crie um `Checkbutton` que altera uma `BooleanVar`. Exiba o estado atual (True ou False) em um `Label`.
    1. **Botão de Ativação/Desativação** : Crie um `Button` que alterna o valor de uma `BooleanVar` entre True e False a cada clique e atualiza um `Label` com o valor atual.
    1. **Simulação de Lâmpada** : Crie uma interface com um `Checkbutton` que simula uma lâmpada. Quando marcado, exiba "Ligada", e quando desmarcado, exiba "Desligada", usando uma `BooleanVar`.
    1. **Habilitar/Desabilitar Widgets** : Crie um `Checkbutton` que habilita e desabilita um `Entry` widget ao marcar e desmarcar, controlado por uma `BooleanVar`.
    1. **Radiobutton com BooleanVar** : Crie dois `Radiobuttons` com opções "Ativado" e "Desativado". Use uma `BooleanVar` para controlar a seleção e exiba o valor atual em um `Label`.
    1. **Alternância entre Estados** : Crie dois `Buttons`, um para definir uma `BooleanVar` como `True` e outro para definir como `False`. Mostre o valor da variável em um `Label`.
    1. **Botão de Validação** : Crie um `Button` que só possa ser clicado se uma `BooleanVar` for `True`. Controle o estado do botão com um `Checkbutton` ligado a essa variável.
    1. **Simulação de Login** : Crie um sistema de login onde um `Checkbutton` deve ser marcado para lembrar a senha. Use uma `BooleanVar` para controlar a opção.
    1. **Seleção de Opções** : Crie três `Checkbuttons` para representar opções de um questionário. Use `BooleanVar` para cada uma e exiba uma mensagem com as opções selecionadas ao clicar em um botão.
    1. **Aplicação de Estilo** : Crie um `Checkbutton` que ativa ou desativa uma cor de fundo para a janela. Use uma `BooleanVar` para controlar a mudança de cor.

</details>

## callback

Um **callback** é uma função que é passada como argumento para outra função e é chamada em um momento posterior, geralmente em resposta a um evento. No contexto do Tkinter, callbacks são usados para manipular eventos de interface do usuário, como cliques em botões, seleções em listas, movimentação do mouse, e assim por diante. Quando um evento específico ocorre, o Tkinter executa a função de callback associada a esse evento.

### por que usar

- **interatividade** : callbacks permitem que se crie interfaces interativas. Quando um usuário interage com a interface (por exemplo, clicando em um botão), o callback permite que execute uma ação em resposta a essa interação;

- **separação de lógica** : callbacks ajudam a manter a lógica da interface separada do restante do código, facilitando a manutenção e a legibilidade;

### exemplo

```python
import tkinter as tk

def meu_callback():
    print("Botão clicado!")

janela = tk.Tk()
botao = tk.Button(janela, text="Clique aqui", command=meu_callback)
botao.pack()
janela.mainloop()
```

Quando clica no botão, a mensagem "Botão clicado!" será impressa no console.

### widgets de entrada

É tabmém possível usar callbacks para manipular valores de entrada de widgets como `Entry` ou `Listbox`.

**Exemplo**

```python
import tkinter as tk

def mostrar_texto():
    texto = entrada.get()
    print(f"Texto digitado: {texto}")

janela = tk.Tk()

entrada = tk.Entry(janela)
entrada.pack()

botao = tk.Button(janela, text="Mostrar Texto", command=mostrar_texto)
botao.pack()

janela.mainloop()
```

Neste exemplo, o botão exibe o texto que foi digitado no campo de entrada quando clicado.

### vários

Pode-se associar múltiplos callbacks a um único evento, ou usar o mesmo callback para diferentes widgets.

**Exemplo**

```python
import tkinter as tk

def botao_clicado(nome):
    print(f"{nome} foi clicado!")

janela = tk.Tk()

botao1 = tk.Button(janela, text="Botão 1", command=lambda: botao_clicado("Botão 1"))
botao1.pack()

botao2 = tk.Button(janela, text="Botão 2", command=lambda: botao_clicado("Botão 2"))
botao2.pack()

janela.mainloop()
```

## tkinter e `lambda`

A função [`lambda`](funcoes.md#lambda) é uma maneira de criar funções anônimas em Python. No contexto do Tkinter, as funções `lambda` são frequentemente usadas para fornecer um modo conveniente de passar argumentos para as funções de callback associadas a eventos, como cliques de botões ou seleções de menu.

### por que usar

Quando se associa uma função a um evento (por exemplo, o clique de um botão) usando o parâmetro `command`, pode-se querer passar parâmetros para essa função. Uma função `lambda` permite que se faça isso de forma concisa.

### exemplos

1. **Passando Parâmetros Simples**

    Suponha que se queira criar um botão que exibe uma mensagem personalizada ao ser clicado. Pode-se usar `lambda` para passar o nome para a função de callback.

    ```python
    import tkinter as tk

    def exibir_mensagem(nome):
        print(f"Olá, {nome}!")

    janela = tk.Tk()

    # usando lambda para passar o argumento
    botao = tk.Button(janela, text="Clique aqui", command=lambda: exibir_mensagem("Schwarzenegger"))
    botao.pack()

    janela.mainloop()
    ```

    Neste exemplo, quando o botão é clicado, a função `exibir_mensagem` é chamada com o argumento `"Schwarzenegger"`.

2. **Acessando Variáveis de Entrada**

    Pode-se usar `lambda` para acessar o valor de um widget `Entry` e passá-lo para uma função.

    ```python
    import tkinter as tk

    def mostrar_texto(texto):
        print(f"Texto digitado: {texto}")

    janela = tk.Tk()

    entrada = tk.Entry(janela)
    entrada.pack()

    # usando lambda para passar o valor da entrada
    botao = tk.Button(janela, text="Mostrar Texto", command=lambda: mostrar_texto(entrada.get()))
    botao.pack()

    janela.mainloop()
    ```

    Aqui, a função `mostrar_texto` recebe o valor atual do widget `Entry` quando o botão é clicado.

3. **Múltiplos Argumentos**

    Também pode-se passar múltiplos argumentos usando `lambda`.

    ```python
    import tkinter as tk

    def somar(a, b):
        print(f"A soma é: {a + b}")

    janela = tk.Tk()

    # usando lambda para passar múltiplos argumentos
    botao = tk.Button(janela, text="Somar", command=lambda: somar(5, 10))
    botao.pack()

    janela.mainloop()
    ```

    Nesse exemplo, a função `somar` é chamada com os valores `5` e `10`.

## exercícios tkinter e `lambda`

<details>
<summary>Lista de Exercícios</summary>

1. Crie uma janela Tkinter com um botão que, ao ser clicado, exibe uma mensagem "Botão clicado!" usando uma função lambda.
1. Crie um campo de entrada (`Entry`) e um botão. Quando o botão for clicado, o texto digitado no campo de entrada deve ser exibido em um rótulo (`Label`), utilizando uma função lambda.
1. Crie dois botões: um que aumenta um contador e outro que diminui o contador. Use uma função lambda para atualizar o valor do contador em um rótulo.
1. Crie um aplicativo simples que permite ao usuário digitar um número e um botão que, ao ser clicado, calcula o dobro desse número e exibe o resultado em um rótulo, utilizando `lambda`.
1. Crie uma janela Tkinter com três botões que mudam a cor de fundo da janela. Use funções `lambda` para definir a cor em cada botão.
1. Crie uma aplicação com um `Listbox` e dois botões. Um botão deve adicionar um item ao `Listbox`, enquanto o outro deve remover o item selecionado. Utilize `lambda` para as funções de ação.
1. Faça um aplicativo com um campo de entrada onde o usuário pode digitar seu nome e um botão que, ao ser clicado, exibe uma saudação personalizada ("Olá, [nome]!"). Utilize uma função `lambda`.
1. Crie um aplicativo que tenha uma caixa de seleção (`Checkbutton`). Quando a caixa estiver marcada, um rótulo deve mostrar "Selecionado", e quando desmarcada, deve mostrar "Não selecionado". Use `lambda` para atualizar o rótulo.
1. Crie um aplicativo que possui três `Radiobuttons`, cada um representando uma cor (vermelho, verde, azul). Quando o usuário seleciona uma cor, a cor de fundo da janela deve mudar, usando `lambda`.
1. Faça um aplicativo que tem um botão que, quando clicado, exibe a soma de dois números digitados em dois campos de entrada (`Entry`). Utilize `lambda` para a função de soma.
1. Crie um aplicativo onde o usuário pode selecionar um número de um `Listbox`. Um botão deve mostrar o quadrado desse número em um rótulo, utilizando uma função `lambda`.
1. Faça uma janela que tem um campo de entrada para o usuário digitar um texto. Adicione um botão que exibe o texto em maiúsculas em um rótulo ao ser clicado, usando `lambda`.
1. Crie um aplicativo com dois campos de entrada para números. Um botão deve multiplicar esses números e mostrar o resultado em um rótulo. Utilize `lambda` para a operação.
1. Faça uma janela com um botão que gera um número aleatório entre 1 e 100. Quando clicado, o número gerado deve ser exibido em um rótulo, usando `lambda`.
1. Crie um aplicativo que tenha uma caixa de entrada e um botão que, ao ser clicado, transforma o texto em uma string reversa e exibe o resultado em um rótulo, utilizando `lambda`.
1. Crie um aplicativo onde o usuário pode selecionar uma opção de uma lista de frutas. Um botão deve mostrar a fruta selecionada em um rótulo, usando uma função `lambda`.
1. Faça um aplicativo com um botão que, quando clicado, muda a imagem de fundo da janela entre duas imagens diferentes usando `lambda`.
1. Crie um aplicativo com um campo de entrada e um botão que calcula a raiz quadrada do número digitado e exibe o resultado em um rótulo, utilizando `lambda`.
1. Faça uma janela com três botões que mostram diferentes mensagens em um rótulo. Use `lambda` para cada botão para exibir uma mensagem específica.
1. Crie um aplicativo com uma caixa de texto (`Text`) e um botão que, ao ser clicado, conta o número de palavras digitadas na caixa de texto e exibe o resultado em um rótulo. Utilize `lambda` para a contagem.

</details>


# tratamento-erros.md

Índice

1. [o que é uma exceção?](#o-que-é-uma-exceção)
1. [blocos `try` e `except`](#blocos-try-e-except)
1. [porque usar `try` e `except`](#porque-usar-try-e-except)
1. [erros](#erros)
    1. [resumo](#resumo)
    1. [`ZeroDivisionError`](#zerodivisionerror)
    1. [`ValueError`](#ValueError)
    1. [`TypeError`](#TypeError)
    1. [`IndexError`](#IndexError)
    1. [`KeyError`](#KeyError)
    1. [`ImportError`](#ImportError)
    1. [`FileNotFoundError`](#FileNotFoundError)
    1. [`NameError`](#NameError)
1. [cuidados](#cuidados)
1. [exercícios](#exercícios)
1. [exceções múltiplas](#exceções-múltiplas)
1. [exercícios exceções múltiplas](#exercícios-exceções-múltiplas)
1. [`except` genérico](#except-genérico)
1. [exercícios `except` genérico](#exercícios-except-genérico)
1. [comandos `else` e `finally`](#comandos-else-e-finally)
1. [exercícios `else` e `finally`](#exercícios-else-e-finally)
1. [capturando mensagens de erro](#capturando-mensagens-de-erro)
1. [exercícios mensagens de erro](#exercícios-mensagens-de-erro)

# tratamento de erros

O tratamento de erros em Python é uma parte crucial do desenvolvimento de software robusto e estável. Para isso, Python oferece estruturas como `try`, `except`, `else`, `finally`, que permitem ao desenvolvedor capturar e gerenciar exceções, evitando que o programa falhe abruptamente.

## o que é uma exceção?

Uma **exceção** é um evento anômalo ou erro que ocorre durante a execução de um programa. Isso pode ocorrer por vários motivos, como:
- uma divisão por zero (`ZeroDivisionError`);
- tentar acessar um índice fora dos limites de uma lista (`IndexError`);
- erros de tipos, como tentar somar um número e uma string (`TypeError`);

Quando ocorre uma exceção, Python interrompe a execução normal e procura um bloco de código que possa lidar com essa exceção. Se não encontrar, o programa será encerrado e uma mensagem de erro será exibida.

## blocos `try` e `except`

O bloco `try` é utilizado para envolver o código que pode gerar uma exceção. Quando um bloco `try` é executado, o Python "monitora" as instruções para ver se ocorre alguma exceção. Se não houver exceção, o programa continua normalmente. Se ocorrer uma exceção, o fluxo do programa muda e o controle é passado para o bloco `except`.

O bloco `except` é usado para capturar e lidar com as exceções que podem ocorrer no bloco `try`. Se uma exceção acontece no bloco `try`, Python interrompe a execução das instruções restantes nesse bloco e procura por um bloco `except` adequado. Se o tipo da exceção gerada corresponde ao tipo especificado no `except`, o código dentro do bloco `except` será executado.

**Estrutura básica**
```python
try:
    # código que pode gerar uma exceção
except TipoDaExceção:
    # código para tratar a exceção
```

**Explicação**

- **bloco `try` : o bloco `try` é onde se coloca o código que deseja "proteger"; se ocorrer algum erro dentro deste bloco, ele será interceptado e o controle será passado para o bloco `except`;
- **bloco `except` : o bloco `except` captura a exceção que ocorre no bloco `try`; pode-se especificar o tipo de exceção que deseja capturar (como `ValueError`, `TypeError`, etc.); se uma exceção ocorre e o tipo da exceção corresponde ao especificado no `except`, o código dentro desse bloco é executado;

Exemplo simples:

```python
try:
    x = 1 / 0
except ZeroDivisionError:
    print("Divisão por zero não é permitida!")
```

Neste exemplo, o bloco `try` tenta executar uma divisão por zero, o que resulta na exceção `ZeroDivisionError`. O bloco `except` captura essa exceção e imprime a mensagem.

## porque usar `try` e `except`

O objetivo do tratamento de exceções é evitar que o programa pare inesperadamente quando ocorre um erro. Imagine que um erro ocorra ao tentar abrir um arquivo que não existe. Sem tratamento de exceções, o programa seria interrompido, e todas as operações subsequentes não seriam executadas. Com o uso de `try` e `except`, pode-se "prever" que esse erro pode ocorrer e fornecer uma solução apropriada ou alternativa.

Aqui está um exemplo de como `try` e `except` ajudam a controlar a abertura de um arquivo :

```python
try:
    arquivo = open("arquivo_inexistente.txt", "r")
except FileNotFoundError:
    print("Erro: O arquivo não foi encontrado.")
```

## erros

Abaixo estão vários erros são comuns e podem ocorrer em diversos contextos durante a execução de um programa.

### resumo

1. `ZeroDivisionError`: ocorre quando tenta-se dividir ou calcular o módulo por zero;
1. `ValueError`: ocorre quando um valor é passado para uma função ou operação que não pode processá-lo, mesmo que o tipo seja correto;
1. `TypeError`: ocorre quando tipos incompatíveis são usados em uma operação ou função;
1. `IndexError`:ocorre quando há uma tentativa de acessar um índice inválido em uma sequência;
1. `KeyError`: ocorre quando há uma tentativa de acessar uma chave inexistente em um dicionário;
1. `ImportError`: ocorre quando há uma falha ao importar um módulo ou componente específico;
1. `FileNotFoundError`: ocorre quando o Python tenta abrir um arquivo que não existe no caminho especificado;
1. `NameError`: ocorre quando uma variável, função ou nome é chamado, mas não está definido;

---

### `ZeroDivisionError`

O `ZeroDivisionError` ocorre quando uma operação de divisão ou módulo tenta dividir um número por zero. Em matemática, a divisão por zero é indefinida, e o Python levanta essa exceção para sinalizar que algo está errado.

Esse erro acontece ao tentar :
- dividir um número por zero (`a / 0` ou `a // 0`)
- calcular o módulo de um número por zero (`a % 0`)

#### Exemplos

- **divisão simples por zero**
    ```python
    try:
        resultado = 10 / 0
    except ZeroDivisionError:
        print("Erro: Tentativa de divisão por zero.")
    ```

    - neste código, o bloco `try` tenta dividir `10` por `0`, o que gera um erro de `ZeroDivisionError`;
    - o bloco `except` captura essa exceção e imprime uma mensagem indicando que ocorreu uma tentativa de divisão por zero;

- **operador de módulo com zero**
    ```python
    try:
        resultado = 10 % 0
    except ZeroDivisionError:
        print("Erro: Tentativa de calcular o módulo com zero.")
    ```

    - o operador de módulo (`%`) também levanta um `ZeroDivisionError` quando o divisor é zero;
    - esse erro é capturado no bloco `except`, e uma mensagem de erro é exibida;

- **tratamento de divisão segura**
    ```python
    def dividir(a, b):
        try:
            return a / b
        except ZeroDivisionError:
            return "Erro: Não é possível dividir por zero."

    resultado = dividir(10, 0)
    print(resultado)  # saída : "Erro: Não é possível dividir por zero."
    ```

    - a função `dividir` tenta dividir dois números; se o divisor for zero, o `ZeroDivisionError` é capturado e uma mensagem apropriada é retornada;
    - isso evita que o programa falhe e garante uma execução controlada;

---

### `ValueError`

O `ValueError` ocorre quando uma função ou operação recebe um argumento do tipo correto, mas com um valor inválido. Isso acontece quando o valor fornecido não faz sentido no contexto esperado, mesmo que o tipo de dado esteja correto.

Esse erro é comum nas seguintes situações :
- tentar converter uma string para um número, mas a string contém caracteres não numéricos;
- passar valores que estão fora do intervalo esperado para funções que exigem certos limites;
- fornecer um número inadequado de elementos a uma função que espera uma sequência com uma quantidade específica de elementos;

#### Exemplos

- **conversão de string para inteiro**
    ```python
    try:
        numero = int("abc")
    except ValueError:
        print("Erro: Não é possível converter 'abc' para um número inteiro.")
    ```

    - o `int()` tenta converter a string `"abc"` para um número inteiro; como `"abc"` não é uma string numérica válida, um `ValueError` é gerado;
    - o erro é capturado no `except` e uma mensagem é exibida;

- **raiz quadrada de um número negativo**
    ```python
    import math

    try:
        resultado = math.sqrt(-10)
    except ValueError:
        print("Erro: Não é possível calcular a raiz quadrada de um número negativo.")
    ```

    - o método `math.sqrt()` gera um `ValueError` quando tenta calcular a raiz quadrada de um número negativo, pois no conjunto dos números reais isso não é possível;
    - o erro é capturado no bloco `except`;

- **conversão de lista de strings para inteiros**
    ```python
    lista = ["1", "2", "três", "4"]
    numeros = []

    for item in lista:
        try:
            numeros.append(int(item))
        except ValueError:
            print(f"Erro: '{item}' não é um número válido.")

    print(numeros)  # saída : [1, 2, 4]
    ```

    - é realizada uma tentativa de converter cada item da lista de strings em inteiros; no entanto, o item `"três"` não pode ser convertido para um número, o que gera um `ValueError`;
    - esse erro é tratado para que apenas os itens válidos sejam adicionados à lista `numeros`;

- **intervalo inválido em função de conversão**
    ```python
    try:
        numero = int("1000", 5)  # Converte "1000" da base 5 para um número decimal
    except ValueError:
        print("Erro: '1000' não é um número válido na base 5.")
    ```

    - o `int()` aqui está sendo usado para converter a string `"1000"` da base 5 para decimal; na base 5, os dígitos válidos são apenas `0`, `1`, `2`, `3`, e `4`; o dígito `5` em `"1000"` gera um `ValueError` porque não é um valor válido para a base especificada;

---

### `TypeError`

O `TypeError` ocorre quando uma operação ou função recebe um argumento de um tipo inadequado. Isso acontece quando um objeto de um tipo inesperado é passado para uma operação que exige outro tipo.

Esse erro é comum nas seguintes situações :
- tentar realizar operações aritméticas entre tipos incompatíveis (por exemplo, somar uma string com um número);
- passar um número de argumentos errado para uma função;
- usar operadores ou métodos que não são aplicáveis ao tipo de objeto fornecido;

#### Exemplos

- **soma de string com número**
    ```python
    try:
        resultado = "5" + 10
    except TypeError:
        print("Erro: Não é possível somar uma string com um número.")
    ```

    - o Python gera um `TypeError` porque é inválido somar uma string (`"5"`) com um número inteiro (`10`);
    - o bloco `except` captura o erro e exibe uma mensagem apropriada;

- **multiplicação de lista por string**
    ```python
    try:
        resultado = [1, 2, 3] * "2"
    except TypeError:
        print("Erro: Não é possível multiplicar uma lista por uma string.")
    ```

    - aqui, Python tenta multiplicar uma lista por uma string, o que não faz sentido; listas só podem ser multiplicadas por números inteiros para replicar os elementos;
    - isso gera um `TypeError`;

- **chamada de função com número incorreto de argumentos**
    ```python
    def somar(a, b):
        return a + b

    try:
        resultado = somar(1)
    except TypeError:
        print("Erro: A função 'somar' requer dois argumentos.")
    ```

    - a função `somar` foi definida para aceitar dois argumentos (`a` e `b`), mas foi passado apenas um argumento (`1`), o que gera um `TypeError`;
    - esse erro é capturado e uma mensagem explicativa é exibida;

- **comparação entre tipos incompatíveis**
    ```python
    try:
        resultado = "texto" > 10
    except TypeError:
        print("Erro: Não é possível comparar uma string com um número.")
    ```

    - python gera um `TypeError` porque comparar uma string com um número usando `>` não é uma operação válida;

---

### `IndexError`

O `IndexError` ocorre quando tenta-se acessar um índice que está fora dos limites de uma sequência (como listas, tuplas ou strings). Em outras palavras, o índice que estamos tentando acessar não existe na sequência.

Esse erro acontece nas seguintes situações :
- tentativa de acessar um índice maior ou igual ao comprimento da sequência;
- tentativa de acessar um índice negativo que excede o início da sequência;
- alterar o tamanho da sequência enquanto itera sobre ela, resultando em índices inválidos;

#### Exemplos

- **acessando um índice fora do alcance**
    ```python
    lista = [1, 2, 3]

    try:
        print(lista[3])  # Índices válidos são 0, 1, 2
    except IndexError:
        print("Erro: Índice fora do alcance da lista.")
    ```

    - a lista `lista` tem três elementos com índices `0`, `1` e `2`;
    - ao tentar acessar `lista[3]`, estamos buscando um quarto elemento inexistente;
    - o Python gera um `IndexError`, que é capturado no bloco `except`;

- **índices negativos fora do alcance**
    ```python
    lista = [10, 20, 30]

    try:
        print(lista[-4])  # Índices negativos válidos: -1, -2, -3
    except IndexError:
        print("Erro: Índice negativo fora do alcance da lista.")
    ```

    - em Python, índices negativos começam do final da lista (`-1` é o último elemento);
    - para uma lista de tamanho 3, índices negativos válidos são `-1`, `-2` e `-3`;
    - tentar acessar `lista[-4]` excede o limite negativo, gerando um `IndexError`;

- **modificando a lista durante a iteração**
    ```python
    lista = [1, 2, 3, 4]

    try:
        for i in range(len(lista)):
            lista.pop()
            print(lista[i])
    except IndexError:
        print("Erro: Índice fora do alcance após modificação da lista.")
    ```

    - o loop itera sobre os índices baseados no tamanho inicial da lista;
    - a cada iteração, `lista.pop()` remove o último elemento, diminuindo o tamanho da lista;
    - eventualmente, o índice `i` excede o tamanho atual da lista, resultando em um `IndexError`;

- **acesso em string**
    ```python
    texto = "Python"

    try:
        print(texto[10])
    except IndexError:
        print("Erro: Índice fora do alcance da string.")
    ```

    - a string `"Python"` tem 6 caracteres, com índices de `0` a `5`;
    - tentar acessar `texto[10]` está fora desses limites, gerando um `IndexError`;

---

### `KeyError`

O `KeyError` ocorre quando tenta-se acessar uma chave que não existe em um dicionário. Em outras palavras, estamos tentando obter o valor associado a uma chave inexistente.

Esse erro acontece nas seguintes situações :
- usar `dict[key]` com uma chave que não está no dicionário;
- tentar deletar uma chave que não existe;
- métodos como `pop()` sem valor padrão;

#### Exemplos

- **acessando uma chave inexistente**
    ```python
    dicionario = {'nome': 'Alice', 'idade': 30}

    try:
        print(dicionario['endereco'])
    except KeyError:
        print("Erro: A chave 'endereco' não existe no dicionário.")
    ```


    - o dicionário `dicionario` não possui a chave `'endereco'`;
    - tentar acessá-la diretamente gera um `KeyError`;

- **removendo uma chave inexistente**
    ```python
    dicionario = {'nome': 'Bob', 'idade': 25}

    try:
        del dicionario['telefone']
    except KeyError:
        print("Erro: Não é possível deletar a chave 'telefone' porque ela não existe.")
    ```

    - tentar deletar uma chave inexistente com `del` resulta em um `KeyError`;

- **iterando sobre chaves**
    ```python
    dicionario = {'a': 1, 'b': 2, 'c': 3}

    try:
        for chave in ['a', 'b', 'd']:
            print(f"{chave}: {dicionario[chave]}")
    except KeyError as e:
        print(f"Erro: A chave '{e.args[0]}' não existe no dicionário.")
    ```

    - ao iterar, tentamos acessar a chave `'d'`, que não existe;
    - o `KeyError` é capturado, e usa-se `e.args[0]` para obter a chave faltante;

---

### `ImportError`

O `ImportError` ocorre quando o Python não consegue importar um módulo, pacote ou componente específico. Isso pode acontecer por vários motivos, como o módulo não existir, o nome estar incorreto ou problemas com o caminho do módulo.

Esse erro acontece nas seguintes situações :
- tentar importar um módulo que não está instalado no ambiente python;
- escrever incorretamente o nome do módulo;
- tentar importar um componente que não existe dentro de um módulo;
- o módulo não está no caminho de pesquisa do python;

#### Exemplos

-  **importando um módulo inexistente**
    ```python
    try:
        import modulo_inexistente
    except ImportError:
        print("Erro: O módulo 'modulo_inexistente' não foi encontrado.")
    ```

    - tenta-se importar um módulo que não existe, resultando em um `ImportError`;

-  **erro de digitação no nome do módulo**
    ```python
    try:
        import mathh  # Deveria ser 'math'
    except ImportError:
        print("Erro: Módulo não encontrado. Verifique o nome do módulo.")
    ```

    - um simples erro de digitação impede o Python de encontrar o módulo, gerando um `ImportError`;

-  **importando função inexistente de um módulo**
    ```python
    try:
        from math import raiz_quadrada  # Deveria ser 'sqrt'
    except ImportError:
        print("Erro: Função 'raiz_quadrada' não encontrada no módulo 'math'.")
    ```

    - tenta-se importar uma função que não existe dentro do módulo, resultando em um `ImportError`;

-  **módulo não instalado**
    ```python
    try:
        import pandas
    except ImportError:
        print("Erro: O módulo 'pandas' não está instalado.")
    ```

    - se o módulo `pandas` não estiver instalado, o Python não pode importá-lo, gerando um `ImportError`;
    - solução: Instalar o módulo com `pip install pandas`;

-  **problema com o caminho do módulo**
    ```python
    try:
        import sys
        sys.path.append('/caminho/para/o/modulo')
        import meu_modulo
    except ImportError:
        print("Erro: Não foi possível importar 'meu_modulo' do caminho especificado.")
    ```

    - mesmo adicionando um novo caminho ao `sys.path`, se o módulo não estiver presente nesse caminho, o `ImportError` ocorrerá;

-  **usando `ModuleNotFoundError` no python 3.6+**
    ```python
    try:
        import modulo_inexistente
    except ModuleNotFoundError:
        print("Erro: Módulo não encontrado.")
    ```

    - no Python 3.6 e posteriores, `ModuleNotFoundError` é uma subclasse de `ImportError`;
    - captura especificamente erros em que o módulo não foi encontrado;

---

### `FileNotFoundError`

O `FileNotFoundError` ocorre quando o Python tenta abrir um arquivo que não existe no sistema. Isso geralmente acontece quando o caminho fornecido está incorreto ou o arquivo foi excluído ou movido. Esse erro é uma subclasse de `OSError` e é especificamente levantado para erros de sistema relacionados à abertura de arquivos inexistentes.

O `FileNotFoundError` pode ocorrer em diversos contextos :
- quando o arquivo que você tenta abrir não existe no caminho especificado;
- quando você tenta abrir um arquivo para leitura mas ele foi deletado, movido ou o caminho está incorreto;
- quando há erros de digitação no nome ou caminho do arquivo;

#### Exemplos

- **tentativa de abrir um arquivo inexistente**
    ```python
    try:
        arquivo = open('arquivo_inexistente.txt', 'r')
    except FileNotFoundError:
        print("Erro: O arquivo 'arquivo_inexistente.txt' não foi encontrado.")
    ```

    - tenta-se abrir um arquivo chamado `'arquivo_inexistente.txt'` para leitura;
    - como o arquivo não existe, o Python gera um `FileNotFoundError`, que é capturado pelo bloco `except`;

- **caminho incorreto**
    ```python
    try:
        arquivo = open('/caminho/incorreto/arquivo.txt', 'r')
    except FileNotFoundError:
        print("Erro: O caminho especificado para o arquivo está incorreto.")
    ```

    - o caminho fornecido para o arquivo está incorreto ou não existe no sistema;
    - o Python gera um `FileNotFoundError`, que é tratado no bloco `except`;

- **criando o arquivo se ele não existir**
    ```python
    caminho = 'novo_arquivo.txt'

    try:
        with open(caminho, 'r') as arquivo:
            conteudo = arquivo.read()
    except FileNotFoundError:
        with open(caminho, 'w') as arquivo:
            arquivo.write('Conteúdo inicial')
        print(f"O arquivo '{caminho}' foi criado com sucesso.")
    ```

    - tentamos abrir o arquivo para leitura; se o arquivo não existir, ele será criado no bloco `except` com o modo de escrita `'w'`, evitando o `FileNotFoundError`;

---

### `NameError`

O `NameError` ocorre quando tenta-se usar uma variável, função ou nome que não foi definido anteriormente. Isso significa que o Python não consegue encontrar uma referência ao nome que está sendo chamado no contexto atual.

O `NameError` pode ocorrer nas seguintes situações :
- tentar usar uma variável que nunca foi declarada;
- chamar uma função que não foi importada ou definida no escopo atual;
- nome de variável ou função digitado incorretamente;

#### Exemplos

- **uso de uma variável não definida**
    ```python
    try:
        print(x)
    except NameError:
        print("Erro: A variável 'x' não está definida.")
    ```

    - tenta-se imprimir a variável `x`, que não foi definida anteriormente, o que gera um `NameError`;
    - o erro é tratado e uma mensagem apropriada é exibida;

- **chamada de função não definida**
    ```python
    try:
        resultado = minha_funcao()
    except NameError:
        print("Erro: A função 'minha_funcao' não está definida.")
    ```

    - tenta-se chamar a função `minha_funcao()`, mas ela não foi definida ou importada;
    - o Python gera um `NameError` que é capturado e tratado no bloco `except`;

- **erro de digitação no nome da variável**
    ```python
    variavel = 10

    try:
        print(varaivel)  # Nome incorreto
    except NameError:
        print("Erro: A variável está mal escrita ou não foi definida.")
    ```

    - tenta-se imprimir `varaivel`, mas o nome correto é `variavel`; um simples erro de digitação resulta em um `NameError`;
    - o erro é tratado e uma mensagem explicativa é exibida;

- **verificação de nome global**
    ```python
    def minha_funcao():
        print("Função definida!")

    try:
        minha_funcao()
    except NameError:
        print("Erro: A função 'minha_funcao' não está definida no escopo global.")
    ```

    - tenta-se chamar uma função que foi corretamente definida, garantindo que não ocorra o `NameError`;
    - caso a função não esteja definida no escopo global, o erro seria capturado;

---

## cuidados

> [!CAUTION]
> Quando se usa os blocos `try` e `except` é importante mencionar que a captura de erros **`deve ser sempre`** pontual. Não se coloca blocos de códigos desnecessários dentro da cláusula `try`, senão outros erros não previstos podem acontecer.

Por exemplo :

```python
try:
    # todo o código está dentro do bloco try
    nova_lista = list(range(10))
    valor = nova_lista[0]
    resultado = valor * "2"
    resultado += 1
    print(f'{resultado = }')
except TypeError:
    print("Erro: Não é possível multiplicar um inteiro por uma string.")
```

O código acima vai gerar um erro, mas praticamente todo o código está dentro do bloc `try`. Isso não é uma boa prática. Pode tornar difícil saber exatamente o que está levantando o erro.

O ideal é isolar dentro do bloco `try` apenas o código passível do respectivo erro.

```python
nova_lista = list(range(10))
valor = nova_lista[0]

try:
    # isola apenas o trecho de código passível de erro
    resultado = valor * "2"
except TypeError:
    print("Erro: Não é possível multiplicar um inteiro por uma string.")

resultado += 1
print(f'{resultado = }')
```

## exercícios

<details>
<summary>Lista de Exercícios</summary>

1. **Exercícios ZeroDivisionError**
    1. Crie um programa que peça ao usuário dois números e divida o primeiro pelo segundo. Trate o **`ZeroDivisionError`** caso o segundo número seja zero.
    1. Escreva uma função que receba dois números como argumentos e retorne a divisão do primeiro pelo segundo. Trate o erro quando o divisor for zero.
    1. Simule uma calculadora que realize as operações básicas (adição, subtração, multiplicação e divisão). Garanta que divisões por zero sejam tratadas.
    1. Crie um programa que divida uma lista de números por um valor fornecido pelo usuário. Trate divisões por zero.
    1. Crie uma função recursiva que calcule a divisão sucessiva de uma lista de números por um divisor constante. Trate o erro de divisão por zero.
    1. Implemente um código que execute uma divisão baseada na entrada do usuário, convertendo a entrada em números e tratando **`ZeroDivisionError`** e **`ValueError`** simultaneamente.
    1. Escreva uma função que simule a divisão em operações bancárias. Ao realizar uma divisão por zero, exiba uma mensagem amigável.
    1. Modifique um código que realiza cálculos matemáticos complexos para verificar sempre se a divisão por zero pode ocorrer e trate o erro.
    1. Faça um programa que divida o total de vendas mensais por um número de meses. Verifique a possibilidade de divisão por zero no caso de meses iguais a zero.
    1. Crie uma função que calcule a média de números em uma lista, onde o denominador pode ser zero (caso a lista esteja vazia). Trate a divisão por zero.
1. **Exercícios ValueError**
    1. Crie um programa que peça ao usuário para inserir um número inteiro e trate o **`ValueError`** caso o usuário insira um valor não numérico.
    1. Implemente uma função que converta uma string para um número. Trate o erro se a string não puder ser convertida.
    1. Faça um programa que leia uma lista de números fornecida pelo usuário e trate **`ValueError`** para entradas inválidas (não numéricas).
    1. Escreva uma função que some todos os elementos de uma lista de strings que representam números. Trate possíveis erros de conversão.
    1. Crie um programa que solicite ao usuário uma data (dia, mês, ano) e trate **`ValueError`** caso a data seja inválida.
    1. Escreva um código que converta entradas do usuário em números inteiros e trate **`ValueError`** caso a entrada não seja válida.
    1. Crie um programa que leia um valor de temperatura e faça a conversão entre diferentes escalas (Celsius, Fahrenheit, Kelvin). Trate **`ValueError`** para entradas inválidas.
    1. Faça um programa que solicite ao usuário que insira valores numéricos em um formato específico (ex: `3.14`) e trate **`ValueError`** para valores inválidos.
    1. Implemente uma função que receba uma lista de strings e converta todas elas em números inteiros, tratando **`ValueError`** caso ocorra um erro.
    1. Faça um programa que peça ao usuário para inserir um número de telefone. Trate **`ValueError`** caso o número inserido seja inválido (contendo letras, por exemplo).
1. **Exercícios TypeError**
    1. Escreva uma função que some dois números e trate o **`TypeError`** caso um dos argumentos não seja um número.
    1. Crie uma função que multiplique dois números fornecidos como entrada. Trate o **`TypeError`** se um dos argumentos for uma string.
    1. Implemente uma função que concatene duas strings. Trate o **`TypeError`** se os argumentos não forem strings.
    1. Faça um programa que some os elementos de uma lista. Trate o **`TypeError`** caso a lista contenha elementos não numéricos.
    1. Crie uma função que execute operações aritméticas em uma lista. Trate o **`TypeError`** caso algum elemento não seja do tipo esperado.
    1. Implemente um programa que calcule a soma de uma lista de números e trate o **`TypeError`** se qualquer item da lista não for um número.
    1. Escreva um programa que receba uma lista e uma função como entrada e aplique a função a todos os elementos da lista. Trate o **`TypeError`** se os tipos forem incompatíveis.
    1. Crie uma função que execute uma divisão entre dois números, tratando o **`TypeError`** se um dos argumentos for uma string.
    1. Escreva um programa que peça ao usuário para fornecer duas entradas e concatene-as. Trate o **`TypeError`** se as entradas não forem strings.
    1. Faça um programa que peça ao usuário dois números e retorne a soma deles. Trate o **`TypeError`** se o usuário fornecer strings em vez de números.
1. **Exercícios IndexError**
    1. Crie um programa que solicite ao usuário para inserir um índice e retorne o elemento correspondente de uma lista. Trate **`IndexError`** caso o índice esteja fora do intervalo da lista.
    1. Implemente uma função que acesse o último elemento de uma lista sem usar índices negativos. Trate **`IndexError`** caso a lista esteja vazia.
    1. Faça um programa que percorra uma lista e tente acessar elementos com índices fora do intervalo. Trate **`IndexError`** adequadamente.
    1. Crie uma função que divida os elementos de uma lista por seus índices. Trate **`IndexError`** caso o índice não exista na lista.
    1. Escreva um programa que peça ao usuário para acessar um índice de uma string. Trate **`IndexError`** para índices inválidos.
    1. Crie um programa que tente acessar o primeiro e o último elemento de uma lista. Trate **`IndexError`** caso a lista esteja vazia.
    1. Faça um programa que peça ao usuário para inserir uma lista de elementos e um índice. Trate **`IndexError`** se o índice fornecido estiver fora dos limites.
    1. Escreva um código que percorra uma lista em um loop e, em cada iteração, tente acessar um índice além do tamanho da lista. Trate **`IndexError`**.
    1. Implemente um programa que modifique elementos de uma lista de acordo com o índice fornecido. Trate **`IndexError`** para índices inválidos.
    1. Crie um código que percorra uma lista de listas e tente acessar índices dentro das sublistas. Trate **`IndexError`** se o índice não existir em alguma sublista.
1. **Exercícios KeyError**
    1. Crie um dicionário simples e peça ao usuário para acessar um valor pela chave. Trate o **`KeyError`** caso a chave não exista.
    1. Faça um programa que use um dicionário para armazenar informações de alunos (nome, idade) e trate **`KeyError`** ao tentar acessar uma chave inexistente.
    1. Escreva um programa que atualize o valor de uma chave em um dicionário. Trate **`KeyError`** caso a chave não exista.
    1. Implemente uma função que receba um dicionário e uma lista de chaves. Para cada chave que não existir no dicionário, trate o **`KeyError`**.
    1. Crie um dicionário de produtos e preços. Peça ao usuário para inserir um nome de produto e exiba o preço. Trate **`KeyError`** se o produto não estiver no dicionário.
    1. Escreva uma função que busque informações de contato (nome, telefone) em um dicionário. Trate **`KeyError`** caso a chave inserida pelo usuário não esteja no dicionário.
    1. Faça um programa que permita que o usuário adicione e remova itens de um dicionário. Trate **`KeyError`** ao tentar remover uma chave inexistente.
    1. Crie uma função que percorra um dicionário de livros e retorne o preço de um livro específico. Trate **`KeyError`** se o livro não estiver no dicionário.
    1. Implemente um código que percorra um dicionário de alunos e verifique se determinadas chaves (nomes de alunos) existem. Trate **`KeyError`** adequadamente.
    1. Crie um programa que use um dicionário para armazenar notas de alunos. Peça ao usuário para inserir o nome de um aluno e exiba sua nota. Trate **`KeyError`** para alunos inexistentes.
1. **Exercícios ImportError**
    1. Escreva um programa que tente importar um módulo inexistente e trate o **`ImportError`**.
    1. Faça um programa que importe um módulo e execute uma função. Trate **`ImportError`** caso o módulo não exista.
    1. Crie um código que use `from` para importar uma função específica de um módulo. Trate **`ImportError`** caso a função não exista.
    1. Faça um programa que importe múltiplos módulos e trate **`ImportError`** para qualquer um que falhe.
    1. Implemente uma função que tente importar uma biblioteca externa e trate **`ImportError`** caso ela não esteja instalada.
    1. Crie um programa que importe um módulo, execute uma função e trate **`ImportError`** caso o módulo ou a função não existam.
    1. Escreva um código que tente importar uma biblioteca de visualização de dados (como `matplotlib`). Trate **`ImportError`** caso ela não esteja instalada.
    1. Faça um programa que importe um módulo baseado na entrada do usuário. Trate **`ImportError`** se o módulo não estiver disponível.
    1. Escreva um código que tente importar uma função matemática de um módulo e trate **`ImportError`** caso o módulo ou função não existam.
    1. Crie um programa que verifique a disponibilidade de um módulo e exiba uma mensagem amigável se houver um **`ImportError`**.
1. **Exercícios FileNotFoundError**
    1. Faça um programa que tente abrir um arquivo inexistente para leitura e trate o **`FileNotFoundError`**.
    1. Implemente uma função que verifique se um arquivo existe antes de abri-lo. Trate **`FileNotFoundError`** se o arquivo não for encontrado.
    1. Escreva um código que peça ao usuário o nome de um arquivo para abrir. Trate **`FileNotFoundError`** se o arquivo não existir.
    1. Crie uma função que leia o conteúdo de um arquivo fornecido pelo usuário. Trate **`FileNotFoundError`** caso o arquivo não esteja no caminho correto.
    1. Faça um programa que tente abrir um arquivo de configuração e trate **`FileNotFoundError`** se o arquivo não existir.
    1. Escreva um código que tente abrir múltiplos arquivos e trate **`FileNotFoundError`** para qualquer arquivo que não possa ser encontrado.
    1. Crie uma função que copie o conteúdo de um arquivo para outro. Trate **`FileNotFoundError`** se o arquivo de origem não existir.
    1. Implemente um programa que tente abrir um arquivo em um caminho fornecido pelo usuário e trate **`FileNotFoundError`** se o caminho estiver incorreto.
    1. Faça um programa que tente abrir um arquivo de log. Trate **`FileNotFoundError`** caso o arquivo de log não tenha sido criado.
    1. Escreva um código que percorra uma lista de arquivos e tente abri-los um por um, tratando **`FileNotFoundError`** para qualquer arquivo inexistente.
1. **Exercícios NameError**
    1. Escreva um código que tente imprimir uma variável não definida e trate o **`NameError`**.
    1. Crie um programa que peça ao usuário para definir uma variável e depois tente usá-la. Trate **`NameError`** se a variável não for definida.
    1. Escreva uma função que utilize uma variável global que não foi definida. Trate **`NameError`**.
    1. Faça um programa que tente usar uma função que não foi definida e trate **`NameError`**.
    1. Implemente um código que peça ao usuário para inserir uma variável e tente acessá-la. Trate **`NameError`** se a variável não estiver no escopo.
    1. Crie um programa que tente acessar uma variável dentro de uma função e trate **`NameError`** se a variável não estiver definida dentro do escopo da função.
    1. Escreva um código que defina uma variável condicionalmente e tente usá-la depois. Trate **`NameError`** caso ela não tenha sido definida.
    1. Faça um programa que simule uma calculadora. Trate **`NameError`** se o usuário tentar usar uma função não definida.
    1. Implemente um código que tente acessar um dicionário com uma variável não definida. Trate **`NameError`** se a variável não estiver no escopo.
    1. Crie uma função que use uma variável definida fora de seu escopo e trate **`NameError`** caso ela não exista.

</details>

## exceções múltiplas

Exceções múltiplas em Python ocorrem quando se deseja capturar e tratar diferentes tipos de erros no mesmo bloco `try-except`. Isso permite que o código lide com uma variedade de possíveis problemas de forma organizada e clara, sem precisar de um bloco `try-except` separado para cada tipo de exceção. Esse conceito é útil porque, muitas vezes, ao escrever um programa, diferentes tipos de erros podem ocorrer em uma mesma seção de código.

### por que usar exceções múltiplas?

1. **manter o código organizado** : em vez de criar vários blocos `try-except` para diferentes tipos de erros, pode-se lidar com vários erros de forma mais concisa;

1. **tratar diferentes cenários de falhas** : quando diferentes tipos de erros podem ocorrer, é importante tratá-los de maneira apropriada; por exemplo, um erro de valor inválido deve ser tratado de maneira diferente de um erro de divisão por zero;

1. **facilitar a depuração** : ao usar exceções múltiplas, pode-se capturar e tratar diferentes exceções com mensagens específicas, ajudando a identificar rapidamente o que deu errado;

### quando usar exceções múltiplas?

1. **quando diferentes tipos de erros podem ocorrer no mesmo bloco de código** : por exemplo, ao fazer operações matemáticas e trabalhar com conversão de dados ao mesmo tempo, é possível que ocorram tanto **`ZeroDivisionError`** quanto **`ValueError`**;

1. **quando os erros precisam de tratamentos diferentes** : se diferentes tipos de erros precisam ser tratados de forma distinta, é útil capturá-los separadamente em um bloco `except`;

1. **ao manipular código que lida com diferentes fontes de entrada** : se o programa lida com vários tipos de entrada, como arquivos, entradas de usuário e operações de rede, diferentes exceções podem ocorrer, e é bom capturá-las corretamente;

### quando não usar exceções múltiplas?

1. **quando apenas um tipo de erro é esperado** : se há um único erro que pode ser previsto, usar exceções múltiplas pode complicar o código desnecessariamente;

1. **quando o código fica confuso** : o uso excessivo de exceções múltiplas em um bloco de código muito longo pode tornar o código difícil de ler; nesse caso, seria melhor dividir o código em funções menores ou lidar com exceções separadamente;

1. **capturar exceções genéricas sem necessidade** : evite capturar exceções amplas como **`Exception`** sem um motivo claro, pois isso pode ocultar erros que deveriam ser tratados de forma mais específica;

### como usar exceções múltiplas?

Há duas formas principais de capturar exceções múltiplas em Python:

1. **listando exceções em uma única linha** : para capturar diferentes tipos de exceções com o mesmo bloco de tratamento, pode-se listá-las entre parênteses no bloco `except`.

    ```python
    try:
        x = int(input("Digite um número: "))
        resultado = 10 / x
    except (ValueError, ZeroDivisionError) as e:
        print(f"Ocorreu um erro: {e}")
    ```

    - o programa tenta converter a entrada do usuário em um número inteiro e depois realiza uma divisão;
    - se o usuário inserir algo que não seja um número (por exemplo, uma string), ocorrerá um **`ValueError`**;
    - se o usuário inserir `0`, ocorrerá um **`ZeroDivisionError`**;
    - ambos os erros são capturados e tratados no mesmo bloco `except`, com uma mensagem genérica exibida para o usuário;

1. **tratamento específico para cada exceção** : se quiser tratar diferentes exceções de maneiras distintas, pode criar vários blocos `except`.

    ```python
    try:
        x = int(input("Digite um número: "))
        resultado = 10 / x
    except ValueError:
        print("Você precisa digitar um número válido!")
    except ZeroDivisionError:
        print("Divisão por zero não é permitida!")
    ```

    - aqui, cada tipo de erro tem uma mensagem de erro específica para ajudar o usuário a entender melhor o que deu errado;
    - o **`ValueError`** é tratado separadamente do **`ZeroDivisionError`**, permitindo um feedback mais claro;

### como não usar exceções múltiplas?

1. **capturar exceções genéricas sem necessidade** : usar um bloco `except Exception` pode capturar todos os erros, mas isso pode ser perigoso, pois pode acabar ignorando erros importantes; sempre que possível, seja específico com as exceções que captura.

    ```python
    try:
        x = int(input("Digite um número: "))
        resultado = 10 / x
    except Exception as e:
        print(f"Ocorreu um erro: {e}")
    ```

    **por que evitar?** : capturar todas as exceções dessa forma impede que se trate adequadamente problemas específicos, além de dificultar a depuração, pois todas as exceções são tratadas da mesma forma;

1. **uso excessivo de exceções múltiplas** : exagerar no uso de exceções pode tornar o código confuso; em vez de tentar capturar muitos erros de uma só vez, é melhor dividir o código em funções menores e capturar exceções em contextos mais específicos.

### exemplo mais complexo de uso de exceções múltiplas

Aqui está um exemplo mais avançado que mostra como diferentes tipos de erros podem ser capturados e tratados de maneira apropriada.

```python
def processar_dados():
    nome_arquivo = input("Digite o nome do arquivo: ")

    try:
        with open(nome_arquivo, "r") as arquivo:
            conteudo = arquivo.read()

        numero = int(input("Digite um número: "))
        resultado = 100 / numero
        print(f"O resultado é {resultado}")

    except FileNotFoundError:
        print("O arquivo especificado não foi encontrado.")

    except ValueError:
        print("Você precisa digitar um número válido!")

    except ZeroDivisionError:
        print("Divisão por zero não é permitida!")

    except Exception as e:
        print(f"Ocorreu um erro inesperado: {e}")

processar_dados()
```

**explicação** :
- o programa tenta abrir um arquivo, ler seu conteúdo e depois realizar uma divisão;
- se o arquivo não existir, **`FileNotFoundError`** será capturado;
- se o usuário inserir um valor que não possa ser convertido em um número inteiro, **`ValueError`** será tratado;
- se o número inserido for zero, **`ZeroDivisionError`** será capturado;
- o bloco genérico `except Exception` captura qualquer outro erro que possa ocorrer, mas isso é usado apenas para garantir que nenhum erro seja ignorado;

---

## exercícios exceções múltiplas

<details>
<summary>Lista de Exercícios</summary>

1. **ZeroDivisionError e ValueError** : Crie um programa que peça ao usuário dois números e realize a divisão do primeiro pelo segundo. Trate a entrada inválida de um número (como uma string ou outro valor não numérico) e o caso de divisão por zero.
1. **TypeError e ZeroDivisionError** : Escreva uma função que receba dois argumentos e retorne a divisão do primeiro pelo segundo. Trate o erro se um dos argumentos não for um número (como uma string) e se o segundo número for zero.
1. **IndexError e ValueError** : Crie um programa que peça ao usuário para inserir um índice e depois retorne o elemento correspondente de uma lista pré-definida. Trate o caso de o índice estar fora do intervalo da lista e o caso de o usuário inserir um valor não numérico.
1. **KeyError e NameError** : Faça um programa que use um dicionário para armazenar os nomes e idades de pessoas. O programa deve pedir ao usuário um nome para procurar a idade correspondente no dicionário. Trate o erro de tentar acessar uma chave inexistente e o erro de tentar usar uma variável não definida.
1. **ImportError e NameError** : Crie um código que tente importar um módulo inexistente (ex: `parangaricutirimirruaro`) e depois use uma função de um módulo inexistente. Trate tanto o erro de importação quanto o erro de nome de função.
1. **FileNotFoundError e IOError** : Escreva um programa que peça ao usuário o nome de um arquivo para ler. Tente abrir o arquivo e ler seu conteúdo. Trate o erro caso o arquivo não exista e qualquer outro erro de leitura/escrita que possa ocorrer.
1. **ZeroDivisionError e KeyError** : Crie um programa que solicite dois números para realizar uma divisão. Caso o usuário insira `0` como o divisor, trate o erro de divisão por zero. Depois, tente acessar o resultado da divisão armazenado em um dicionário e trate o erro de chave inexistente.
1. **ValueError, IndexError e ZeroDivisionError** : Escreva um programa que leia uma lista de números fornecida pelo usuário, peça um índice e tente dividir o número do índice por outro número inserido pelo usuário. Trate entradas inválidas, divisões por zero e índices fora do intervalo da lista.
1. **TypeError, NameError e KeyError** : Crie uma função que receba dois números e retorne sua soma. Trate o erro caso um dos argumentos não seja um número e o erro de tentar usar uma variável não definida para armazenar o resultado. Depois, tente acessar o resultado em um dicionário e trate o erro de chave inexistente.
1. **ValueError e FileNotFoundError** : Faça um programa que peça ao usuário para inserir um número e depois o nome de um arquivo para armazenar esse número. Trate o erro se o valor inserido não for um número e o erro caso o arquivo não exista ao tentar acessá-lo.
1. **KeyError e IndexError** : Implemente um dicionário com listas de números como valores. Peça ao usuário para inserir uma chave e um índice. Tente acessar o valor correspondente e o índice dentro da lista associada à chave. Trate o erro de chave inexistente e índice fora dos limites da lista.
1. **ImportError e TypeError** : Escreva um código que tente importar um módulo que não está instalado e depois tente executar uma função que espera uma string, mas receba um número como argumento. Trate tanto o erro de importação quanto o erro de tipo.
1. **ZeroDivisionError, ValueError e FileNotFoundError** : Faça um programa que peça ao usuário para inserir dois números e depois divida o primeiro pelo segundo. Em seguida, tente gravar o resultado em um arquivo cujo nome é inserido pelo usuário. Trate os erros de divisão por zero, valor inválido e arquivo não encontrado.
1. **ValueError, NameError e TypeError** : Crie uma função que some dois números. Peça ao usuário para inserir os números e trate o erro de entrada inválida. Depois, trate o erro de usar uma variável não definida e o erro de tentar somar valores de tipos diferentes.
1. **IndexError, TypeError e KeyError** : Escreva um programa que percorra uma lista e um dicionário ao mesmo tempo. Tente acessar um índice inválido na lista e uma chave inexistente no dicionário, tratando ambos os erros. Além disso, trate o erro de tentar realizar operações com tipos incompatíveis.
1. **FileNotFoundError e ZeroDivisionError** : Crie um código que tente abrir um arquivo de texto e ler seu conteúdo. Depois, tente dividir um número lido do arquivo por outro número inserido pelo usuário. Trate os erros de arquivo não encontrado e divisão por zero.
1. **ImportError e NameError** : Faça um programa que tente importar uma biblioteca externa não instalada. Em seguida, tente usar uma variável que não foi definida. Trate os erros de importação e nome de variável indefinida.
1. **KeyError, IndexError e ValueError** : Escreva um programa que trabalhe com um dicionário de listas. O programa deve pedir ao usuário para inserir uma chave, um índice e um número. Trate o erro caso a chave ou o índice não existam, além de tratar entradas inválidas de números.
1. **FileNotFoundError, ValueError e IOError** : Faça um programa que peça ao usuário para inserir o nome de um arquivo para abrir, um número para ler do arquivo e trate os erros de arquivo inexistente, número inválido e outros problemas de leitura/escrita.
1. **NameError, ZeroDivisionError e KeyError** : Implemente um programa que calcule a média de valores armazenados em um dicionário. Trate os erros de usar uma variável não definida, tentar dividir pela quantidade zero de elementos e acessar uma chave inexistente no dicionário.

</details>

## `except` genérico

Em Python, o bloco `except` genérico captura qualquer tipo de exceção que ocorra dentro de um bloco `try`. Embora o uso de exceções genéricas possa parecer uma maneira conveniente de evitar que o programa falhe inesperadamente, essa prática pode ser prejudicial e levar a diversos problemas de depuração e manutenção de código.

### como funciona

O `except` genérico é um bloco de tratamento de exceções que captura **qualquer** exceção que ocorra no bloco `try`, sem especificar o tipo de erro :

```python
try:
    x = 10 / 0
except:
    print("Ocorreu um erro!")
```

Neste exemplo, qualquer exceção dentro do bloco `try` será capturada e tratada pelo bloco `except`, sem diferenciar o tipo de erro. Isso inclui exceções que você talvez não deseje capturar, como erros de sintaxe ou interrupções do sistema.

### Por que não se deve usar o `except` genérico

1. **Oculta o tipo de exceção real**: Ao capturar exceções de forma genérica, se perde a capacidade de identificar o que realmente causou o erro. Isso torna a depuração muito mais difícil, já que não há informações detalhadas sobre o tipo de exceção que ocorreu.

1. **Captura exceções que não quer capturar**: Algumas exceções, como **`KeyboardInterrupt`** (interrupção do programa pelo usuário) ou **`SystemExit`** (sinalizando o encerramento do programa), não deveriam ser capturadas e tratadas da mesma forma que outras exceções comuns. Usar `except` genérico pode capturar essas exceções e impedir o comportamento natural do sistema.

1. **Difícil de manter**: O uso de exceções genéricas torna o código mais difícil de manter, já que o tratamento de erros não está claro. Outros desenvolvedores (ou mesmo você no futuro) podem ter dificuldade para entender quais tipos de erros o código está preparado para tratar.

1. **Pode mascarar erros graves**: Capturar erros inesperados de forma genérica pode mascarar falhas sérias no programa. Por exemplo, um erro de lógica no código pode ser capturado silenciosamente, sem que o programador perceba que há um problema maior que precisa ser corrigido.

### exemplos de como o uso do `except` genérico pode ser prejudicial

#### exemplo 1: ocultando exceções inesperadas

Aqui, um erro de sintaxe no código será capturado pelo `except` genérico, mas o programador não perceberá o erro subjacente :

```python
try:
    resultado = 10 / 0
except:
    print("Algo deu errado!")
```

**Problema**:
- O erro **`ZeroDivisionError`** é silenciosamente capturado, mas o programador não tem ideia do que realmente deu errado.
- O bloco `except` simplesmente imprime uma mensagem genérica, sem fornecer informações úteis para resolver o problema.

**Consequência**:
- Isso dificulta a identificação do erro real. O programador pode pensar que o problema é menor, quando, na verdade, pode haver uma falha grave no código.

#### **exemplo 2: captura indesejada de exceções críticas**

No exemplo abaixo, o `except` genérico captura um **`KeyboardInterrupt`**, impedindo o usuário de interromper o programa com `Ctrl+C`:

```python
try:
    while True:
        pass  # Loop infinito
except:
    print("Ocorreu um erro!")
```

**Problema**:
- Se o usuário tentar interromper o programa com `Ctrl+C`, a exceção **`KeyboardInterrupt`** será capturada e tratada como um "erro" comum.
- Isso impede que o usuário encerre o programa como esperado.

**Consequência**:
- Capturar exceções como **`KeyboardInterrupt`** pode impedir o funcionamento correto do sistema e fazer com que o programa não responda adequadamente a interrupções externas.

#### **exemplo 3: mascarando erros graves**

Neste exemplo, um erro crítico que não deveria ser capturado é tratado de forma genérica:

```python
def abrir_arquivo():
    try:
        with open("arquivo_inexistente.txt", "r") as f:
            conteudo = f.read()
    except:
        print("Erro ao abrir o arquivo")

abrir_arquivo()
```

**Problema**:
- O arquivo não existe, então um **`FileNotFoundError`** ocorre. No entanto, a exceção é capturada de forma genérica.
- Isso mascara o erro real, e a única coisa que o programador vê é a mensagem "Erro ao abrir o arquivo".

**Consequência**:
- O código não fornece informações suficientes sobre o erro. Se o problema for mais grave do que a falta do arquivo (por exemplo, permissões inadequadas no sistema), ele não será diagnosticado corretamente.

### boas práticas

#### quando evitar

1. **Na maioria dos casos**: Em praticamente todas as situações, é melhor ser específico sobre quais exceções você deseja capturar e tratar. Isso torna o código mais legível e ajuda na depuração de erros.

    ```python
    try:
        resultado = 10 / 0
    except ZeroDivisionError:
        print("Erro: Divisão por zero.")
    ```

1. **Quando há exceções críticas**: Exceções como **`SystemExit`**, **`KeyboardInterrupt`**, e **`MemoryError`** geralmente não devem ser capturadas, pois interferem no comportamento normal do sistema. Capturar essas exceções de forma genérica pode resultar em consequências indesejadas.

#### quando usar

1. **Em situações de fallback seguro**: Se está implementando um sistema que precisa continuar funcionando a todo custo, como um servidor que precisa estar sempre disponível, capturar exceções genéricas pode ser aceitável, desde que seja acompanhado de um log detalhado que ajude na depuração posterior.

    ```python
    try:
        resultado = 10 / 0
    except Exception as e:
        print(f"Ocorreu um erro: {e}")
    ```

    Aqui, está sendo capturado todas as exceções, mas ainda fornecemos informações úteis sobre o erro, imprimindo a mensagem do erro original. Embora seja genérico, isso permite alguma transparência no que deu errado.

2. **Em scripts simples e descartáveis**: Se está criando um script rápido ou algo temporário, o uso de `except` genérico pode ser aceitável, já que o objetivo é mais a funcionalidade do que a robustez a longo prazo.

### consequências

1. **Dificuldade na manutenção**: O código se torna difícil de manter, já que os erros reais são mascarados. Outros programadores podem ter dificuldade em identificar e corrigir problemas.

2. **Falha na depuração**: A depuração se torna complexa, pois não há informações claras sobre o que exatamente deu errado. Em vez de corrigir o problema, o programador pode acabar "silenciando" o erro sem realmente resolvê-lo.

3. **Perda de controle sobre exceções críticas**: O sistema pode se comportar de maneira imprevisível ao capturar exceções que não deveriam ser capturadas, como interrupções de sistema ou problemas de memória.

## exercícios `except` genérico

<details>
<summary>Lista de Exercícios</summary>

1. **Ocultando erros de programação** : O código tenta converter uma entrada do usuário para um número inteiro e realizar uma divisão. Use um `except` genérico para capturar a exceção e veja como ele oculta erros inesperados.

    ```python
    def calcular_divisao():
        try:
            numero = int(input("Digite um número: "))
            resultado = 10 / numero
        except:
            print("Erro ocorreu!")

    calcular_divisao()
    ```

    - Por que o uso de `except` genérico pode ser prejudicial neste código? Quais exceções poderiam ser ocultas?

1. **Ocultando erros de digitação** : No código abaixo, há um erro de digitação na variável `numer`, que deveria ser `numero`. O `except` genérico oculta o erro, o que pode tornar a depuração mais difícil.

    ```python
    def calcular():
        try:
            numer = 10
            resultado = 100 / numero  # Erro de digitação
        except:
            print("Ocorreu um erro.")

    calcular()
    ```

    - Qual é o problema com o `except` genérico aqui? O que aconteceria se você corrigisse o erro e especificasse as exceções?

1. **Ocultando exceções de arquivos** : O código tenta abrir um arquivo que não existe. O `except` genérico impede que o erro `FileNotFoundError` seja tratado adequadamente.

    ```python
    def abrir_arquivo():
        try:
            with open("arquivo_inexistente.txt", "r") as f:
                conteudo = f.read()
        except:
            print("Erro ao abrir o arquivo.")

    abrir_arquivo()
    ```

    - Qual exceção está sendo capturada? Por que seria melhor capturar `FileNotFoundError` especificamente em vez de usar um `except` genérico?

1. **Ignorando erros de tipo** : O código tenta somar dois valores, mas um deles não é numérico. O `except` genérico esconde o erro de tipo (`TypeError`).

    ```python
    def somar(a, b):
        try:
            return a + b
        except:
            print("Ocorreu um erro.")

    somar(10, "vinte")
    ```

    - Por que o uso de `except` genérico é problemático aqui? Como você trataria especificamente a exceção `TypeError`?

1. **Ignorando divisões por zero** : O código tenta realizar uma divisão por zero, mas o `except` genérico não informa ao usuário que o problema é uma divisão por zero.

    ```python
    def dividir():
        try:
            resultado = 10 / 0
        except:
            print("Algo deu errado.")

    dividir()
    ```

    - Qual exceção está sendo capturada aqui? Por que é importante informar ao usuário qual foi o erro?

1. **Capturando todas as exceções** : O código tenta abrir um arquivo, converter uma entrada para número e fazer uma divisão. O `except` genérico captura todos os erros possíveis, sem distinção.

    ```python
    def processo():
        try:
            with open("arquivo.txt", "r") as f:
                conteudo = f.read()
            numero = int(input("Digite um número: "))
            resultado = 10 / numero
        except:
            print("Ocorreu um erro durante o processo.")

    processo()
    ```

    - Por que o uso de `except` genérico em várias operações é prejudicial? Como você poderia melhorar o tratamento de exceções?

1. **Ocultando exceções de `KeyError`** : No código abaixo, o dicionário não contém a chave "nome", mas o `except` genérico não permite que o erro `KeyError` seja mostrado corretamente.

    ```python
    def acessar_dicionario():
        dados = {"idade": 30}
        try:
            print(dados["nome"])
        except:
            print("Erro ao acessar o dicionário.")

    acessar_dicionario()
    ```

    - O que o `except` genérico está ocultando? Como você poderia capturar e tratar especificamente o erro `KeyError`?

1. **Ignorando exceções de importação** : O código tenta importar um módulo inexistente, mas o `except` genérico esconde o erro de `ImportError`.

    ```python
    def importar_modulo():
        try:
            import modulo_inexistente
        except:
            print("Erro ao importar módulo.")

    importar_modulo()
    ```

    - Por que o uso de `except` genérico pode ser problemático em operações de importação? Como você capturaria especificamente o erro `ImportError`?

1. **Ocultando erros lógicos** : Aqui, o código tenta acessar um índice inválido de uma lista. O `except` genérico oculta o erro `IndexError`.

    ```python
    def acessar_lista():
        lista = [1, 2, 3]
        try:
            print(lista[5])
        except:
            print("Erro ao acessar lista.")

    acessar_lista()
    ```

    - Por que o `except` genérico está ocultando o erro? Como você poderia capturar a exceção `IndexError` de forma adequada?

1. **Ocultando exceções de variáveis não definidas** : O código tenta usar uma variável não definida. O `except` genérico oculta o erro `NameError`, que indica que a variável não foi declarada.

    ```python
    def usar_variavel():
        try:
            print(variavel_inexistente)
        except:
            print("Erro ao usar variável.")

    usar_variavel()
    ```

    - O que está sendo capturado pelo `except` genérico? Por que é importante capturar o erro `NameError` especificamente?

</details>

## comandos `else` e `finally`

O tratamento de exceções em Python oferece recursos poderosos, e além do uso básico de `try` e `except`, dois blocos opcionais complementam o tratamento de erros: **`else`** e **`finally`**. Ambos têm papéis distintos que aumentam a flexibilidade e robustez do código.

### `else`

O bloco `else` é executado **somente** se **nenhuma exceção** for levantada dentro do bloco `try`. Ele é opcional e permite que se execute um código que deve ocorrer somente quando o bloco `try` for bem-sucedido, sem erros.

A estrutura geral é a seguinte :

```python
try:
    # código que pode gerar uma exceção
except SomeException:
    # código para tratar a exceção
else:
    # código que será executado se não houver exceções
```

- **Exemplo do uso**

```python
try:
    numero = int(input("Digite um número: "))
    resultado = 10 / numero
except ValueError:
    print("Erro: O valor inserido não é um número válido.")
except ZeroDivisionError:
    print("Erro: Divisão por zero.")
else:
    print(f"O resultado da divisão é: {resultado}")
```

- o bloco `try` tenta converter a entrada do usuário para um número inteiro e depois realiza uma divisão;
- se uma exceção **`ValueError`** ou **`ZeroDivisionError`** for levantada, o código no bloco `except` correspondente será executado;
- se **nenhuma exceção** ocorrer, o bloco `else` será executado, exibindo o resultado da divisão;

#### vantagens

1. **clareza de propósito** : colocar o código no bloco `else` ajuda a separar o que deve acontecer em caso de sucesso do que ocorre em caso de erro; isso melhora a legibilidade, tornando o código mais intuitivo;
1. **evita o uso excessivo de código no `try`** : o código no bloco `try` deve ser apenas o necessário para detectar e tratar erros; o `else` permite que o código de sucesso seja separado, reduzindo o risco de capturar exceções inadvertidamente;
1. **melhora a manutenção do código** : com o `else`, é mais fácil entender e gerenciar o fluxo de execução, o que facilita a manutenção e expansão do código;

#### desvantagens

1. **pouco utilizado em alguns casos** : nem sempre é necessário; se todo o código puder ser contido no bloco `try` sem perda de clareza, o `else` pode parecer redundante;
1. **pode ser confundido com o fluxo do `try`** : novos programadores podem não entender de imediato o porquê de separar o código de sucesso no `else`, o que pode levar a uma má interpretação;

### `finally`

O bloco `finally` é executado **sempre**, independentemente de uma exceção ter sido levantada ou não. Ele é usado para garantir que o código crítico seja executado, como fechar arquivos, liberar recursos ou encerrar conexões com banco de dados, mesmo se ocorrer um erro.

A estrutura geral é:

```python
try:
    # código que pode gerar uma exceção
except SomeException:
    # código para tratar a exceção
finally:
    # código que sempre será executado, com ou sem exceção
```

- **Exemplo do uso**

```python
try:
    arquivo = open('arquivo.txt', 'r')
    conteudo = arquivo.read()
except FileNotFoundError:
    print("Erro: O arquivo não foi encontrado.")
else:
    print(conteudo)
finally:
    arquivo.close()
    print("Arquivo fechado.")
```

- o bloco `try` tenta abrir um arquivo e lê seu conteúdo;
- se o arquivo não for encontrado, um **`FileNotFoundError`** é levantado e tratado no bloco `except`;
- se o arquivo for encontrado, o conteúdo é exibido no bloco `else`;
- o bloco `finally` é executado sempre, fechando o arquivo, independentemente de ter havido uma exceção ou não;

#### Vantagens

1. **garantia de execução** : o `finally` garante que o código será executado, mesmo que uma exceção ocorra; isso é útil para operações como:
    - fechar arquivos ou liberar recursos;
    - desconectar de um banco de dados ou de uma API;
    - limpeza de variáveis ou processos temporários;

1. **robustez no código** : ele aumenta a robustez, pois, não importa o que aconteça no bloco `try` ou `except`, o código no `finally` será executado;

1. **previne vazamento de recursos** : em programas que lidam com recursos limitados ou externos (como arquivos ou conexões de rede), o `finally` é essencial para garantir que esses recursos sejam corretamente fechados ou liberados;

#### desvantagens

1. **pode ocultar exceções** : se um erro ocorrer dentro do bloco `finally`, ele pode sobrescrever uma exceção levantada no bloco `try`, ocultando o erro original; isso dificulta a depuração.

    ```python
    try:
        resultado = 10 / 0
    except ZeroDivisionError:
        print("Erro de divisão por zero.")
    finally:
        raise ValueError("Erro dentro do finally.")
    ```

    - neste caso, o erro **`ValueError`** do `finally` substitui a exceção **`ZeroDivisionError`**, o que pode confundir na hora da depuração, pois o erro original é perdido;

1. **execução de código irrelevante** : se o bloco `finally` contiver código que não é crítico para a execução final (como mensagens desnecessárias), ele pode aumentar a complexidade sem benefícios reais;

### quando usar `else` e `finally`

#### `else`

- **quando o código após o `try` só deve ser executado se não houver exceções** : isso torna o fluxo de execução mais claro e separado do tratamento de exceções;
- **quando o código dentro do `try` deve ser mínimo**, limitando-se apenas ao que pode gerar exceções, enquanto o código de "sucesso" vai no `else`;

#### `finally`

- **quando for necessário liberar recursos ou fazer "limpeza"**, como fechar arquivos, desconectar de uma rede ou liberar memória, independentemente de erros;
- **quando for fundamental garantir a execução de um bloco de código específico**, como garantir que um log seja escrito ou um backup seja criado, mesmo em caso de erro;

### quando evitar `else` e `finally`

- **evite `else` quando o código no bloco `try` for simples e fácil de ler** : se todo o código puder ser executado no `try` sem perda de clareza, o `else` pode não ser necessário;

- **evite `finally` se não houver recursos para liberar ou ações críticas a serem executadas** : se não há ações que devam ser garantidas após o bloco `try`, o uso do `finally` pode ser desnecessário e pode adicionar complexidade desnecessária ao código;

## exercícios `else` e `finally`

<details>
<summary>Lista de Exercícios</summary>

1. **Operação aritmética** : Escreva um código que peça ao usuário dois números e os divida. Utilize um bloco `try` para capturar erros de divisão por zero e tipos inválidos. No bloco `else`, exiba o resultado. No bloco `finally`, exiba uma mensagem indicando que a operação foi concluída.
1. **Leitura de arquivo** : Tente abrir um arquivo para leitura. Se o arquivo não for encontrado, capture a exceção com um `except`. Utilize o bloco `else` para ler o conteúdo e imprimir na tela. No `finally`, feche o arquivo, se ele tiver sido aberto.
1. **Verificação de índice** : Peça ao usuário uma lista e um índice. No `try`, tente acessar o elemento da lista usando o índice. Capture o erro de `IndexError`. No `else`, exiba o valor encontrado. No `finally`, exiba uma mensagem indicando o fim da operação.
1. **Conversão de tipos** : Peça ao usuário para digitar um número. No `try`, tente converter a entrada para `int`. Capture erros de conversão de tipos com `except`. No `else`, informe que a conversão foi bem-sucedida. No `finally`, imprima "Processo concluído".
1. **Remoção de item de dicionário** : Crie um dicionário com alguns elementos. No `try`, remova uma chave fornecida pelo usuário. Se a chave não existir, capture o erro `KeyError`. No `else`, exiba o dicionário atualizado. No `finally`, exiba uma mensagem indicando que a operação de remoção foi tentada.
1. **Escrita em arquivo** : Tente abrir um arquivo para escrita e adicionar algum conteúdo. Utilize `try` para capturar erros relacionados ao acesso ao arquivo. No `else`, informe que a escrita foi bem-sucedida. No `finally`, feche o arquivo.
1. **Execução de função matemática** : Peça ao usuário um número e tente calcular sua raiz quadrada usando `try`. Capture qualquer erro relacionado a valores negativos. No `else`, exiba o resultado da raiz quadrada. No `finally`, exiba uma mensagem final.
1. **Remoção de item de lista** : Peça ao usuário uma lista e um valor para remover. No `try`, tente remover o valor da lista. Capture erros caso o valor não esteja presente com `ValueError`. No `else`, exiba a lista atualizada. No `finally`, exiba uma mensagem indicando o fim da operação.
1. **Divisão com múltiplas exceções** : Escreva um código que tente dividir dois números inseridos pelo usuário. Capture erros de `ZeroDivisionError` e `TypeError`. No `else`, mostre o resultado da divisão. No `finally`, exiba uma mensagem de conclusão.
1. **Processamento de lista de inteiros** : Peça ao usuário uma lista de inteiros e tente somar os valores. Capture erros caso a lista contenha valores que não sejam inteiros. No `else`, exiba a soma. No `finally`, informe que o processamento foi concluído.
1. **Operação em dicionário** : Peça ao usuário para fornecer uma chave e um valor, e tente adicioná-los a um dicionário. Capture erros de tipo com `TypeError`. No `else`, exiba o dicionário atualizado. No `finally`, exiba uma mensagem indicando que a operação foi finalizada.
1. **Entrada de número positivo** : Solicite ao usuário um número positivo. No `try`, verifique se o número é maior que zero. Capture erros de entrada inválida. No `else`, mostre que a entrada foi válida. No `finally`, imprima "Fim do programa".
1. **Acesso a arquivos protegidos** : Tente abrir um arquivo protegido. Capture erros de permissão com `PermissionError`. No `else`, informe que o arquivo foi acessado corretamente. No `finally`, exiba uma mensagem indicando que a tentativa foi feita.
1. **Acesso a chaves em dicionários aninhados** : Peça ao usuário um dicionário aninhado e uma chave de primeiro nível para acessar. Capture erros de `KeyError` se a chave não existir. No `else`, exiba o valor da chave. No `finally`, exiba uma mensagem de fim.
1. **Verificação de múltiplos índices** : Peça ao usuário uma lista e múltiplos índices. Tente acessar os elementos de cada índice e capture `IndexError`. No `else`, mostre os valores acessados. No `finally`, exiba uma mensagem de conclusão.
1. **Cálculo de média** : Solicite uma lista de números do usuário. No `try`, tente calcular a média dos números. Capture erros de divisão por zero caso a lista esteja vazia. No `else`, exiba a média calculada. No `finally`, exiba uma mensagem final.
1. **Conversão de dados para float** : Peça ao usuário para fornecer uma lista de números (em string) e tente converter todos para `float`. Capture qualquer erro de `ValueError` ao tentar a conversão. No `else`, mostre a lista de floats. No `finally`, exiba uma mensagem de conclusão.
1. **Acesso a arquivos em um diretório** : Tente acessar um arquivo específico dentro de um diretório fornecido pelo usuário. Capture erros de `FileNotFoundError` caso o arquivo não exista. No `else`, exiba o conteúdo do arquivo. No `finally`, exiba uma mensagem indicando que a operação foi finalizada.

</details>

## capturando mensagens de erro

Capturar e exibir as mensagens de erro em Python é uma prática crucial para a depuração e manutenção de um código robusto. Com o tratamento de exceções, é possível acessar as mensagens de erro associadas às exceções geradas durante a execução do programa. Isso ajuda a identificar rapidamente a causa de um problema, melhorar a experiência do usuário e evitar falhas não tratadas.

### como funciona

Quando uma exceção é levantada (gerada) em Python, ela contém uma mensagem descritiva que indica o motivo do erro. Capturar essa mensagem permite entendê-la melhor e tomar decisões sobre como tratar o erro.

A captura da mensagem de erro geralmente é feita no bloco `except` ao manipular exceções, mas há formas mais detalhadas de capturar o rastreamento completo do erro e os detalhes sobre o contexto onde ele ocorreu.

#### captura básica de exceção com `as`

A forma mais simples de capturar a mensagem de erro é associando a exceção a uma variável usando o `as` dentro do bloco `except`. Essa variável conterá a mensagem de erro, que pode ser impressa ou registrada.

- **Exemplo: Captura básica com `ZeroDivisionError`**

```python
try:
    resultado = 10 / 0
except ZeroDivisionError as e:
    print(f"Erro: {e}")
```

- o bloco `try` tenta executar uma divisão por zero, o que gera uma exceção do tipo `ZeroDivisionError`;
- o bloco `except` captura essa exceção e a associa à variável `e`, que contém a mensagem de erro `"division by zero"`;
- a mensagem de erro é então impressa;

**Saída:**
```
Erro: division by zero
```

#### módulo `traceback`

O módulo `traceback` fornece informações detalhadas sobre o erro, incluindo o rastreamento da pilha (stack trace), que mostra a sequência de chamadas de função que levaram ao erro. Isso é especialmente útil para depurar grandes programas, pois ajuda a identificar onde, exatamente, o erro ocorreu.

- **Exemplo: Usando `traceback.print_exc()`**

```python
import traceback

try:
    resultado = 10 / 0
except ZeroDivisionError:
    print("Erro detectado:")
    traceback.print_exc()  # Exibe o rastreamento completo do erro
```

- o bloco `try` tenta realizar uma divisão por zero;
- `traceback.print_exc()` imprime o rastreamento completo da exceção, incluindo o local do código onde ocorreu o erro;

**Saída:**
```
Erro detectado:
Traceback (most recent call last):
  File "example.py", line 3, in <module>
    resultado = 10 / 0
ZeroDivisionError: division by zero
```

### acessando atributos específicos da exceção

Dependendo do tipo de exceção, pode-se acessar informações adicionais. Por exemplo, com exceções relacionadas a arquivos, como `FileNotFoundError`, pode-se acessar atributos como `filename` (nome do arquivo) e `strerror` (mensagem de erro).

- **Exemplo: `FileNotFoundError` com atributos adicionais**

```python
try:
    with open("arquivo_inexistente.txt", "r") as f:
        conteudo = f.read()
except FileNotFoundError as e:
    print(f"Erro: {e.strerror}")
    print(f"Arquivo não encontrado: {e.filename}")
```

- o bloco `try` tenta abrir um arquivo que não existe, o que gera uma exceção `FileNotFoundError`;
- a variável `e` contém informações detalhadas, como o nome do arquivo e a mensagem de erro;

**Saída:**
```
Erro: No such file or directory
Arquivo não encontrado: arquivo_inexistente.txt
```

### vantagens

- 1. **Facilita a depuração** : capturar e exibir mensagens de erro ajuda a entender o que está acontecendo no programa em tempo de execução; isso é crucial para identificar e corrigir bugs rapidamente;
- 1. **Permite mensagens de erro personalizadas** : pode-se capturar a mensagem de erro e, ao mesmo tempo, exibir uma mensagem personalizada que explique melhor o contexto do erro para o usuário ou para o desenvolvedor;

    Exemplo:
    ```python
    try:
        numero = int(input("Digite um número: "))
        resultado = 10 / numero
    except ValueError:
        print("Erro: O valor fornecido não é um número válido.")
    except ZeroDivisionError:
        print("Erro: Não é possível dividir por zero.")
    ```

- 1. **Melhora a experiência do usuário** : ao capturar mensagens de erro e tratá-las adequadamente, pode-se fornecer feedback amigável para o usuário, em vez de permitir que o programa quebre com uma exceção não tratada;

- 1. **Possibilita o uso de logs** : em sistemas maiores ou em ambientes de produção, é comum registrar as exceções em um arquivo de log para análise posterior; capturar a mensagem de erro permite gravá-la para monitoramento contínuo;

### desvantagens

- 1. **Pode esconder problemas graves** : capturar exceções sem o tratamento adequado ou sem re-exibi-las pode ocultar problemas maiores que deveriam parar o programa, dificultando a depuração;

- 2. **Pode aumentar a complexidade** : adicionar muitos blocos de captura de erro pode tornar o código mais difícil de ler e manter, especialmente se não for claro quais exceções estão sendo capturadas e por quê;

- 3. **Excessos no tratamento de erros** : se capturar mensagens de erro de maneira excessiva e tratar exceções que não necessariamente precisam ser tratadas, pode acabar mascarando problemas que deveriam ser abordados de outra forma, levando a comportamentos inesperados;

    Exemplo negativo:
    ```python
    try:
        resultado = 10 / 0
    except Exception as e:
        print("Erro desconhecido:", e)  # Captura genérica sem distinção
    ```

    - **Problema** : usar `except Exception` de maneira genérica pode capturar qualquer exceção, inclusive aquelas que não se espera, tornando o código mais difícil de depurar;

## exercícios mensagens de erro

<details>
<summary>Lista de Exercícios</summary>

1. **Exercício 1: ZeroDivisionError - Divisão Simples** : Peça ao usuário dois números e tente dividi-los. Capture o erro de divisão por zero e exiba a mensagem de erro.
1. **Exercício 2: ValueError - Conversão de String para Inteiro** : Peça ao usuário para inserir um número. Tente converter a entrada para `int`. Capture qualquer erro de `ValueError` e exiba a mensagem de erro.
1. **Exercício 3: TypeError - Soma de Tipos Diferentes** : Tente somar uma string e um número. Capture o erro de `TypeError` e exiba a mensagem de erro.
1. **Exercício 4: IndexError - Acessar Índice Inválido** : Crie uma lista com alguns elementos e peça ao usuário um índice. Tente acessar o elemento na posição fornecida. Capture o erro de `IndexError` e exiba a mensagem de erro.
1. **Exercício 5: KeyError - Acesso a Chave de Dicionário Inexistente** : Crie um dicionário com algumas chaves e peça ao usuário uma chave. Tente acessar o valor correspondente à chave fornecida. Capture o erro de `KeyError` e exiba a mensagem de erro.
1. **Exercício 6: ImportError - Importar Módulo Inexistente** : Tente importar um módulo que não existe. Capture o erro de `ImportError` e exiba a mensagem de erro.
1. **Exercício 7: FileNotFoundError - Abrir Arquivo Inexistente** : Tente abrir um arquivo que não existe no sistema. Capture o erro de `FileNotFoundError` e exiba a mensagem de erro.
1. **Exercício 8: NameError - Variável Não Definida** : Tente imprimir o valor de uma variável que não foi definida. Capture o erro de `NameError` e exiba a mensagem de erro.
1. **Exercício 9: ZeroDivisionError - Cálculo de Média** : Peça ao usuário uma lista de números e calcule a média. Capture qualquer erro de `ZeroDivisionError` se a lista estiver vazia e exiba a mensagem de erro.
1. **Exercício 10: ValueError - Entrada de Números** : Peça ao usuário para fornecer uma lista de números, mas digite uma string em vez de um número. Capture o erro de `ValueError` e exiba a mensagem de erro.
1. **Exercício 11: TypeError - Concatenar Tipos Diferentes** : Peça ao usuário um número e uma string. Tente concatená-los diretamente. Capture o erro de `TypeError` e exiba a mensagem de erro.
1. **Exercício 12: IndexError - Acesso em Lista Vazia** : Crie uma lista vazia e tente acessar o primeiro elemento. Capture o erro de `IndexError` e exiba a mensagem de erro.
1. **Exercício 13: KeyError - Remoção de Chave Inexistente** : Tente remover uma chave de um dicionário que não existe. Capture o erro de `KeyError` e exiba a mensagem de erro.
1. **Exercício 14: ImportError - Função Inexistente de Módulo** : Tente importar uma função específica de um módulo, mas use o nome errado da função. Capture o erro de `ImportError` e exiba a mensagem de erro.
1. **Exercício 15: FileNotFoundError - Leitura de Arquivo Inexistente** : Tente abrir e ler o conteúdo de um arquivo que não existe no diretório atual. Capture o erro de `FileNotFoundError` e exiba a mensagem de erro.
1. **Exercício 16: NameError - Função Não Definida** : Tente chamar uma função que não foi definida anteriormente. Capture o erro de `NameError` e exiba a mensagem de erro.
1. **Exercício 17: ZeroDivisionError - Função de Divisão** : Crie uma função que divide dois números. Peça ao usuário dois números e tente dividi-los. Capture o erro de `ZeroDivisionError` e exiba a mensagem de erro.
1. **Exercício 18: ValueError - Conversão de Lista de Strings para Inteiros** : Peça ao usuário uma lista de strings e tente converter todos os elementos para inteiros. Capture qualquer erro de `ValueError` e exiba a mensagem de erro.
1. **Exercício 19: TypeError - Multiplicação de Tipos Diferentes** : Tente multiplicar uma string por outro tipo não permitido (ex.: `None`). Capture o erro de `TypeError` e exiba a mensagem de erro.
1. **Exercício 20: IndexError - Listas Aninhadas** : Crie uma lista de listas e peça ao usuário para fornecer dois índices (um para a lista principal e outro para a lista interna). Tente acessar o elemento. Capture o erro de `IndexError` e exiba a mensagem de erro.

</details>


# usando-python.md

Índice Usando o Python

1. [pep 8](#pep-8)
1. [usando o python](#usando-o-python)
1. [interpretador python](#interpretador-python)
1. [módulo python](#módulo-python)
1. [explicando exemplos](#explicando-exemplos)
1. [comandos de saída e entrada de dados](#comando-de-saída-e-entrada-de-dados)
1. [comentários](#comentários)
1. [o que foi visto até agora](#o-que-foi-visto-até-agora)

# pep 8
Antes de iniciar o Python é preciso saber que existe a `PEP 8`.

A PEP 8 existe para melhorar a leitura do código Python. Uma vez o Guido van Rossum (autor do Python) disse que `um código é lido com muito mais frequência do que é escrito`.

Um código pode ser escrito em alguns minutos ou um dia inteiro, mas uma vez escrito, ele nunca mais terá que ser escrito novamente (muito provavelmente alterado em algum ponto). E DEFINITIVAMENTE ele terá que ser lido novamente. Pode ser difícil de relembrar o que um determinado trecho de código feito há alguns dias, semanas, meses ou até mesmo anos está fazendo se ele não estiver bem claro e documentado.

Seguir as orientações da PEP 8 ajuda a manter uma boa legibilidade das variáveis; saber que há espaço em branco suficiente para tornar o código mais fácil de ler; saber que os comentários são precisos e ajudam a lembrar o que ele faz. Além desses aspectos, também facilita para ler o código de outros programadores.

O manual de referência para todas essas boas práticas está documentado na [PEP 8 - Style Guide for Python Code](https://peps.python.org/pep-0008) (em inglês). PEP é uma abreviação de Python Enhancement Proposals (Propostas de Melhoramentos do Python).

Conforme novas funcionalidades do Python são apresentadas, sua respectiva PEP 8 será mostrada.

# usando o python
O Python pode ser utilizado de diversas formas.

As duas mais comuns são:
- [Interpretador Python](#interpretador-python) : ele é acessado pelo Prompt de Comando digitando python e também é conhecido como *Modo Interativo*;
- [Módulo Python](#módulo-python) : arquivo com extensão .py;

> [!TIP]
> Ative a visualização das extensões de arquivos de seu sistema operacional.
>
> [Como ativar no Windows](https://support.microsoft.com/pt-br/windows/extens%C3%B5es-de-nome-de-arquivo-comuns-no-windows-da4a4430-8e76-89c5-59f7-1cdbbc75cb01);
>
> [Como ativar no macOS](https://support.apple.com/pt-br/guide/mac-help/mchlp2304/mac);
>
> Como ativar no Linux : se usa Linux, provavelmente você já sabe como;

## interpretador python
Uma vez que o Python é instalado, é possível iniciar o interpretador através do terminal (Linux e macOS) ou Prompt de Comando (Windows). Para isso, basta realizar a chamada do python no shell.

Chamada do Python no Linux / macOS :
```shell
$ python
Python 3.12.3 (main, Apr 23 2024, 09:16:07) [GCC 13.2.1 20240417] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> |
```

Chamada do Python no Windows :
```powershell
C:\> python
Python 3.12.3 (tags/v3.12.2:6abddd9, Feb 6 2024, 21:26:36) [MSC v.1937 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>> |
```

Pode-se sair do interpretador digitando :
```shell
>>> quit()
```
ou
```shell
>>> exit()
```
ou ainda segurando as teclas `Ctrl + z` no Windows ou `Ctrl + d` no Linux/macOS;

Os recursos de edição de linha do interpretador incluem edição interativa, substituição de histórico e completamento de código.

Quando os comandos são lidos a partir do terminal/console, diz-se que o interpretador está em modo interativo. Nesse modo, ele solicita um próximo comando através do *prompt primário*, representado por três sinais de maior `>>>`; para linhas de continuação do comando atual, o *prompt secundário* padrão é formado por três pontos `...`.

Veja alguns exemplos de uso do interpretador :
```python
$ python
Python 3.12.3 (main, Apr 23 2024, 09:16:07) [GCC 13.2.1 20240417] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> 10
10
>>> 30 + 12
42
>>>
>>> 'um texto'
'um texto'
>>> "outro texto"
'outro texto'
>>>
>>> True is False
False
>>>
>>> 4/1 - 4/3 + 4/5 - 4/7 + 4/9 - 4/11
2.9760461760461765
>>>
>>> a_terra_eh_plana = True
>>> if a_terra_eh_plana:
...     print('Cuidado com o Cthulhu!')
...
Cuidado com o Cthulhu!
>>> |
```
Há também uma forma de executar comandos python diretamente do terminal (fora do interpretador), mas isso será visto mais adiante.

`PS.:` nos sistemas Linux e macOS pode haver uma diferença na versão do interpretador. Muitos pacotes antigos ainda presentes nesses sistemas são dependentes da versão 2 do Python para funcionar corretamente, número esse que diminui a cada ano. Por causa disso, em algumas versões mais antigas do Linux e do macOS ainda é necessário digitar `python3` para que a terceira versão seja executada e não a segunda.

## módulo python
Outra forma de usar o Python é através de arquivos com a extensão `.py`, que são chamados de *módulos* no Python.

Quando se usa um módulo Python, qualquer comando lá colocado é executado apenas quando ele é chamado após o `python` no terminal.

Por exemplo, imagine que há um módulo chamado `resposta.py` que, quando chamado, vai exibir uma pergunta e sua resposta.

Módulo `resposta.py` :
```python
valor = 42

print('Qual é a resposta da vida, do universo e tudo mais?')

if valor != 42:
    print('Resposta errada!')
else:
    print(f'A resposta é : {valor}')
```
Chamando o módulo `resposta.py` usando o interpretador python :
```shell
$ python resposta.py
Qual é a resposta da vida, do universo e tudo mais?
A resposta é : 42
```

## explicando exemplos
A partir de agora muitos exemplos serão mostrados. Qualquer exemplo mostrado em *Modo Interativo* também pode ser usado em um *módulo* Python.

Usando o módulo *main.py* e sua chamada pelo interpretador :
```python
# usando o módulo main.py
n_1 = 10
n_2 = 32

print(f'A expressão {n_1} + {n_2} é igual a {n_1 + n_2}.')
```
```shell
$ python main.py
A expressão 10 + 32 é igual a 42.
```

Usando o mesmo exemplo diretamente no interpretador :
```python
>>> # usando o Interpretador Python
>>> n_1 = 10
>>> n_2 = 32
>>>
>>> print(f'A expressão {n_1} + {n_2} é igual a {n_1 + n_2}.')
A expressão 10 + 32 é igual a 42.
>>>
>>> |
```

## comando de saída e entrada de dados

Os algoritmos precisam ser 'alimentados' com dados proveniente do meio externo para efetuarem as operações e cálculos que são necessários para alcançar algum objetivo. Com essa finalidade, utiliza-se comandos de entrada e saída. Por hora, o foco será na saída de dados.

### saída de dados

Para que um algoritmo em Python possa mostrar os dados que calculou dentro do módulo, usa-se o comando `print()`. Em português, pode ser lido como "imprimir" algo na tela.

Veja como fica :
```python
>>> nome = 'Arnoldão'
>>> print(nome)
Arnoldão
>>> print(10 + 32)
42
```

Esse comando, também permite mostrar mais de um objeto, desde que esteja separado por vírgula.
```python
>>> nome = 'Arnoldão'
>>> valor = 10
>>> print(nome, valor)
Arnoldão 10
>>> print(nome, 3.141592)
Arnoldão 3.141592
>>> print(52 - valor)
42
```

Ele também funciona no modo interativo, mostrando e executando alguns comandos de dentro da string, como a quebra de linha `\n`, por exemplo. Mais adiante isso será visto com mais detalhes.

## comentários
Quando se desenvolve códigos, é muito importante criar o hábito de manter seu código bem documentado. Deixar ele claro para outras pessoas e até para você mesmo do futuro quando precisa voltar e realizar alterações nele meses depois de criado.

Comentários em Python começam com o caractere cerquilha `#` e se estende até o final da linha. Um comentário pode aparecer no início da linha ou após espaço em branco ou código, mas não dentro de uma string literal. Nela, ele será interpretado como apenas mais um caractere da string.

Exemplos :
```python
>>> # este é o primeiro comentário
>>> num = 1 # e este é o segundo comentário
>>>         # ... e agora o terceiro!
>>> texto = '# isto não é um comentário porque está dentro das aspas'
>>> texto
'# isto não é um comentário porque está dentro das aspas'
```

### pep 8 - comentários
<details>
  <summary>Detalhes</summary>

Os comentários possuem 3 regras básicas :
- limite o tamanho da linha dos comentários e das strings de documentação em 79 caracteres;
- use frases completas, iniciando com letra maiúscula;
- tenha certeza de atualizar os comentários se o código for alterado;

Existem diversos tipos de comentários em Python. Conforme os estudos avançam, mais tipos serão vistos.

### comentários de linha
Comentários de linha explicam um único treco de código. São úteis para relembrar, ou explicar para outros desenvolvedores, porque certa linha de código é necessária.

A PEP 8 sugere que :
- use os comentários de linha com moderação;
- escreva o comentário do código na mesma linha a que se referem;
- separe os comentários de linha com dois ou mais espaços;
- inicie o comentário com um `#` e um simples espaço;
- não use para explicar o óbvio;

```python
>>> x = 5  # este é um comentário de linha
```

Às vezes, um nome de variavel pode servir melhor que um comentário :
```python
>>> x = 'Arnold Schwarzenegger'  # nome do ator
>>>
>>> nome_ator = 'Arnold Schwarzenegger'
```

Comentários de linha como o abaixo são uma má prática porque eles são óbvios e poluem o código :
```python
>>> lista_vazia = []  # inicializa uma lista vazia
>>>
>>> x = 5
>>> x = x * 5  # multiplica x por 5
```
</details>

## o que foi visto até agora

Até agora foram vistos os tipos primitivos, como declarar variáveis, constantes, como usar expressões aritméticas e lógicas, parênteses, comandos de atribuição e comentários.

Tudo o que foi visto pode ser usado diretamente no Interpretador do Python.

<details>
  <summary>Lista de Exercícios</summary>

Refaça todos os exercícios do arquivo [tipos-primitivos](tipos-primitivos.md#expressões-aritméticas) a partir das expressões aritméticas, mas agora usando o interpretador do Python.

Use um ou mais módulos Python para salvar a execução de seus códigos.

</details>


# vs-code.md

# VS Code

## Atalhos

Abaixo há uma tabela de atalhos usados no VS Code.

[link com atalhos](https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf)

### Geral

| Função                            | Windows                  | Linux                      | macOS                        |
|-----------------------------------|--------------------------|----------------------------|------------------------------|
| Mostrar Paleta de Comandos        | <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>P</kbd>, <kbd>F1</kbd>         | <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>P</kbd>, <kbd>F1</kbd>           | <kbd>Shift</kbd>+<kbd>Cmd</kbd>+<kbd>P</kbd>, <kbd>F1</kbd>              |
| Abertura Rápida, Ir para Arquivo… | <kbd>Ctrl</kbd>+<kbd>P</kbd>                   | <kbd>Ctrl</kbd>+<kbd>P</kbd>                     | <kbd>Cmd</kbd>+<kbd>P</kbd>                        |
| Nova janela/instância             | <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>N</kbd>             | <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>N</kbd>               | <kbd>Shift</kbd>+<kbd>Cmd</kbd>+<kbd>N</kbd>                  |
| Fechar janela/instância           | <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>W</kbd>             | <kbd>Ctrl</kbd>+<kbd>W</kbd>                     | <kbd>Cmd</kbd>+<kbd>W</kbd>                        |
| Configurações do Usuário          | <kbd>Ctrl</kbd>+<kbd>,</kbd>                   | <kbd>Ctrl</kbd>+<kbd>,</kbd>                     | <kbd>Cmd</kbd>+<kbd>,</kbd>                        |
| Atalhos de Teclado                | <kbd>Ctrl</kbd>+<kbd>K</kbd> <kbd>Ctrl</kbd>+<kbd>S</kbd>            | <kbd>Ctrl</kbd>+<kbd>K</kbd> <kbd>Ctrl</kbd>+<kbd>S</kbd>              | <kbd>Cmd</kbd>+<kbd>K</kbd> <kbd>Cmd</kbd>+<kbd>S</kbd>                  |

### Edição Básica

| Função                                  | Windows                   | Linux                     | macOS                               |
|-----------------------------------------|---------------------------|---------------------------|-------------------------------------|
| Cortar linha (seleção vazia)            | <kbd>Ctrl</kbd>+<kbd>X</kbd>                    | <kbd>Ctrl</kbd>+<kbd>X</kbd>                    | <kbd>Cmd</kbd>+<kbd>X</kbd>                                |
| Copiar linha (seleção vazia)            | <kbd>Ctrl</kbd>+<kbd>C</kbd>                    | <kbd>Ctrl</kbd>+<kbd>C</kbd>                    | <kbd>Cmd</kbd>+<kbd>C</kbd>                                |
| Mover linha para cima/baixo             | <kbd>Alt</kbd>+<kbd>↑</kbd> / <kbd>↓</kbd>                 | <kbd>Alt</kbd>+<kbd>↑</kbd> / <kbd>↓</kbd>                 | <kbd>Opt</kbd>+<kbd>↑</kbd> / <kbd>↓</kbd>                          |
| Copiar linha para cima/baixo            | <kbd>Shift</kbd>+<kbd>Alt</kbd>+<kbd>↑</kbd> / <kbd>↓</kbd>           |                           | <kbd>Shift</kbd>+<kbd>Opt</kbd>+<kbd>↑</kbd> / <kbd>↓</kbd>                 |
| Deletar linha                           | <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>K</kbd>              | <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>K</kbd>              | <kbd>Cmd</kbd>+<kbd>Shift</kbd>+<kbd>K</kbd>                         |
| Inserir linha abaixo                    | <kbd>Ctrl</kbd>+<kbd>Enter</kbd>                | <kbd>Ctrl</kbd>+<kbd>Enter</kbd>                | <kbd>Cmd</kbd>+<kbd>Enter</kbd>                            |
| Inserir linha acima                     | <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>Enter</kbd>          | <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>Enter</kbd>          | <kbd>Cmd</kbd>+<kbd>Shift</kbd>+<kbd>Enter</kbd>                      |
| Ir para o parêntese correspondente      | <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>\\</kbd>              | <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>\\</kbd>              | <kbd>Cmd</kbd>+<kbd>Shift</kbd>+<kbd>\\</kbd>                         |
| Indentar/Desindentar linha              | <kbd>Ctrl</kbd>+<kbd>]</kbd> / <kbd>[</kbd>                | <kbd>Ctrl</kbd>+<kbd>]</kbd> / <kbd>[</kbd>                | <kbd>Cmd</kbd>+<kbd>]</kbd> / <kbd>[</kbd>                         |
| Ir para o início/fim da linha           | <kbd>Home</kbd> / <kbd>End</kbd>                | <kbd>Home</kbd> / <kbd>End</kbd>                | <kbd>Home</kbd> / <kbd>End</kbd>                           |
| Ir para o início/fim do arquivo         | <kbd>Ctrl</kbd>+<kbd>Home</kbd> / <kbd>End</kbd>           | <kbd>Ctrl</kbd>+<kbd>Home</kbd> / <kbd>End</kbd>           | <kbd>Cmd</kbd>+<kbd>↑</kbd> / <kbd>↓</kbd>                        |
| Rolar linha para cima/baixo             | <kbd>Ctrl</kbd>+<kbd>↑</kbd> / <kbd>↓</kbd>                | <kbd>Ctrl</kbd>+<kbd>↑</kbd> / <kbd>↓</kbd>                | <kbd>Ctrl</kbd>+<kbd>PgUp</kbd> / <kbd>PgDn</kbd>               |
| Rolar página para cima/baixo            | <kbd>Alt</kbd>+<kbd>PgUp</kbd> / <kbd>PgDn</kbd>           | <kbd>Alt</kbd>+<kbd>PgUp</kbd> / <kbd>PgDn</kbd>           | <kbd>Cmd</kbd>+<kbd>PgUp</kbd> / <kbd>PgDn</kbd>                 |
| Dobre (colapsar) região                 | <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>[</kbd>              | <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>[</kbd>              | <kbd>Cmd</kbd>+<kbd>Opt</kbd>+<kbd>[</kbd>                            |
| Desdobre (expandir) região              | <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>]</kbd>              | <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>]</kbd>              | <kbd>Cmd</kbd>+<kbd>Opt</kbd>+<kbd>]</kbd>                            |
| Dobre (colapsar) todas as subregiões    | <kbd>Ctrl</kbd>+<kbd>K</kbd> <kbd>Ctrl</kbd>+<kbd>[</kbd>             | <kbd>Ctrl</kbd>+<kbd>K</kbd> <kbd>Ctrl</kbd>+<kbd>[</kbd>             | <kbd>Cmd</kbd>+<kbd>K</kbd> <kbd>Cmd</kbd>+<kbd>[</kbd>                          |
| Desdobre (expandir) todas as subregiões | <kbd>Ctrl</kbd>+<kbd>K</kbd> <kbd>Ctrl</kbd>+<kbd>]</kbd>             | <kbd>Ctrl</kbd>+<kbd>K</kbd> <kbd>Ctrl</kbd>+<kbd>]</kbd>             | <kbd>Cmd</kbd>+<kbd>K</kbd> <kbd>Cmd</kbd>+<kbd>]</kbd>                          |
| Dobre (colapsar) todas as regiões       | <kbd>Ctrl</kbd>+<kbd>K</kbd> <kbd>Ctrl</kbd>+<kbd>0</kbd>             | <kbd>Ctrl</kbd>+<kbd>K</kbd> <kbd>Ctrl</kbd>+<kbd>0</kbd>             | <kbd>Cmd</kbd>+<kbd>K</kbd> <kbd>Cmd</kbd>+<kbd>0</kbd>                          |
| Desdobre (expandir) todas as regiões    | <kbd>Ctrl</kbd>+<kbd>K</kbd> <kbd>Ctrl</kbd>+<kbd>J</kbd>             | <kbd>Ctrl</kbd>+<kbd>K</kbd> <kbd>Ctrl</kbd>+<kbd>J</kbd>             | <kbd>Cmd</kbd>+<kbd>K</kbd> <kbd>Cmd</kbd>+<kbd>J</kbd>                          |
| Alternar comentário na linha            | <kbd>Ctrl</kbd>+<kbd>/</kbd>                    | <kbd>Ctrl</kbd>+<kbd>/</kbd>                    | <kbd>Cmd</kbd>+<kbd>/</kbd>                                |
| Alternar comentário em bloco            | <kbd>Shift</kbd>+<kbd>Alt</kbd>+<kbd>A</kbd>               | <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>A</kbd>              | <kbd>Shift</kbd>+<kbd>Opt</kbd>+<kbd>A</kbd>                          |
| Alternar quebra de linha                | <kbd>Alt</kbd>+<kbd>Z</kbd>                     | <kbd>Alt</kbd>+<kbd>Z</kbd>                     | <kbd>Opt</kbd>+<kbd>Z</kbd>                                |

### Edição de Linguagens Avançadas

| Ação                                 | Windows                   | Linux                       | macOS                      |
|--------------------------------------|---------------------------|-----------------------------|----------------------------|
| Acionar sugestão                     | <kbd>Ctrl</kbd>+<kbd>Space</kbd>, <kbd>Ctrl</kbd>+<kbd>I</kbd>        | <kbd>Ctrl</kbd>+<kbd>Space</kbd>, <kbd>Ctrl</kbd>+<kbd>I</kbd>          | <kbd>Ctrl</kbd>+<kbd>Space</kbd>, <kbd>Cmd</kbd>+<kbd>I</kbd>                 |
| Acionar dicas de parâmetro           | <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>Space</kbd>          | <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>Space</kbd>            | <kbd>Cmd</kbd>+<kbd>Shift</kbd>+<kbd>Space</kbd>                    |
| Formatar documento                   | <kbd>Shift</kbd>+<kbd>Alt</kbd>+<kbd>F</kbd>               | <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>I</kbd>                | <kbd>Shift</kbd>+<kbd>Opt</kbd>+<kbd>F</kbd>                        |
| Formatar seleção                     | <kbd>Ctrl</kbd>+<kbd>K</kbd> <kbd>Ctrl</kbd>+<kbd>F</kbd>             | <kbd>Ctrl</kbd>+<kbd>K</kbd> <kbd>Ctrl</kbd>+<kbd>F</kbd>               | <kbd>Cmd</kbd>+<kbd>K</kbd> <kbd>Cmd</kbd>+<kbd>F</kbd>                      |
| Ir para a Definição                  | <kbd>F12</kbd>                       | <kbd>F12</kbd>                         | <kbd>F12</kbd>                        |
| Ver Definição                        | <kbd>Alt</kbd>+<kbd>F12</kbd>                   | <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>F10</kbd>              | <kbd>Opt</kbd>+<kbd>F12</kbd>                       |
| Abrir Definição ao lado              | <kbd>Ctrl</kbd>+<kbd>K</kbd> <kbd>F12</kbd>                | <kbd>Ctrl</kbd>+<kbd>K</kbd> <kbd>F12</kbd>                  | <kbd>Cmd</kbd>+<kbd>K</kbd> <kbd>F12</kbd>                     |
| Correção Rápida                      | <kbd>Ctrl</kbd>+<kbd>.</kbd>                    | <kbd>Ctrl</kbd>+<kbd>.</kbd>                      | <kbd>Cmd</kbd>+<kbd>.</kbd>                         |
| Mostrar Referências                  | <kbd>Shift</kbd>+<kbd>F12</kbd>                 | <kbd>Shift</kbd>+<kbd>F12</kbd>                   | <kbd>Shift</kbd>+<kbd>F12</kbd>                       |
| Renomear Símbolo                     | <kbd>F2</kbd>                        | <kbd>F2</kbd>                          | <kbd>F2</kbd>                         |
| Remover espaços em branco finais     | <kbd>Ctrl</kbd>+<kbd>K</kbd> <kbd>Ctrl</kbd>+<kbd>X</kbd>             | <kbd>Ctrl</kbd>+<kbd>K</kbd> <kbd>Ctrl</kbd>+<kbd>X</kbd>               | <kbd>Cmd</kbd>+<kbd>K</kbd> <kbd>Cmd</kbd>+<kbd>X</kbd>                      |
| Mudar linguagem do arquivo           | <kbd>Ctrl</kbd>+<kbd>K</kbd> <kbd>M</kbd>                  | <kbd>Ctrl</kbd>+<kbd>K</kbd> <kbd>M</kbd>                    | <kbd>Cmd</kbd>+<kbd>K</kbd> <kbd>M</kbd>                       |

### Navegação

| Ação                                        | Windows                   | Linux                       | macOS                       |
|---------------------------------------------|---------------------------|-----------------------------|-----------------------------|
| Mostrar todos os Símbolos                   | <kbd>Ctrl</kbd>+<kbd>T</kbd>                    | <kbd>Ctrl</kbd>+<kbd>T</kbd>                      | <kbd>Cmd</kbd>+<kbd>T</kbd>                          |
| Ir para a Linha...                          | <kbd>Ctrl</kbd>+<kbd>G</kbd>                    | <kbd>Ctrl</kbd>+<kbd>G</kbd>                      | <kbd>Ctrl</kbd>+<kbd>G</kbd>                          |
| Ir para o Arquivo...                        | <kbd>Ctrl</kbd>+<kbd>P</kbd>                    | <kbd>Ctrl</kbd>+<kbd>P</kbd>                      | <kbd>Cmd</kbd>+<kbd>P</kbd>                          |
| Ir para o Símbolo...                        | <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>O</kbd>              | <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>O</kbd>                | <kbd>Cmd</kbd>+<kbd>Shift</kbd>+<kbd>O</kbd>                         |
| Mostrar painel de Problemas                 | <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>M</kbd>              | <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>M</kbd>                | <kbd>Cmd</kbd>+<kbd>Shift</kbd>+<kbd>M</kbd>                         |
| Ir para o erro ou aviso seguinte            | <kbd>F8</kbd>                        | <kbd>F8</kbd>                          | <kbd>F8</kbd>                          |
| Ir para o erro ou aviso anterior            | <kbd>Shift</kbd>+<kbd>F8</kbd>                  | <kbd>Shift</kbd>+<kbd>F8</kbd>                    | <kbd>Shift</kbd>+<kbd>F8</kbd>                         |
| Navegar pelo histórico do grupo de editores | <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>Tab</kbd>            | <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>Tab</kbd>              | <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>Tab</kbd>                       |
| Voltar / Avançar                            | <kbd>Alt</kbd>+<kbd>←</kbd> / <kbd>→</kbd>                | <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>-</kbd> / <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>-</kbd>   | <kbd>Ctrl</kbd>+<kbd>-</kbd> / <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>-</kbd>                    |
| Alternar foco do Tab                        | <kbd>Ctrl</kbd>+<kbd>M</kbd>                    | <kbd>Ctrl</kbd>+<kbd>M</kbd>                      | <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>M</kbd>                         |

### Encontrar e Substituir

| Ação                                                            | Windows                   | Linux                       | macOS                       |
|-----------------------------------------------------------------|---------------------------|-----------------------------|-----------------------------|
| Encontrar                                                       | <kbd>Ctrl</kbd>+<kbd>F</kbd>                    | <kbd>Ctrl</kbd>+<kbd>F</kbd>                      | <kbd>Cmd</kbd>+<kbd>F</kbd>                          |
| Substituir                                                      | <kbd>Ctrl</kbd>+<kbd>H</kbd>                    | <kbd>Ctrl</kbd>+<kbd>H</kbd>                      | <kbd>Cmd</kbd>+<kbd>Opt</kbd>+<kbd>F</kbd>                         |
| Encontrar seguinte/anterior                                     | <kbd>F3</kbd> / <kbd>Shift</kbd>+<kbd>F3</kbd>             | <kbd>F3</kbd> / <kbd>Shift</kbd>+<kbd>F3</kbd>               | <kbd>Cmd</kbd>+<kbd>G</kbd> / <kbd>Cmd</kbd>+<kbd>Shift</kbd>+<kbd>G</kbd>                    |
| Selecionar todas as ocorrências da busca                        | <kbd>Alt</kbd>+<kbd>Enter</kbd>                 | <kbd>Alt</kbd>+<kbd>Enter</kbd>                   | <kbd>Opt</kbd>+<kbd>Enter</kbd>                      |
| Adicionar seleção à próxima ocorrência                          | <kbd>Ctrl</kbd>+<kbd>D</kbd>                    | <kbd>Ctrl</kbd>+<kbd>D</kbd>                      | <kbd>Cmd</kbd>+<kbd>D</kbd>                          |
| Mover a última seleção para a próxima ocorrência                | <kbd>Ctrl</kbd>+<kbd>K</kbd> <kbd>Ctrl</kbd>+<kbd>D</kbd>             | <kbd>Ctrl</kbd>+<kbd>K</kbd> <kbd>Ctrl</kbd>+<kbd>D</kbd>               | <kbd>Cmd</kbd>+<kbd>K</kbd> <kbd>Cmd</kbd>+<kbd>D</kbd>                       |
| Alternar entre maiúsculas/minúsculas, regex e palavra inteira   | <kbd>Alt</kbd>+<kbd>C</kbd> / <kbd>R</kbd> / <kbd>W</kbd>             |                             |                          |

###  Multi-cursor e Seleção

| Ação                                              | Windows                           | Linux                          | macOS                          |
|---------------------------------------------------|-----------------------------------|--------------------------------|--------------------------------|
| Inserir cursor                                    | <kbd>Alt</kbd>+Click                         | <kbd>Alt</kbd>+Click                      | <kbd>Opt</kbd>+click                       |
| Inserir cursor acima/abaixo                       | <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>↑</kbd> / <kbd>↓</kbd>                    | <kbd>Shift</kbd>+<kbd>Alt</kbd>+<kbd>↑</kbd> / <kbd>↓</kbd>                | <kbd>Cmd</kbd>+<kbd>Opt</kbd>+<kbd>↑</kbd> / <kbd>↓</kbd>                     |
| Desfazer última operação de cursor                | <kbd>Ctrl</kbd>+<kbd>U</kbd>                            | <kbd>Ctrl</kbd>+<kbd>U</kbd>                         | <kbd>Cmd</kbd>+<kbd>U</kbd>                             |
| Inserir cursor no final de cada linha selecionada | <kbd>Shift</kbd>+<kbd>Alt</kbd>+<kbd>I</kbd>                       | <kbd>Shift</kbd>+<kbd>Alt</kbd>+<kbd>I</kbd>                    | <kbd>Shift</kbd>+<kbd>Opt</kbd>+<kbd>I</kbd>                            |
| Selecionar linha atual                            | <kbd>Ctrl</kbd>+<kbd>L</kbd>                            | <kbd>Ctrl</kbd>+<kbd>L</kbd>                         | <kbd>Cmd</kbd>+<kbd>L</kbd>                             |
| Selecionar todas as ocorrências da seleção atual  | <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>L</kbd>                      | <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>L</kbd>                   | <kbd>Cmd</kbd>+<kbd>Shift</kbd>+<kbd>L</kbd>                            |
| Selecionar todas as ocorrências da palavra atual  | <kbd>Ctrl</kbd>+<kbd>F2</kbd>                           | <kbd>Ctrl</kbd>+<kbd>F2</kbd>                        | <kbd>Cmd</kbd>+<kbd>F2</kbd>                            |
| Expandir seleção                                  | <kbd>Shift</kbd>+<kbd>Alt</kbd>+<kbd>→</kbd>                       | <kbd>Shift</kbd>+<kbd>Alt</kbd>+<kbd>→</kbd>                    | <kbd>Cmd</kbd>+<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>→</kbd>                           |
| Reduzir seleção                                   | <kbd>Shift</kbd>+<kbd>Alt</kbd>+<kbd>←</kbd>                       | <kbd>Shift</kbd>+<kbd>Alt</kbd>+<kbd>←</kbd>                    | <kbd>Cmd</kbd>+<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>←</kbd>                           |
| Seleção em coluna (caixa)                         | <kbd>Shift</kbd>+<kbd>Alt</kbd> + arrastar o mouse      | <kbd>Shift</kbd>+<kbd>Alt</kbd> + arrastar o mouse   | <kbd>Shift</kbd>+<kbd>Opt</kbd> + arrastar o mouse                |
| Seleção em coluna (caixa)                         | <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>Alt</kbd> + (seta)           |                                | <kbd>Shift</kbd>+<kbd>Opt</kbd>+<kbd>Cmd</kbd>+ (seta)                       |

### Gerenciamento do Editor

| Ação                                        | Windows                        | Linux                         | macOS                          |
|---------------------------------------------|--------------------------------|-------------------------------|--------------------------------|
| Fechar editor                               | <kbd>Ctrl</kbd>+<kbd>F4</kbd>, <kbd>Ctrl</kbd>+<kbd>W</kbd>                | <kbd>Ctrl</kbd>+<kbd>W</kbd>                        | <kbd>Cmd</kbd>+<kbd>W</kbd>                            |
| Fechar pasta                                | <kbd>Ctrl</kbd>+<kbd>K</kbd> <kbd>F</kbd>                       | <kbd>Ctrl</kbd>+<kbd>K</kbd> <kbd>F</kbd>                      | <kbd>Cmd</kbd>+<kbd>K</kbd> <kbd>F</kbd>                          |
| Dividir editor                              | <kbd>Ctrl</kbd>+<kbd>\\</kbd>                         | <kbd>Ctrl</kbd>+<kbd>\\</kbd>                        | <kbd>Cmd</kbd>+<kbd>\\</kbd>                            |
| Focar no 1º, 2º ou 3º grupo de editores     | <kbd>Ctrl</kbd>+ <kbd>1</kbd> / <kbd>2</kbd> / <kbd>3</kbd>                | <kbd>Ctrl</kbd>+ <kbd>1</kbd> / <kbd>2</kbd> / <kbd>3</kbd>               | <kbd>Cmd</kbd>+ <kbd>1</kbd> / <kbd>2</kbd> / <kbd>3</kbd>                 |
| Focar no grupo de editores anterior/próximo | <kbd>Ctrl</kbd>+<kbd>K</kbd> <kbd>Ctrl</kbd>+ <kbd>←</kbd> / <kbd>→</kbd>             | <kbd>Ctrl</kbd>+<kbd>K</kbd> <kbd>Ctrl</kbd> + <kbd>←</kbd> / <kbd>→</kbd>           | <kbd>Cmd</kbd>+<kbd>K</kbd> <kbd>Cmd</kbd>+ <kbd>←</kbd> / <kbd>→</kbd>               |
| Mover editor para a esquerda/direita        | <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>PgUp</kbd> / <kbd>PgDn</kbd>         | <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>PgUp</kbd> / <kbd>PgDn</kbd>        | <kbd>Cmd</kbd>+<kbd>K</kbd> <kbd>Cmd</kbd>+<kbd>Shift</kbd>+ <kbd>←</kbd> / <kbd>→</kbd>                |
| Mover grupo de editores ativo               | <kbd>Ctrl</kbd>+<kbd>K</kbd> <kbd>←</kbd> / <kbd>→</kbd>                   | <kbd>Ctrl</kbd>+<kbd>K</kbd> <kbd>←</kbd> / <kbd>→</kbd>                  | <kbd>Cmd</kbd>+<kbd>K</kbd> <kbd>←</kbd> / <kbd>→</kbd>                  |

### Gerenciamento de Arquivo

## Extensões

Abaixo há uma sugestão de extensões para serem usadas no programa.

| extensão | tipo | uso |
| :----: | :----: | :----: |
| python | obrigatório | melhora o suporte do vs code para o python |
| vscode-icons | opcional | altera os ícones quando abre uma pasta |
| indent-rainbow | opcional | adiciona uma cor diferente a cada indentação |


